<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Coding | 대체로 무해함</title>
    <link>/tags/coding/</link>
      <atom:link href="/tags/coding/index.xml" rel="self" type="application/rss+xml" />
    <description>Coding</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>ko-kr</language><copyright>© lethean</copyright><lastBuildDate>Fri, 24 Feb 2012 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Coding</title>
      <link>/tags/coding/</link>
    </image>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (5)</title>
      <link>/2012/02/24/oop-with-gobject-5/</link>
      <pubDate>Fri, 24 Feb 2012 00:00:00 +0000</pubDate>
      <guid>/2012/02/24/oop-with-gobject-5/</guid>
      <description>&lt;p&gt;거의 2년만에 GObject 객체 지향 프로그래밍 연재 글을 포스팅합니다. 사실 이 글의 일부는 예전에 작성해 둔 것인데, 이번 
&lt;a href=&#34;http://gnome-kr.blogspot.com/2012/02/2-gnome-tech-talks.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GNOME Tech Talks&lt;/a&gt;
에서 발표 하나를 맡게 되면서, 슬라이드 자료를 따로 만들 시간은 없고 그렇다고 오래된 자료를 재탕하는 건 실례인 것 같아 조금 보완해서 작성했습니다. 참고로, GObject 개념을 잘 모르는 분이라면 이전 연재 글을 먼저 읽어 보시면 도움이 될 수 있습니다. :)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;/2009/08/10/oop-with-gobject-1/&#34; title=&#34;GObject 객체 지향 프로그래밍 (1)&#34;&gt;GObject 객체 지향 프로그래밍 (1)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;/2009/08/14/oop-with-gobject-2/&#34; title=&#34;GObject 객체 지향 프로그래밍 (2)&#34;&gt;GObject 객체 지향 프로그래밍 (2)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;/2009/08/18/oop-with-gobject-3/&#34; title=&#34;GObject 객체 지향 프로그래밍 (3)&#34;&gt;GObject 객체 지향 프로그래밍 (3)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;/2009/08/24/oop-with-gobject-4/&#34; title=&#34;GObject 객체 지향 프로그래밍 (4)&#34;&gt;GObject 객체 지향 프로그래밍 (4)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;/2010/02/11/how-to-make-a-gobject-singleton/&#34; title=&#34;싱글턴(Singleton) GObject 객체 만들기&#34;&gt;싱글턴(Singleton) GObject 객체 만들기&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;/2010/04/07/serialize-gobject-properties/&#34; title=&#34;GObject 속성 직렬화(Serialization)하기&#34;&gt;GObject 속성 직렬화(Serialization)하기&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GObject 객체 지향 시스템을 구성하는 여러가지 개념 중 상속(inheritance), 참고 카운터(reference counting), 속성(properties) 등에 대해서는 지난 글에서 이미 소개했습니다. 아직 GObject 라이브러리에서 소개하지 않은 개념이 아직 많이 남아 있지만, 그 중에서 가장 중요한 것 중 하나는 바로 시그널(signals)이 아닐까 생각합니다. 속성이 변경되었을때 자동으로 호출되는 콜백 함수를 등록해서 사용하는 방법을 설명할 때 약간 소개했지만, 아무래도 그걸로는 부족하기 때문에 이번 글은 시그널의 개념과 사용 방법, 그리고 속성 바인딩을 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;간단한 클러터 기반 시계&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/myclock-screenshot.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;언제나 그렇듯이 재미없는 예제 소스를 먼저 보여드립니다. 이 소스를 컴파일해서 실행하면 위 그림과 같은 시계가 동작합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* myclock1.c */

/*****************************************************************************/

#include &amp;lt;glib-object.h&amp;gt;

#define MY_TYPE_CLOCK (my_clock_get_type ())
#define MY_CLOCK(obj) 
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_CLOCK, MyClock))
#define MY_CLOCK_CLASS(klass) 
  (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_CLOCK, MyClockClass))
#define MY_IS_CLOCK(obj) 
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_CLOCK))
#define MY_IS_CLOCK_CLASS(klass) 
  (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_CLOCK))
#define MY_CLOCK_GET_CLASS(obj) 
  (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_CLOCK, MyClockClass))

typedef struct _MyClock        MyClock;
typedef struct _MyClockClass   MyClockClass;
typedef struct _MyClockPrivate MyClockPrivate;

struct _MyClock
{
  GObject         parent;
  MyClockPrivate *priv;
};

struct _MyClockClass
{
  GObjectClass parent_class;
};

enum
{
  PROP_0,
  PROP_DATE_TIME,
  PROP_LAST
};

struct _MyClockPrivate
{
  GDateTime *datetime;
  guint      timeout;
};

G_DEFINE_TYPE (MyClock, my_clock, G_TYPE_OBJECT);

static GParamSpec *props[PROP_LAST];

GDateTime *
my_clock_get_date_time (MyClock *clock_)
{
  g_return_val_if_fail (MY_IS_CLOCK (clock_), NULL);

  return g_date_time_ref (clock_-&amp;gt;priv-&amp;gt;datetime);
}

static void
my_clock_set_date_time (MyClock   *clock_,
                        GDateTime *datetime)
{
  g_date_time_unref (clock_-&amp;gt;priv-&amp;gt;datetime);
  clock_-&amp;gt;priv-&amp;gt;datetime = g_date_time_ref (datetime);
  g_object_notify_by_pspec (G_OBJECT (clock_), props[PROP_DATE_TIME]);
}

static gboolean
my_clock_update (gpointer data)
{
  MyClock   *clock_ = data;
  GTimeVal   now;
  GDateTime *datetime;
  guint      interval;

  g_get_current_time (&amp;amp;now);

  datetime = g_date_time_new_from_timeval_local (&amp;amp;now);
  my_clock_set_date_time (clock_, datetime);
  g_date_time_unref (datetime);

  interval = (1000000L - now.tv_usec) / 1000L;
  clock_-&amp;gt;priv-&amp;gt;timeout =
    g_timeout_add_full (G_PRIORITY_HIGH_IDLE,
                        interval,
                        my_clock_update,
                        g_object_ref (clock_),
                        g_object_unref);

  return FALSE;
}

static void
my_clock_set_property (GObject      *object,
                       guint         param_id,
                       const GValue *value,
                       GParamSpec   *pspec)
{
  switch (param_id)
    {
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec);
      break;
    }
}

static void
my_clock_get_property (GObject   *object,
                       guint      param_id,
                       GValue     *value,
                       GParamSpec *pspec)
{
  MyClock *clock_ = MY_CLOCK (object);

  switch (param_id)
    {
    case PROP_DATE_TIME:
      g_value_set_boxed (value, clock_-&amp;gt;priv-&amp;gt;datetime);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec);
      break;
    }
}

static void
my_clock_finalize (GObject *gobject)
{
  MyClockPrivate *priv = MY_CLOCK (gobject)-&amp;gt;priv;

  g_date_time_unref (priv-&amp;gt;datetime);
  g_source_remove (priv-&amp;gt;timeout);

  G_OBJECT_CLASS (my_clock_parent_class)-&amp;gt;finalize (gobject);
}

static void
my_clock_class_init (MyClockClass *klass)
{
  GObjectClass *obj_class = G_OBJECT_CLASS (klass);
  GParamSpec   *pspec;

  obj_class-&amp;gt;set_property = my_clock_set_property;
  obj_class-&amp;gt;get_property = my_clock_get_property;
  obj_class-&amp;gt;finalize     = my_clock_finalize;

  g_type_class_add_private (klass, sizeof (MyClockPrivate));

  pspec = g_param_spec_boxed (&amp;quot;datetime&amp;quot;,
                              &amp;quot;Date and Time&amp;quot;,
                              &amp;quot;The date and time to show in the clock&amp;quot;,
                              G_TYPE_DATE_TIME,
                              G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
  props[PROP_DATE_TIME] = pspec;
  g_object_class_install_property (obj_class, PROP_DATE_TIME, pspec);
}

static void
my_clock_init (MyClock *clock_)
{
  MyClockPrivate *priv;

  priv = clock_-&amp;gt;priv =
    G_TYPE_INSTANCE_GET_PRIVATE (clock_,
                                 MY_TYPE_CLOCK,
                                 MyClockPrivate);

  priv-&amp;gt;datetime = g_date_time_new_now_local ();
  priv-&amp;gt;timeout = 0;

  my_clock_update (clock_);
}

MyClock *
my_clock_new (void)
{
  return g_object_new (MY_TYPE_CLOCK, NULL);
}

/*****************************************************************************/

#include &amp;lt;clutter/clutter.h&amp;gt;

static void
clock_datetime_changed (GObject    *object,
                        GParamSpec *pspec,
                        gpointer    data)
{
  MyClock      *clock_ = MY_CLOCK (object);
  ClutterActor *text   = data;
  GDateTime    *datetime;
  gchar        *str;

  datetime = my_clock_get_date_time (clock_);
  str = g_date_time_format (datetime, &amp;quot;%xn%H:%M:%S&amp;quot;);

  clutter_text_set_text (CLUTTER_TEXT (text), str);

  g_free (str);
  g_date_time_unref (datetime);
}

int
main (int    argc,
      char **argv)
{
  ClutterActor      *stage;
  ClutterActor      *text;
  ClutterConstraint *constraint;
  MyClock           *clock_;

  if (clutter_init (&amp;amp;argc, &amp;amp;argv) != CLUTTER_INIT_SUCCESS)
    return -1;

  /* stage */
  stage = clutter_stage_get_default ();
  clutter_actor_set_size (stage, 320, 240);
  clutter_stage_set_color (CLUTTER_STAGE (stage), CLUTTER_COLOR_Black);
  clutter_stage_set_user_resizable (CLUTTER_STAGE (stage), TRUE);

  /* text */
  text = clutter_text_new_full (&amp;quot;Sans Bold 20&amp;quot;,
                                &amp;quot;NOW&amp;quot;,
                                CLUTTER_COLOR_LightButter);
  clutter_container_add_actor (CLUTTER_CONTAINER (stage), text);
  clutter_text_set_line_alignment (CLUTTER_TEXT (text), PANGO_ALIGN_CENTER);

  /* align text in center of stage */
  constraint =
    clutter_align_constraint_new (stage, CLUTTER_ALIGN_X_AXIS, 0.5);
  clutter_actor_add_constraint (text, constraint);

  constraint =
    clutter_align_constraint_new (stage, CLUTTER_ALIGN_Y_AXIS, 0.5);
  clutter_actor_add_constraint (text, constraint);

  /* clock */
  clock_ = my_clock_new ();
  g_signal_connect (clock_,
                    &amp;quot;notify::datetime&amp;quot;,
                    G_CALLBACK (clock_datetime_changed),
                    text);

  clutter_actor_show (stage);

  clutter_main ();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;소스 코드를 간단하게 설명하면, &lt;code&gt;MyClock&lt;/code&gt; 객체가 1초 간격으로 현재 시간을 얻어와 자신의 &lt;code&gt;datetime&lt;/code&gt; 속성을 갱신하면[&lt;code&gt;my_clock_update()&lt;/code&gt;], 속성이 변경되었을때(&lt;code&gt;notify::datetime&lt;/code&gt;) 자동으로 호출되는 콜백 함수를[&lt;code&gt;clock_datetime_changed()&lt;/code&gt;] 등록해 자동으로 클러터 텍스트(&lt;code&gt;ClutterText&lt;/code&gt;)를 이용해 화면에 표시합니다.&lt;/p&gt;
&lt;p&gt;이제 이 소스 코드를 두 가지 방법으로 확장하려고 합니다. 첫번째 방법은 속성 바인딩(property binding)을 이용해 시그널을 사용하지 않는 방법이고, 두번째 방법은 시간이 변경되었을때 호출되는 진짜(!) 시그널을 추가하는 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;속성 바인딩 (Property Binding)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;속성 바인딩(property binding)이란 두 GObject 객체간의 두 속성을 묶는 걸 말합니다. 여기서 묶는다는 의미는, 한 객체의 속성 값이 변하면 다른 객체의 속성 값도 자동으로 변한다는 의미입니다. 물론 묶으려는 두 속성은 같은 형(type)이어야 합니다. 그런데, 위 예제의 경우 &lt;code&gt;MyClock:``datetime&lt;/code&gt; 속성과 
&lt;a href=&#34;http://developer.gnome.org/clutter/stable/ClutterText.html#ClutterText--text&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;ClutterText:``text&lt;/code&gt;&lt;/a&gt;
 속성은 형(type)이 다릅니다. 그래서, 위 소스를 다음과 같이 수정합니다. (변경된 부분만 보여 드립니다)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* myclock2.c */

/* ... */

enum
{
  PROP_0,
  PROP_DATE_TIME,
  PROP_TEXT,
  PROP_LAST
};

struct _MyClockPrivate
{
  GDateTime *datetime;
  guint      timeout;
  gchar     *text;
};

/* ... */

const gchar *
my_clock_get_text (MyClock *clock_)
{
  g_return_val_if_fail (MY_IS_CLOCK (clock_), NULL);

  return clock_-&amp;gt;priv-&amp;gt;text;
}

static void
my_clock_set_date_time (MyClock   *clock_,
                        GDateTime *datetime)
{
  g_date_time_unref (clock_-&amp;gt;priv-&amp;gt;datetime);
  clock_-&amp;gt;priv-&amp;gt;datetime = g_date_time_ref (datetime);
  g_object_notify_by_pspec (G_OBJECT (clock_), props[PROP_DATE_TIME]);

  g_free (clock_-&amp;gt;priv-&amp;gt;text);
  clock_-&amp;gt;priv-&amp;gt;text = g_date_time_format (datetime, &amp;quot;%xn%H:%M:%S&amp;quot;);
  g_object_notify_by_pspec (G_OBJECT (clock_), props[PROP_TEXT]);
}

/* ... */

static void
my_clock_finalize (GObject *gobject)
{
  /* ... */
  g_free (priv-&amp;gt;text);
  /* ... */
}

static void
my_clock_class_init (MyClockClass *klass)
{
  /* ... */

  pspec = g_param_spec_string (&amp;quot;text&amp;quot;,
                               &amp;quot;Text&amp;quot;,
                               &amp;quot;The text of the date and time&amp;quot;,
                               NULL,
                               G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
  props[PROP_TEXT] = pspec;
  g_object_class_install_property (obj_class, PROP_TEXT, pspec);
}

static void
my_clock_init (MyClock *clock_)
{
  /* ... */
  priv-&amp;gt;text = NULL;
  /* ... */
}

/* ... */

int
main (int    argc,
      char **argv)
{
  /* ... */

  /* clock */
  clock_ = my_clock_new ();
  g_object_bind_property (clock_, &amp;quot;text&amp;quot;,
                          text,  &amp;quot;text&amp;quot;,
                          G_BINDING_SYNC_CREATE);

  /* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드에서 변경된 내용은, &lt;code&gt;MyClock&lt;/code&gt;에 문자열 형식의 &lt;code&gt;text&lt;/code&gt; 속성을 추가하고[&lt;code&gt;my_clock_class_init()&lt;/code&gt;], &lt;code&gt;datetime&lt;/code&gt; 속성을 갱신할때 &lt;code&gt;text&lt;/code&gt; 속성도 함께 갱신하도록 한 다음[&lt;code&gt;my_clock_set_date_time()&lt;/code&gt;], 기존 속성 변경(&lt;code&gt;notify::datetime&lt;/code&gt;)에 대한 &lt;code&gt;g_signal_connect()&lt;/code&gt; 함수 호출 대신 &lt;code&gt;g_object_bind_property()&lt;/code&gt; 함수를 이용해 두 객체의 속성을 묶었다는 점입니다. 여기서 핵심은 물론 &lt;code&gt;g_object_bind_property()&lt;/code&gt; 함수인데, 이 함수는 
&lt;a href=&#34;/2010/10/02/glib-2-26-0-release/&#34;&gt;GLib 2.26 버전에 추가&lt;/a&gt;
되었으며 
&lt;a href=&#34;/2008/12/15/exobinding/&#34;&gt;예전에 소개한 ExoBinding&lt;/a&gt;
과 사용법이 거의 유사합니다. 물론, 옵션을 통해 바인딩하는 시점부터 값을 동기화할 지(&lt;code&gt;G_BINDING_SYNC_CREATE&lt;/code&gt;), 단방향이 아닌 양방향으로 동기화할 지(&lt;code&gt;G_BINDING_BIDIRECTIONAL&lt;/code&gt;) 등을 지정할 수도 있습니다. 이처럼, 위의 코드에서 볼 수 있듯이, 속성 바인딩을 이용하면 매번 콜백함수를 만들지 않고도 간단하게 코드 몇 줄로 원하는 객체 속성간의 동기화(synchronization)를 처리할 수 있습니다.&lt;/p&gt;
&lt;p&gt;여담이지만, 처음 이 기능을 접했을때 맥, 아이폰 응용 프로그램을 개발하기 위해 XCode에서 마우스 드래그 만으로 객체 속성간 바인딩이 지원되는 것처럼, 코딩이 아닌, Glade 같은 GUI 도구에서 위젯 속성간 바인딩이 지원되면 참 편하지 않을까 하는 생각이 들었던 적도 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;시그널 (Signals)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://developer.gnome.org/gobject/stable/chapter-signal.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GObject 공식 매뉴얼&lt;/a&gt;
에 의하면 시그널(signals)은 메시지 전달 시스템을 구성하는 두가지 기술 중 하나입니다. 하나는 클로저(closures)이고 다른 하나가 시그널(signals)인데, 클로저가 콜백(callback) 함수를 자료구조로 정의한 거라면, 시그널은 이 콜백함수를 등록하고 호출하는 알고리즘을 정의한 것이라고 이해해도 무방합니다.&lt;/p&gt;
&lt;p&gt;클로저를 다시 정의하지 않고 함수 포인터를 직접 사용해도 될 것 같은데 이를 객체로 정의한 이유는 여러가지가 있지만, 무엇보다도 콜백함수에 전달되는 인자(parameters) 목록과 인자 형(type)에 대한 처리(marshalling) 때문입니다. C/C++ 언어에서 함수 호출시 스택에 쌓이는 인자를 가공하는 것 뿐 아니라, GObject가 지원하는 여러 언어에 대한 바인딩을 위해 더 일반화된 클로저(closure) 객체가 필요합니다.&lt;/p&gt;
&lt;p&gt;아무튼, 이론적인 설명은 그만하고 다시 본론으로 돌아와서, 위 예제에서 구현한 &lt;code&gt;MyClock&lt;/code&gt; 객체가 생각보다 잘 설계되고 동작하는 바람에(&amp;hellip;) 프로그램 전체에서 이 객체를 사용하기로 결정했다고 가정해 봅시다. 수많은 모듈과 수많은 객체에서 전역 시계 객체에 속성 알림(notify) 시그널을 연결합니다. 그리고 그때마다 &lt;code&gt;my_clock_get_date_time()&lt;/code&gt;을 호출해 현재 시간을 가져와서 처리합니다. 물론 이 예제에서 전달되는 &lt;code&gt;GDateTime&lt;/code&gt; 구조체는 참조 카운터 방식으로 관리되기 때문에 구조체 전달시  많은 오버헤드가 없지만, 문자열을 복사하거나 많은 데이터가 전달되는 경우라면 무시할 수 없는 상황이 발생합니다. 그래서, 위 첫번째 소스를 다음과 같이 조금 수정합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* myclock3.c */

/* ... */

struct _MyClockClass
{
  GObjectClass parent_class;

  /* signals */
  void (*changed) (MyClock   *clock_,
                   GDateTime *datetime);
};

enum
{
  SIGNAL_CHANGED,
  SIGNAL_LAST
};

/* ... */

static guint       signals[SIGNAL_LAST];

/* ... */

static void
my_clock_set_date_time (MyClock   *clock_,
                        GDateTime *datetime)
{
  /* ... */
}

static void
my_clock_real_changed (MyClock   *clock_,
                       GDateTime *datetime)
{
  my_clock_set_date_time (clock_, datetime);
}

static gboolean
my_clock_update (gpointer data)
{
  /* ... */

  datetime = g_date_time_new_from_timeval_local (&amp;amp;now);
  g_signal_emit (clock_, signals[SIGNAL_CHANGED], 0, datetime);
  g_date_time_unref (datetime);

  /* ... */
}

static void
my_clock_class_init (MyClockClass *klass)
{
  /* ... */

  klass-&amp;gt;changed = my_clock_real_changed;

  signals[SIGNAL_CHANGED] =
    g_signal_new (&amp;quot;changed&amp;quot;,
                  G_TYPE_FROM_CLASS (klass),
                  G_SIGNAL_RUN_LAST,
                  G_STRUCT_OFFSET (MyClockClass, changed),
                  NULL,
                  NULL,
                  g_cclosure_marshal_VOID__POINTER,
                  G_TYPE_NONE,
                  1,
                  G_TYPE_POINTER);
}

/* ... */

static void
clock_changed (MyClock   *clock_,
               GDateTime *datetime,
               gpointer   user_data)
{
  ClutterActor *text = user_data;
  gchar        *str;

  str = g_date_time_format (datetime, &amp;quot;%xn%H:%M:%S&amp;quot;);
  clutter_text_set_text (CLUTTER_TEXT (text), str);
  g_free (str);
}

int
main (int    argc,
      char **argv)
{
  /* ... */

  /* clock */
  clock_ = my_clock_new ();
  g_signal_connect (clock_,
                    &amp;quot;changed&amp;quot;,
                    G_CALLBACK (clock_changed),
                    text);

  /* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;바로 위 코드에 보이는 것처럼 &lt;code&gt;g_signal_connect()&lt;/code&gt; 호출시 연결하는 시그널 이름과 콜백 함수[&lt;code&gt;clock_changed()&lt;/code&gt;]가 더 단순하고 효율적으로 변경된 걸 확인할 수 있습니다. 콜백 함수 호출시 전달되는 인수를 그냥 사용하면 되니까 오버헤드가 매우 많이 줄어들 수 밖에 없습니다. 하지만 시그널을 정의해서 사용하는게 단순히 성능과 효율 때문만은 아닙니다. 위 예제에서는 속성이 변경되었을 때 발생하는 시그널을 정의했지만, 일반적으로 시그널은 속성 만으로 표현할 수 없는 객체의 상태 변화를 알리기 위해서 많이 사용합니다.(예: &lt;code&gt;ClutterActor::enter-event&lt;/code&gt; 시그널) 또한 속성의 변화를 통해 알 수 있더라도 더 쉽고 명확하게 이를 전파하기 위해서도 사용합니다.(예: &lt;code&gt;ClutterActor::hide&lt;/code&gt; 시그널과 &lt;code&gt;ClutterActor:visible&lt;/code&gt; 속성)&lt;/p&gt;
&lt;p&gt;더 나아가, 시그널은 상태 변화 뿐 아니라 객체의 동작 방식을 외부에서 제어할 수 있도록 유연성을 제공하는데도 사용합니다. 더 자세한 이해를 위해 시그널 함수 포인터부터 설명하자면, 클래스 구조체 안에 선언된 시그널 함수 포인터[&lt;code&gt;MyClockClass::changed()&lt;/code&gt;]는 일종의 가상 함수(virtual function) 역할을 하면서, 시그널이 발생하면(emit) &lt;code&gt;g_signal_connect()&lt;/code&gt;를 이용해 등록된 사용자 콜백함수가 모두 실행된 뒤 맨 나중에 실행되거나 혹은 사용자 콜백 함수보다 먼저 실행됩니다. 따라서 필요 없을 경우 그냥 &lt;code&gt;NULL&lt;/code&gt;로 내버려두어도 상관없지만, 위 예제에서는 클래스 생성시 &lt;code&gt;my_clock_real_changed()&lt;/code&gt; 함수를 등록시켰습니다. &lt;code&gt;my_clock_real_changed()&lt;/code&gt;는 다시  실제로 &lt;code&gt;datetime&lt;/code&gt; 속성을 갱신하는 작업을 처리하는 &lt;code&gt;my_clock_set_date_time()&lt;/code&gt;을 호출합니다. 그리고, 기존 시간 갱신 함수[&lt;code&gt;my_clock_update()&lt;/code&gt;]에서는 직접 &lt;code&gt;my_clock_set_date_time()&lt;/code&gt;을 호출하지 않고, 시그널을 발생시켜[&lt;code&gt;g_signal_emit()&lt;/code&gt;] 작업을 처리합니다.&lt;/p&gt;
&lt;p&gt;왜 이렇게 복잡하게 일을 나누어 처리할까요? 이렇게 구현하면 몇 가지 장점이 있기 때문입니다. 예를 들어 위 예제에서는 &lt;code&gt;datetime&lt;/code&gt; 속성이 읽기 전용으로 선언되어 있기 때문에 외부에서 그 값을 변경할 수 없습니다. 하지만, 외부에서 직접 &lt;code&gt;g_signal_emit_by_name()&lt;/code&gt; 등을 이용해 시그널을 발생시키면 시그널에 연결된 모든 콜백 함수 뿐 아니라 &lt;code&gt;my_clock_real_changed()&lt;/code&gt; 함수까지도 간접적으로 호출되어 작업을 처리하도록 할 수 있습니다. 게다가 만일 시그널에 연결된 콜백 함수 중 하나가 어떤 이유로 &lt;code&gt;g_signal_stop_emission_by_name()&lt;/code&gt; 등을 호출하면 이후 실행될 콜백 함수나 &lt;code&gt;my_clock_real_changed()&lt;/code&gt; 함수가 호출되지 않게 할 수도 있고, 심지어 객체의 클래스에 등록된 함수 포인터에 직접 자신만의 콜백 함수를 등록해서 원래 작업이 아예 수행되지 않게 할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;참고로, GTK+ / Clutter 등과 같은 GObject 기반 그래픽 툴킷 시스템은 대부분 이 시그널 콜백 함수 메커니즘을 이용해 커스텀 위젯을 만들거나 기존 액터를 상속받아 사용자가 마음껏 기능을 확장할 수 있는 길을 열어 두었습니다.(예: 
&lt;a href=&#34;http://git.gnome.org/browse/clutter/tree/clutter/clutter-actor.c#n4856&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;clutter_actor.c:clutter_actor_real_paint()&lt;/code&gt;&lt;/a&gt;
 소스 참고)&lt;/p&gt;
&lt;p&gt;시그널 객체는 &lt;code&gt;g_signal_new()&lt;/code&gt; 함수를 이용해 생성한 뒤 전역 &lt;code&gt;signals[]&lt;/code&gt; 배열에 ID를 저장해 둡니다. 이렇게 저장한 시그널 ID는 &lt;code&gt;g_signal_emit()&lt;/code&gt; 함수 호출시 사용합니다. 물론 이렇게 ID를 따로 저장하지 않고 &lt;code&gt;g_signal_emit_by_name()&lt;/code&gt;을 사용해 시그널 이름으로 직접 시그널을 발생시켜도 되지만, 어차피 내부적으로 시그널 이름을 ID로 변환하는 과정을 거치기 때문에 효율을 위해 객체 구현시 관례적으로 이런식으로 작성합니다. 물론 객체 외부에서는 시그널 ID를 모르기 때문에 어쩔 수 없이  &lt;code&gt;g_signal_emit_by_name()&lt;/code&gt;을 사용해야 합니다.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;g_signal_new()&lt;/a&gt;
 함수의 인자 중에서 중요한 항목만 설명하면, 첫번째 항목은 시그널 이름을 정의하고, 세번째 항목은 시그널 함수 포인터가 맨 나중에 실행될 지(&lt;code&gt;G_SIGNAL_RUN_LAST&lt;/code&gt;), 또는 가장 먼저 실행될 지(&lt;code&gt;G_SIGNAL_RUN_FIRST&lt;/code&gt;) 등을 지정합니다. 네번째 항목은 클래스 구조체에 정의된 시그널 함수 포인터 위치를 지정하고, 여덟번째는 시그널 콜백 함수의 리턴 형(type), 아홉번째는 콜백 함수에게 전달할 인자의 갯수, 열번째부터는 전달될 인자의 형(types)을 차례대로 정의합니다.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;g_signal_new()&lt;/a&gt;
 함수의 일곱번째 인자는 함수 호출시 인자를 처리하는 마샬링(marshalling) 함수를 지정하는데, 함수의 리턴 형(type)과 인자 목록, 인자의 각 형(type)이 정확히 일치되는 함수를 지정해야 합니다. 그런데 원하는 형태의 마샬링 함수를 GLib에서 기본으로 제공하지 않을 경우 &lt;code&gt;glib-genmarshal&lt;/code&gt; 프로그램을 이용해 직접 C 소스 코드를 생성해서 사용해야 했는데, GLib 2.30 버전부터는 그냥 &lt;code&gt;NULL&lt;/code&gt;을 지정하면 
&lt;a href=&#34;http://sourceware.org/libffi/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libffi&lt;/a&gt;
 라이브러리를 이용해 구현한 &lt;code&gt;g_cclosure_marshal_generic()&lt;/code&gt; 함수가 기본으로 호출되어, 알아서 자동으로 마샬링을 처리합니다.&lt;/p&gt;
&lt;p&gt;정리하자면, GObject 시그널은 모델-뷰(model-view) 구조나 관찰자 패턴(observer pattern)을 구현하는데 사용하기도 하지만, 더 복잡한 객체 지향 시스템을 설계할 때도 유용합니다. 하지만, 여기서는 시그널의 특징과 개념만 설명하느라 전체 기능의 반의 반도 소개되지 않은 셈입니다. 따라서 더 깊은 이해와 활용을 원하시면 반드시 참고 매뉴얼을 한 번 정독하시길 권합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그리고&amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;다른 프로그래머가 왜 C++, Java, Python 처럼 좋은 언어 놔두고 C 언어 기반에서 복잡한 GObject 같은 걸 가지고 객체 지향 프로그래밍을 할려고 애쓰냐고 물어본다면,  
&lt;a href=&#34;http://www.tux.org/lkml/#s15-3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;리눅스 커널 메일링 리스트 FAQ&lt;/a&gt;
에 있는 유명한 다음 구절을 해석해서 미소지으며 알려주시기 바랍니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What&amp;rsquo;s important about object-oriented programming is the techniques, not the languages used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;뭐, 모든 도구는 필요한 곳이 반드시 있으니까 계속 존재합니다. 다만 내가 아직 그 쓰임새를 알지 못할 뿐이죠&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dr. Memory 메모리 오류 / 누수 감지 도구</title>
      <link>/2012/02/08/detect-memory-leaks-and-corruption-with-dr-memory/</link>
      <pubDate>Wed, 08 Feb 2012 00:00:00 +0000</pubDate>
      <guid>/2012/02/08/detect-memory-leaks-and-corruption-with-dr-memory/</guid>
      <description>&lt;p&gt;대부분의 작업을 리눅스 환경에서 진행하지만 가끔은 어쩔 수 없이 윈도우 프로그램을 디버깅합니다. 그런데 메모리 오류를 디버깅할 때 리눅스에서 애용하는 
&lt;a href=&#34;http://valgrind.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Valgrind&lt;/a&gt;
 같은 괜찮은 무료(!) 도구가 없어서 아쉬었는데, 오늘 발견한 
&lt;a href=&#34;http://code.google.com/p/drmemory/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dr. Memory&lt;/a&gt;
 덕분에 매우 수월하게 메모리 오류 디버깅을 진행할 수 있었습니다. 또한, 리눅스에서도 사용할 수 있다고 하니 계속 디버깅에 사용해 볼 생각입니다.&lt;/p&gt;
&lt;p&gt;사실, 이 포스팅은, 사용하기 쉬우면서도 
&lt;a href=&#34;http://valgrind.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Valgrind&lt;/a&gt;
 만큼 강력한 
&lt;a href=&#34;http://code.google.com/p/drmemory/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dr. Memory&lt;/a&gt;
 덕분에 해묵은 버그와 오류까지 모조리 잡을 수 있게 되어, 그 고마움을 표시하고 싶어서 남기는 글입니다. 따라서, 사용법 같은 자세한 내용이 궁금하신 분은 홈페이지를 방문해 보시길&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Clutter 메모리 누수 디버깅</title>
      <link>/2011/09/28/clutter-memory-leak-debugging/</link>
      <pubDate>Wed, 28 Sep 2011 00:00:00 +0000</pubDate>
      <guid>/2011/09/28/clutter-memory-leak-debugging/</guid>
      <description>&lt;p&gt;최근 
&lt;a href=&#34;/2011/09/15/note-about-using-clutter/&#34;&gt;클러터를 이용한 프로그램을 개발&lt;/a&gt;
하면서 메모리 누수 현상을 발견했습니다. 코드를 하나 하나 막아가면서 테스트를 한 결과 
&lt;a href=&#34;http://developer.gnome.org/clutter-gst/1.3/ClutterGstVideoSink.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;ClutterGstVideoSink&lt;/code&gt;&lt;/a&gt;
 객체를 사용하지 않으면 메모리 누수가 발생하지 않았습니다. 하지만, 아무리 소스를 분석해도 원인을 찾아낼 수 없었고, 잘못된 부분도 없는 것 같았습니다. 물론 구글링을 해도, 검색 실력이 미천한지, 답을 찾을 수 없었습니다.&lt;/p&gt;
&lt;p&gt;그래서 결국 예전에 소개한 적 있는 
&lt;a href=&#34;/2009/06/18/debugging-memory-leaks-with-tcmalloc-google-perftools/&#34;&gt;구글 성능 도구(google-perftools)를 이용해 디버깅&lt;/a&gt;
을 했습니다. 그런데 문제는, 
&lt;a href=&#34;http://www.archlinux.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;아치 리눅스(Arch Linux)&lt;/a&gt;
 x86_64 환경으로 개발 환경을 바꾸면서 메모리 프로파일 기능이 제대로 동작하지 않는다는 사실인데, 특히 메모리 누수 발생 지점을 정확하게 알기 위해서 필요한 함수 호출 백트레이스(backtrace) 정보가 추출되지 않는 게 가장 큰 문제였습니다. 이 문제를 해결하기 위한 과정을 기록으로 남겨봅니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;구글 성능 도구 설치&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;아치 리눅스(Arch Linux) x86_64 환경에서 구글 성능 도구(google-perftools)가 정확한 메모리 프로파일 결과를 얻으려면 
&lt;a href=&#34;http://www.nongnu.org/libunwind/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libunwind&lt;/a&gt;
 라이브러리를 설치해야 하는데, 아치리눅스 
&lt;a href=&#34;https://wiki.archlinux.org/index.php/AUR&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AUR&lt;/a&gt;
 패키지를 
&lt;a href=&#34;https://wiki.archlinux.org/index.php/Yaourt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;yaourt&lt;/a&gt;
를 이용해 다음과 같이 쉽게 설치했습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ yaourt -S libunwind
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 다음과 같이 구글 성능 도구를 빌드하고 설치합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ cd google-perftools
$ ./configure --prefix=/usr --enable-frame-pointers
$ make
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;라이브러리 패키지 재생성 및 재설치&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;정확한 함수 호출 백트레이스(backtrace) 정보를 얻기 위해 프로그램에 사용되는 모든 라이브러리를 다시 컴파일해 패키지를 다시 설치해야 하는데, 그 과정은 다음과 같습니다. (
&lt;a href=&#34;https://wiki.archlinux.org/index.php/Debug_-_Getting_Traces&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;관련 위키 페이지&lt;/a&gt;
 참고)&lt;/p&gt;
&lt;p&gt;먼저 아치 리눅스 빌드 시스템(ABS) 정보를 동기화합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sudo abs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그러면 &lt;code&gt;/var/abs&lt;/code&gt; 디렉토리 밑에 모든 공식 패키지의 빌드 정보가 다운로드됩니다.&lt;/p&gt;
&lt;p&gt;라이브러리의 패키지 빌드 옵션을 수정하기 위해, &lt;code&gt;/etc/makepkg.conf&lt;/code&gt; 파일에서 아래 부분을 찾아 디버그 심볼(&lt;code&gt;-g&lt;/code&gt;)과 프레임 포인터 포함(&lt;code&gt;-fno-omit-frame-pointer&lt;/code&gt;) 컴파일 옵션을 추가하고 빌드 옵션에서 &lt;code&gt;strip&lt;/code&gt;을 제외합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;CFLAGS=&amp;quot;-g -fno-omit-frame-pointer -march=x86-64 -mtune=generic -O2 -pipe&amp;quot;
CXXFLAGS=&amp;quot;-g -fno-omit-frame-pointer -march=x86-64 -mtune=generic -O2 -pipe&amp;quot;
OPTIONS=(!strip docs libtool emptydirs zipman purge)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;/var/abs/local&lt;/code&gt; 디렉토리로 이동해서(없으면 새로 생성) 다음과 같이 사용되는 프로그램에 사용되는 모든 라이브러리 패키지를 다시 생성하고 설치합니다. 예를 들어 클러터 라이브러리는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ src=$(find /var/abs -name clutter | grep -v /var/abs/local)
$ cp -r $src /var/abs/local
$ cd /var/abs/local/clutter
$ makepkg -f
$ sudo pacman -U *.pkg.tar.xz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같은 방식으로 clutter, cogl, glib2, glibc 패키지를 다시 만들고 설치합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;메모리 프로파일링&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이제 다음 명령으로 디버깅할 프로그램(&lt;code&gt;eview-demo&lt;/code&gt;)을 실행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ G_SLICE=always-malloc 
  HEAPPROFILE=/tmp/profile 
  HEAP_PROFILE_ALLOCATION_INTERVAL=10737418240 
  LD_PRELOAD=/usr/lib/libtcmalloc.so 
  ./eview-demo
Starting tracking the heap
Dumping heap profile to /tmp/profile.0001.heap (...)
Dumping heap profile to /tmp/profile.0002.heap (...)
Dumping heap profile to /tmp/profile.0003.heap (...)
Dumping heap profile to /tmp/profile.0004.heap (...)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;정상적으로 구글 성능 도구의 메모리 프로파일러가 동작하면 위와 같은 메시지가 출력됩니다. 이제 적당한 시점에서 프로그램을 멈추고, 다음과 같이 프로파일링 데이터를 분석합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ pprof 
    --pdf 
    --lines 
    --base /tmp/profile.0001.heap 
    ./eview-demo 
    /tmp/profile.0004.heap 
    &amp;gt; profile-1.pdf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 생성된 그래프는 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/clutter-1-6-memory-leak-profile.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;이 그래프를 분석해서 관련 코드를 분석해 보니, 결정적으로 두 군데에 문제가 있습니다. 첫번째는 &lt;code&gt;cogl_pipeline_fragend_arbfp_start()&lt;/code&gt; 함수 내부에서 생성한 &lt;code&gt;arbfp_program_state&lt;/code&gt; 객체를 해제하는 곳이 없다는 점이고, 두번째는 &lt;code&gt;cogl_pipeline_get_layers()&lt;/code&gt; 함수에서 생성한 &lt;code&gt;deprecated_get_layers_list&lt;/code&gt; 리스트를 해제하는 곳이 없다는 점입니다. 그런데 최근 클러터 1.8 버전 소스를 보면 두번째 문제는 해결이 된 것 같은데, 첫번째 문제가 있는 곳은 코드 수정이 많이 되어 해결 여부를 알 수가 없습니다.&lt;/p&gt;
&lt;p&gt;그래서 결론은, 며칠 전에 릴리스된 클러터 1.8 안정 버전이 아치 리눅스 패키지로 올라오면 다시 메모리 누수 여부를 확인해볼 예정입니다. (GNOME 3 핵심 라이브러리를 직접 컴파일해서 사용하는게 귀찮기도 하고 두렵기도 해서입니다&amp;hellip; :)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[UPDATE 2011-10-04]&lt;/strong&gt; 클러터 1.8 버전에서 확인해 보니 메모리 누수 문제가 해결된 것 같습니다. 역시, 미루기를 잘 했습니다. ;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[UPDATE 2011-10-05]&lt;/strong&gt; 다시 확인해 보니, 이제는 다른 부분에서 메모리 누수가 발생합니다. 그래서 이번에는 당당히(?) 버그 리포팅(
&lt;a href=&#34;https://bugzilla.gnome.org/show_bug.cgi?id=660985&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bug 660985&lt;/a&gt;
, 
&lt;a href=&#34;https://bugzilla.gnome.org/show_bug.cgi?id=660986&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Bug 660986&lt;/a&gt;
) 했습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[UPDATE 2011-10-10]&lt;/strong&gt; CPU 사용량이 가장 많은 함수를 프로파일링하려면 다음과 같이 실행하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ CPUPROFILE=./cpu.prof 
  LD_PRELOAD=/usr/lib/libtcmalloc_and_profiler.so 
  ./eview-demo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;정상적으로 종료한뒤 다음과 같이 CPU 사용량을 함수별로 프로파일한 그래프를 얻을 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ pprof 
    --pdf 
    --lines 
    ./eview-demo 
    ./cpu.prof
    &amp;gt; profile-1.pdf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;[UPDATE 2012-02-04]&lt;/strong&gt; 최신 아치 리눅스에 포함되어 있는 
&lt;a href=&#34;http://code.google.com/p/gperftools/issues/detail?id=396&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;glibc 2.15 버전의 버그&lt;/a&gt;
 때문에 프로파일링이 제대로 동작하지 않을 경우 &lt;del&gt;
&lt;a href=&#34;http://permalink.gmane.org/gmane.comp.lib.glibc.alpha/17093&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;sscanf 관련 패치&lt;/a&gt;
를 적용해 glibc 패키지를 다시 빌드하고 설치해야 합니다.&lt;/del&gt; glibc 2.15-5 버전으로 업그레이드하면 됩니다. 
&lt;a href=&#34;https://bugs.archlinux.org/task/28246&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;버그 리포팅&lt;/a&gt;
이 바로 반영되어 버렸습니다. :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>코딩하던 노인</title>
      <link>/2010/07/10/old-man-who-was-coding/</link>
      <pubDate>Sat, 10 Jul 2010 00:00:00 +0000</pubDate>
      <guid>/2010/07/10/old-man-who-was-coding/</guid>
      <description>&lt;p&gt;한 10년만에 가져보는 방학(?)을 만끽하느라, 오랜만에 올리는 글입니다.&lt;/p&gt;
&lt;p&gt;다른게 아니라, Xper 메일링 리스트에 어느 분이 
&lt;a href=&#34;http://groups.google.com/group/xper/browse_thread/thread/4d79bc2343024442&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;재미있는 글&lt;/a&gt;
을 올리셨는데, 글에도 언급된 것처럼 예전에 비슷한 내용이 있었지만, 개인적으로는, 이 버전이 더 나은 것 같습니다.&lt;/p&gt;
&lt;p&gt;특히 구로 디지털단지 역 앞 건물들 이름이 너무 친숙해서, 더 실감이 나기도 하고&amp;hellip;&lt;/p&gt;
&lt;p&gt;P.S. 워드프레스 3.0 버전으로 업그레이드하면서 기본 테마를 사용하게 되었는데, 집에서 보이는 관악산 전경을 휴대폰 카메라로 촬영한 뒤 약간의 조작을 거쳐 상단 이미지로 사용했습니다. (어디냐고 물어보는 분이 계셔서&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GLib 테스트 프레임워크 사용하기</title>
      <link>/2010/02/12/using-glib-test-framework/</link>
      <pubDate>Fri, 12 Feb 2010 00:00:00 +0000</pubDate>
      <guid>/2010/02/12/using-glib-test-framework/</guid>
      <description>&lt;p&gt;GLib 라이브러리 2.16 버전부터 지원하는 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;테스트 프레임워크&lt;/a&gt;
는 C 언어용 
&lt;a href=&#34;http://en.wikipedia.org/wiki/Unit_testing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;유닛테스트&lt;/a&gt;
 도구입니다. 물론 많은 유닛 테스트 도구가 이미 존재하지만, GLib 라이브러리 기반 C 언어 프로그램이라면 굳이 다른 라이브러리를 사용하는 것보다는 이미 지원하는 훌륭한 도구를 사용하는게 더 좋겠지요. 참고로,
&lt;a href=&#34;http://www.gtk.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+&lt;/a&gt;
, 
&lt;a href=&#34;http://clutter-project.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Clutter&lt;/a&gt;
 등 같은 프로젝트도 이미 이 기능을 이용해 테스트 코드를 작성하고 있으므로 알아두면 도움이 됩니다. 모든게 그렇지만, 알고나면 별게 아니므로 기본 개념과 API 사용법만 충실히 이해하면 됩니다.&lt;/p&gt;
&lt;p&gt;**기본 개념 및 사용법
**&lt;/p&gt;
&lt;p&gt;유닛테스트 개념은 스몰토크, 자바, C++처럼 언어적으로 객체지향 개념을 지원하는 언어에서 시작했기 때문에 C 언어에 그대로 적용하기에는 조금 까다로운 점이 많습니다. 그래서 GLib 테스트 프레임워크는 유닛테스트에서 기본 개념과 테스트 실행 방식만 빌려옵니다. 우선 알아야하는 기본 개념은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트 케이스 (Test Case) : 가장 기본이 되는 하나의 테스트 단위입니다. GLib에서는 하나의 테스트 함수(function)가 이 역할을 합니다.&lt;/li&gt;
&lt;li&gt;픽스쳐 (Fixture) : 고정 설치된 물건이라는 뜻처럼, 테스트 케이스 실행 전후에 항상 실행하는 함수를 의미합니다. 실제로는, 테스트 함수를 실행하기 위해 필요한 환경을 미리 구축하거나(setup) 실행 후 리소스를 정리하는(teardown) 함수, 그리고 이와 함께 사용되는 사용자 데이터(data)로 구성됩니다. 참고로, GLib에서는 각 테스트간 의존성을 피하기 위해 모든 테스트 케이스를 실행할때마다 매번 픽스쳐를 새로 구성하는 방식(fresh fixture)을 사용합니다.&lt;/li&gt;
&lt;li&gt;테스트 슈트 (Test Suite) : 여러 테스트 케이스를 묶은 그룹입니다. 트리 구조처럼 테스트 슈트 여러개를 묶어 더 큰 테스트 슈트를 구성할 수도 있습니다. GLib에서는 테스트 경로(path)라는 개념으로 사용합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;개념은 조금 복잡한 것 같지만, 복잡하고 다양한 테스트 케이스를 그룹화하면 나중에 테스트 슈트별로 테스트를 진행할 수도 있는 등 많은 장점이 있습니다. 그리고 GLib이 제공하는 커맨드라인 도구를 이용하면 테스트 결과를 XML로 출력할 수도 있고, HTML 문서로 자동 변환할 수도 있는데 이 경우에도 테스트 슈트를 구성해 두면 많은 도움이 됩니다.&lt;/p&gt;
&lt;p&gt;물론 GLib은 정교하게 테스트 슈트와 테스트 케이스, 픽스쳐를 구성할 수 있는 많은 API를 제공하지만, 복잡한 과정을 API 호출 하나로 처리할 수 있는 기능도 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;g_test_add_func (&amp;quot;/onvif/nvc-connections&amp;quot;, test_onvif_nvc_connections);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 예제에서 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-add-func&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_add_func()&lt;/code&gt;&lt;/a&gt;
 함수는 &amp;ldquo;onvif&amp;rdquo; 테스트 슈트 밑에 &amp;ldquo;nvc-connections&amp;rdquo; 이름의 테스트 케이스를 추가합니다. 테스트시 실행할 함수는 사용자가 직접 구현한 &lt;code&gt;test_onvif_nvc_connections()&lt;/code&gt; 함수입니다. &lt;code&gt;g_test_add_func()&lt;/code&gt; 함수가 테스트 슈트를 자동으로 생성해 주기 때문에 별도의 추가 작업이 불필요합니다. 비슷한 기능의 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-add-data-func&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_add_data_func()&lt;/code&gt;&lt;/a&gt;
 함수는 테스트 함수에 데이터를 전달할 수 있어서, 한 함수로 데이터만 바꿔서 테스트하고자 할때 유용합니다. 하지만, 두 API는 픽스쳐를 지정할 수 없으므로, 픽스쳐를 사용하려면 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-add&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_add()&lt;/code&gt;&lt;/a&gt;
 함수를 이용해야 합니다.일단, 간단한 예제 코드를 보여드리면 다음과 같습니다. (&amp;quot;
&lt;a href=&#34;http://blogs.gnome.org/timj/2008/06/24/23062008-writing-unit-tests-with-glib/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Writing Unit Tests with GLib&lt;/a&gt;
&amp;rdquo; 글에서 발췌했습니다)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;glib.h&amp;gt;

static void
simple_test_case (void)
{
  /* a suitable test */
  g_assert (g_bit_storage (1) == 1);

  /* a test with verbose error message */
  g_assert_cmpint (g_bit_storage (1), ==, 1);
}

int
main (int argc, char **argv)
{
  /* initialize test program */
  g_test_init (&amp;amp;argc, &amp;amp;argv, NULL);

  /* hook up your test functions */
  g_test_add_func (&amp;quot;/Simple Test Case&amp;quot;, simple_test_case);

  /* run tests from the suite */
  return g_test_run ();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드를 &lt;code&gt;g-test-sample1.c&lt;/code&gt; 파일로 저장하고 컴파일 후 실행하면 다음과 같은 결과를 볼 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gcc -o g-test-sample1 g-test-sample1.c `pkg-config --cflags --libs glib-2.0`
$ ./g-test-sample1
/Simple Test Case: OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 결과를 재활용하기 위해 XML 형식으로 저장하거나, HTML 문서로 만들고 싶다면 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/gtester.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtester&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/gtester-report.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtester-report&lt;/a&gt;
 프로그램을 사용하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gtester -o sample-log.xml g-test-sample1
TEST: g-test-sample1... (pid=2771)
PASS: g-test-sample1
$ gtester-report sample-log.xml &amp;gt; sample-log.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같이 실행하여 생성한 HTML 문서 결과는 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/gtester-report-screenshot.png&#34; alt=&#34;&#34; title=&#34;gtester-report screenshot&#34;&gt;&lt;/p&gt;
&lt;p&gt;참고로, gtester 프로그램의 인수로 여러 테스트 실행 파일을 한꺼번에 전달하면 모든 테스트 실행 파일의 테스트 슈트가 하나의 결과로 통합됩니다.&lt;/p&gt;
&lt;p&gt;위 코드에서 사용한 테스트 코드를 보면 제일 먼저 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-init&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_init()&lt;/code&gt;&lt;/a&gt;
 함수가 나타납니다. 이 함수는 테스트 기능을 초기화하는데, 리퍼런스 매뉴얼을 보시면 프로그램 실행 인수를 통해 사용자가 여러 테스트 옵션을 지정할 수 있는 걸 알 수 있습니다. 물론 특정 테스트 슈트만 실행하게 하는 옵션도 인수로 지정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;테스트 함수를 보면 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-assert-cmpint&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_assert_cmpint()&lt;/code&gt;&lt;/a&gt;
라는 다소 생소한 API가 보이는데, GLib은 테스트 코드를 위해 이와 비슷한 매크로를 더 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define g_assert             (expr)
#define g_assert_not_reached ()
#define g_assert_cmpstr      (s1, cmp, s2)
#define g_assert_cmpint      (n1, cmp, n2)
#define g_assert_cmpuint     (n1, cmp, n2)
#define g_assert_cmphex      (n1, cmp, n2)
#define g_assert_cmpfloat    (n1,cmp,n2)
#define g_assert_no_error    (err)
#define g_assert_error       (err, dom, c)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 매크로를 사용하여 테스트 코드를 작성하면 더 친절하고 자세한 에러 메시지를 출력합니다. 예를 들어 다음 코드는,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;gchar *string = &amp;quot;foo&amp;quot;; g_assert_cmpstr (string, ==, &amp;quot;bar&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 메시지를 출력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ERROR: assertion failed (string == &amp;quot;bar&amp;quot;): (&amp;quot;foo&amp;quot; ==  &amp;quot;bar&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 기본적으로 실패한 경우에만 메시지를 보여줍니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그 외 더 많은&amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;지금까지 설명한 기본 기능 외에도 표준출력 / 표준에러 메시지를 표시하지 않도록 한 뒤 이 메시지에서 특정 문자열을 확인한다든가, 항상 동일한 패턴의 난수를 생성하여 이를 테스트에 이용하거나,  테스트에 시간이 얼마나 더 걸리는지 측정할 수도 있습니다. 프로그램을 종료시키는 치명적인 에러가 발생하는 경우도 테스트할 수 있고, 여러가지 테스트 모드(quick / slow / performace 등)를 두어 프로그램 인자를 이용해 원하는 테스트 코드만 실행할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;더 많은 활용 예제가 GLib 자체 테스트 코드에(
&lt;a href=&#34;http://git.gnome.org/browse/glib/tree/glib/tests/testing.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;glib/tests/testing.c&lt;/a&gt;
) 있으므로, 별로 길지 않으니, 직접 확인해 보시기 바랍니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로젝트에 활용하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MVP 개발 모델과 TDD + 유닛테스트 도구를 이용하여 응용 프로그램을 개발하면(
&lt;a href=&#34;/2008/12/17/presenter-first-development/&#34;&gt;Presenter First 개발&lt;/a&gt;
) 더 빠르고 쉽게 튼튼한 코드를 만들 수 있으니, 한 번 검토해 보시기 바랍니다. 개발자가 TDD 방법론을 주저하는 이유 중 하나가 테스트 코드까지 만들다 보니 늘어나는 코드량과 늘어나는 개발 시간 때문인데, 테스트 코드를 그대로 실제 코드로 재활용할 수 있다면 얘기가 달라지겠죠.&lt;/p&gt;
&lt;p&gt;프로젝트 일일빌드시 테스트 루틴도 동작하도록 한뒤 자동으로 테스트 결과를 웹사이트에 게재하는 것도 좋은 개발 습관입니다. 아예 코드 수정 후 저장소에 커밋하면 반드시 모든 테스트 케이스를 통과해야만 커밋되도록 저장소를 설정할 수도 있지만, 엄청난 서버 부하를 야기할 수 있으므로, 테스트 케이스를 통과한 코드만 커밋할 수 있도록 가이드라인을 규정하는 것도 좋습니다.&lt;/p&gt;
&lt;p&gt;유닛테스트는 특정 객체나 모듈의 모든 API가 항상 정상적으로 동작하는지를 검사하기 위해 사용합니다. 그래서 가장 기본적인 사용법은 공개 함수를 다양한 인수로 호출한 뒤 그 결과값을 확인하는 방식입니다. 하지만 실무에서는 그렇게 단순한(?) 버그만 존재하는게 아니라서, 특정 시나리오나 특정 조건을 만족할 경우에만 버그 현상이 재현되는 경우도 많습니다. 이러한 경우, 버그에 대한 테스트 케이스를 추가하고 이 케이스에 대한 테스트가 통과할때까지 디버깅을 합니다. 이렇게 해두면 동일한 버그가 나중에 재발하는 걸 방지할 수 있습니다. 대부분 회사에서는 버그(이슈)관리시스템을 사용하므로 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-bug&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_bug()&lt;/code&gt;&lt;/a&gt;
 API를 사용하면 편리합니다.&lt;/p&gt;
&lt;p&gt;참고로, GTK+ 라이브러리는 GLib 테스트 프레임워크를 기반으로 마우스 버튼 동작이나 키보드 입력을 에뮬레이션하는 기능처럼 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/gtk-Testing.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GUI 프로그램 테스트용 API&lt;/a&gt;
를 제공합니다. 더불어 
&lt;a href=&#34;http://en.wikipedia.org/wiki/Xvfb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Xvfb&lt;/a&gt;
 같은 더미 X서버를 이용하면 원격 터미널이나 cron 작업처럼 실제 X서버가 없는 환경에서도 GUI 프로그램 테스트 진행이 가능합니다. 꼭 GTK+ 프로그램이 아니더라도, 폰트 렌더링 루틴이 정확한 그래픽 비트맵을 생성하는지, 특정 항목을 선택하고 특정 행동을 취했을때 정상적으로 문자열이 표시되는지 등도 테스트 케이스로 작성할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;테스트 케이스 실행 방식 및 테스트 코드 위치&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;위 예제처럼 테스트 케이스를 특정 주제별로 나누어 각각의 실행파일로 만들어도 되지만, 테스트 케이스를 초기화하는 부분을 잘 정리하여 테스트 케이스를 여러 모듈로 분리한 뒤,  모든 테스트 케이스를 통째로 하나의 실행파일로 만들어도 됩니다. 이렇게 하면 추가적인 스크립트나 도구의 도움없이도 명령어 한번 실행으로 모든 테스트 케이스를 실행할 수 있기 때문에 더 편리할 수 있습니다. 또는 Clutter 프로젝트처럼 테스트 모듈을 각각 공유라이브러리로 만들어 플러그인처럼 로드해서 실행하는 방법도 있습니다.&lt;/p&gt;
&lt;p&gt;하지만, 위 방식은 모두 실제 코드와 테스트 코드가 서로 다른 파일에 존재하는 방식입니다. 테스트 코드가 실제 코드와 하나의 파일에 존재한다면 테스트 코드 작성이 더 일상화되고 자연스러워질 수 있습니다. 그러므로, 프로그램 실행 파일 크기가 별로 문제가 되지 않는다면, 또는 릴리스 / 디버그 모드를 분리하여 컴파일하도록 구성된 프로젝트라면,  프로그램에 특정 옵션을 주었을 경우에만 테스트 케이스 실행 모드로 동작하게 하면 됩니다. 물론 특정 테스트 프로그램은 예제로 사용하기 위해 분리할 수도 있겠지만, 모듈이나 객체의 고유 기능만 테스트하는 코드라면 같은 파일에 있는게 더 자연스러울 수 있습니다. 예를 들어 GObject 객체라면, 속성(properties) / 시그널(signal) 이름이 갑자기 변경되었을때 이를 참조하는 모듈이 문제를 일으키지 않도록 하기 위해, &amp;lsquo;validate-properties&amp;rsquo;, &amp;lsquo;validate-signals&amp;rsquo; 등의 테스트 케이스를 추가한뒤 통과하지 못했을 경우 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-message&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_message()&lt;/code&gt;&lt;/a&gt;
 등을 이용해 이를 참조하는 모듈을 찾아 수정하라는 강조 메시지를 표시하는 것도 가능합니다. 또한 특정 시그널이 정상적으로 발생하는지, 순서대로 발생하는지 확인할 수 있습니다. 그리고 무엇보다도, 같은 파일에 있으면 내부 자료구조에도 접근할 수 있으므로 내부 로직에 대한 테스트 코드를 작성하는 것도 가능해집니다.&lt;/p&gt;
&lt;p&gt;따라서 무조건 한 가지 방식만 고집하기보다, 적절하게 필요에 따라 알맞는 방식을 선택하는 것이 중요합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결론&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;뭐 다른 결론이 있을리 없을만큼 유닛 테스트와 리그레션 테스트(regression test) 등은 이미 소프트웨어 개발 분야 전반에 광범위하게 사용하고 있습니다. 다만, C 언어를 이용해 개발하는 경우 리거시(legacy) 코드가 너무 많거나, 마땅한 테스트 도구를 찾지 못했거나, 여러가지 이유로 도입하지 못하는 경우가 많은데, 함께 잘 극복하고 익숙해져서 더 좋은 방향으로 나아가야 하지 않을까&amp;hellip; 생각해 봅니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>구글 프로토콜 버퍼(Protocol Buffers)</title>
      <link>/2010/02/12/google-protocol-buffers/</link>
      <pubDate>Fri, 12 Feb 2010 00:00:00 +0000</pubDate>
      <guid>/2010/02/12/google-protocol-buffers/</guid>
      <description>&lt;p&gt;구글 
&lt;a href=&#34;http://code.google.com/p/protobuf/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;프로토콜 버퍼&lt;/a&gt;
 라이브러리에 대해서는 몇 번 
&lt;a href=&#34;/2010/01/29/0mq-a-new-approach-to-messaging/&#34;&gt;언급&lt;/a&gt;
을 한 적이 있는데, 관심만 있고 아직 프로젝트에 사용은 못해보고 있었습니다. 그 이유는 프로젝트 대부분이 C 언어를 사용하는데, &lt;strong&gt;공식적으로&lt;/strong&gt; 지원하는 언어에는 없었기 때문입니다.&lt;/p&gt;
&lt;p&gt;그런데 오늘 우분투 패키지를 업데이트하다가 
&lt;a href=&#34;http://code.google.com/p/protobuf-c/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protobuf-c&lt;/a&gt;
 
&lt;a href=&#34;http://packages.ubuntu.com/lucid/protobuf-c-compiler&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;우분투 패키지&lt;/a&gt;
가 있어서 확인해보니, 프로토콜 버퍼 데이터를 읽고 쓸 수 있는 런타임 라이브러리와 *.[hc] 파일을 생성하는 컴파일러가 들어있군요. 그래서 아예 구글 코드 사이트에 있는 
&lt;a href=&#34;http://code.google.com/hosting/search?q=label:protobuf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protobuf 관련 프로젝트 목록&lt;/a&gt;
을 훑어보니, C 언어 뿐 아니라 다양한 언어에 대한 바인딩을 지원할 뿐 아니라 이클립스 플러그인, 와이어샤크(wireshark) 플러그인 등처럼 유용한 도구도 많이 찾을 수 있었습니다.&lt;/p&gt;
&lt;p&gt;이런 경우 언제나 느끼는 거지만, 요즘은 노하우(know-how)보다 노훼어(know-where)가 더 필요한 세상인 것 같습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Power of 10: 안전성이 중요한 코드 개발을 위한 규칙</title>
      <link>/2010/01/25/power-of-10-rules-for-developing-safety-critical-code/</link>
      <pubDate>Mon, 25 Jan 2010 00:00:00 +0000</pubDate>
      <guid>/2010/01/25/power-of-10-rules-for-developing-safety-critical-code/</guid>
      <description>&lt;p&gt;`
&lt;a href=&#34;http://www.embedded.com/design/222301487&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;정적 분석과 코딩 규칙을 이용한 임베디드 소프트웨어 버그 줄이기&lt;/a&gt;
&amp;lsquo;라는 제목의 기사를 읽다가 `
&lt;a href=&#34;http://spinroot.com/gerard/pdf/Power_of_Ten.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Power of 10&lt;/a&gt;
&amp;rsquo; 규칙이 언급되었길래 다시 읽어볼 기회가 생겼습니다. 기사 내용은 필자가 개발한 정적 분석 도구 제품을 홍보하는 느낌을 받았지만, 어느 정도의 가이드라인을 지킨 코드는 정적 분석 도구의 도움을 받아 미리 오류를 발견하고 수정하기가 더 쉽기 때문에 상호 보완하는 것이 좋다는 점에는 동의합니다. 아무튼 기사와는 별도로, 십제곱(?) 규칙은 다시 읽어도 나름대로 곱씹을 가치가 있는 것 같아 우리말로 다시 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;대부분 소프트웨어 프로젝트는 나름의 코딩 가이드라인을 사용합니다. 가이드라인은 프로그래머가 소프트웨어를 만들때 어떻게 구성할지, 언어의 어떤 특징을 사용하고 사용하면 안되는지 등을 규정합니다. 하지만 수많은 코딩 가이드라인이 대부분 비슷하고, 너무 규칙이 많거나 모호한 경우도 많습니다. 때로는 공백문자 사용법 등과 같은 개인적인 취향을 반영하기도 합니다. 결과적으로 이러한 코딩 가이드라인은 개발자가 코드를 작성할때 별로 영향을 끼치지 못하곤 합니다. 더 나아가 도구를 사용하여 검사하는 작업과 병행하기 어렵게 하기도 합니다. 도구를 사용하여 검사하는 과정은 중요한데, 수십만 라인의 코드를 직접 검토하는 작업은 불가능하기 때문입니다.&lt;/p&gt;
&lt;p&gt;따라서 좋은 코딩 가이드라인은 분량이 적고, 사람들이 쉽게 이해하고 기억할 수 있도록 명료해야 합니다. 그래서 저자는 10개의 효율적이고 규칙을 제안합니다. 이 가이드라인은 임베디드 소프트웨어 개발에 오랫동안 널리 사용해 온 C 언어를 대상으로 합니다. (참고로 저자는 NASA의 JPL(Jet Propulsion Lab.)에 근무하면서 고신뢰 소프트웨어 개발을 연구하는 분입니다)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;규칙 1: 단순하게 제어 흐름(control flow)을 구성하고 goto, setjmp(), longjump(), 재귀(recursion) 사용 안하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;제어 흐름이 단순할수록 더 튼튼하고 분석이 용이하며 코드를 명료하게 합니다. 재귀를 없애면 순환하는 호출 그래프를 없앨 수 있고, 그로 인해 스택 오버플로우 등을 걱정할 필요도 없습니다. 그렇다고 이 규칙이 모든 함수가 단일점에서 복귀(return)해야 한다는 건 아닙니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;규칙 2: 루프에서 상한값을 고정하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;검사 도구가 쉽게 분석할 수 있을 뿐 아니라, 재귀를 피하는 규칙과 더불어 이 규칙을 따르면 무한루프처럼 폭주하는 코드를 걱정할 필요가 없습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;규칙 3: 초기화 이후 동적 메모리 할당 사용 한하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;많은 가이드라인에 포함되어 있는 규칙인데, 이유는 명료합니다. 동적 메모리 할당 함수는 성능에 심각한 영향을 끼칠 뿐 아니라 실수로 인한 메모리 누수는 시스템을 심각한 상태에  빠뜨릴 수 있기 때문입니다. 필요하다면 alloca() 등과 같은 스택 기반 동적 할당은 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;규칙 4: 함수 하나가 출력시 한 페이지를 넘어가지 않도록 제한하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;함수를 더 쉽게 이해하고 검증할 수 있는 단위로 나누기 위해 필요합니다. 함수가 길어질수록 논리적으로 잘 구조화된 코드를 작성하기 어렵습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;규칙 5: 함수에 최소 2개 이상의 단언문(assert) 사용하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;최종 빌드시 비활성화될 수 있는 단언문은 개발 도중 많이 사용할 수록 좋습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;규칙 6: 자료 객체는 가능한 가장 작은 범위(scope)에서 선언하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;정보 은닉(information hiding) 원칙에 따라, 불필요하게 변수의 범위를 확장하지 않으면 잘못 참조해서 발생하는 오류를 줄일 수 있습니다. 또한 변수 재사용을 막아서, 코드를 더 정확하게 분석하고 구조화할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;규칙 7: 결과값을 돌려주는 함수의 결과값을 반드시 확인하고, 함수에 전달된 모든 인수가 유효한지 확인하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;가장 지켜지지 않는 규칙 중 하나입니다. printf(), scanf(), close() 등의 결과값을 검사하지 않는 사람도 대부분이지만, 검사하는 것이 맞습니다. 결과값이 맞던 틀리던 상관없더라도 반드시 각 조건에 해당하는 처리 코드가 있어야 하며, 분명히 인지하고 있다면 명시적으로 함수 결과값을 (void) 문을 이용해 형변환해서 무시해야 합니다. 하지만 에러값을 돌려주는 함수는 반드시 무조건 검사해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;규칙 8: 매크로는 파일을 포함하거나(include) 단순하게 정의할 때만 사용하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C 전처리기는 강력하기 때문에, 그만큼 코드를 복잡하게 만듭니다. 그래서 정적 분석 도구는 물론 사람 역시 코드를 분석하고 이해하려면 매우 많은 노력이 필요하고, 이는 결과적으로 불안정하고 불확실한 코드를 생성하는 주범이 될 수 있습니다. 특히 조건 컴파일을 사용하면 코드 복잡도가 사용하는 회수만큼 높아지기 때문에 가능하면 피해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;규칙 9: 포인터 사용 안하기, 필요하더라도 1단계 이상 참조하는 포인터는 절대 사용 안하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;typedef 선언을 이용해 2단계 이상 포인터 참조를 숨겨서도 안됩니다. 포인터는 경험많은 프로그래머라도 오용하기 쉽고, 프로그램에서 데이터 흐름을 따라가기 어렵게 합니다. 함수 포인터 역시 가능하면 사용하지 않는 것이 좋은데, 분석 도구를 사용하더라도, 포인터 유효성, 재귀 호출의 위험 등을 미리 알 수 있는 방법이 어렵기 때문입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;규칙 10: 컴파일시 모든 경고 메시지를 켜고, 모든 코드가 경고 없이 컴파일되도록 하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;컴파일러 역시 하나의 분석 도구라고 간주할 수 있습니다. 컴파일러가 혼란을 일으키는 코드라면 반드시 실행 중에 문제를 일으킬 수 있습니다.&lt;/p&gt;
&lt;p&gt;물론 위 규칙을 모든 소프트웨어 개발에 적용할 수는 없겠지만, 항상 염두에 두고 있다면, 비단 임베디드 시스템 개발 뿐 아니라 모든 소프트웨어 개발 과정에서 오류를 미리 예방하는데 도움될 것이라는 점은 분명한 것 같습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GLib 메인루프 이용하기</title>
      <link>/2009/09/21/using-glib-mainloop/</link>
      <pubDate>Mon, 21 Sep 2009 00:00:00 +0000</pubDate>
      <guid>/2009/09/21/using-glib-mainloop/</guid>
      <description>&lt;p&gt;GLib API를 이용한 멀티쓰레드 프로그래밍에서 비동기 메시지 큐를 이용하는 방법은 지난 
&lt;a href=&#34;/2008/08/06/glib-thread-programming/&#34;&gt;포스트&lt;/a&gt;
에서 설명한 적이 있는데, 이번에는 
&lt;a href=&#34;/2009/09/17/glib-mainloop-vs-libdispatch-of-apple-gcd/&#34;&gt;애플 GCD의 libdispatch와 비교되는 GLib의 메인루프&lt;/a&gt;
를 이용하는 방법을 정리해 보았습니다. 이 방법은 어떤 관점에서 보면 더 쉽고, 이미 많은 기능이 기본적으로 지원되기 때문에 몇몇 경우를 제외하면 더 좋은 방법입니다. 다만 API 사용법을 이해하기가 처음에 조금 까다롭다는 점이 걸림돌입니다.&lt;/p&gt;
&lt;p&gt;일반적으로 GLib / GTK 어플리케이션은 메인 쓰레드에서 실행되는 메인 이벤트 루프 기반에서 동작합니다. 키보드 / 마우스 이벤트 처리, 화면 표시, 사용자가 등록한 Idle / Timeout 함수 처리 등이 모두 이 메인 이벤트 루프에서 처리됩니다. 그런데 이 메인 이벤트 루프라는 건 마냥 개념적인게 아니라, 실제로 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-The-Main-Event-Loop.html#GMainLoop&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GMainLoop&lt;/a&gt;
 객체를 기반으로 동작합니다. 그런데 &lt;code&gt;g_main_loop_*()&lt;/code&gt; 계열 함수를 살펴보면 몇 개 안됩니다. 루프 객체를 생성하고, 참조하고, 해제하고, 돌리고[&lt;code&gt;g_main_loop_run()]&lt;/code&gt;, 종료하고[&lt;code&gt;g_main_loop_quit()]&lt;/code&gt;, 돌아가는 중인지 확인하기 등의 함수만 있습니다. 아, 하나 더 있군요. 객체를 생성할때 전달하는 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-The-Main-Event-Loop.html#GMainContext&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GMainContext&lt;/a&gt;
 객체를 얻어오는 함수[&lt;code&gt;g_main_loop_get_context()]&lt;/code&gt;가 있군요.&lt;/p&gt;
&lt;p&gt;모든 GMainLoop는 하나의 GMainContext와 함께 사용됩니다. GMainContext 객체는 실행할 소스[
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-The-Main-Event-Loop.html#GSource&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GSource&lt;/a&gt;
] 목록을 관리합니다. 소스는 파일, 파이프, 소켓 등의 디스크립터를 기반으로 한 이벤트 소스일 수도 있고, Idle / Timeout 등과 같은 시간 소스일 수도 있습니다. 컨텍스트는 실행 소스 각각을 검사해서 원하는 이벤트가 발생했는지, 아니면 실행할 시간이 되었는지를 판단해 등록한 콜백함수를 호출합니다. 참고로, 메인 쓰레드에서 동작하기 위한 컨텍스트[&lt;code&gt;g_main_context_default()&lt;/code&gt;]는 기본적으로 제공합니다. 이 기본 컨텍스트는 &lt;code&gt;gtk_main()&lt;/code&gt; 함수가 사용하는 것은 물론, &lt;code&gt;g_idle_add()&lt;/code&gt;, &lt;code&gt;g_timeout_add()&lt;/code&gt; 등과 같은 함수도 이 기본 컨텍스트를 사용합니다.&lt;/p&gt;
&lt;p&gt;아무튼 조금 더 구체적이고 자세한 내용은 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-The-Main-Event-Loop.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;공식 문서&lt;/a&gt;
를 참고하시고, 이제 이를 이용한 멀티쓰레드 프로그래밍을 해보겠습니다. 말이 길었으니 코드를 먼저 보여드리겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;glib.h&amp;gt;

static GThread *my_thread;
static GMainLoop *my_loop;

static void
add_idle_to_my_thread (GSourceFunc    func,
                       gpointer       data)
{
  GSource *src;

  src = g_idle_source_new ();
  g_source_set_callback (src, func, data, NULL);
  g_source_attach (src,
                   g_main_loop_get_context (my_loop));
  g_source_unref (src);
}

static void
add_timeout_to_my_thread (guint          interval,
                          GSourceFunc    func,
                          gpointer       data)
{
  GSource *src;

  src = g_timeout_source_new (interval);
  g_source_set_callback (src, func, data, NULL);
  g_source_attach (src,
                   g_main_loop_get_context (my_loop));
  g_source_unref (src);
}

static gpointer
loop_func (gpointer data)
{
  GMainLoop *loop = data;

  g_main_loop_run (loop);

  return NULL;
}

static void
start_my_thread (void)
{
  GMainContext *context;

  context = g_main_context_new ();
  my_loop = g_main_loop_new (context, FALSE);
  g_main_context_unref (context);

  my_thread = g_thread_create (loop_func, my_loop, TRUE, NULL);
}

static void
stop_my_thread (void)
{
  g_main_loop_quit (my_loop);
  g_thread_join (my_thread);
  g_main_loop_unref (my_loop);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;함수 먼저 설명하면, &lt;code&gt;start_my_thread()&lt;/code&gt; 함수는 쓰레드를 시작하고, &lt;code&gt;stop_my_thread()&lt;/code&gt; 함수는 쓰레드를 중지합니다. &lt;code&gt;add_idle_to_my_thread()&lt;/code&gt; 함수는 바로 실행되는 Idle 콜백 함수를 추가하고, &lt;code&gt;add_timeout_to_my_thread()&lt;/code&gt; 함수는 주기적으로 실행되는 Timeout 콜백 함수를 추가합니다. 마지막 두 함수의 인수는 &lt;code&gt;g_idle_add()&lt;/code&gt;, &lt;code&gt;g_timeout_add()&lt;/code&gt; 함수와 각각 동일합니다. 따라서, 콜백 함수가 &lt;code&gt;TRUE&lt;/code&gt;를 리턴하면 자동으로 반복해서 계속 실행되고, &lt;code&gt;FALSE&lt;/code&gt;를 리턴하면 한번만 실행되고 종료합니다.&lt;/p&gt;
&lt;p&gt;위 코드의 핵심은 GMainContext 객체를 만들고 이를 기반으로 GMainLoop 객체를 만든 뒤 별도 쓰레드에서 실행하도록 하는 부분입니다. 그리고, 필요한 모든 작업은 Idle / Timeout 소스 객체를 만들어 컨텍스트에 추가(attach)해서 동작하도록 하는 겁니다. 참고로, 관련 API는 모두 쓰레드에 안전합니다.&lt;/p&gt;
&lt;p&gt;물론 위 함수를 조금 더 확장하면 콜백함수가 종료될때 자동으로 호출되는 notify 함수도 등록할 수 있고, 우선순위도 조절할 수 있습니다. 또한 여러 쓰레드를 종류별로 만들어 필요한 쓰레드에게 해당 작업만 전달해도 됩니다. 하지만 그 정도는 응용하는데 별로 어려움이 없을 거라 생각하고 한가지만 더 설명하겠습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 네트워크 소켓(socket)을 하나 만들고 이 소켓에 읽을 데이터가 도착했을 경우에만 호출되는 함수를 등록하고 싶은 경우, 다음과 같은 코드를 사용하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static gboolean
socket_read (GIOChannel  *source,
             GIOCondition condition,
             gpointer data)
{
  /* Use g_io_channel_read_chars() to read data... */

  return TRUE;
}

static void
add_socket_to_my_thread (gint sock_fd)
{
  GIOChannel *channel;
  GSource *src;

  channel = g_io_channel_unix_new (sock_fd);
  src = g_io_create_watch (channel, G_IO_IN);
  g_source_set_callback (src,
                         (GSourceFunc) read_socket,
                         NULL,
                         NULL);
  g_source_attach (src,
                   g_main_loop_get_context (my_loop));
  g_source_unref (src);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;자세한 내용은 위 코드와 비슷하지만 기본 메인 이벤트 루프에서 동작하도록 하는 &lt;code&gt;g_io_add_watch()&lt;/code&gt; API 설명 부분을 참고하시기 바랍니다. 어쨌든, 기본적으로 GMainContext 객체는 유닉스 시스템의 폴링(polling) 메카니즘을 사용하기 때문에 이론적으로는 거의 모든 파일 디스크립터를 사용할 수 있습니다. 물론 비슷한 방식으로 윈도우 운영체제에서 이벤트 핸들이나 소켓 핸들도 사용할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;글머리에서 적은 것처럼 비동기 메시지 큐를 이용하는 방식보다 아주 약간의 오버헤드는 있겠지만, 훨씬 더 많은 기능을 제공하는 것 같지 않나요?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (4)</title>
      <link>/2009/08/24/oop-with-gobject-4/</link>
      <pubDate>Mon, 24 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/24/oop-with-gobject-4/</guid>
      <description>&lt;p&gt;이전 글에 계속 이어집니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;객체 속성 정보 얻기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EdcHost 객체의 속성 정보를 실행 중에 얻어볼까 합니다.&lt;/p&gt;
&lt;p&gt;왜 또 갑자기 불필요한 예제를 꺼내냐고 물어보실 분이 있을 것 같아 말하자면, 가끔 요긴한 경우가 있기 때문입니다. 예를 들어 EdcHost 객체를 상속받은 EdcHostDoosan, EdcHostKia, EdcHostLitte 객체가 여러 개 존재할 경우, 이 객체들은 EdcHost의 공통 속성 뿐 아니라 본인의 속성도 따로 가집니다. 이러한 여러 객체를 관리할때, 특정 속성이 있는지 여부를 검사해서 관련 UI를 활성 / 비활성하거나, 편집 UI 자체를 속성 스펙과 목록을 이용해 100% 자동화하는 게 가능합니다. (Glade 처럼 말이죠) 물론 옵션 같은 플래그(flags) 변수를 정의하는 방법 등 여러가지 대안이 가능하겠지만, 최초 객체 설계시 고려하지 못했던 기능이나 속성을 나중에 계속 추가해 나가야 하는 경우 기존에 만든 객체를 매번 다시 수정하고 업그레이드하는 것보다 더 안전하고 깔끔한 방법이 될 수 있습니다. 그리고 당연히 더많은 응용이 있겠지만, 일단 알아두면 나중에 어떤 식으로든 도움이 되리라 생각합니다.&lt;/p&gt;
&lt;p&gt;일단, 다음 코드는 객체가 가지고 있는 속성 이름과 각 속성의 현재 값을 출력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void
print_properties (GObject *object)
{
  GObjectClass *oclass;
  GParamSpec **specs;
  guint n;
  guint i;

  oclass = G_OBJECT_GET_CLASS (object);
  specs = g_object_class_list_properties (oclass, &amp;amp;n);
  for (i = 0; i &amp;lt; n; i++)
    {
      GParamSpec *spec;
      GValue value = { 0 };
      gchar *str;

      spec = specs[i];

      g_value_init (&amp;amp;value, spec-&amp;gt;value_type);
      g_object_get_property (G_OBJECT (object),
                             spec-&amp;gt;name,
                             &amp;amp;value);
      str = g_strdup_value_contents (&amp;amp;value);

      g_print (&amp;quot;property &#39;%s&#39; is &#39;%s&#39;n&amp;quot;,
               spec-&amp;gt;name,
               str);

      g_value_unset (&amp;amp;value);
      g_free (str);
    }
  g_free (specs);
}

{
  EdcHost *host;

  /* ... */ 

  host = g_object_new (
           EDC_TYPE_HOST,
           &amp;quot;address&amp;quot;, &amp;quot;demo.emstone.com&amp;quot;,
           &amp;quot;port&amp;quot;, 8081,
           NULL);
  print_properties (G_OBJECT (host));
  g_object_unref (host);

  /* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드에서 분명하게 이해해야 하는 점은, 객체 인스턴스가 아닌 객체 클래스에게 속성 정보를 질의한다는 점입니다. 모든 속성의 스펙을 얻기 위해 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-list-properties&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_list_properties()&lt;/code&gt;&lt;/a&gt;
 함수를 사용하고, GValue 객체에 속성 값을 가져온 다음, 문자열로 출력하기 위해 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Generic-values.html#g-strdup-value-contents&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_strdup_value_contents()&lt;/code&gt;&lt;/a&gt;
 함수를 이용해 변환하고 있습니다.&lt;/p&gt;
&lt;p&gt;객체에 어떤 속성이 있는지 알아보려면 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-find-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_find_property()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;속성 변경 알림 시그널 이용하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;객체의 속성 값을 변경할 때 &lt;code&gt;g_object_set()&lt;/code&gt; 함수를 이용하면 좋은 점은, 값을 변경하면 자동으로 시그널(signal)이 발생한다는 점입니다. GObject 시스템에서 시그널은 특정 사건(event)이 일어나면 발생(emit)합니다. 대부분의 경우 시그널은 객체 클래스 초기화시에 정의해야 하지만, 다행히도 속성 값이 변경될때 발생하는 시그널은 특별한 작업을 해주지 않아도 기본적으로 동작합니다. 따라서 &amp;ldquo;&lt;code&gt;notify::property-name&lt;/code&gt;&amp;rdquo; 형식의 이름을 가지는 시그널에 콜백 함수를 연결하면 객체 값이 변경될때 자동으로 호출되는 함수를 등록할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void
property_notified (GObject    *object,
                   GParamSpec *pspec,
                   gpointer    data)
{
  GValue value = { 0 };
  gchar *str;

  g_value_init (&amp;amp;value, pspec-&amp;gt;value_type);
  g_object_get_property (object, pspec-&amp;gt;name, &amp;amp;value);
  str = g_strdup_value_contents (&amp;amp;value);

  g_print (&amp;quot;property &#39;%s&#39; is set to &#39;%s&#39;n&amp;quot;,
             pspec-&amp;gt;name, str);

  g_value_unset (&amp;amp;value);
  g_free (str);
}

{
  EdcHost *host;

  host = g_object_new (EDC_TYPE_HOST, NULL);

  g_signal_connect (host,
                    &amp;quot;notify::address&amp;quot;,
                    G_CALLBACK (property_notified),
                    NULL);
  g_signal_connect (host,
                    &amp;quot;notify::port&amp;quot;,
                    G_CALLBACK (property_notified),
                    NULL);

  g_object_set (host,
                &amp;quot;address&amp;quot;, &amp;quot;192.168.0.1&amp;quot;,
                &amp;quot;port&amp;quot;, 8087,
                NULL);

  edc_host_set_address (host, &amp;quot;192.168.0.22&amp;quot;);

  g_object_unref (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 이 기능은, 디자인 패턴에서 말하는 관찰자(observer) 패턴일 수도 있고, GObject 매뉴얼에서 사용하는 것처럼 일종의 메시징 시스템 역할도 합니다. 예를 들어 모델(model)의 값이 변경되면 자동으로 뷰(view) 역할을 하는 GUI에 반영하는 코드를 작성할 경우 기존 객체 구현 코드를 수정하지 않고, 다시 말해 의존성을 추가하지 않고 기능을 구현할 수 있게 도와주어 객체간 결합도를 없애 줍니다.&lt;/p&gt;
&lt;p&gt;자 그런데, 위 예제에서 &lt;code&gt;edc_host_set_address()&lt;/code&gt; 를 사용할 때는 콜백함수가 호출이 안되는 문제점이 있습니다. 왜냐하면 이 함수는 내부 address 변수를 직접 수정하기 때문에 값이 변경되었는지 여부를 GObject 시스템이 알 방법이 없기 때문입니다. 따라서 기존 코드를 수정해야 하는데, 첫번째 방법은 접근자를 이용하더라도 내부적으로 &lt;code&gt;g_object_set()&lt;/code&gt; 을 호출하도록 하는 겁니다. (여기서는 &amp;lsquo;address&amp;rsquo; 관련 API만 보여드립니다)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void
edc_host_set_address (EdcHost     *host,
                      const gchar *address)
{
  g_return_if_fail (EDC_IS_HOST (host));
  g_return_if_fail (address != NULL);

  g_object_set (host,
                &amp;quot;address&amp;quot;,  address,
                NULL);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 이 방법은 약간의 오버헤드가 있을 수 있습니다. 두번째 방법은, 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-notify&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_notify()&lt;/code&gt;&lt;/a&gt;
 함수를 이용해 직접 알려주는 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void
edc_host_set_address (EdcHost     *host,
                      const gchar *address)
{
  EdcHostPrivate *priv;

  g_return_if_fail (EDC_IS_HOST (host));
  g_return_if_fail (address != NULL);

  priv = EDC_HOST_GET_PRIVATE (host);

  g_free (priv-&amp;gt;address);
  priv-&amp;gt;address = g_strdup (address);

  g_object_notify (G_OBJECT (host), &amp;quot;address&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;edc_host_set_property()&lt;/code&gt; 함수 안에서 중복되는 코드도 정리해 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void
edc_host_set_property (GObject      *object,
                       guint         property_id,
                       const GValue *value,
                       GParamSpec   *pspec)
{
  EdcHost *host = EDC_HOST (object);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  switch (property_id)
    {
    case EDC_HOST_PROP_NAME:
      edc_host_set_name (host, g_value_get_string (value));
      break;
    case EDC_HOST_PROP_ADDRESS:
      edc_host_set_address (host, g_value_get_string (value));
      break;
    case EDC_HOST_PROP_PORT:
      edc_host_set_port (host, g_value_get_int (value));
      break;
    case EDC_HOST_PROP_USER:
      edc_host_set_user (host, g_value_get_string (value));
      break;
    case EDC_HOST_PROP_PASSWORD:
      edc_host_set_password (host, g_value_get_string (value));
      break;
    default:
      /* We don&#39;t have any other property... */
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object,
                                         property_id,
                                         pspec);
      break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;시그널이 중복 발생할 경우를 염려할 필요는 없습니다. 시그널은 GObject 내부적으로 알아서 잘 정리되어 한 번 변경하면 한 번만 시그널이 발생합니다.&lt;/p&gt;
&lt;p&gt;오늘은 여기까지입니다&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (3)</title>
      <link>/2009/08/18/oop-with-gobject-3/</link>
      <pubDate>Tue, 18 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/18/oop-with-gobject-3/</guid>
      <description>&lt;p&gt;이 글은 회사 개발팀 내부 세미나를 위해 작성중인 글입니다. 하지만, 블로그란 매체의 특성상 외부에도 공개되고 있는데, 댓글은 달지 않아도 접속하는 사람들 대부분이 제가 아는 분일 거라 생각하고 한마디 하자면, 세상에 공짜가 어디 있는가, 주저하지 말고 내게 연락해서 술 한 잔 사게! (언젠가부터 술 강요 청탁 협박 블로그가 되어 가고 있군&amp;hellip;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;속성 (Properties) 추가하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이제, GObject 속성(properties) 기능을 추가하려고 하는데, 왜 쓸데없이 일을 만들어서 하냐고 물으면 할 말이 있어야할 것 같아서, GObject 속성의 특징을 요약해 봤습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;단일 API로 모든 속성 값을 얻어오거나 변경하기&lt;/li&gt;
&lt;li&gt;속성 변경시 자동으로 호출되는 함수 등록하기 (시그널 이용)&lt;/li&gt;
&lt;li&gt;실행 중에 속성에 대한 정보 얻어내기&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;물론 이미 많은 언어와 라이브러리가 그 이상의 기능을 지원하기도 하고, 일정 능력 이상의 개발자라면 직접 구현하는게 아주 어려운 것도 아닙니다. 하지만 이미 잘 구현되어 검증받은 라이브러리가 있는데 굳이 새로운 바퀴를 만들 필요는 없겠지요? 아무튼, 정확한 내용은 글을 적으면서 하나씩 설명해 나가겠습니다.&lt;/p&gt;
&lt;p&gt;GObject 객체에 속성을 추가하려면 속성의 값(value)이 어떤 형(type)인지, 이름이 무엇인지, 값의 범위는 어떻게 되는지, 기본값은 무엇인지 등을 정의해서 알려주어야 합니다. (C++이나 Java에서 클래스 멤버 변수를 정의하는 것과 비슷합니다) 이러한 정보를 줄임말로 스펙(spec.)이라고 한다면, 속성을 추가한다는 건 다른 말로, 스펙으로 명시한 속성 정보를 클래스에 설치(install)하는 것을 의미합니다. 객체 인스턴스마다 속성의 실제 값(value)은 모두 다르겠지만, 어떤 속성이 있는지 그 속성은 어떻게 구성되어는지는 모두 동일하겠지요. (참고로 GObject 관련 API를 훑어보시면 정확히 모르더라도 지금 언급한 개념의 단어로 이루어진 API가 꽤 많은 걸 아시게 될 겁니다) 그렇기 때문에, 속성을 추가하는 작업은 클래스 초기화 함수에서 이루어집니다.&lt;/p&gt;
&lt;p&gt;다음은 기존 예제에서 속성을 추가한 코드입니다. (변경된 부분만 보여드립니다)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* ...[snip]... */

enum
{
  EDC_HOST_PROP_0, /* ignore */
  EDC_HOST_PROP_NAME,
  EDC_HOST_PROP_ADDRESS,
  EDC_HOST_PROP_PORT,
  EDC_HOST_PROP_USER,
  EDC_HOST_PROP_PASSWORD
};

/* ...[snip]... */

static void
edc_host_get_property (GObject    *object,
                       guint       property_id,
                       GValue     *value,
                       GParamSpec *pspec)
{
  EdcHost *host = EDC_HOST (object);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  switch (property_id)
    {
    case EDC_HOST_PROP_NAME:
      g_value_set_string (value, priv-&amp;gt;name);
      break;
    case EDC_HOST_PROP_ADDRESS:
      g_value_set_string (value, priv-&amp;gt;address);
      break;
    case EDC_HOST_PROP_PORT:
      g_value_set_int (value, priv-&amp;gt;port);
      break;
    case EDC_HOST_PROP_USER:
      g_value_set_string (value, priv-&amp;gt;user);
      break;
    case EDC_HOST_PROP_PASSWORD:
      g_value_set_string (value, priv-&amp;gt;password);
      break;
    default:
      /* We don&#39;t have any other property... */
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object,
                                         property_id,
                                         pspec);
      break;
    }
}

static void
edc_host_set_property (GObject      *object,
                       guint         property_id,
                       const GValue *value,
                       GParamSpec   *pspec)
{
  EdcHost *host = EDC_HOST (object);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  switch (property_id)
    {
    case EDC_HOST_PROP_NAME:
      g_free (priv-&amp;gt;name);
      priv-&amp;gt;name = g_value_dup_string (value);
      break;
    case EDC_HOST_PROP_ADDRESS:
      g_free (priv-&amp;gt;address);
      priv-&amp;gt;address = g_value_dup_string (value);
      break;
    case EDC_HOST_PROP_PORT:
      priv-&amp;gt;port = g_value_get_int (value);
      break;
    case EDC_HOST_PROP_USER:
      g_free (priv-&amp;gt;user);
      priv-&amp;gt;user = g_value_dup_string (value);
      break;
    case EDC_HOST_PROP_PASSWORD:
      g_free (priv-&amp;gt;password);
      priv-&amp;gt;password = g_value_dup_string (value);
      break;
    default:
      /* We don&#39;t have any other property... */
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object,
                                         property_id,
                                         pspec);
      break;
    }
}

/* ...[snip]... */

/* class initializer */
static void
edc_host_class_init (EdcHostClass *klass)
{
  GObjectClass *gobj_class;
  GParamSpec *pspec;

  gobj_class = G_OBJECT_CLASS (klass);
  gobj_class-&amp;gt;finalize = edc_host_finalize;
  gobj_class-&amp;gt;set_property = edc_host_set_property;
  gobj_class-&amp;gt;get_property = edc_host_get_property;

  g_type_class_add_private (gobj_class,
                            sizeof (EdcHostPrivate));

  pspec =
    g_param_spec_string (&amp;quot;name&amp;quot;,               /* name */
                         &amp;quot;Name&amp;quot;,               /* nick */
                         &amp;quot;the name of a host&amp;quot;, /* blurb */
                         &amp;quot;&amp;quot;,                   /* default */
                         G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_NAME,
                                   pspec);

  pspec = g_param_spec_string (&amp;quot;address&amp;quot;,
                               &amp;quot;Address&amp;quot;,
                               &amp;quot;the address of a host&amp;quot;,
                               &amp;quot;&amp;quot;,
                               G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_ADDRESS,
                                   pspec);

  pspec = g_param_spec_int (&amp;quot;port&amp;quot;,
                            &amp;quot;Port&amp;quot;,
                            &amp;quot;the port number of a host&amp;quot;,
                            0,     /* minimum */
                            65535, /* maximum */
                            0,     /* default */
                            G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_PORT,
                                   pspec);

  pspec = g_param_spec_string (&amp;quot;user&amp;quot;,
                               &amp;quot;User&amp;quot;,
                               &amp;quot;password for authetication&amp;quot;,
                               &amp;quot;&amp;quot;,
                               G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_USER,
                                   pspec);

  pspec = g_param_spec_string (&amp;quot;password&amp;quot;,
                               &amp;quot;Password&amp;quot;,
                               &amp;quot;password for authetication&amp;quot;,
                               &amp;quot;&amp;quot;,
                               G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_PASSWORD,
                                   pspec);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제일 먼저 정의된 열거형 타입에 대해 설명하자면, 클래스 내부에서 속성은 정수형 숫자로 관리됩니다. 예를 들어 1번 속성, 3번 속성처럼 직접 정수형을 사용해도 되지만, 관례적으로 가독성을 위해 열거형으로 정의합니다. 이렇게 정의한 번호를 클래스에 속성을 설치할때 지정하면 [
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-install-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_install_property()&lt;/code&gt;&lt;/a&gt;
],  &lt;code&gt;edc_host_{get/set}_property() &lt;/code&gt;속성 읽기 / 쓰기 함수의 인자로 `&lt;code&gt;property_id&lt;/code&gt;&#39;가 전달되는데, 이 ID가 바로 속성 번호입니다. 물론 속성 번호는 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-override-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_override_property()&lt;/code&gt;&lt;/a&gt;
 같은 다른 API에서도 사용합니다.[](&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-override-property&#34;&gt;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-override-property&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edc_host_class_init()&lt;/code&gt; 클래스  초기화 함수를 보면, 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_param_spec_*()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하여 각 속성의 스펙을 정의해서 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-install-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_install_property()&lt;/code&gt;&lt;/a&gt;
함수를 이용해 클래스 객체에 설치합니다. 그리고,속성 읽기 /쓰기 메쏘드를 재정의합니다. 참고로 API 문서를 확인하시면, 다양한 형(type)을 위한 스펙 정의 함수가 있는 걸 알 수 있습니다. 속성 스펙을 정의할때 마지막에 넣어주는 플래그(flags)는 속성의 특성을 정의하는데, 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-GParamSpec.html#GParamFlags&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GParamFlags&lt;/a&gt;
 설명을 한 번 읽어보시면 어렵지 않게 이해할 수 있습니다. 여기서는 모든 속성을 읽고 쓰기 가능하게 했습니다.&lt;/p&gt;
&lt;p&gt;재정의된 &lt;code&gt;edc_host_{get/set}_property() &lt;/code&gt;속성 읽기 / 쓰기 메쏘드 함수를 보면, 접근자(accessor) 함수와 동일한 작업을 합니다. 다른 점이라면 속성 ID에 따라 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Generic-values.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GValue&lt;/a&gt;
 객체에서 값을 읽거나, 값을 할당한다는 점입니다. GValue 객체는 쉽게 말해 어떤 형(type)의 값이라도 담을 수 있는 일반적인 값(generic values)입니다. 참고로 이 역시 다양한 형(type)을 위한 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_value_{set,get}_*()&lt;/code&gt;&lt;/a&gt;
 형태의 함수가 존재하므로 이를 그대로 이용하면 됩니다. (물론 더 능숙하게 사용하려면 API 문서를 한 번 훑어보는게 좋겠지요)&lt;/p&gt;
&lt;p&gt;여기까지 이해하셨다면 아시겠지만, GObject 시스템은 속성에 전반적인 틀과 관리 체계만 제공할 뿐 실제 속성을 다루는 작업은 대부분 직접 구현해야 합니다. 이는 프로그래머의 자유도를 높여 주기도 하지만, 불필요한 반복 작업을 유발하기도 합니다. 그리고 이 때문에 
&lt;a href=&#34;http://live.gnome.org/Vala&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vala&lt;/a&gt;
 같은 GObject 기반 언어가 새로 만들어지기도 했습니다.&lt;/p&gt;
&lt;p&gt;**속성 (Properties) 사용하기
**&lt;/p&gt;
&lt;p&gt;이렇게 정의한 속성을 객체 외부에서 사용하기 위해 몇 가지 방법이 있지만, 가장 쉽고 많이 사용하는 방법은 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-get&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_get()&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_set()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하는 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  EdcHost *host;
  gchar *address;
  gint port;

  g_type_init ();

  host = edc_host_new ();

  g_object_set (host,
                &amp;quot;address&amp;quot;, &amp;quot;192.168.0.100&amp;quot;,
                &amp;quot;port&amp;quot;, 8080,
                NULL);

  address = edc_host_get_address (host);
  g_assert_cmpstr (address, ==, &amp;quot;192.168.0.100&amp;quot;);
  g_free (address);

  g_object_get (host,
                &amp;quot;address&amp;quot;, &amp;amp;address,
                &amp;quot;port&amp;quot;, &amp;amp;port,
                NULL);

  g_assert_cmpstr (address, ==, &amp;quot;192.168.0.100&amp;quot;);
  g_assert_cmpint (port, ==, 8080);
  g_free (address);
  
  g_object_unref (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_new()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하여 객체를 생성할때 아예 속성을 함께 지정할 수도 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  EdcHost *host;
  gchar *address;
  gint port;

  g_type_init ();

  host = g_object_new (EDC_TYPE_HOST,
                       &amp;quot;address&amp;quot;, &amp;quot;demo.emstone.com&amp;quot;,
                       &amp;quot;port&amp;quot;, 8081,
                       NULL);
  g_object_get (host,
                &amp;quot;address&amp;quot;, &amp;amp;address,
                &amp;quot;port&amp;quot;, &amp;amp;port,
                NULL);
  g_assert_cmpstr (address, ==, &amp;quot;demo.emstone.com&amp;quot;);
  g_assert_cmpint (port, ==, 8081);
  g_free (address);

  g_object_unref (host);  

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;눈여겨 보신 분은 아시겠지만, &lt;code&gt;edc_host_new()&lt;/code&gt; 함수는 &lt;code&gt;g_object_new (EDC_TYPE_HOST, NULL)&lt;/code&gt; 호출로 만들어진 객체를 돌려주는 역할만 합니다.&lt;/p&gt;
&lt;p&gt;이렇게 대략 GObject 속성 기본 사용법을 설명한 것 같습니다. 물론 이 예제 코드에는 몇 가지 오류가 남아있는데, 이는 위에서 언급한 것처럼 객체 속성을 다루는 다른 부분을 설명하면서 보완해 나갈 예정입니다.&lt;/p&gt;
&lt;p&gt;오늘은 여기까지입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (2)</title>
      <link>/2009/08/14/oop-with-gobject-2/</link>
      <pubDate>Fri, 14 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/14/oop-with-gobject-2/</guid>
      <description>&lt;p&gt;첫번째 글이 당연한 내용을 너무 길게 설명했다는 의견이 있어서, 이번 글부터는 더 짧고 간결하게 정리해 보려고 노력하고 있습니다. 그리고, 이 글의 대상은 한 번이라도 GTK+ / GLib 라이브러리를 사용한 경험이 있는 개발자입니다. 그래서 정말로 기초적인 내용은 피하고 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;접근자 (Accessors)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;소프트웨어 공학에서 모듈이나 객체 설계시 기본적으로 강조하는 정보은닉(information hiding), 캡슐화(encapsulation), 결합도(coupling) 등과 같은 개념에 의하면, C 언어처럼 구조체의 필드 변수를 외부로 직접 공개하는 건 좋지 않다고 합니다. 그리고 대부분의 경우 직접 접근 방식보다 읽고 쓰는 접근자(accessors)를 제공하는 게 여러모로 좋다고 하지요. 물론 성능 문제로 직접 접근 방식을 고려해야 하는 경우도 있지만, 지금까지 경험에 비춰보면, 병목을 일으키는 부분은 프로파일러를 돌려서 정확하게 파악한 다음에 해결하는 게 대부분 좋기 때문에 처음부터 그럴 필요는 없을 것 같습니다.&lt;/p&gt;
&lt;p&gt;참고로 현재 개발 중인 
&lt;a href=&#34;http://live.gnome.org/GTK%2B/3.0/Roadmap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+ 3.0&lt;/a&gt;
에서도 기존에 공개되었던 변수들을 모조리 안으로 숨기고, GTK+ 2.x 어플리케이션의 이전(migration)을 위해 
&lt;a href=&#34;http://live.gnome.org/GnomeGoals/UseGseal&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GSEAL() 매크로&lt;/a&gt;
를 2.14 버전부터 제공하고 있습니다.&lt;/p&gt;
&lt;p&gt;아무튼 그래서, 일단 지난 글에서 예제로 사용한 호스트 객체의 필드를 숨기고 접근 API를 구현해 보았습니다. (변경되거나 수정한 부분만 보여드립니다)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct _EdcHostClass EdcHostClass;
typedef struct _EdcHost      EdcHost;

struct _EdcHost
{
  GObject parent;
};

struct _EdcHostClass
{
  GObjectClass parent_class;
};

GType        edc_host_get_type     (void) G_GNUC_CONST;
EdcHost     *edc_host_new          (void);
const gchar *edc_host_get_name     (EdcHost     *host);
void         edc_host_set_name     (EdcHost     *host,
                                    const gchar *name);
const gchar *edc_host_get_address  (EdcHost     *host);
void         edc_host_set_address  (EdcHost     *host,
                                    const gchar *address);
gint         edc_host_get_port     (EdcHost     *host);
void         edc_host_set_port     (EdcHost     *host,
                                    gint         port);
const gchar *edc_host_get_user     (EdcHost     *host);
void         edc_host_set_user     (EdcHost     *host,
                                    const gchar *user);
const gchar *edc_host_get_password (EdcHost     *host);
void         edc_host_set_password (EdcHost     *host,
                                    const gchar *password);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

typedef struct _EdcHostPrivate EdcHostPrivate;
struct _EdcHostPrivate
{
  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;
};

#define EDC_HOST_GET_PRIVATE(host) 
 G_TYPE_INSTANCE_GET_PRIVATE (host, EDC_TYPE_HOST, EdcHostPrivate)

G_DEFINE_TYPE (EdcHost, edc_host, G_TYPE_OBJECT);

EdcHost *
edc_host_new (void)
{
  return EDC_HOST (g_object_new (EDC_TYPE_HOST, NULL));
}

/* object initializer */
static void
edc_host_init (EdcHost *host)
{
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  priv-&amp;gt;name = g_strdup (&amp;quot;&amp;quot;);
  priv-&amp;gt;address = g_strdup (&amp;quot;&amp;quot;);
  priv-&amp;gt;port = 0;
  priv-&amp;gt;user = g_strdup (&amp;quot;&amp;quot;);
  priv-&amp;gt;password = g_strdup (&amp;quot;&amp;quot;);
}

/* object finalizer */
static void
edc_host_finalize (GObject *self)
{
  EdcHost *host = EDC_HOST (self);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  g_free (priv-&amp;gt;name);
  g_free (priv-&amp;gt;address);
  g_free (priv-&amp;gt;user);
  g_free (priv-&amp;gt;password);

  /* call our parent method (always do this!) */
  G_OBJECT_CLASS (edc_host_parent_class)-&amp;gt;finalize (self);
}

/* class initializer */
static void
edc_host_class_init (EdcHostClass *klass)
{
  GObjectClass *gobj_class;

  gobj_class = G_OBJECT_CLASS (klass);
  gobj_class-&amp;gt;finalize = edc_host_finalize;

  g_type_class_add_private (gobj_class, sizeof (EdcHostPrivate));
}

const gchar *
edc_host_get_name (EdcHost *host)
{
  EdcHostPrivate *priv;

  g_return_val_if_fail (EDC_IS_HOST (host), NULL);

  priv = EDC_HOST_GET_PRIVATE (host);

  return priv-&amp;gt;name;
}

void
edc_host_set_name (EdcHost     *host,
                   const gchar *name)
{
  EdcHostPrivate *priv;

  g_return_if_fail (EDC_IS_HOST (host));
  g_return_if_fail (name != NULL);

  priv = EDC_HOST_GET_PRIVATE (host);

  g_free (priv-&amp;gt;name);
  priv-&amp;gt;name = g_strdup (name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;먼저 헤더 파일을 보면, &lt;code&gt;EdcHost&lt;/code&gt; 구조체에서 공개되었던 객체 변수가 모두 사라지고, 대신 &lt;code&gt;edc_host_{get,set}_*()&lt;/code&gt; 형태의 API 선언이 추가되었습니다. 소스 파일에는 새로 &lt;code&gt;EdcHostPrivate&lt;/code&gt; 구조체를 정의하고 모든 비공개 변수를 집어 넣은 뒤, 클래스 초기화 함수[&lt;code&gt;edc_host_class_init ()&lt;/code&gt;] 마지막 부분에서 이 크기만큼의 공간을 확보하도록 합니다.[
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Type-Information.html#g-type-class-add-private&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_type_class_add_private()&lt;/code&gt;&lt;/a&gt;
] 그리고 모든 함수에서 이 구조체를 쉽게 얻어오기 위해 정의한 &lt;code&gt;EDC_HOST_GET_PRIVATE()&lt;/code&gt; 매크로를 사용해 필요한 작업을 수행합니다.&lt;/p&gt;
&lt;p&gt;부가적으로 조금만 더 설명하면, 모든 문자열을 넘겨주는 API는 문자열을 복사해서 넘겨주어 원본 문자열을 보호합니다. 따라서 API 문서에 넘겨받은 문자열을 반드시 해제하라고 명시되어 있어야 하겠죠. 또한 지난 글에서 잠시 언급한 것처럼, 공개된 함수 진입 시점에서 인수 적합성 검사를 할때 &lt;code&gt;EDC_IS_HOST()&lt;/code&gt; 매크로를 사용해 NULL 여부 뿐 아니라 정확하게 해당 객체인지 검사하도록 합니다.&lt;/p&gt;
&lt;p&gt;참고로 위 예제에서 비공개(private) 객체에 접근하는 방법은 설명을 위해 오버헤드가 존재하는 단순한 방식입니다. 따라서 실제로 사용하려면 반드시 이 
&lt;a href=&#34;/2008/12/23/reduce-accesing-overhead-for-gobject-private-data/&#34;&gt;포스트&lt;/a&gt;
를 참고하시기 바랍니다.&lt;/p&gt;
&lt;p&gt;이렇게 해서 기본적인 객체 속성에 대한 접근자를 구현했습니다. 물론 이게 다는 아니고, 다음에 설명할 GObject 속성(properties) 기능을 이용하면 사실 접근자를 구현할 필요도 없습니다. 하지만, GTK+와 같은 대부분의 GObject 기반 객체는 함수 API 기반의 접근자를 동시에 제공하고 있으므로 관례를 따르는 게 나쁘지는 않겠지요.&lt;/p&gt;
&lt;p&gt;글머리에서 언급했듯이, 계속 적다 보면 내용도 길어지고 포스팅 주기도 길어질 것 같아 오늘은 일단 여기까지만 적습니다. 다음에는 본격적으로 GObject 속성(properties)을 추가할 예정인데, 설명할 게 많아서&amp;hellip; ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (1)</title>
      <link>/2009/08/10/oop-with-gobject-1/</link>
      <pubDate>Mon, 10 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/10/oop-with-gobject-1/</guid>
      <description>&lt;p&gt;GTK+, Clutter 등과 같은 라이브러리는 C 언어로 구현되었지만 객체 지향 개념을 충실히 따르고 있는데, 그 중심에는 GLib 라이브러리의 GObject가 있습니다. 따라서 이러한 라이브러리를 제대로 이해하고 사용하려면 필수적으로 GObject 개념을 잘 이해하고 있어야 합니다. 그런데, 생각보다 GObject 개념은 이해하기 어렵습니다. 이해하더라도 이를 응용하려면 그만큼 시간이 또 필요합니다.&lt;/p&gt;
&lt;p&gt;그래서 이번 글을 시작으로 GObject 라이브러리를 이용한 C 언어에서 객체 지향 프로그래밍이라는 거창한 주제를 예제 형식을 이용해 다루어 보려고 합니다. 바로 새 GTK+ 위젯을 구현하거나 클러터 객체를 분석하는 방식이 아니라 왜 GObject가 이런 방식으로 설계되었는지 그 철학을 따라가 보려고 합니다. 그리고, 가능한 기존 GObject 튜토리얼의 어려운 설명이 아니라 실제 사용하는 코드를 중심으로 설명할 예정이니, 그래도 무슨 말인지 모르겠거나 더 풀어서 설명을 하는 게 좋을 것 같을 경우 의견 주시기 바랍니다.&lt;/p&gt;
&lt;p&gt;여기서 예제로 사용할 개념은 네트워크 카메라 호스트와 호스트 목록입니다. (하는 일이 이쪽 분야라서&amp;hellip; :)&lt;/p&gt;
&lt;p&gt;네트워크 카메라 호스트는 이름(name), 주소(address), 포트번호(port), 사용자(user), 비밀번호(password) 등과 같은 항목을 포함합니다. 필요한 함수로는 새 객체를 만들거나 해제, 그리고 각 필드값을 얻어오거나 변경하는 정도입니다. (아마도 나중에는 값이 변경되면 자동으로 호출되는 콜백 함수도 추가할 겁니다)&lt;/p&gt;
&lt;p&gt;모든 코드는 GLib API를 이용하여 작성합니다.&lt;/p&gt;
&lt;p&gt;**객체 (Objects) + 참조 카운터 (Reference Counter)
**&lt;/p&gt;
&lt;p&gt;소프트웨어 공학자들이 객체라고 부르기 전부터 C 언어에는 구조체(struct)가 있었습니다. GObject 시스템 역시 기본 바탕은 구조체입니다. 그러면 GObject 프로그래밍을 하기 전에, 일반 C 언어 구조체를 이용해 네트워크 카메라 호스트를 정의하면, 다음과 같은 코드가 나오지 않을까요?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct _EdcHost EdcHost;
struct _EdcHost
{
  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만일 상속이나 함수 오버로딩(overloading)을 전혀 사용하지 않는다면, 굳이 새로운 함수를 추가할 필요를 못 느끼는 분들이 많을 겁니다. 왜냐하면, 직접 구조체 크기만큼 메모리를 할당한 뒤 해제하고, 직접 모든 필드를 접근하면 되니까요. 하지만, 할당하고 해제하는 코드가 여러 곳에 분산되어 있다면 디버깅도 힘들고 유지 보수도 힘드니까 최소한 객체를 생성하고 해제하는 함수만이라도 만들어 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EdcHost *
edc_host_new (void)
{
  EdcHost *host;

  host = g_new0 (EdcHost, 1);

  return host;
}

void
edc_host_destroy (EdcHost *host)
{
  g_return_if_fail (host != NULL);

  g_free (host-&amp;gt;name);
  g_free (host-&amp;gt;address);
  g_free (host-&amp;gt;user);
  g_free (host-&amp;gt;password);
  g_free (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;간단한 코드라서 설명할 필요는 없을 것 같습니다. 참고로 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Memory-Allocation.html#g-free&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_free()&lt;/code&gt;&lt;/a&gt;
 함수는 인수가 NULL일 경우 무시하므로 NULL 검사 코드는 필요없습니다.&lt;/p&gt;
&lt;p&gt;그런데, 이 객체는 단순히 목록 관리 뿐 아니라 여러 다른 모듈에서도 사용할 예정입니다. 여기서 갑자기, 모든 모듈이 하나의 객체를 공유하고 싶은 욕망이 꿈틀대기 시작합니다. 모듈 간에 객체를 전달할때 복사할 필요도 없고, 모듈 별로 객체를 따로 만들어 정보를 보관하는 것보다 메모리를 절약할 수 있으며, 필드 하나가 변경되었을 경우 그 정보를 모든 관련 객체에 반영할 수고도 덜 수 있기 때문입니다. 그렇다고 무턱대고 모든 모듈에서 객체 주소(pointer)만 참조하게 하면 객체를 어느 시점에 할당하고 해제해야 하는지 매우 까다로워집니다. 특히 동적으로 임시 객체를 생성해 다른 모듈에게 넘겨주는 경우라면, 객체를 어느 시점에서 해제해야 하는지도 실수하기 딱 좋습니다. 더 나아가 멀티 쓰레드 환경까지 고려한다면, 단순히 포인터만 가리키는 방식은, 아마추어나 사용하는 옛날 UML 클래스 빌더가 자동으로 생성해주는 코드만으로는, 힘들 수 밖에 없습니다.&lt;/p&gt;
&lt;p&gt;이런 경우 자주 사용하는 방식이 참조 카운터(reference counter) 기법입니다. 짧게 설명하자면, 모든 모듈에서 몇 가지 원칙만 지키면 됩니다. 첫번째 원칙은, 객체(메모리)를 할당한 모듈에서 반드시 해제하기입니다. 두번째는, 모듈 관점에서 내가 필요한 시점부터 객체의 참조 카운터를 증가하고, 더이상 사용하지 않으면 객체의 참조 카운터를 감소합니다. 새로 생성된 객체는 참조 카운터 값이 1이고, 참조 카운터가 감소되어 0이 되면 객체는 자동으로 해제됩니다. 참고로, 참조 카운터 기법은 멀티미디어 프레임 버퍼, 네트워크 패킷 등과 같은 버퍼 관리에도 널리 사용하는 것은 물론, 오브젝티브-C 언어(Objective-C)의 NSObject 객체가 기본적으로 제공하는 기능이기도 합니다.&lt;/p&gt;
&lt;p&gt;자 이제, 호스트 객체를 참조 카운터 기법을 적용해 수정해 보면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_HOST_H__
#define __EDC_HOST_H__

#include &amp;lt;glib.h&amp;gt;

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

typedef struct _EdcHost EdcHost;
struct _EdcHost
{
  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;

  gint   ref_count;
};

EdcHost *edc_host_new   (void);
EdcHost *edc_host_ref   (EdcHost *host);
void     edc_host_unref (EdcHost *host);

#ifdef __cplusplus
}
#endif

#endif /* __EDC_HOST_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

EdcHost *
edc_host_new (void)
{
  EdcHost *host;

  host = g_new0 (EdcHost, 1);
  if (!host)
    return NULL;

  host-&amp;gt;ref_count = 1;

  return host;
}

static void
edc_host_destroy (EdcHost *host)
{
  g_return_if_fail (host != NULL);

  g_free (host-&amp;gt;name);
  g_free (host-&amp;gt;address);
  g_free (host-&amp;gt;user);
  g_free (host-&amp;gt;password);
  g_free (host);
}

EdcHost *
edc_host_ref (EdcHost *host)
{
  g_return_val_if_fail (host != NULL, NULL);

  g_atomic_int_inc (&amp;amp;host-&amp;gt;ref_count);

  return host;
}

void
edc_host_unref (EdcHost *host)
{
  g_return_if_fail (host != NULL);

  if (g_atomic_int_dec_and_test (&amp;amp;host-&amp;gt;ref_count))
    edc_host_destroy (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제일 먼저 설명할 부분은 역시 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Atomic-Operations.html#g-atomic-int-inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_atomic_int_inc()&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Atomic-Operations.html#g-atomic-int-dec-and-test&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_atomic_int_dec_and_test()&lt;/code&gt;&lt;/a&gt;
 함수입니다. 멀티 쓰레드에서 안전하게 카운터 변수를 증가하고 감소할 수 있게 도와주는 GLib API입니다. 이를 이용해 위에서 설명한 참조 카운터 개념을 구현하고 있습니다. 공개했던 &lt;code&gt;edc_host_destroy()&lt;/code&gt; 함수는 모듈 내부에서만 접근할 수 있도록 &lt;code&gt;static&lt;/code&gt; 키워드를 붙였습니다. 또한 C++ 소스에서 포함(include)할때 문제를 일으키지 않도록 헤더파일에 &amp;lsquo;&lt;code&gt;extern &amp;quot;c&amp;quot; {}&lt;/code&gt;&amp;rsquo; 키워드도 추가했습니다.&lt;/p&gt;
&lt;p&gt;그런데 참조 카운터가 필요한 객체마다 이렇게 구현하면 비슷한 작업을 하는 코드가 중복될 수 밖에 없습니다. 이를 일반적인 API로 분리해 다시 구현하면 재활용이 가능할테니, 다음과 같이 수정해 보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-object.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_OBJECT_H__
#define __EDC_OBJECT_H__

#include &amp;lt;glib.h&amp;gt;

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

typedef struct _EdcObject EdcObject;
struct _EdcObject
{
  gint           ref_count;
  GDestroyNotify finalize;
};

static inline gpointer
edc_object_alloc (GDestroyNotify finalize,
                  gint           obj_size)
{
  EdcObject *obj;

  obj = g_malloc (obj_size);
  if (!obj)
    return NULL;

  obj-&amp;gt;ref_count = 1;
  obj-&amp;gt;finalize = finalize;

  return obj;
}

static inline gpointer
edc_object_ref (gpointer obj)
{
  EdcObject *object = obj;

  if (object)
    g_atomic_int_inc (&amp;amp;object-&amp;gt;ref_count);

  return object;
}

static inline void
edc_object_unref (gpointer obj)
{
  EdcObject *object = obj;

  if (!obj)
    return;

  if (g_atomic_int_dec_and_test (&amp;amp;object-&amp;gt;ref_count))
    {
      if (object-&amp;gt;finalize)
        object-&amp;gt;finalize (object);
      g_free (object);
    }
}

#ifdef __cplusplus
}
#endif

#endif /* __EDC_OBJECT_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_HOST_H__
#define __EDC_HOST_H__

#include &amp;quot;edc-object.h&amp;quot;

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

typedef struct _EdcHost EdcHost;
struct _EdcHost
{
  EdcObject parent;

  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;
};

EdcHost *edc_host_new (void);

#ifdef __cplusplus
}
#endif

#endif /* __EDC_HOST_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

static void
edc_host_finalize (gpointer obj)
{
  EdcHost *host = obj;

  g_free (host-&amp;gt;name);
  g_free (host-&amp;gt;address);
  g_free (host-&amp;gt;user);
  g_free (host-&amp;gt;password);
}

EdcHost *
edc_host_new (void)
{
  EdcHost *host;

  host = edc_object_alloc (edc_host_finalize,
                           sizeof (EdcHost));
  if (!host)
    return NULL;

  host-&amp;gt;name = NULL;
  host-&amp;gt;address = NULL;
  host-&amp;gt;user = NULL;
  host-&amp;gt;password = NULL;

  return host;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;객체 지향 상속(또는 파생 객체)을 C 언어로 구현하는 가장 쉬운 방법은 위 코드에서 보는 것처럼 부모(또는 원본 객체)를 구조체 맨 앞에 두는 겁니다. 그러면 부모와 자식 API 모두 사용할 수 있게 되죠. 위 코드의 경우 개념상으로 보면 EdcObject 객체를 상속 받아 EdcHost 객체를 구현한 셈이 되죠. 따라서 다음과 같이 사용할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void
func_a (EdcHost *host)
{
  edc_object_ref (host);
  // do some stuff for long time...
  edc_object_unref (host);
}

{
  EdcHost *host;

  host = edc_host_new ();
  ...
  func_a (host);
  ...
  edc_object_unref (host); /* destroy */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 C 언어에서 `&lt;code&gt;void *&lt;/code&gt;&amp;rsquo; 형은 어떤 포인터와도 양방향 대입(assignment)을 할 수 있으므로 컴파일 경고를 피하기 위해 불필요한 형변환을 할 필요가 없습니다. (
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Basic-Types.html#gpointer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;gpointer&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Datasets.html#GDestroyNotify&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;GDestroyNotify&lt;/code&gt;&lt;/a&gt;
 API도 설명도 확인해 보시기 바랍니다)&lt;/p&gt;
&lt;p&gt;이제 지금까지 구현한 부분을 GObject 객체 기반으로 옮겨 봅니다. 자세히 보시면, 지금까지 프로그래밍한 내용과 거의 비슷한 점을 알아챌 수 있을 겁니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_HOST_H__
#define __EDC_HOST_H__

#include &amp;lt;glib-object.h&amp;gt;

G_BEGIN_DECLS

#define EDC_TYPE_HOST 
 (edc_host_get_type ())
#define EDC_HOST(obj) 
 (G_TYPE_CHECK_INSTANCE_CAST ((obj), EDC_TYPE_HOST, EdcHost))
#define EDC_HOST_CLASS(obj) 
 (G_TYPE_CHECK_CLASS_CAST ((obj), EDC_TYPE_HOST, EdcHostClass))
#define EDC_IS_HOST(obj) 
 (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EDC_TYPE_HOST))
#define EDC_IS_HOST_CLASS(obj) 
 (G_TYPE_CHECK_CLASS_TYPE ((obj), EDC_TYPE_HOST))
#define EDC_GET_HOST_CLASS(obj) 
 (G_TYPE_INSTANCE_GET_CLASS ((obj), EDC_TYPE_HOST, EdcHostClass))

typedef struct _EdcHostClass EdcHostClass;
typedef struct _EdcHost      EdcHost;

struct _EdcHost
{
 GObject parent;

 gchar  *name;
 gchar  *address;
 gint    port;
 gchar  *user;
 gchar  *password;
};

struct _EdcHostClass
{
 GObjectClass parent_class;
};

GType    edc_host_get_type (void) G_GNUC_CONST;
EdcHost *edc_host_new      (void);

G_END_DECLS

#endif /* __EDC_HOST_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

G_DEFINE_TYPE (EdcHost, edc_host, G_TYPE_OBJECT);

EdcHost *
edc_host_new (void)
{
 return EDC_HOST (g_object_new (EDC_TYPE_HOST, NULL));
}

/* object initializer */
static void
edc_host_init (EdcHost *host)
{
 host-&amp;gt;name = NULL;
 host-&amp;gt;address = NULL;
 host-&amp;gt;port = 0;
 host-&amp;gt;user = NULL;
 host-&amp;gt;password = NULL;
}

/* object finalizer */
static void
edc_host_finalize (GObject *self)
{
 EdcHost *host = EDC_HOST (self);

 g_free (host-&amp;gt;name);
 g_free (host-&amp;gt;address);
 g_free (host-&amp;gt;user);
 g_free (host-&amp;gt;password);

 /* call our parent method (always do this!) */
 G_OBJECT_CLASS (edc_host_parent_class)-&amp;gt;finalize (self);
}

/* class initializer */
static void
edc_host_class_init (EdcHostClass *klass)
{
 GObjectClass *gobject_class;

 gobject_class = G_OBJECT_CLASS (klass);
 gobject_class-&amp;gt;finalize = edc_host_finalize;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;갑자기 코드량이 증가했다고 놀랄 필요는 없습니다. 뭐든지 다 그렇지만, 알고 보면 별 거 아닙니다.&lt;/p&gt;
&lt;p&gt;먼저 헤더 파일을 설명하면,  GObject 객체를 사용하기 위해 glib-object.h 파일을 포함했습니다. 이는 EdcHost 객체가 GObject 객체만 사용하기 때문에, 더 정확히는 GObject의 파생 객체(derived objects), 다른 말로는 GObject 객체만 상속(inheritance)하기 때문에 그렇습니다. 만일 다른 객체에서 파생한다면 그 객체를 정의하는 헤더 파일을 포함해야 합니다. &amp;lsquo;&lt;code&gt;extern &amp;quot;c&amp;quot; {}&lt;/code&gt;&amp;rsquo; 키워드는 GLib의 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Miscellaneous-Macros.html#G-BEGIN-DECLS--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;G_BEGIN_DECLS&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Miscellaneous-Macros.html#G-END-DECLS--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;G_END_DECLS&lt;/code&gt;&lt;/a&gt;
 API로 대체했습니다.&lt;/p&gt;
&lt;p&gt;EdcHost 인스턴스와 EdcHostClass 클래스를 정의하고 있는 부분을 설명하면, 클래스 객체는 전역으로 하나만 존재하고 그냥 객체는 인스턴스(instance) 역할을 합니다. 또한 여기서는 인스턴스 객체의 모든 필드가 공개되어 있지만, 물론 외부에 공개하지 않는(private) 필드를 정의할 수도 있습니다. (이는 다른 글에서 따로 설명하겠습니다)&lt;/p&gt;
&lt;p&gt;복잡해 보이는 몇몇 매크로는 자주 사용하는 긴 API를 간편화한 것입니다. 런타임 중에 인스턴스가 유효하고 EdcHost 객체로 형변환까지 해주거나[&lt;code&gt;EDC_HOST(obj)&lt;/code&gt;], 인스턴스가 EdcHost 객체인지 확인하거나[&lt;code&gt;EDC_IS_HOST(obj)&lt;/code&gt;], 인스턴스의 클래스 객체를 얻어오거나[&lt;code&gt;EDC_GET_HOST_CLASS(obj)&lt;/code&gt;] 하는 등 일종의 
&lt;a href=&#34;http://en.wikipedia.org/wiki/Run-time_type_information&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RTTI&lt;/a&gt;
 관련 매크로입니다. 아마 제일 많이 사용하는 매크로는 `&lt;code&gt;EDC_HOST(obj)&lt;/code&gt;&#39;일 겁니다.&lt;/p&gt;
&lt;p&gt;소스를 살펴 보면, 제일 먼저 나오는게 `
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Type-Information.html#G-DEFINE-TYPE--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;G_DEFINE_TYPE(TN, t_n, T_P)&lt;/code&gt;&lt;/a&gt;
&amp;rsquo; 입니다. 여담이지만, 이 매크로가 추가되기 전에 작성한 GObject 기반 코드는 귀찮은 작업을 많이 해야 했는데, 이 매크로가 자동으로 해주는 기능이 많아서 불필요하게 중복되는 코드가 많이 줄어들었습니다. 그래서 GTK+ 소스 코드 중에도 가끔 그렇게 작성한 코드도 있고, GObject 관련 초기 문서를 보면 이 매크로를 사용하지 않고 구현되어 있는 경우도 있습니다.&lt;/p&gt;
&lt;p&gt;이 매크로가 하는 일은 다음과 같습니다. 지정한 `&lt;code&gt;t_n&lt;/code&gt;` 이름으로 시작하는 클래스 초기화 함수[&lt;code&gt;*_class_init()&lt;/code&gt;] / 인스턴스 초기화 함수[&lt;code&gt;*_init()&lt;/code&gt;] 모두 구현되어 있다고 가정하고 `&lt;code&gt;*_get_type()&lt;/code&gt;&amp;rsquo; 함수를 자동으로 삽입해 줍니다. 더불어 부모 클래스 객체를 가리키는 `&lt;code&gt;*_parent_class&lt;/code&gt;&amp;rsquo; 전역 변수도 만들어 줍니다. 따라서 프로그래머는 최소한 함수 두 개만 구현해 주면 되는 셈입니다. [&lt;code&gt;edc_host_init()&lt;/code&gt; / &lt;code&gt;edc_host_class_init()&lt;/code&gt;]&lt;/p&gt;
&lt;p&gt;하지만 위 예제에서는 클래스 초기화 함수에서 인스턴스 객체가 해제될때 호출되는 finalize 함수를 교체하고 있습니다. 이를 통해 객체가 해제될때 사용하던 리소스를 해제해 줍니다. 그리고, 반드시 상위 클래스의 finalize 함수를 호출해 주어야 정상적으로 부모 객체의 해제 함수가 차례대로 호출될 수 있습니다.&lt;/p&gt;
&lt;p&gt;자 이제 GObject의 핵심 기능 중 하나인 객체 참조 카운터(object reference counter) 기능을 쉽게 이용할 수 있습니다. 이렇게 작성한 객체는 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-ref&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_ref()&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_unref()&lt;/code&gt;&lt;/a&gt;
 함수 등을 이용해 참조 카운터를 제어할 수 있습니다. GObject 소스 코드를 확인해 보시면 알겠지만, 실제 객체 참조 카운터 기능은 거의 비슷하게 구현되어 있습니다. 더 많은 경우의 수를 고려하고 더 많은 기능을 제공하다보니 코드가 더 복잡한 것 뿐입니다.&lt;/p&gt;
&lt;p&gt;더 중요한 점은 모든 GObject 기반 객체, 예를 들어 GTK+ 위젯이나 클러터 객체 모두 GObject 기반이기 때문에 객체간 연결(부모-자식, 컨테이너-아이템 등)시 객체에 대한 포인터를 유지하면서 동시에 참조 카운터를 유지하여 메모리를 관리한다는 점입니다. 이 부분에 대한 더 자세한 설명은 
&lt;a href=&#34;/2008/12/28/gtk-memory-management/&#34;&gt;GTK+ 메모리 관리&lt;/a&gt;
 글에서 확인하시기 바랍니다.&lt;/p&gt;
&lt;p&gt;오늘은 일단 여기까지만&amp;hellip; ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>doxy2dbook: Doxygen-DocBook 변환기</title>
      <link>/2009/07/06/doxy2dbook-doxygen-to-docbook-converter/</link>
      <pubDate>Mon, 06 Jul 2009 00:00:00 +0000</pubDate>
      <guid>/2009/07/06/doxy2dbook-doxygen-to-docbook-converter/</guid>
      <description>&lt;p&gt;소스 코드 문서화에 
&lt;a href=&#34;http://www.stack.nl/~dimitri/doxygen/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Doxygen&lt;/a&gt;
을 이용하고 매뉴얼이나 공식 문서 작성에는 
&lt;a href=&#34;http://www.docbook.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DocBook&lt;/a&gt;
을 사용하신다면 혹시 둘을 합칠 수 있는 방법이 있으면 좋겠다는 생각을 해보지 않으셨나요?&lt;/p&gt;
&lt;p&gt;긴 말 필요없이 소개하자면, doxy2dbook 프로그램이 그런 역할을 합니다. Doxygen XML 결과물을 DocBook XML로 변환해서 기존 DocBook 문서 안에 자연스럽게 포함할 수 있도록 해줍니다. 제가 GLib 라이브러리 문서 형식에 익숙해서 결과물 역시 비슷하게 출력합니다.&lt;/p&gt;
&lt;p&gt;물론 인터넷을 찾아보면, Boost 라이브러리에서 사용하는 것도 있고, XSLT 프로세싱을 이용하는 방법도 있는데, 생각보다 제게는 커스터마이징이 쉽지 않더군요. 그래서 결국 목마른 자 우물 파는 법, 직접 만들어 보았습니다. 처음에는 펄 / 루비로도 만들어 보았으나 Doxygen XML 파싱과 객체 관리에 너무 시간이 오래 걸리는 점이 맘에 들지 않아, 결국 GLib 라이브러리 기반 C 언어로 만들게 되었습니다. 따라서 GLib 라이브러리 + GCC + Make 만 있으면 빌드할 수 있습니다. (하지만 Doxygen XML을 하나로 묶으려면 xsltproc 프로그램도 필요하게 됩니다) 지원하는 Doxygen 태그도 많지 않아서 제가 특정 매뉴얼을 작성하면서 사용하는 태그만 일단 지원합니다.&lt;/p&gt;
&lt;p&gt;아직 홈페이지도 따로 없고, 이 블로그 자체가 별로 유명하지도 않기 때문에 얼마나 많은 피드백이나 패치가 올지 모르는데 괜히 처음부터 거창할 필요는 없을 것 같아서, 외부로 공개된 버전 관리 저장소도 없이 달랑 소스 코드 묶음만 공개합니다.&lt;/p&gt;
&lt;p&gt;사용법은 안에 들어있는 README 파일을 참고하시기 바랍니다.&lt;/p&gt;
&lt;p&gt;이 프로그램은 업무상 회사에서 작성한 코드이기 때문에 저작권은 당연히 회사에게 있습니다. 라이센스는 GPL입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>코딩 잘하는 방법?</title>
      <link>/2009/07/06/how-to-code-well/</link>
      <pubDate>Mon, 06 Jul 2009 00:00:00 +0000</pubDate>
      <guid>/2009/07/06/how-to-code-well/</guid>
      <description>&lt;p&gt;저는 개발자(developer)보다 프로그래머(programmer)라고 부르는 걸 더 좋아합니다. 왜냐하면 프로그래머라는 단어는 프로그램(program)을 만드는 이라고 명확하게 나타내주기 때문입니다. 개발자라는 단어는 어쩐지 프로그래머라는 직업이 단순 코더(coder)로 인식되기 시작하면서, 그보다 더 많은 일을 하고 있다고 포장하기 위해 그럴듯한 단어로 대체한 것처럼 느껴집니다.&lt;/p&gt;
&lt;p&gt;프로그램은 코드(code)입니다. 아무리 많은 기술과 기법을 사용했어도 그 마지막 결과물은 결국 코드입니다. 그래서 저한테 프로그래밍(programming)이란 곧 코딩(coding)을 의미합니다. 또한 코딩은 머릿속 추상적인 개념이 구체화되는 과정이기도 합니다.  언제부터 소프트웨어 공학이 프로그래밍에서 설계와 구현(코딩)을  구분했는지는 모르지만, 제게는 코딩이 곧 프로그래밍의 중심입니다. 나머지는 코딩을 더 잘하기 위해 필요한 도구이며 과정일 뿐입니다. (물론 디버깅도 프로그래밍의 큰 과정 중 하나입니다. 정확하게 요구사항을 분석하는 것, 코딩을 시작하기 위한 기본 개념을 선택하고 설계하는 것 등도 당연히 프로그래머의 일입니다. 하지만, 이 글에서는 코딩이 주인공이라서 다른 부분은 과소평가 할테니 소프트웨어 공학 하시는 분은 태클 걸지 말아 주시길 :)&lt;/p&gt;
&lt;p&gt;아무튼, 댓가를 받고 업으로 프로그래밍을 하기 시작한지 약 15년 즈음 되는 지금, 언젠가부터 현업 프로그래머 중에서는 선배보다 후배들이 많아지다 보니, 가끔 술자리에서 실력도 안되는 제게 어려운 질문을 하는 후배들에게 항상 취중에 중언부언하던 개인적인 생각을, (역시 취중에) 대략 세 가지로 &lt;strong&gt;감히&lt;/strong&gt; 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;좋은 코드를 작성하려면 다른 사람의 코드를 많이 읽어야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;글 쓰는 사람이 책 한 권을 쓰기 위해 열 배 백 배 이상의 독서를 하듯이, 프로그래머도 많은 코드를 읽어야 합니다.  좋은 코드에서는 배움을 얻고, 나쁜 코드에서는 금해야 할 게 무엇인지 알게 됩니다. 그런데, 유독 프로그래머는 다른 사람의 코드를 읽는 일에 인색합니다. 심지어 매뉴얼이나 API 문서에 나온 예제 코드도 읽지 않고, 동료가 작성한 코드도 읽지 않으며 오직 자신이 만든 코드만 읽고 또 읽습니다.&lt;/p&gt;
&lt;p&gt;모든 프로그래밍은 모방에서 시작합니다. 우리 용어로 하면 카피 앤 페이스트(copy &amp;amp; paste) 쯤 되겠지요. 하지만, 보는 만큼 아는 만큼 프로그래밍하게 됩니다. 경험이 아무리 많아도 새로운 지식이 없으면 결국 아는 한도 내에서 똑같은 틀의 코드만 계속 만들 뿐, 나아지는 건 없습니다.&lt;/p&gt;
&lt;p&gt;참고로, 저는 이런 관점에서 오픈소스 프로젝트를 지지하는 편입니다. 프로그래머를 성장시키는 가장 빠른 방법 중 하나는 오픈소스 프로젝트에 참여시키는 것이라는 말도 공감합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;좋은 코드를 작성하려면 많이 쓰고 자주 고쳐야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;하나의 기능을 구현하기 위해 수없이 많은 시행착오를 겪어야 결국 좋은 코드가 나옵니다. 글 쓰는 사람 예를 다시 들어보면, 한 번 쓴 글을 바로 내보내는 경우는 없습니다. 수없이 다시 쓰고 퇴고의 과정을 거쳐, 심지어 쉼표 하나 마침표 하나까지 고치고 또 고칩니다. 프로그램은 더 고약한 놈이라, 릴리스 이후에도 언제든 다시 손을 대야 합니다.&lt;/p&gt;
&lt;p&gt;저는 프로그래밍할때 가장 중요한 부분부터 간단하게 코딩하는 습관이 있습니다. 똑똑한 편이 아니라서, 대부분의 개념은 코딩하면서 구체화되는 경우가 대부분입니다. 변수 이름부터 구조체, API 방식, 동작 알고리즘 모두 계속 코딩하고 테스트하면서 계속 바뀝니다. (보통 다른 사람의 다섯 배 정도는 코드를 다시 고쳐 쓴다고 자부합니다. 자랑은 아닌데&amp;hellip;) 그래서 저는 처음에 만든 코드 형태가 그대로 있는 경우가 별로 없습니다.&lt;/p&gt;
&lt;p&gt;프로그래머는 결국 코드로 자신의 생각을 표현해야 하고, 자신의 주장을 뒷받침해야 합니다. 코드의 가독성(readability)을 높이기 위해 노력해야 하는 이유이기도 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;쉽게 레벨업 되려는 욕심은 버려야 하지만, 꾸준이 노력하는 습관은 욕심내야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;프로그래머는 알아야 할 게 너무 많습니다. 새 언어, 라이브러리, 디자인패턴, 기술 , 개발 도구, 플랫폼,  코딩 스타일, 디버깅 기법&amp;hellip; 거기에다 글도 잘써야 하고, 영어도 잘해야 하고, 말도 잘해야 하고&amp;hellip; 알면 알수록 모르는 게 더 많다는 걸 느끼고 기본 개념이 중요하다는 걸 깨닫게 됩니다. 그리고 좌절과 무기력도 동시에 느낍니다. 이럴때 대부분은 머리가 나빠서, 혹은 소질이 없는 것 같다고 핑계를 대는데&amp;hellip; 제 경험엔 모두 핑계일 뿐, 노력하지 않고 게으르거나 또는 투자를 하지 않고 바라기만 하기 때문입니다.&lt;/p&gt;
&lt;p&gt;제가 자주 인용하는 표현이지만, 강물에 아무리 돌을 던져도 티가 나지 않습니다. 하지만, 좌절하지 않고 계속 던지다 보면 물 밑에서 돌무더기는 계속 쌓이게 되고, 어느 순간 수면위로 올라오게 되면, 그때부터는 한 개만 던져도 바로 쌓이는 게 티가 납니다. 프로그래밍도 마찬가지라, 어느 순간 흩어져있던 여러 가지가 한 가지로 연결되면서 깨닫게 되는 순간이 있습니다. 이미 알고 있던 지식의 다른 관점, 다른 개념도 조금씩 보이기 시작합니다. 그리고 그 후부터는 조금만 노력해도 다른 사람에 비해 쉽게 이해할 수 있게 됩니다.하지만, 대부분 이 단계까지 오기 전에 포기하거나, 자기합리화를 선택합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;여기까지 적다보니, 역시나 대가들이 했던 말을 앵무새처럼 되풀이하고 있군요. 아, 몇 시간 동안 적은 글 버리기는 아까워 그냥 내버려 두니, 저보다 나중에 시작하시는 분들에게 조금이라도 도움이 되길 바랍니다. 그리고, 지극히 개인적인 생각이라 나중엔 바뀔 수도 있고 논리적 오류도 많을 테지만, 개인 블로그에 돈 받지 않고 적는 글이니, 이렇게 생각하는 사람도 있구나 하고 넘어가 주시길~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCMalloc 구글 성능 도구를 이용한 메모리 누수 디버깅</title>
      <link>/2009/06/18/debugging-memory-leaks-with-tcmalloc-google-perftools/</link>
      <pubDate>Thu, 18 Jun 2009 00:00:00 +0000</pubDate>
      <guid>/2009/06/18/debugging-memory-leaks-with-tcmalloc-google-perftools/</guid>
      <description>&lt;p&gt;리눅스에서 메모리 침범이나 메모리 누수, 혹은 복잡한 메모리 접근 관련 오류를 디버깅할때는 대부분 
&lt;a href=&#34;http://valgrind.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Valgrind&lt;/a&gt;
 도구를 이용합니다. 하지만 Valgrind는 많은 메모리를 사용하고 실행 속도가 현저하게 느려지기 때문에, 별도의 타겟 장비에서 제한된 조건으로 동작하는 어플리케이션에는 조금 무리가 있습니다. 게다가 Valgrind의 메모리 검사 도구는 프로그램이 종료된 시점에서 누수된 메모리만 찾기 때문에, 실행 중에는 엄청나게 메모리를 사용하다가 정상적인 객체 해제 루틴이 호출되면 모든 메모리가 정리되어 찾을 수 없는 경우는 발견하지 못합니다.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;/2009/04/29/tcmalloc-google-perftools/&#34;&gt;구글 성능 도구&lt;/a&gt;
를 다시 검토하고 사용하게 된 이유도 바로 여기에 있습니다. 현재 디버깅 중인 프로그램의 문제가 대략 이렇습니다. 몇날 며칠이고 문제없이 가동해야 하는 프로그램이 특정 설정을 적용한 후에는, 자고 일어나면 10~20메가씩 메모리 점유율이 한꺼번에 올라갑니다. 하지만 Valgrind 도구를 사용해도 어느 부분이 문제인지 찾을 수가 없습니다. 지난 글에서 TCMalloc 메모리 할당자로 교체한 후 문제가 해결된 줄 알았던 바로 그 패턴이기도 합니다. 그래서 이번에는 프로파일 기능을 이용해 직접 메모리 누수를 디버깅 해보고, 나중을 위해 그 과정을 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;디버깅 환경&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;디버깅 환경은 우분투 9.04 x86_32 플랫폼입니다. x86_64 플랫폼에서는 이상하게 호출 그래프가 그려지지 않아서 일단 무시했습니다. 사용한 버전은 
&lt;a href=&#34;http://code.google.com/p/google-perftools/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;공식 홈페이지&lt;/a&gt;
에서 다운로드 받은 1.2 버전입니다. 1.3 버전은 이상하게 프로파일 기능이 동작하지 않아 역시 무시했습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCMalloc 도구 설치 및 연결&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;호출 그래프를 생성하기 위해 &lt;code&gt;dot&lt;/code&gt; 프로그램이 필요한데 이 프로그램은 graphviz 패키지에 들어있으므로 설치해야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install graphviz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;우선, 공식 홈페이지에서 google-perftools 압축 파일을 다운로드 한 뒤 다음과 같이 빌드하고 설치합니다. &lt;strong&gt;[2011.05.02 추가]&lt;/strong&gt; INSTALL 문서에도 명시되어 있듯이, x86_64 환경에서는 
&lt;a href=&#34;http://www.nongnu.org/libunwind/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libunwind&lt;/a&gt;
 라이브러리를 미리 설치한 뒤 빌드해야 정상적으로 동작합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd google-perftools*
$ ./configure --prefix=/usr
$ make
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TCMalloc 라이브러리를 연결하는 방법은 
&lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/doc/heapprofile.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;공식 문서&lt;/a&gt;
에도 나와 있듯이 디버깅할 프로그램 링크 마지막에 &amp;lsquo;&lt;code&gt;-ltcmalloc&lt;/code&gt;&amp;rsquo; 옵션을 추가하거나, 실행할때 프로그램 앞에 &amp;lsquo;&lt;code&gt;LD_PRELOAD=/usr/lib/libtcmalloc.so execute-file&lt;/code&gt;&amp;rsquo; 처럼 라이브러리를 먼저 로드해주면 됩니다. &lt;del&gt;저는 첫번째 방법을 사용했습니다.&lt;/del&gt; &lt;strong&gt;[2011.05.02 갱신]&lt;/strong&gt; 언제부터인지는 확실치 않지만 첫번째 방법은 동작하지 않고 두번째 방법으로 해야 메모리 프로파일이 정상적으로 동작합니다.&lt;/p&gt;
&lt;p&gt;참고로, 디버깅할 프로그램을 컴파일할때는 디버깅 심볼 옵션(&lt;code&gt;-g&lt;/code&gt;)이 있어야 호출 그래프에서 정확한 함수 이름이 표시됩니다. 또한 최적화 옵션(&lt;code&gt;-O2&lt;/code&gt; 등)을 사용 안하면 더 정확한 함수 호출 그래프를 얻을 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로파일 데이터 얻기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCMalloc 라이브러리를 연결해도 기본적으로 프로파일 기능은 동작하지 않습니다. &lt;code&gt;HEAPPROFILE&lt;/code&gt; 환경변수에 프로파일 정보를 주기적으로 덤프할 파일 이름 접두사(prefix)를 지정해야만 동작합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ HEAPPROFILE=/tmp/profile execute-file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;접두사는 파일 절대 경로로 디렉토리를 포함할 수 있습니다.&lt;/p&gt;
&lt;p&gt;만일 덤프 파일이 너무 자주 생성되거나 반대로 너무 드물게 생성된다면 환경 변수를 통해 간격을 조절할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ HEAPPROFILE=/tmp/profile 
  HEAP_PROFILE_ALLOCATION_INTERVAL=107374182400 
  execute-file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;더 자세한 옵션은 
&lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/doc/heapprofile.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;공식 문서&lt;/a&gt;
를 확인해 보시기 바랍니다.&lt;/p&gt;
&lt;p&gt;위 예제에서 지정한 방식대로 프로그램을 실행하면 &lt;code&gt;/tmp/profile.0001.heap&lt;/code&gt;, &lt;code&gt;/tmp/profile.0002.heap&lt;/code&gt;, &lt;code&gt;/tmp/profile.0003.heap&lt;/code&gt; 등과 같은 프로파일 덤프 파일이 실행 도중 계속 생성됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결과 그래프 얻기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;포스트스크립트(PostScript) 파일 형식으로 메모리 프로파일 정보를 포함한 함수 호출 그래프를 얻으려면 다음과 같이 형식으로 pprof 프로그램을 실행하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pprof --ps --lines 
    execute-file 
    /tmp/profile.0001.heap 
    &amp;gt; profile-0001.ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로파일 덤프 파일에 대하여 하나씩 그래프를 생성해 직접 눈과 손으로 비교하는 것도 나쁘지 않지만, 두 프로파일의 차이점만 그래프로 만들어주는 옵션이 있으므로 이를 사용하면 더 편리합니다. 즉, 시간대별 메모리 사용량의 달라진 부분이 정확하게 어느 함수 호출 때문인지 알 수 있게 해줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pprof --ps --lines 
    --base /tmp/profile.0001.heap 
    execute-file 
    /tmp/profile.0002.heap 
    &amp;gt; profile-0002-diff.ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론, PDF(&lt;code&gt;--pdf&lt;/code&gt;), GIF(&lt;code&gt;--gif&lt;/code&gt;) 등과 같은 다른 형식으로 그래프 파일을 얻을 수도 있습니다. 더 자세한 옵션은 &amp;lsquo;&lt;code&gt;pprof --help&lt;/code&gt;&#39;를 참고하시면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결론&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;며칠간 디버깅에 적용해보니 문제가 발생한 패턴이 무엇이었는지도 찾아내고, 간과했던 작은 메모리 누수 버그들도 함께 발견할 수 있었습니다. 하지만, 언제나 그렇듯이, 디버깅 사태까지 오기 전에 더 튼튼하게 설계하고, 더 꼼꼼하게 프로그래밍하고, 더 철저하게 코드 리뷰와 테스트를 거치는 게 정도임을 새삼 깨닫습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCMalloc, 구글 성능 도구</title>
      <link>/2009/04/29/tcmalloc-google-perftools/</link>
      <pubDate>Wed, 29 Apr 2009 00:00:00 +0000</pubDate>
      <guid>/2009/04/29/tcmalloc-google-perftools/</guid>
      <description>&lt;p&gt;장기간 실행되면서 빈번하게 메모리를 할당 / 해제하는 것은 물론 수십 개의 쓰레드가 동작하는 프로그램에서는 어쩔 수 없이 메모리 단편화(Memory Fragmentation)가 발생합니다. 메모리 단편화가 많을 경우 어플리케이션 로직에 메모리 누수(memork leak)가 없어도 C 라이브러리 메모리 관리자가 메모리를 커널에 반환하지 않기 때문에 프로세스의 메모리 사용량은 계속 늘어납니다.(참고로 이러한 경우인지 여부는 주기적으로 &lt;code&gt;mallinfo()&lt;/code&gt; 정보를 확인하면 됩니다) 물론 이를 회피하기 위한 기법이나 아키텍쳐는 많이 있지만, 그리 쉽게 원하는 성능과 효율을 얻기는 힘들더군요.&lt;/p&gt;
&lt;p&gt;그런데, 며칠 동안 이와 비슷한 문제를 디버깅하다가 예전에 무심코 지나쳤던 
&lt;a href=&#34;http://code.google.com/p/google-perftools/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Performance Tools&lt;/a&gt;
 라이브러리를 다시 발견하고, 그 안에 들어 있는 
&lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TCMalloc(Thread-Caching Malloc)&lt;/a&gt;
 모듈을 사용해 보았는데 사용하지 않을 때와 비교해 놀랄만큼 많은 차이를 보이는군요. 문서에 보면 성능과 효율을 동시에 향상시킨다고 하는데 성능은 사실 잘 모르겠지만,  장기간 실행시 메모리 사용량 변동률은 너무나 맘에 듭니다.&lt;/p&gt;
&lt;p&gt;간단하게 TCMalloc의 동작 방식을 설명하면, 일단 중앙 메모리 관리자와 쓰레드별 메모리 관리자를 구분합니다. 작은 크기(32K 이하)의 메모리 할당 / 해제 요청은  쓰레드별 메모리 관리자가 처리하고, 부족할 경우 중앙 메모리 관리자에서 얻어오는 방식입니다. 따라서 메모리 할당시 불필요한 동기화 과정이 이론상 거의 없어 성능 향상을 얻을 수 있습니다.  메모리 크기를 60개의 클래스로 나누어 관리하게 때문에 단편화도 줄어듧니다. 큰 메모리(32K 이상)는 전역 관리자에서 페이지 크기(4K) 단위로 클래스를 나누어 mmap()을 이용하여 할당하는 것을 제외하고 전체적으로 비슷하게 처리합니다.&lt;/p&gt;
&lt;p&gt;소스를 빌드하고 프로젝트에 라이브러리를 링크하는 방법은 
&lt;a href=&#34;http://code.google.com/p/google-perftools/wiki/GooglePerformanceTools&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;위키페이지&lt;/a&gt;
에 설명되어 있으며, 문제가 발생하거나 더 복잡한 튜닝을 원한다면 소스 묶음 안에 있는 
&lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/README&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;README&lt;/a&gt;
, 
&lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/INSTALL&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;INSTALL&lt;/a&gt;
 파일 등을 참고하면 됩니다. (특히 리눅스 x86_64 환경에서는 &lt;code&gt;configure&lt;/code&gt; 실행시 &amp;lsquo;&lt;code&gt;--enable-frame-pointers&lt;/code&gt;&amp;rsquo; 옵션을 추가하는 것이 좋습니다)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>우분투에서 C 라이브러리 맨페이지(manpage) 설치하기</title>
      <link>/2009/04/08/pthread-man-pages-in-ubuntu-or-debian/</link>
      <pubDate>Wed, 08 Apr 2009 00:00:00 +0000</pubDate>
      <guid>/2009/04/08/pthread-man-pages-in-ubuntu-or-debian/</guid>
      <description>&lt;p&gt;리눅스에서 개발할때 &amp;lsquo;man&amp;rsquo; 명령을 이용해 매뉴얼 페이지를 많이 참고하는데, 자주 시스템을 다시 설치하다 보니 설치되지 않은 매뉴얼 때문에 매번 구글을 찾는라 귀찮은 적이 많아 적어둡니다. 우분투나 데비안에서만 유효합니다.&lt;/p&gt;
&lt;p&gt;기본적인 C 라이브러리 관련 매뉴얼 패이지는 `manpages-dev&amp;rsquo; 패키지를 설치하면 되고, pthread_*()  류의 함수는 `glibc-doc&amp;rsquo; 패키지를 설치하면 됩니다. 즉, 터미널에서 다음과 같이 입력하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install manpages-dev glibc-doc
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>윈도우 심볼 패키지 사용하기</title>
      <link>/2009/02/12/using-windows-symbol-packages/</link>
      <pubDate>Thu, 12 Feb 2009 00:00:00 +0000</pubDate>
      <guid>/2009/02/12/using-windows-symbol-packages/</guid>
      <description>&lt;p&gt;윈도우 비주얼 스튜디오 환경에서 디버깅을 하다보면 시스템에서 기본으로 제공하는 DLL 라이브러리에 대한 디버깅 심볼 정보가 없어 불편한 경우가 많습니다. 이 문제를 해결하려면 DLL 라이브러리에 대한 디버깅 심볼을 설치하면 됩니다.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://www.microsoft.com/whdc/DevTools/Debugging/debugstart.mspx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;이 사이트&lt;/a&gt;
에서 자신의 운영체제와 서비스 팩에 맞는 윈도우 심볼 패키지(Windows Symbol Packages)를 다운로드해서 설치한 뒤 &amp;lsquo;호출 스택(Call Stack)&amp;lsquo;을 확인해 보면, 아래 그림과 같이, 전과 다르게 ntdll.dll, kernel32.dll, user32.dll 등의 함수 이름이 표시됩니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/call-stacks-with-symbols.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;참고로, 위 사이트에 보면 비주얼 스튜디오를 설치하지 않아도(되는지 확인은 안해보았지만) 실행 중인 프로그램을 디버깅할 수 있도록 도와주는 WinDbg 디버깅 도구도 다운로드할 수 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Presenter First 개발</title>
      <link>/2008/12/17/presenter-first-development/</link>
      <pubDate>Wed, 17 Dec 2008 00:00:00 +0000</pubDate>
      <guid>/2008/12/17/presenter-first-development/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Presenter_First&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;프리젠터 먼저하기(Presenter First)&lt;/a&gt;
는
&lt;a href=&#34;http://en.wikipedia.org/wiki/Model_View_Presenter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;모델-뷰-프리젠터(MVP)&lt;/a&gt;
 디자인 패턴과 테스트 주도 개발(TDD) 등의 아이디어를 버무린  소프트웨어 개발 방법론입니다. 이에 대해 설명하기에 앞서 먼저 모델-뷰-컨트롤러(MVC) 패턴과 비교하여 모델-뷰-프리젠터(MVP) 개념을 정리하면 대략 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;모델(Model)&lt;/strong&gt; : 실제 다루고자 하는 데이터 읽기 / 쓰기. 관찰자(Observer) 패턴처럼 이벤트를 제공하면 더 좋습니다. MVC 패턴에서는 모델이 실제 데이터 뿐 아니라 사용자 인터페이스(View)와 연관된 데이터까지 처리하지만, MVP 패턴에서 모델은 순수하게 데이터만 처리합니다. 즉, 모델은 뷰나 프리젠터(사용자 인터페이스)에 대해서는 알 필요도 없고 알아서도 안됩니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;뷰(View)&lt;/strong&gt; : 사용자 인터페이스. 데이터 표시 뿐 아니라 사용자 입력까지 모두 처리합니다. MVC 패턴에서는 사용자 입력을 컨트롤러(Controller)에서 처리하지만 MVP 패턴에서는 뷰가 모두 처리합니다. 사용자 이벤트는 프리젠터에게 전달합니다. (관찰자 패턴을 사용합니다) 모델의 데이터가 변경되었다는 이벤트가 발생하면 데이터를 표시합니다. 하지만 초기 MVP 패턴과 달리 요즘에는 뷰와 모델간의 의존성까지 아예 없애버리고, 프리젠터가 디스플레이까지 제어합니다. 프리젠터 먼저하기 방법론에서 특히 이 방식을 이용합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;프리젠터(Presenter)&lt;/strong&gt; : 뷰가 전달한 사용자 이벤트에 기반하여 시나리오에 따라 모델 데이터를 조작합니다. MVC 패턴에서 어플리케이션 역할을 하는 부분이며, 사용자 요구사항이 변경되거나 로직이 변경되면 수정이 되어야 하는 부분이기도 합니다. 결과적으로, 모델과 뷰에 대해 알고있는 건 오직 프리젠터 뿐이고, 모델과 뷰는 프리젠터를 모릅니다. 뷰는 모델에 대해 알 수도 있지만, 프리젠터 먼저하기 방법론에서는 이 의존성도 없애버립니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;뷰를 오버로딩 가능한 추상 인터페이스로 만들고 프리젠터가 이 인터페이스를 사용하도록 하면, 뷰를 구현한(implementation) 객체는 플러그인처럼 교체 가능합니다. 즉, 뷰는 어쩔 수 없이 플랫폼이나 GUI 라이브러리에 의존하게 구현해야 하지만 모델과 프리젠터, 추상 뷰는 이와 상관없이 구현할 수 있습니다. 따라서 쉽게 이식 가능할 뿐 이나라, 하나의 데이터에 대해 여러가지 모양의 사용자 인터페이스를 지원하는 소프트웨어 개발이 쉬워집니다. 물론 모델 역시 추상 인터페이스로 만들고 같은 방식으로 프리젠터가 이 인터페이스를 사용하도록 하면 모델 구현 역시 쉽게 교체 가능한 구조가 됩니다. 그리고, 이러한 추상화는 테스트 주도 개발에도 응용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;결과적으로, 프리젠터 먼저하기 방법론에서 모델-뷰-프리젠터의 관계는 다음 그림과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; [M]  -----&amp;gt;    [P]    &amp;lt;----- [V]
Model &amp;lt;===== Presenter =====&amp;gt; View

  (---&amp;gt; : Events, ===&amp;gt; : Messages)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모델과 뷰는 프리젠터에게 이벤트를 전달하고, 프리젠터는 모델과 객체를 제어하기 위한 메시지를 전달합니다. 즉, 프리젠터만 모델과 뷰에 대해 알고 있을 뿐, 모델과 뷰는 다른 구성 요소를 알지 못합니다. 뷰는 비즈니스 로직에서 완전히 분리하고 모든 로직은 프리젠터에서 처리합니다.  뷰 인터페이스는 가능한 얇고 단순해야 하고, 이상적인 경우 사용자 이벤트를 그대로 프리젠터에게 전달하고, 표시할 내용을 읽고 쓰는 동작만 해야 합니다.&lt;/p&gt;
&lt;p&gt;프리젠터에게 전달하는 이벤트는 비즈니스 로직에서 사용하는 용어를 사용하여 전달되어야 합니다. 엔지니어 관점의 이벤트가 아닌 사용자 관점의 이벤트를 사용해야 한다는 점입니다. 예를 들어, 비즈니스 로직이 &amp;ldquo;추가 버튼을 누르면 텍스트 입력 내용이 할일목록에 추가되어야 함&amp;quot;이라면, 뷰는 &amp;ldquo;save-button-clicked&amp;rdquo; 이벤트가 정의되어야 하고, 프리젠터는 이 이벤트가 발생했을때 호출할 핸들러를 연결합니다. 핸들러에서는 뷰의 &amp;ldquo;get_text()&amp;rdquo; 함수를 호출하여 텍스트 내용을 얻은 뒤 모델의 &amp;ldquo;add_to_list()&amp;rdquo; 함수를 이용해 모델에 추가합니다. 여기서 만일 버튼 대신 예쁜 아이콘으로 뷰가 달라졌다고 이벤트 이름을 &amp;ldquo;save-image-clicked&amp;quot;로 변경하거나 새로운 이벤트를 추가하면 안됩니다. 사용자가 팝업 메뉴를 원해 메뉴 선택을 이용해 동일한 처리를 하게 되더라도 &amp;ldquo;save-menu-activated&amp;quot;로 변경하거나 새로 추가할 필요도 없습니다.  또는 실제로 버튼의 &amp;ldquo;clicked&amp;rdquo; 이벤트가 아닌 &amp;ldquo;button-pressed&amp;rdquo; 이벤트를 사용하더라도 프리젠터에게 전달하는 이벤트 이름은 변경하면 안된다는 점이 중요합니다.&lt;/p&gt;
&lt;p&gt;위 예를 조금 더 이어보면, 모델의 &amp;ldquo;add_to_list()&amp;rdquo; 함수 내에서는 데이터에 새로운 텍스트 내용을 추가한 뒤 내용이 변경되었음을 알리는 &amp;ldquo;list-changed&amp;rdquo; 이벤트를 발생하고, 프리젠터에서 미리 이 이벤트에 연결한 핸들러는 모델의 &amp;ldquo;get_list()&amp;rdquo; 함수를 호출해 목록을 얻은 뒤, 뷰의 &amp;ldquo;set_list()&amp;rdquo; 함수를 이용해 변경된 데이터를 화면에 표시합니다. 여기까지 설명에서 중요한 점은, 모든 변경사항은 관찰자 패턴처럼 이벤트를 이용해 전달한다는 점이고, 프리젠터가 모델과 뷰 간의 중재 작업을 통해 비즈니스 로직을 완성한다는 점입니다. 만일 할일 목록과 할 일 목록 편집 화면이 분리되어 구현되어 있을 경우 서로 의존성을 가지고 싶지 않을 수도 있습니다. 이런 경우 두 모델을 중재(coordinator)해서 연결하는 새로운 프리젠터, 혹은 어플리케이션 객체를 새로 만들어 이벤트 처리를 하면 두 모델간의 의존성도 사라질 수 있습니다.&lt;/p&gt;
&lt;p&gt;프리젠터 먼저하기 방법론은 지금까지 설명한 MVP 패턴으로 프로그램을 할때 프리젠터 객체를 가장 먼저 코딩합니다. 어차피 모델과 뷰 객체의 인터페이스(API)와 이벤트는 프리젠터 객체 구현이 마무리 될때까지 계속 수정되므로, 모델과 뷰는 가짜 객체(Mock Object)로 구현합니다. 가짜 객체라고 해도 프리젠터가 원하는 작업은 실제로 수행하는 것처럼 동작해야 하므로 가능한 단순한 자료구조를 이용해야 합니다.  이렇게 해서 비즈니스 로직을 모두 프리젠터에 구현한 뒤에, 모델과 뷰를 실제로 데이터 베이스에 접근하거나 파일에 읽고 쓰든, GTK+ 위젯 라이브러리를 이용하거나 콘솔 GUI를 이용하든 해서 구현하면 됩니다.&lt;/p&gt;
&lt;p&gt;하지만 유닛 테스트 도구를 사용하지 않는다면 뷰 없이 프리젠터 동작을 확인하는 코드를 만들기는 조금 불편합니다. 이런 경우 뷰를 가짜 객체 방식으로 만들더라도 어느 정도 기본적인 사용자 입출력이 가능하도록 만들면서 해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;참고한 자료&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.wildcrest.com/Potel/Portfolio/mvp.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;MVP: Model-View-Presenter, The Taligent Programming Model for C++ and Java&amp;rdquo;&lt;/a&gt;
, Mike Potel, 1996&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.object-arts.com/papers/TwistingTheTriad.PDF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;TWISTING THE TRIAD, The evolution of the Dolphin Smalltalk MVP application framework&amp;rdquo;&lt;/a&gt;
, Andy Bower, Blair McGlashan, Tutorial Paper for ESUG 2000&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://atomicobject.com/files/PresenterFirstAgile2006.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;Presenter First: Organizing Complex GUI Applications for Test-Drivn Development&amp;rdquo;&lt;/a&gt;
, agile, pp. 276-288, AGILE 2006 (AGILE&amp;rsquo;06), 2006.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://atomicobject.com/files/BigComplexTested_Feb07.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;Big, Complex, and Tested? Just Say &amp;lsquo;When&amp;rsquo;&amp;quot;&lt;/a&gt;
, Better Software Magazine February, 2007&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>GLib 쓰레드 프로그래밍</title>
      <link>/2008/08/06/glib-thread-programming/</link>
      <pubDate>Wed, 06 Aug 2008 00:00:00 +0000</pubDate>
      <guid>/2008/08/06/glib-thread-programming/</guid>
      <description>&lt;p&gt;소프트웨어를 개발하면서 멀티 쓰레드 방식을 사용하는 경우는 많습니다. 하지만 그만큼 복잡도가 증가해서 세심하게 고려하여 설계하지 않으면 디버깅 재앙을 얻는 경우가 많습니다. 이 글은 &amp;lsquo;
&lt;a href=&#34;/2008/12/28/gtk-memory-management/&#34;&gt;멀티쓰레드 프로그래밍 규칙&lt;/a&gt;
&amp;lsquo;에서 이어지는 내용입니다. 
&lt;a href=&#34;/2006/01/20/multi-thread-gtk-programming/&#34;&gt;GTK+ 쓰레드 관련 잡설&lt;/a&gt;
은 이미 언급한 적이 있으니까, 오늘은 별도의 쓰레드로 동작하는 간단한 예제 모듈을 만들면서 몇가지 유용한 GLib 쓰레드 API를 설명하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;리소스-resources&#34;&gt;리소스 (Resources)&lt;/h3&gt;
&lt;p&gt;한 개 이상의 쓰레드가 동작하는 방식의 소프트웨어를 설계할 경우 가장 염두에 두어야 하는 점은 **자원(resources)**입니다. 자원, 즉 리소스는 쉽게 말해 소프트웨어가 사용하는 데이터를 의미합니다. 전역 변수, 디스크 파일, 네트웍 소켓, 외부 장치 심지어 비디오 카드 같은 그래픽 장치 등이 모두 리소스입니다. 물론 넓은 의미에서 보면 리소스는 하나의 기능이나 세부 작업을 나타낼 수도 있습니다.&lt;/p&gt;
&lt;p&gt;멀티쓰레드 프로그래밍에서 가능한 지켜야 하는 가장 중요한 원칙은 &amp;lsquo;&lt;strong&gt;하나의 쓰레드만 하나의 리소스에 접근할 수 있어야 한다&lt;/strong&gt;&amp;lsquo;입니다. 아무 생각없이 하나의 리소스에 여러 쓰레드가 동시에 접근하도록 설계할 경우, 어쩔 수 없이 뮤텍스(mutex) 계열 API를 이용해 접근할 때마다 임계 구역을 보호해야 합니다. 그리고 이러한 기법은 소스 코드가 복잡해지고 커질수록 버그가 많아지고, 디버깅도 점점 어려워집니다. 물론, 쓰레드-풀(thread-pool) 기법처럼 성능 최적화나 확장성을 위해 멀티쓰레드를 사용하는 경우처럼 예외도 사실 많지만, 일단 이 글에서는 무시합니다.&lt;/p&gt;
&lt;p&gt;앞서 예를 들었던 GTK+ 쓰레드 프로그래밍도 리소스 관점에서 보면, 무조건 모든 쓰레드에서 GTK+ / GDK API 호출 전후에 gdk_threads_*() 계열 API를 남용해서 지독한 데드락과 이중락에 고생하던가, 아니면 GTK+ / GDK API 호출을 메인 쓰레드에서만 호출하도록 g_idle_add() / g_timeout_add() API만 이용하는 방법이 있습니다. 두번째 방법을 모델-뷰(Model-View) 개념으로 생각하면 마지막 GTK+ / GDK API 호출을 뷰(view) 갱신으로 볼 수 있고, g_idle_add() 계열 API는 일종의 메시지 전달로 생각할 수도 있습니다. (참고로 Sentry24DVR 2.x 버전은 첫번째 방식을, Sentry24CMS 2.x 버전은 두번째 방식을 사용합니다)&lt;/p&gt;
&lt;h3 id=&#34;쓰레드-시작--정지--실행&#34;&gt;쓰레드 시작 / 정지 / 실행&lt;/h3&gt;
&lt;p&gt;가장 먼저 쓰레드를 만들고 종료하는 루틴을 만들어 봅시다. 편의상 모듈 이름은 &amp;lsquo;drink&#39;라고 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;glib.h&amp;gt;

typedef struct _Drink Drink;
struct _Drink
{
  GThread *thread;
  gint running;
  GAsyncQueue *queue;
  gchar *host;
  gint port;
};

static gpointer
drink_process (gpointer data)
{
  Drink *drink = data;

  while (g_atomic_int_get (&amp;amp;drink-&amp;gt;running))
    {
      // do something...
    }

  return NULL;
}

Drink *
drink_new (const gchar *host, gint port)
{
  Drink *drink;

  g_return_val_if_fail (host != NULL, NULL);
  g_return_val_if_fail (port &amp;gt; 0, NULL);

  drink = g_new (Drink, 1);
  drink-&amp;gt;host = g_strdup (host);
  drink-&amp;gt;port = port;
  drink-&amp;gt;queue = g_async_queue_new ();

  g_atomic_int_set (&amp;amp;drink-&amp;gt;running, 1);
  drink-&amp;gt;thread = g_thread_new (drink_process, drink, TRUE, NULL);

  return drink;
}

void
drink_destroy (Drink *drink)
{
  g_return_if_fail (drink != NULL);

  g_atomic_int_set (&amp;amp;drink-&amp;gt;running, 0);
  g_thread_join (drink-&amp;gt;thread);

  g_async_queue_unref (disk-&amp;gt;queue);
  g_free (drink-&amp;gt;host);
  g_free (drink);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;drink_new() 함수는 지정한 호스트 / 포트 번호를 이용하여 새로운 Drink 객체를 만듭니다. 그리고 앞으로 나올 모든 데이터는 각각 자신이 속한 Drink 객체만 접근합니다. 즉, Drink 객체를 하나의 리소스로 여기면 됩니다. drink_destroy() 함수는 쓰레드가 종료할때까지 기다렸다가 Drink 객체를 해제하고 마무리합니다.&lt;/p&gt;
&lt;p&gt;쓰레드 함수 무한 루프는 간단하게 정수형 변수를 플래그처럼 사용합니다. 제대로 하려면 플래그 변수 역시 뮤텍스 API로 보호해주어야 하지만 대부분의 경우 간단한 원자연산자(atomic operator)로 처리가 가능합니다. 일단 이렇게 만들어 둡시다.&lt;/p&gt;
&lt;p&gt;마지막으로 설명할 API가 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Asynchronous-Queues.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GAsyncQueue&lt;/a&gt;
 객체인데, 가장 중요한 역할을 담당하는 물건입니다. 설명 그대로 이 API는 쓰레드간 비동기 통신(asynchronous communication between threads)을 하는데 사용합니다. 이 객체를 생성하는데는 g_async_queue_new(), 없애기 위해서는 g_async_queue_unref() 함수를 이용하는데, 일단 지금은 만들어만 놓습니다.&lt;/p&gt;
&lt;h3 id=&#34;api-추가--메시지-전달&#34;&gt;API 추가 + 메시지 전달&lt;/h3&gt;
&lt;p&gt;제일 먼저 하고 싶은 일은 미리 지정한 서버에 TCP 연결을 하거나, 끊고 싶습니다. 이를 비동기큐를 이용해서 간단하게 구현해 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum
{
  DRINK_MSG_CONNECT = 1,
  DRINK_MSG_SHUTDOWN = 2,
};

void
drink_connect (Drink *drink)
{
  g_return_if_fail (drink != NULL);

  g_async_queue_push (drink-&amp;gt;queue,
                      GINT_TO_POINTER (DRINK_MSG_CONNECT));
}

void
drink_shutdown (Drink *drink)
{
  g_return_if_fail (drink != NULL);

  g_async_queue_push (drink-&amp;gt;queue,
                      GINT_TO_POINTER (DRINK_MSG_SHUTDOWN));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 drink_connect() / drink_shutdown() 함수를 호출하면 g_async_queue_push() 함수를 이용해 메시지를 큐에 넣기만 하고 아무 일도 안합니다. (참고 : 모듈 외부에서 볼때는 내부 구현에 쓰레드를 사용하는지, 메시지 큐를 이용하는지 등은 공개되지도 않고, 공개할 필요도 없습니다) 이제 drink_process() 함수를 다음과 같이 수정합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static gpointer
drink_process (gpointer data)
{
  Drink *drink = data;

  while (g_atomic_int_get (&amp;amp;drink-&amp;gt;running))
    {
      do {
        GTimeVal tval;
        gpointer msg;

        /* wait for messages */
        g_get_current_time (&amp;amp;tval);
        g_timeval_add (&amp;amp;tval, 10000); /* 10msec */
        msg = g_async_queue_timed_pop (drink-&amp;gt;queue, &amp;amp;tval);
        if (!msg)
          break;

        switch (GPOINTER_TO_INT (msg))
          {
          case DRINK_MSG_CONNECT:
            // do connect work...
            break;
          case DRINK_MSG_SHUTDOWN:
            // do shutdown work...
            break;
          default:
            g_warning (&amp;quot;unknown drink msg&amp;quot;);
            break;
          }
      } while (1);

      // do something else ...
    }

  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;보는 바와 같이 메시지 큐에서 메시지를 꺼내어 메시지에 해당하는 작업을 처리합니다. 만일 메시지 큐를 사용하지 않고 drink_connect() 함수에서 직접 연결 작업을 수행하면 쓰레드 부분과 공유하는 부분을 모두 뮤텍스로 보호해야 하지만 이처럼 모든 작업을 담당 쓰레드가 처리하도록 메시지만 전송하면 실행 순서도 맞고 쓰레드가 자료 공유를 걱정할 필요도 없게 됩니다.&lt;/p&gt;
&lt;p&gt;여기서 사용한 g_async_queue_timed_pop() 함수는 지정한 시간 동안 아무 메시지도 없으면 NULL을 돌려줍니다. 비슷한 함수로 g_async_queue_pop() 함수는 메시지가 올때까지 무한정 기다랍니다. g_async_queue_try_pop() 함수는 메시지가 없을 경우 바로 NULL을 돌려줍니다. 만일 쓰레드 함수 자체적인 작업은 없고 100% 외부에서 메시지가 올때만 작업이 수행된다면 g_async_queue_pop() 함수를 사용하는 것이 더 좋습니다. 프로세스 동기화나 수면 상태(sleep) 등을 다른 작업을 하면서 자체적으로 하는 경우라면 g_async_queue_try_pop() 함수가 유용합니다.&lt;/p&gt;
&lt;p&gt;이 예제에서는 단순하게 10 밀리초 여유를 두고 메시지를 확인하고, 그외 다른 작업을 처리하도록 했습니다.&lt;/p&gt;
&lt;h3 id=&#34;쓰레드-종료-다듬기&#34;&gt;쓰레드 종료 다듬기&lt;/h3&gt;
&lt;p&gt;예제 처음에 있던 쓰레드 종료 코드가 너무 단순해서 조금 불안할 지도 모르겠네요. 메시지 큐에 데이터가 있을때 종료되면 메모리 누수도 있을 것 같고&amp;hellip; 그래서 쓰레드 종료도 하나의 메시지로 처리하도록 하려고 합니다. 수정하는 부분은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum
{
  DRINK_MSG_STOP_THREAD = -1,
  DRINK_MSG_CONNECT = 1,
  DRINK_MSG_SHUTDOWN = 2,
};

static gpointer
drink_process (gpointer data)
{
  Drink *drink = data;

  while (TRUE)
    {
      GTimeVal tval;
      gpointer msg;

      /* wait for messages */
      g_get_current_time (&amp;amp;tval);
      g_timeval_add (&amp;amp;tval, 10000); /* 10msec */
      msg = g_async_queue_timed_pop (drink-&amp;gt;queue, &amp;amp;tval);
      if (msg)
        {
          if (msg == GINT_TO_POINTER (DRINK_MSG_STOP_THREAD)) break;

          switch (GPOINTER_TO_INT (msg))
            {
            case DRINK_MSG_CONNECT:
              // do connect work...
              break;
            case DRINK_MSG_SHUTDOWN:
              // do shutdown work...
              break;
            default:
              g_warning (&amp;quot;unknown drink msg&amp;quot;);
              break;
            }
        }

      // do something else ...
    }

void
drink_destroy (Drink *drink)
{
  g_return_if_fail (drink != NULL);

  g_async_queue_push (drink-&amp;gt;queue, GINT_TO_POINTER (DRINK_MSG_STOP_THREAD));
  g_thread_join (drink-&amp;gt;thread);

  g_async_queue_unref (disk-&amp;gt;queue);
  g_free (drink-&amp;gt;host);
  g_free (drink);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;쓰레드 함수 무한루프 조건문이 조금 변경되었을 뿐 기본적인 원리는 동일합니다.&lt;/p&gt;
&lt;h3 id=&#34;마지막-조금-더-개선&#34;&gt;마지막, 조금 더 개선&amp;hellip;&lt;/h3&gt;
&lt;p&gt;이놈의 메시지 방식을 사용하면 대부분 프로그래머는 쉽게 switch() 문의 유혹을 떨쳐버리지 못합니다. 근데, 만일 당신이 매우 성능 좋은 메시징 서비스를 만들고 있다면 이런 방식의 코드는 유지보수도 힘들고 성능도 나쁠 수 있습니다. 메시지-함수 테이블을 유지해도 되고, 여러가지 방법이 있겠지만 여기서는 약간 가독성(readability)과 유지보수에 중점을 둔 방식을 설명하려 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct _DrinkMsg DrinkMsg;
struct _DrinkMsg
{
  void (*func) (Drink *drink, gpointer data1, gpointer data2);
  gpointer data1;
  gpointer data2;
};

static gpointer
drink_process (gpointer data)
{
  ...
  DrinkMsg *msg;

  msg = g_async_queue_try_pop (drink-&amp;gt;queue);
  if (msg)
    {
      if (msg == GINT_TO_POINTER (-1))
        break;
      msg-&amp;gt;func (drink, msg-&amp;gt;data1, msg-&amp;gt;data2);
      g_slice_free1 (msg);
    }
  ...
}

void
drink_destroy (Drink *drink)
{
  ...
  g_async_queue_push (drink-&amp;gt;queue, GINT_TO_POINTER (-1));
  g_thread_join (drink-&amp;gt;thread);
  ...
}

static void
drink_connect_real (Drink *drink, gpointer data1, gpointer data2)
{
  gchar *host = data1;
  gint port = GPOINTER_TO_INT (data2);

  // do connect work...

  g_free (host);
}

void
drink_connect (Drink *drink, const gchar *host, gint port)
{
  DrinkMsg *msg;

  msg = g_slice_new (DrinkMsg);
  msg-&amp;gt;func = drink_connect_real;
  msg-&amp;gt;data1 = g_strdup (host);
  msg-&amp;gt;data2 = GINT_TO_POINRTER (port);
  g_async_queue_push (drink-&amp;gt;queue, msg);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;뭐&amp;hellip; 더 이상의 설명은 피곤해서&amp;hellip;&lt;/p&gt;
&lt;p&gt;궁금한 API는 직접 매뉴얼을 한 번 뒤져보시길&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>라이브러리 설계, 구현, 유지에 좋은 습관</title>
      <link>/2006/02/24/good-practices-in-library-design-implementation-and-maintenance/</link>
      <pubDate>Fri, 24 Feb 2006 00:00:00 +0000</pubDate>
      <guid>/2006/02/24/good-practices-in-library-design-implementation-and-maintenance/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://www.gnu.org/software/libc/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;glibc(GNU libc)&lt;/a&gt;
 관리자이며 개발자인 
&lt;a href=&#34;http://people.redhat.com/drepper/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ulrich Drepper&lt;/a&gt;
의 글 중에 &amp;lsquo;
&lt;a href=&#34;http://people.redhat.com/drepper/goodpractice.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Good Practices in Library Design, Implementation, and Maintenance&amp;rsquo;&lt;/a&gt;
 는 비단 라이브러리 개발 뿐 아니라 일반 프로젝트를 진행할때도 유용한 여러 가이드라인을 제시한다. 간략하게 정리해보면 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;font-weight:bold;&#34;&gt;인터페이스 설계하기&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;가능한 API에 변수를 포함하지 말라. 대신 내부 변수를 처리하는 get-/set-함수를 구현하라.&lt;/li&gt;
&lt;li&gt;라이브러리가 제공하는 모든 인터페이스, 변수, 함수, 자료구조에 접두사(prefix)를 붙여라. 모든 객체에 반드시 같은 접두사를 사용할 필요는 없으며, 한 라이브러리가 여러 접두사를 사용해도 된다.&lt;/li&gt;
&lt;li&gt;C/C++ 라이브러리 설치시 함께 제공하는 헤더파일은 인터페이스를 정의하는데 필요한 정의(definition)와 선언(declaration)만 포함해야 한다.&lt;/li&gt;
&lt;li&gt;사용자가 직접 객체를 할당하지 않는 불완전한 형식(incomplete type)을 사용한다면 선정의(forward declaration)를 이용하는 것이 맞다.&lt;/li&gt;
&lt;li&gt;컴파일 설정(configuration)이 변경되더라도 라이브러리 헤더 파일은 변하면 안된다.&lt;/li&gt;
&lt;li&gt;어쩔 수 없이 불완전하게 정의한 데이터 타입을 제공해야 한다면, 나중에 커질 부분을 고려하여 최소한의 패딩을 만들어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span style=&#34;font-weight:bold;&#34;&gt;라이브러리 구현하기&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;가능한 많은 함수와 변수를 &amp;lsquo;static&#39;을 이용하여 오브젝트 파일에 지역적으로(local) 정의하라.&lt;/li&gt;
&lt;li&gt;외부로 보여지는(export) 심볼은 최대한 줄여라. 가장 좋은 경우는 문서화된 인터페이스만 보여지는 것이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span style=&#34;font-weight:bold;&#34;&gt;라이브러리 유지하기&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;이전 버전에 없었던 새로운 인터페이스는 따로 표시해야 새로운 인터페이스를 사용하는 어플리케이션이 아예 동작하지 못하도록 할 수 있다.&lt;/li&gt;
&lt;li&gt;오류를 수정하는게 아닌 다른 이유로 인터페이스가 변경되더라도 이전 인터페이스는 그대로 존재해야 한다.&lt;/li&gt;
&lt;li&gt;문서화된 라이브러리 인터페이스의 모든 면은 문서화해야 한다. 인터페이스가 변경되어야 한다면, 이전 동작이 그대로 유지된다는 것을 보장하기 위해 최소한 새 테스트가 추가되어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;키워드만 정리한 것이지만, 10쪽 분량밖에 안되는 글이므로 가능한 원본을 읽어보는 것이 좋을 것이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>printf() 함정에 빠지다</title>
      <link>/2006/01/20/printf-pitfall/</link>
      <pubDate>Fri, 20 Jan 2006 00:00:00 +0000</pubDate>
      <guid>/2006/01/20/printf-pitfall/</guid>
      <description>&lt;p&gt;C/C++ 프로그래밍을 10년 넘게 해오면서 아마도 언젠가는 이런 문제를 부딪힌 적이 있었을 지도 모른다. 다만 잊어버리고, 다음에 또 반복하고&amp;hellip;&lt;/p&gt;
&lt;p&gt;몇 주에 걸쳐 원인을 알 수 없는 세그멘테이션 폴트를 발생하는 문제를 디버깅했다. 프로그램은 e2fsck 명령 실행 결과를 &lt;code&gt;popen()&lt;/code&gt;을 이용하여 얻어온뒤 &lt;code&gt;syslog()&lt;/code&gt;를 통해 출력한다. gdb 백트레이스는 &lt;code&gt;syslog()&lt;/code&gt; 함수 내부에서 호출하는 &lt;code&gt;printf()&lt;/code&gt; 종류의 함수에서 멈추고 있었다. 지금까지 그랬던 것처럼 그 시점 이전 어디선가 메모리 침범이 발생한 것이라 판단하고 모든 관련 코드를 재검토하고 의심이 가는 부분을 재작성하기를 반복했으나 해결할 수 없었다. 그러다가 항상 같은 문자열에서 오류를 낸다는 패턴을 다시 검토하게 되었는데, 문제의 문자열은 &amp;lsquo;%&amp;rsquo; 기호를 포함하고 있었다. 순간 머리를 스치는 생각&amp;hellip; 역시 &lt;code&gt;syslog()&lt;/code&gt;의 매뉴얼 페이지를 확인해 보니 &lt;code&gt;syslog()&lt;/code&gt;는 &lt;code&gt;printf()&lt;/code&gt; 스타일의 가변 인수를 지원하는 함수였던 것이다. 즉, 문자열의 &amp;lsquo;%&amp;rsquo; 기호를 보고 뒤에 오는 &amp;lsquo;s&amp;rsquo;, &amp;lsquo;d&amp;rsquo; 등의 문자와 연동하여 있지도 않은 인수를 접근하면서 발생하는 문제였다. 즉, 다음 코드는&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;syslog(LOG_INFO, msg);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음과 같이 작성해야 하는 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;syslog(LOG_INFO, &amp;quot;%s&amp;quot;, msg);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;printf()&lt;/code&gt; 방식의 함수는 의외로 많다. &lt;code&gt;sprintf()&lt;/code&gt;, &lt;code&gt;scanf()&lt;/code&gt;, &lt;code&gt;syslog()&lt;/code&gt;, 심지어 자체적으로 만들어 사용하는 디버그 매크로까지&amp;hellip; 하지만, 위와 같이 첫번째 인수인 포맷을 지정하고 않고 출력할 문자열을 그대로 전달하면 일단 컴파일과 실행에는 문제가 없지만, &amp;lsquo;%&#39;, &#39;&amp;rsquo; 등의 기호가 포함되어 있다면 개발자의 삶은 고달퍼지기 시작하는 것이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Duff&#39;s Device</title>
      <link>/2006/01/11/duffs-device/</link>
      <pubDate>Wed, 11 Jan 2006 00:00:00 +0000</pubDate>
      <guid>/2006/01/11/duffs-device/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Duff%27s_device&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Duff&amp;rsquo;s Device&lt;/a&gt;
는 연속적인 복사 작업을 수행하는 알고리즘에 있어 C 언어로 구현된 가장 최적화된 기법이다. 일반적으로 어셈블리에서 사용되는 기술을 &lt;code&gt;switch&lt;/code&gt; 문과 루프 풀기(Loop Unrolling) 기법을 이용하여 구현하는데, 이 기법이 발표된 1983년 이후 아직까지 이보다 더 최적화된 구현은 없다고 한다. 코드를 보면 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int n = (count + 7) / 8;      /* count &amp;gt; 0 assumed */
switch (count % 8) {
case 0: do { *to = *from++;
case 7:      *to = *from++;
case 6:      *to = *from++;
case 5:      *to = *from++;
case 4:      *to = *from++;
case 3:      *to = *from++;
case 2:      *to = *from++;
case 1:      *to = *from++;
        } while (--n &amp;gt; 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;얼핏보면 컴파일도 안될 것 같지만 깔끔하게 컴파일되고 제대로 동작하는 ANSI C 코드이다. 이 코드는 &lt;code&gt;switch&lt;/code&gt; 문의 &lt;code&gt;case&lt;/code&gt; 문이 &lt;code&gt;goto&lt;/code&gt; 문에서도 사용하는 레이블(label)로 처리된다는 점을 이용한다. 8의 배수 크기만큼은 &lt;code&gt;do { } while ()&lt;/code&gt; 문의 최적화된 루프 풀기(loop unroll) 코드로 동작하고, 8로 나누어지지 않는 나머지 부분은 &lt;code&gt;switch()&lt;/code&gt; 문에 의해 직접 해당 위치로 점프하여 그만큼을 미리 수행하는 방식이다. &amp;lsquo;
&lt;a href=&#34;http://www.codemaestro.com/reviews/review00000102.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Loop Unrolling with Duff&amp;rsquo;s Device&lt;/a&gt;
&amp;rsquo; 리뷰 문서는 이 알고리즘을 더 자세히 설명하고 있다.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://www.chiark.greenend.org.uk/%7Esgtatham/coroutines.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;lsquo;Coroutines in C&amp;rsquo;&lt;/a&gt;
는 Duff&amp;rsquo;s Device에서 사용한 &lt;code&gt;switch&lt;/code&gt; 기법을 이용하여 상태가 유지되는 함수를 만들 수 있는 방법을 알려주고 있다. 또한 스테이트 머신(state machine)과 같이 상태에 따라 다른 동작을 해야하는 루틴을 만들 경우 상태 변수에 따라 일일히 분기하는 알고리즘이 아니라, 하나의 작업 흐름대로 코드를 만들고, 다음에 루틴에 진입할 경우 바로 마지막 작업 시점에서 계속 수행되도록 할 수 있다. Duff&amp;rsquo;s Device 기법을 고안한 사람도 처음에는 인터럽트 핸들러를 작성할때 이 방법을 이용하여 만들었다고 한다.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://www.sics.se/%7Eadam/pt/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Protothreads&lt;/a&gt;
 라이브러리는 Duff&amp;rsquo;s Device 기법을 이용하여 ANSI C 에서 멀티쓰레드를 프로그래밍을 할 수 있도록 도와준다. 쓰레드별 스택(stack)을 지원하지 않고 이벤트 기반으로 동작할 경우에만 유용하다. 하지만, 메모리가 적은 임베디드 시스템이나 마이크로 컨트롤러 시스템에서 멀티쓰레드를 지원하는 운영체제를 이용하기 힘든 경우가 많은데, 이런 경우에 적합하다고 하며, 실제로 이 라이브러리를 이용해 구현한 초경량 커널에 대한 정보도 얻을 수 있다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>멀티쓰레드 프로그래밍 규칙</title>
      <link>/2005/11/20/multi-thread-programming-rules/</link>
      <pubDate>Sun, 20 Nov 2005 00:00:00 +0000</pubDate>
      <guid>/2005/11/20/multi-thread-programming-rules/</guid>
      <description>&lt;p&gt;멀티 쓰레드 방식 프로그래밍은 강력한 효율을 제공하지만 그만큼 프로그래머를 힘들게 하기도 한다. 그렇다면, 멀티 쓰레드 방식을 대체할 수 있는 방법은 무엇이 있을까? 물론 많은 사람들이 이 주제에 대하여 책도 쓰고 글도 남겼지만 여기는 내 블로그니까, 가능한 내 경험에 비추어 생각해본다.&lt;/p&gt;
&lt;h3 id=&#34;뮤텍스mutex를-사용해야-하는-구조로-설계하지-말기&#34;&gt;뮤텍스(mutex)를 사용해야 하는 구조로 설계하지 말기&lt;/h3&gt;
&lt;p&gt;뮤텍스를 이용하는 근본적인 이유는 하나의 리소스에 대해 동시에 접근할 경우 문제가 발생할 수 있을 경우 이에 대한 상호 배제(Mutual Exclusion)를 하기 위함이다. 하지만 하나의 리소스 또는 기능에 대한 처리를 전담하는 쓰레드를 만들고, 원하는 작업을 이 쓰레드(또는 프로세스)에게 메시지로 전달하여 처리하는 방식을 이용하면 뮤텍스를 사용해야 하는 경우는 사라지게 된다. 즉, 메시지 처리 방식(message-driven)을 이용하는 것이다. 물론 이 방식은 비동기적인 메시지일 경우 별로 문제가 없지만, 동기화가 필요한 경우 복잡해진다는 단점이 있다. 또한 성능 문제도 무시할 수 없다.&lt;/p&gt;
&lt;h3 id=&#34;폴링polling-방식을-적극적으로-이용하고-쓰레드로-분리하지-않기&#34;&gt;폴링(polling) 방식을 적극적으로 이용하고 쓰레드로 분리하지 않기&lt;/h3&gt;
&lt;p&gt;멀 티쓰레드 프로그래밍시 발생하는 대부분의 문제는 한번 쓰레드 방식을 이용하게 되면 이후 추가되는 모든 구현에 적극적으로 쓰레드를 도입하게 되는 습관에서 시작한다. 특히 IO(비디오,디스크,네트워크) 관련 처리에 대한 비동기 처리를 폴링 방식으로 프로그래밍하면 느려지고 복잡하기 때문에 쓰레드로 분리해서 쉽게 해결하지만, 바로 이때부터가 재앙의 시작이다. 경험상으로 보면 가장 큰 기능별로 쓰레드를 분리하는 것이 가장 바람직하며, 정말로 성능에 별로 지장을 주지 않는다면 조금 수고가 들더라도 비동기 방식으로 제작하여 한 쓰레드에서 수행되도록 하는 것이 데드락(deadlock)과 같은 저주를 피하면서 뇌세포에게 더 많은 휴식을 줄 수 있는 방법일 것이다.&lt;/p&gt;
&lt;h3 id=&#34;이미-잘설계된-라이브러리를-이용하기&#34;&gt;이미 잘설계된 라이브러리를 이용하기&lt;/h3&gt;
&lt;p&gt;
&lt;a href=&#34;http://www.gtk.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GLib&lt;/a&gt;
 같은 라이브러리를 살펴보면 위의 원칙대로 프로그래밍하기 위한 API가 너무나 잘 지원되고 있다. 욕심이 나지 않을 수가 없다. 다만, 임베디드 시스템에도 이용할 수 있도록 다른 라이브러리에 대한 의존성이 적고, WinCE 등과 같은 플랫폼도 문제없이 지원한다면 현재 진행중인 모든 프로젝트의 기본 라이브러리로 채택하지 않을 이유가 없을텐데 말이다.&lt;/p&gt;
&lt;p&gt;물론 다른 규칙도 많겠지만, 오늘은 일단 여기까지만&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quake3 Source Skimming</title>
      <link>/2005/11/15/quake3-source-skimming/</link>
      <pubDate>Tue, 15 Nov 2005 00:00:00 +0000</pubDate>
      <guid>/2005/11/15/quake3-source-skimming/</guid>
      <description>&lt;p&gt;퀘이크3(Quake3) 소스가 GPL 라이센스로 풀리면서 나같은 사람도 한번 얼핏 훑어볼 기회가 생겼다. 얼핏 훑어본 퀘이크3 소스 코드의 특징은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;메모리 할당은 대부분 필요한 크기를 정해서 초기에 한꺼번에 할당한다. 즉, 프로그램 실행 도중에 메모리를 할당하고 해제하는 일이 거의 없다.&lt;/li&gt;
&lt;li&gt;링크드 리스트 대신 배열을 많이 쓴다.&lt;/li&gt;
&lt;li&gt;내부적으로 가상 머신을 따로 만들어 사용한다. 또한 멀티쓰레드 방식이 아닌 가능한 하나의 이벤트 루프 안에서 모든 것을 처리하는 것 같다. (전통적인 게임 프로그래밍 방식?)&lt;/li&gt;
&lt;li&gt;이름 충돌을 위해 전역 변수에 static 키워드를 철저하게 지킨다. 대신 네이밍룰은 조금 자유로운 것 같다.&lt;/li&gt;
&lt;li&gt;역시 메뉴와 같은 UI 엔진은 따로 구현하고 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;역시 게임 소프트웨어는 소프트웨어의 모든 기술을 망라하여 이용하고 있다는 느낌도 새삼 든다. 우리는 책임도 지지 못하는 메모리 할당 방식 API를 너무 남용하고 있는 것은 아닐까.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
