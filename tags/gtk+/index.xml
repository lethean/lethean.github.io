<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GTK&#43; | 대체로 무해함</title>
    <link>/tags/gtk&#43;/</link>
      <atom:link href="/tags/gtk+/index.xml" rel="self" type="application/rss+xml" />
    <description>GTK&#43;</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>ko-kr</language><copyright>© lethean</copyright><lastBuildDate>Mon, 02 Jul 2012 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>GTK&#43;</title>
      <link>/tags/gtk&#43;/</link>
    </image>
    
    <item>
      <title>X 윈도우 마우스 포인터 장벽(barrier)</title>
      <link>/2012/07/02/2012-07-02-mouse-pointer-barriers-in-x-window/</link>
      <pubDate>Mon, 02 Jul 2012 00:00:00 +0000</pubDate>
      <guid>/2012/07/02/2012-07-02-mouse-pointer-barriers-in-x-window/</guid>
      <description>&lt;p&gt;그놈3 데스크탑 환경을 사용할때 불편했던 점 중 하나는,  프로그램을 실행하는 등의 창 작업을 위해 화면 상단 왼쪽 구석으로 마우스를 이동했을때 듀얼 모니터에서 마우스가 미끌어져 버리는 현상이었습니다. 그런데, 어느 날부터인가 이 현상, 즉 마우스를 화면 구석으로 이동해도 마우스가 다음 모니터로 미끌어져 넘어가는 현상이 발생하지 않았습니다. 제가 &amp;lsquo;어느 날&#39;이라는 표현을 사용한 이유는, 
&lt;a href=&#34;/2011/02/21/migrated-to-arch-linux/&#34;&gt;아치 리눅스로 이전&lt;/a&gt;
한 이후로 아직까지 한 번도 시스템을 재설치하지 않고, 생각날 때마다 최소 2~3일에 한 번씩 패키지를 업그레이드하는 습관 때문입니다.&lt;/p&gt;
&lt;p&gt;그러다가 최근 
&lt;a href=&#34;http://lwn.net/Articles/500747/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LWN.net의 X11R7.7 릴리스 기사&lt;/a&gt;
에서 이런 내용을 읽게 되었습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Pointer barriers&lt;/strong&gt; were added by X Fixes extension Version 5.0. Compositing managers and desktop environments may have UI elements in particular screen locations such that for a single-headed display they correspond to easy targets, for example, the top left corner. For a multi-headed environment these corners should still be semi-impermeable. Pointer barriers allow the application to define additional constraint on cursor motion so that these areas behave as expected even in the face of multiple displays.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, X Fixes 확장 기능 5.0 버전에 포인터 장벽(?)이라는게 추가되었는데, 어플리케이션이 커서 움직임에 제한을 더할 수 있도록 했다는 겁니다. 그리고 이를 이용하면 바로 정확하게 제가 경험한 것과 같은 멀티 모니터에서의 구석 마우스 미끄러짐 현상을 없앨 수 있다는 점도 부연하고 있습니다.&lt;/p&gt;
&lt;p&gt;사실 비슷한 문제가 제가 회사에서 개발 중인 프로그램에서도 발생하고 있었기 때문에 이 기능에 관심이 안 갈 수가 없었습니다. 그래서 조금 더 정확하게 확인하기 위해 그놈 셸 소스 코드를 조사했더니 아니나 다를까, 패널 박스 크기가 변경될때마다(&amp;ldquo;allocation-changed&amp;rdquo;) 호출되는 
&lt;a href=&#34;http://git.gnome.org/browse/gnome-shell/tree/js/ui/layout.js#n171&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;_updatePanelBarriers()&lt;/code&gt;&lt;/a&gt;
 함수가 그 역할을 하고 있습니다. (
&lt;a href=&#34;http://git.gnome.org/browse/gnome-shell/commit/js/ui/layout.js?id=021d3dadbb63676c1ac9496ecbb0b80ce2eb6dfe&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;2011년 7월 25일에 작성된 코드&lt;/a&gt;
군요&amp;hellip;)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;_updatePanelBarriers: function() {
    if (this._leftPanelBarrier)
        global.destroy_pointer_barrier(this._leftPanelBarrier);
    if (this._rightPanelBarrier)
        global.destroy_pointer_barrier(this._rightPanelBarrier);

    if (this.panelBox.height) {
        let primary = this.primaryMonitor;
        this._leftPanelBarrier =
            global.create_pointer_barrier(primary.x, primary.y,
                                          primary.x, primary.y + this.panelBox.height,
                                          1 /* BarrierPositiveX */);
        this._rightPanelBarrier =
            global.create_pointer_barrier(primary.x + primary.width, primary.y,
                                          primary.x + primary.width, primary.y + this.panelBox.height,
                                          4 /* BarrierNegativeX */);
    } else {
        this._leftPanelBarrier = 0;
        this._rightPanelBarrier = 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 자바스크립트 코드가 호출하는 
&lt;a href=&#34;http://git.gnome.org/browse/gnome-shell/tree/src/shell-global.c#n1010&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;실제 C 함수 코드&lt;/a&gt;
는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/**
 * shell_global_create_pointer_barrier:
 * @global: a #ShellGlobal
 * @x1: left X coordinate
 * @y1: top Y coordinate
 * @x2: right X coordinate
 * @y2: bottom Y coordinate
 * @directions: The directions we&#39;re allowed to pass through
 *
 * If supported by X creates a pointer barrier.
 *
 * Return value: value you can pass to shell_global_destroy_pointer_barrier()
 */
guint32
shell_global_create_pointer_barrier (ShellGlobal *global,
                                     int x1, int y1, int x2, int y2,
                                     int directions)
{
#if HAVE_XFIXESCREATEPOINTERBARRIER
  return (guint32)
    XFixesCreatePointerBarrier (global-&amp;gt;xdisplay,
                                DefaultRootWindow (global-&amp;gt;xdisplay),
                                x1, y1,
                                x2, y2,
                                directions,
                                0, NULL);
#else
  return 0;
#endif
}

/**
 * shell_global_destroy_pointer_barrier:
 * @global: a #ShellGlobal
 * @barrier: a pointer barrier
 *
 * Destroys the @barrier created by shell_global_create_pointer_barrier().
 */
void
shell_global_destroy_pointer_barrier (ShellGlobal *global, guint32 barrier)
{
#if HAVE_XFIXESCREATEPOINTERBARRIER
  g_return_if_fail (barrier &amp;gt; 0);

  XFixesDestroyPointerBarrier (global-&amp;gt;xdisplay, (PointerBarrier)barrier);
#endif
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;XFixesCreatePointerBarrier()&lt;/code&gt; / &lt;code&gt;XFixesDestroyPointerBarrier()&lt;/code&gt; 함수에 대한 더 자세한 사용법을 확인하기 위해 
&lt;a href=&#34;http://www.x.org/releases/X11R7.7/doc/fixesproto/fixesproto.txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;XFIXES 공식 프로토콜 문서&lt;/a&gt;
를 확인해 보니 마지막에 다음과 같은 API 설명이 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;12. Pointer Barriers

...

12.1 Types

    BARRIER:    XID

    BarrierDirections

        BarrierPositiveX:       1 &amp;lt;&amp;lt; 0
        BarrierPositiveY:       1 &amp;lt;&amp;lt; 1
        BarrierNegativeX:       1 &amp;lt;&amp;lt; 2
        BarrierNegativeY:       1 &amp;lt;&amp;lt; 3

12.3 Requests

CreatePointerBarrier

        barrier:            BARRIER
        drawable:           DRAWABLE
        x1, y2, x2, y2:         INT16
        directions:         CARD32
        devices:            LISTofDEVICEID

    Creates a pointer barrier along the line specified by the given
    coordinates on the screen associated with the given drawable.  The
    barrier has no spatial extent; it is simply a line along the left
    or top edge of the specified pixels.  Barrier coordinates are in
    screen space.

    The coordinates must be axis aligned, either x1 == x2, or
    y1 == y2, but not both.  The varying coordinates may be specified
    in any order.  For x1 == x2, either y1 &amp;gt; y2 or y1 &amp;lt; y2 is valid.
    If the coordinates are not valid BadValue is generated.

    Motion is allowed through the barrier in the directions specified:
    setting the BarrierPositiveX bit allows travel through the barrier
    in the positive X direction, etc.  Nonsensical values (forbidding Y
    axis travel through a vertical barrier, for example) and excess set
    bits are ignored.

    If the server supports the X Input Extension version 2 or higher,
    the devices element names a set of master device to apply the
    barrier to.  If XIAllDevices or XIAllMasterDevices are given, the
    barrier applies to all master devices.  If a slave device is named,
    BadDevice is generated; this does not apply to slave devices named
    implicitly by XIAllDevices.  Naming a device multiple times is
    legal, and is treated as though it were named only once.  If a
    device is removed, the barrier continues to apply to the remaining
    devices, but will not apply to any future device with the same ID
    as the removed device.  Nothing special happens when all matching
    devices are removed; barriers must be explicitly destroyed.

    Errors: IDChoice, Window, Value, Device

DestroyPointerBarrier

        barrier:            BARRIER

    Destroys the named barrier.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;포인터 장벽은 반드시 화면 구석에서만 사용할 수 있는 게 아니라 화면 어느 곳에나 생성할 수 있으며, 장벽 생성시 지정한 방향(direction)으로만 마우스 커서가 이동할 수 있도록 허용합니다. 다시 말해 마우스 커서가 반대 방향으로는 장벽을 넘어갈 수 없게 합니다.방향과 함께 장벽의 영역 좌표를 지정해야 하는데, 예를 들어 왼쪽에서 오른쪽이라면 Y 좌표값만 다르고 X 좌표값을 동일하게 지정해야 합니다. 즉, 세로로 장벽 선을 그리면 됩니다. 그런데, 사실 화면 구석에서는 원하는 대로 동작하는데, 화면 임의의 위치에 포인터 장벽을 생성해 보면 마우스 커서의 대각선 움직임 등은 허용하기 때문에 아주 정확하게 원하는 대로 동작하지 않을 수도 있습니다.&lt;/p&gt;
&lt;p&gt;참고로 상위 툴킷에서 X 윈도우 API 호출에 사용하는 Display, Window 핸들을 얻으려면, Clutter의 경우 
&lt;a href=&#34;http://developer.gnome.org/clutter/stable/clutter-X11-Specific-Support.html#clutter-x11-get-default-display&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;clutter_x11_get_default_display()&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://developer.gnome.org/clutter/stable/clutter-X11-Specific-Support.html#clutter-x11-get-stage-window&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;clutter_x11_get_stage_window()&lt;/code&gt;&lt;/a&gt;
 또는 
&lt;a href=&#34;http://developer.gnome.org/clutter/stable/clutter-X11-Specific-Support.html#clutter-x11-get-root-window&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;clutter_x11_get_root_window()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하면 됩니다. GTK+ 역시 GDK 관련 API를 뒤져 보시면 됩니다. ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GNOME 개발 설명서 / 동영상</title>
      <link>/2011/07/15/2011-07-15-gnome-development-screencasts-and-tutorials/</link>
      <pubDate>Fri, 15 Jul 2011 00:00:00 +0000</pubDate>
      <guid>/2011/07/15/2011-07-15-gnome-development-screencasts-and-tutorials/</guid>
      <description>&lt;p&gt;오랜만에 
&lt;a href=&#34;http://developer.gnome.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GNOME 개발자 센터&lt;/a&gt;
를 들어갔더니, 모양 뿐 아니라 내용도 확 바뀌어 있습니다. 예전에도 있었는데 제가 몰랐던 건지도 모르지만, 
&lt;a href=&#34;http://developer.gnome.org/gnome-devel-demos/unstable/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;10분짜리 설명서(10-minute tutorials)&lt;/a&gt;
가 가장 먼저 눈에 띄었습니다. (접속한 페이지의 실제 이름은 GNOME 개발자 플랫폼 데모입니다) 이미지 보기, 기타 튜너, 메시지 보드 등과 같은 여러 예제를 통해 단순한 GTK+ 위젯 라이브러리 사용법만 보여주는것 뿐 아니라, 말 그대로 GNOME 플랫폼의 중심이 되는 
&lt;a href=&#34;http://www.gtk.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+&lt;/a&gt;
 / 
&lt;a href=&#34;http://www.clutter-project.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Clutter&lt;/a&gt;
 / 
&lt;a href=&#34;http://gstreamer.freedesktop.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GStreamer&lt;/a&gt;
 / 
&lt;a href=&#34;https://live.gnome.org/WebKitGtk&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;WebKitGtk&lt;/a&gt;
 라이브러리 등을 이용하여 유용하게 참고할 수 있는 간단한 응용 프로그램을 
&lt;a href=&#34;http://www.anjuta.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Anjuta&lt;/a&gt;
 통합 개발 도구, 
&lt;a href=&#34;http://glade.gnome.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Glade&lt;/a&gt;
 UI 편집기를 이용하여 개발하는 방법을 설명합니다. 또한 C / C++ / JavaScript / Python / 
&lt;a href=&#34;https://live.gnome.org/Vala&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vala&lt;/a&gt;
 등과 같은 언어별 예제도 각각 제공하고 있습니다.&lt;/p&gt;
&lt;p&gt;최근 계속 연재되는 
&lt;a href=&#34;http://www.python.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;파이썬(Python)&lt;/a&gt;
 언어와 
&lt;a href=&#34;http://www.gtk.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+&lt;/a&gt;
 / 
&lt;a href=&#34;http://www.clutter-project.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Clutter&lt;/a&gt;
 / 
&lt;a href=&#34;http://gstreamer.freedesktop.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GStreamer&lt;/a&gt;
 라이브러리를 이용한 GNOME 개발 동영상(screencast)도 볼만합니다. 몇몇 예제는 그놈 개발자 사이트 데모 프로그램과 겹치는 것도 있습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;http://vimeo.com/25185245&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GNOME 스크린캐스트 - 01. 첫번째 GTK+ 어플리케이션&lt;/a&gt;
 &lt;em&gt;(2011-06-16)&lt;/em&gt;: 파이썬을 이용해 기본 기능을 가진 GTK+ 프로그램 만들기&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://vimeo.com/25483019&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GNOME 스크린캐스트 - 02. 화려한 사진 어플리케이션 만들기&lt;/a&gt;
 &lt;em&gt;(2011-06-22)&lt;/em&gt;: 파이썬과 GTK+를 이용해 간단한 사진 프로그램 만들기&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://vimeo.com/25796446&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GNOME 스크린캐스트 - 03. 멋진 계산기 만들기&lt;/a&gt;
 &lt;em&gt;(2011-06-29)&lt;/em&gt;: 파이썬과 GTK+를 이용해 간단한 계산기 프로그램 만들기&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://vimeo.com/26100971&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GNOME 스크린캐스트 - 04. 우아한 기타 튜너 만들기&lt;/a&gt;
 &lt;em&gt;(2011-07-07)&lt;/em&gt;: 파이썬과 GTK+, GStreamer를 이용해 기타 튜너 프로그램 만들기&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://vimeo.com/26452876&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GNOME 스크린캐스트 - 05. 매력적인 동영상 재생기 만들기&lt;/a&gt;
 &lt;em&gt;(2011-07-15)&lt;/em&gt;: 파이썬과 GTK+, GStreamer, Clutter를 이용해 동영상 재생기 만들기&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;
&lt;a href=&#34;http://projects.gnome.org/gedit/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gedit&lt;/a&gt;
 텍스트 편집기와 
&lt;a href=&#34;http://glade.gnome.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Glade&lt;/a&gt;
 UI 편집기만을 이용해 파이썬 언어의 간결함과 GNOME 플랫폼 라이브러리의 강력함을 잘 보여주고 있습니다. 여담이지만, 영어가 짧아 단어만 알아듣는 본인도 코드만 보고 이해할 수 있었습니다. :)&lt;/p&gt;
&lt;p&gt;물론 이 글에서 소개한 설명서는 대부분 아마도 많은 개발자에게 GNOME 플랫폼의 우수성을 전파하고 사용을 독려하기 위해 매우 기본적인 내용만 맛보기로 소개하기 때문에 더 심각하고(?) 자세한 내용을 알고 싶다면 각 기술에 대한 심층적인 공부가 필요합니다.&lt;/p&gt;
&lt;p&gt;또한 GNOME 플랫폼 라이브러리라는 제목을 달고 있지만 대부분의 기술이 반드시 GNOME 환경에서만 동작하는 게 아니므로 리눅스 관련 개발자라면 한 번 들여다보는 것도 좋을 것 같습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2010년 1학기에 작성한 프로그램</title>
      <link>/2010/09/28/2010-09-28-programs-written-in-2010-spring-semester/</link>
      <pubDate>Tue, 28 Sep 2010 00:00:00 +0000</pubDate>
      <guid>/2010/09/28/2010-09-28-programs-written-in-2010-spring-semester/</guid>
      <description>&lt;p&gt;뭐, 전혀 관심 없는 분이 대부분이겠지만, 제 하드 디스크에서 묵히는 것보다 누군가에게 도움이 되는 편이 좋을 것 같아, 별로 품질이 좋은 소스는 아니지만, 오픈 소스만 사용해도 무난하게 과제 수행에 문제가 없음을 보여주기 위해, 지난 학기 수업 과제물로 제출했던 과제물의 문서와 프로그램 소스를 공개합니다.&lt;/p&gt;
&lt;p&gt;참고로, 앞의 두 프로그램은 GTK+ 라이브러리를 이용해서 리눅스에서 개발했지만, 과제 시연을 위해 윈도우에서도 문제없이 컴파일되고 실행되도록 만들었습니다. 그리고, 안드로이드 뷰어는 라이브 보기만 구현된 소스입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Image Histogram Viewer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;﻿﻿이 프로그램은 JPEG 이미지 파일을 읽어들여 화면에 표시하고 파일의 이름, 생성일시, 수정일시 등과 같은 속성을 보여주고, 이미지의 히스토그램을 분석하여 그래프로 표시합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Photo Mosaic Builder&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이 프로그램은 원본 사진을 동일한 크기의 작은 영역으로 쪼갠뒤 복수의 다른 사진으로 다시 구성하여 최종 모자이크 사진을 생성합니다. 복수의 사진은 작은 썸네일(thumbnail) 사진으로 변환되며 각 영역의 색 속성과 가장 유사한 썸네일 사진으로 채워집니다. 이 과정에 복수의 사진을 한번만 사용할 지 여부를 선택할 수 있으 며, 최종 사진을 파일로 다시 저장할 수도 있습니다. 이 모든 과정을 처리하는데 걸리는 시간을 측정하여, OpenMP 라이브러리를 이용한 성능 최적화 정도를 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 안드로이드 IP 카메라 뷰어 설계 및 구현&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;안드로이드 IP 카메라 뷰어는 휴대폰 같은 안드로이드(Android) 장비에서 네트워크에 연결된 IP 카메라에 접속하여 라이브 영상과 음성을 재생하고 카메라 동작을 제어합니다. 또한 사용자에게 친숙한 안드로이드폰의 다른 기능과 유기적으로 연동하여 언제 어디서나 쉽고 빠르게 긴급상황에 대처할 수 있도록 도와줍니다. 이를 위해 원격에서 비디오 스트리밍 데이터를 수신하여 디코딩한 후 색상 공간(color space) 변환까지 마친 후 화면에 표시하는 작업에 안드로이드 NDK(Native Development Kit) 방식 C/C++ 코드를 활용합니다. 또한 네이티브 C 모듈과 자바 언어와의 통신 오버헤드를 줄이기 위해 메모리 공유 기법을 이용하여 제한된 하드웨어의 성능을 최대화합니다.&lt;/p&gt;
&lt;p&gt;P.S. 새 학기가 시작되었는데, 오히려 지난 첫 학기보다 더 험난한 시절을 보내고 있습니다. 요즘은 술 사준다고 연락하는 사람도 점점 뜸해지고&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GLib 테스트 프레임워크 사용하기</title>
      <link>/2010/02/12/2010-02-12-using-glib-test-framework/</link>
      <pubDate>Fri, 12 Feb 2010 00:00:00 +0000</pubDate>
      <guid>/2010/02/12/2010-02-12-using-glib-test-framework/</guid>
      <description>&lt;p&gt;GLib 라이브러리 2.16 버전부터 지원하는 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;테스트 프레임워크&lt;/a&gt;
는 C 언어용 
&lt;a href=&#34;http://en.wikipedia.org/wiki/Unit_testing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;유닛테스트&lt;/a&gt;
 도구입니다. 물론 많은 유닛 테스트 도구가 이미 존재하지만, GLib 라이브러리 기반 C 언어 프로그램이라면 굳이 다른 라이브러리를 사용하는 것보다는 이미 지원하는 훌륭한 도구를 사용하는게 더 좋겠지요. 참고로,
&lt;a href=&#34;http://www.gtk.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+&lt;/a&gt;
, 
&lt;a href=&#34;http://clutter-project.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Clutter&lt;/a&gt;
 등 같은 프로젝트도 이미 이 기능을 이용해 테스트 코드를 작성하고 있으므로 알아두면 도움이 됩니다. 모든게 그렇지만, 알고나면 별게 아니므로 기본 개념과 API 사용법만 충실히 이해하면 됩니다.&lt;/p&gt;
&lt;p&gt;**기본 개념 및 사용법
**&lt;/p&gt;
&lt;p&gt;유닛테스트 개념은 스몰토크, 자바, C++처럼 언어적으로 객체지향 개념을 지원하는 언어에서 시작했기 때문에 C 언어에 그대로 적용하기에는 조금 까다로운 점이 많습니다. 그래서 GLib 테스트 프레임워크는 유닛테스트에서 기본 개념과 테스트 실행 방식만 빌려옵니다. 우선 알아야하는 기본 개념은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트 케이스 (Test Case) : 가장 기본이 되는 하나의 테스트 단위입니다. GLib에서는 하나의 테스트 함수(function)가 이 역할을 합니다.&lt;/li&gt;
&lt;li&gt;픽스쳐 (Fixture) : 고정 설치된 물건이라는 뜻처럼, 테스트 케이스 실행 전후에 항상 실행하는 함수를 의미합니다. 실제로는, 테스트 함수를 실행하기 위해 필요한 환경을 미리 구축하거나(setup) 실행 후 리소스를 정리하는(teardown) 함수, 그리고 이와 함께 사용되는 사용자 데이터(data)로 구성됩니다. 참고로, GLib에서는 각 테스트간 의존성을 피하기 위해 모든 테스트 케이스를 실행할때마다 매번 픽스쳐를 새로 구성하는 방식(fresh fixture)을 사용합니다.&lt;/li&gt;
&lt;li&gt;테스트 슈트 (Test Suite) : 여러 테스트 케이스를 묶은 그룹입니다. 트리 구조처럼 테스트 슈트 여러개를 묶어 더 큰 테스트 슈트를 구성할 수도 있습니다. GLib에서는 테스트 경로(path)라는 개념으로 사용합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;개념은 조금 복잡한 것 같지만, 복잡하고 다양한 테스트 케이스를 그룹화하면 나중에 테스트 슈트별로 테스트를 진행할 수도 있는 등 많은 장점이 있습니다. 그리고 GLib이 제공하는 커맨드라인 도구를 이용하면 테스트 결과를 XML로 출력할 수도 있고, HTML 문서로 자동 변환할 수도 있는데 이 경우에도 테스트 슈트를 구성해 두면 많은 도움이 됩니다.&lt;/p&gt;
&lt;p&gt;물론 GLib은 정교하게 테스트 슈트와 테스트 케이스, 픽스쳐를 구성할 수 있는 많은 API를 제공하지만, 복잡한 과정을 API 호출 하나로 처리할 수 있는 기능도 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;g_test_add_func (&amp;quot;/onvif/nvc-connections&amp;quot;, test_onvif_nvc_connections);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 예제에서 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-add-func&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_add_func()&lt;/code&gt;&lt;/a&gt;
 함수는 &amp;ldquo;onvif&amp;rdquo; 테스트 슈트 밑에 &amp;ldquo;nvc-connections&amp;rdquo; 이름의 테스트 케이스를 추가합니다. 테스트시 실행할 함수는 사용자가 직접 구현한 &lt;code&gt;test_onvif_nvc_connections()&lt;/code&gt; 함수입니다. &lt;code&gt;g_test_add_func()&lt;/code&gt; 함수가 테스트 슈트를 자동으로 생성해 주기 때문에 별도의 추가 작업이 불필요합니다. 비슷한 기능의 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-add-data-func&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_add_data_func()&lt;/code&gt;&lt;/a&gt;
 함수는 테스트 함수에 데이터를 전달할 수 있어서, 한 함수로 데이터만 바꿔서 테스트하고자 할때 유용합니다. 하지만, 두 API는 픽스쳐를 지정할 수 없으므로, 픽스쳐를 사용하려면 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-add&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_add()&lt;/code&gt;&lt;/a&gt;
 함수를 이용해야 합니다.일단, 간단한 예제 코드를 보여드리면 다음과 같습니다. (&amp;quot;
&lt;a href=&#34;http://blogs.gnome.org/timj/2008/06/24/23062008-writing-unit-tests-with-glib/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Writing Unit Tests with GLib&lt;/a&gt;
&amp;rdquo; 글에서 발췌했습니다)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;glib.h&amp;gt;

static void
simple_test_case (void)
{
  /* a suitable test */
  g_assert (g_bit_storage (1) == 1);

  /* a test with verbose error message */
  g_assert_cmpint (g_bit_storage (1), ==, 1);
}

int
main (int argc, char **argv)
{
  /* initialize test program */
  g_test_init (&amp;amp;argc, &amp;amp;argv, NULL);

  /* hook up your test functions */
  g_test_add_func (&amp;quot;/Simple Test Case&amp;quot;, simple_test_case);

  /* run tests from the suite */
  return g_test_run ();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드를 &lt;code&gt;g-test-sample1.c&lt;/code&gt; 파일로 저장하고 컴파일 후 실행하면 다음과 같은 결과를 볼 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gcc -o g-test-sample1 g-test-sample1.c `pkg-config --cflags --libs glib-2.0`
$ ./g-test-sample1
/Simple Test Case: OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 결과를 재활용하기 위해 XML 형식으로 저장하거나, HTML 문서로 만들고 싶다면 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/gtester.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtester&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/gtester-report.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtester-report&lt;/a&gt;
 프로그램을 사용하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gtester -o sample-log.xml g-test-sample1
TEST: g-test-sample1... (pid=2771)
PASS: g-test-sample1
$ gtester-report sample-log.xml &amp;gt; sample-log.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같이 실행하여 생성한 HTML 문서 결과는 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/gtester-report-screenshot.png&#34; alt=&#34;&#34; title=&#34;gtester-report screenshot&#34;&gt;&lt;/p&gt;
&lt;p&gt;참고로, gtester 프로그램의 인수로 여러 테스트 실행 파일을 한꺼번에 전달하면 모든 테스트 실행 파일의 테스트 슈트가 하나의 결과로 통합됩니다.&lt;/p&gt;
&lt;p&gt;위 코드에서 사용한 테스트 코드를 보면 제일 먼저 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-init&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_init()&lt;/code&gt;&lt;/a&gt;
 함수가 나타납니다. 이 함수는 테스트 기능을 초기화하는데, 리퍼런스 매뉴얼을 보시면 프로그램 실행 인수를 통해 사용자가 여러 테스트 옵션을 지정할 수 있는 걸 알 수 있습니다. 물론 특정 테스트 슈트만 실행하게 하는 옵션도 인수로 지정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;테스트 함수를 보면 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-assert-cmpint&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_assert_cmpint()&lt;/code&gt;&lt;/a&gt;
라는 다소 생소한 API가 보이는데, GLib은 테스트 코드를 위해 이와 비슷한 매크로를 더 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define g_assert             (expr)
#define g_assert_not_reached ()
#define g_assert_cmpstr      (s1, cmp, s2)
#define g_assert_cmpint      (n1, cmp, n2)
#define g_assert_cmpuint     (n1, cmp, n2)
#define g_assert_cmphex      (n1, cmp, n2)
#define g_assert_cmpfloat    (n1,cmp,n2)
#define g_assert_no_error    (err)
#define g_assert_error       (err, dom, c)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 매크로를 사용하여 테스트 코드를 작성하면 더 친절하고 자세한 에러 메시지를 출력합니다. 예를 들어 다음 코드는,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;gchar *string = &amp;quot;foo&amp;quot;; g_assert_cmpstr (string, ==, &amp;quot;bar&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 메시지를 출력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ERROR: assertion failed (string == &amp;quot;bar&amp;quot;): (&amp;quot;foo&amp;quot; ==  &amp;quot;bar&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 기본적으로 실패한 경우에만 메시지를 보여줍니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그 외 더 많은&amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;지금까지 설명한 기본 기능 외에도 표준출력 / 표준에러 메시지를 표시하지 않도록 한 뒤 이 메시지에서 특정 문자열을 확인한다든가, 항상 동일한 패턴의 난수를 생성하여 이를 테스트에 이용하거나,  테스트에 시간이 얼마나 더 걸리는지 측정할 수도 있습니다. 프로그램을 종료시키는 치명적인 에러가 발생하는 경우도 테스트할 수 있고, 여러가지 테스트 모드(quick / slow / performace 등)를 두어 프로그램 인자를 이용해 원하는 테스트 코드만 실행할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;더 많은 활용 예제가 GLib 자체 테스트 코드에(
&lt;a href=&#34;http://git.gnome.org/browse/glib/tree/glib/tests/testing.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;glib/tests/testing.c&lt;/a&gt;
) 있으므로, 별로 길지 않으니, 직접 확인해 보시기 바랍니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로젝트에 활용하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MVP 개발 모델과 TDD + 유닛테스트 도구를 이용하여 응용 프로그램을 개발하면(
&lt;a href=&#34;/2008/12/17/presenter-first-development/&#34;&gt;Presenter First 개발&lt;/a&gt;
) 더 빠르고 쉽게 튼튼한 코드를 만들 수 있으니, 한 번 검토해 보시기 바랍니다. 개발자가 TDD 방법론을 주저하는 이유 중 하나가 테스트 코드까지 만들다 보니 늘어나는 코드량과 늘어나는 개발 시간 때문인데, 테스트 코드를 그대로 실제 코드로 재활용할 수 있다면 얘기가 달라지겠죠.&lt;/p&gt;
&lt;p&gt;프로젝트 일일빌드시 테스트 루틴도 동작하도록 한뒤 자동으로 테스트 결과를 웹사이트에 게재하는 것도 좋은 개발 습관입니다. 아예 코드 수정 후 저장소에 커밋하면 반드시 모든 테스트 케이스를 통과해야만 커밋되도록 저장소를 설정할 수도 있지만, 엄청난 서버 부하를 야기할 수 있으므로, 테스트 케이스를 통과한 코드만 커밋할 수 있도록 가이드라인을 규정하는 것도 좋습니다.&lt;/p&gt;
&lt;p&gt;유닛테스트는 특정 객체나 모듈의 모든 API가 항상 정상적으로 동작하는지를 검사하기 위해 사용합니다. 그래서 가장 기본적인 사용법은 공개 함수를 다양한 인수로 호출한 뒤 그 결과값을 확인하는 방식입니다. 하지만 실무에서는 그렇게 단순한(?) 버그만 존재하는게 아니라서, 특정 시나리오나 특정 조건을 만족할 경우에만 버그 현상이 재현되는 경우도 많습니다. 이러한 경우, 버그에 대한 테스트 케이스를 추가하고 이 케이스에 대한 테스트가 통과할때까지 디버깅을 합니다. 이렇게 해두면 동일한 버그가 나중에 재발하는 걸 방지할 수 있습니다. 대부분 회사에서는 버그(이슈)관리시스템을 사용하므로 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-bug&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_bug()&lt;/code&gt;&lt;/a&gt;
 API를 사용하면 편리합니다.&lt;/p&gt;
&lt;p&gt;참고로, GTK+ 라이브러리는 GLib 테스트 프레임워크를 기반으로 마우스 버튼 동작이나 키보드 입력을 에뮬레이션하는 기능처럼 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/gtk-Testing.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GUI 프로그램 테스트용 API&lt;/a&gt;
를 제공합니다. 더불어 
&lt;a href=&#34;http://en.wikipedia.org/wiki/Xvfb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Xvfb&lt;/a&gt;
 같은 더미 X서버를 이용하면 원격 터미널이나 cron 작업처럼 실제 X서버가 없는 환경에서도 GUI 프로그램 테스트 진행이 가능합니다. 꼭 GTK+ 프로그램이 아니더라도, 폰트 렌더링 루틴이 정확한 그래픽 비트맵을 생성하는지, 특정 항목을 선택하고 특정 행동을 취했을때 정상적으로 문자열이 표시되는지 등도 테스트 케이스로 작성할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;테스트 케이스 실행 방식 및 테스트 코드 위치&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;위 예제처럼 테스트 케이스를 특정 주제별로 나누어 각각의 실행파일로 만들어도 되지만, 테스트 케이스를 초기화하는 부분을 잘 정리하여 테스트 케이스를 여러 모듈로 분리한 뒤,  모든 테스트 케이스를 통째로 하나의 실행파일로 만들어도 됩니다. 이렇게 하면 추가적인 스크립트나 도구의 도움없이도 명령어 한번 실행으로 모든 테스트 케이스를 실행할 수 있기 때문에 더 편리할 수 있습니다. 또는 Clutter 프로젝트처럼 테스트 모듈을 각각 공유라이브러리로 만들어 플러그인처럼 로드해서 실행하는 방법도 있습니다.&lt;/p&gt;
&lt;p&gt;하지만, 위 방식은 모두 실제 코드와 테스트 코드가 서로 다른 파일에 존재하는 방식입니다. 테스트 코드가 실제 코드와 하나의 파일에 존재한다면 테스트 코드 작성이 더 일상화되고 자연스러워질 수 있습니다. 그러므로, 프로그램 실행 파일 크기가 별로 문제가 되지 않는다면, 또는 릴리스 / 디버그 모드를 분리하여 컴파일하도록 구성된 프로젝트라면,  프로그램에 특정 옵션을 주었을 경우에만 테스트 케이스 실행 모드로 동작하게 하면 됩니다. 물론 특정 테스트 프로그램은 예제로 사용하기 위해 분리할 수도 있겠지만, 모듈이나 객체의 고유 기능만 테스트하는 코드라면 같은 파일에 있는게 더 자연스러울 수 있습니다. 예를 들어 GObject 객체라면, 속성(properties) / 시그널(signal) 이름이 갑자기 변경되었을때 이를 참조하는 모듈이 문제를 일으키지 않도록 하기 위해, &amp;lsquo;validate-properties&amp;rsquo;, &amp;lsquo;validate-signals&amp;rsquo; 등의 테스트 케이스를 추가한뒤 통과하지 못했을 경우 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-message&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_message()&lt;/code&gt;&lt;/a&gt;
 등을 이용해 이를 참조하는 모듈을 찾아 수정하라는 강조 메시지를 표시하는 것도 가능합니다. 또한 특정 시그널이 정상적으로 발생하는지, 순서대로 발생하는지 확인할 수 있습니다. 그리고 무엇보다도, 같은 파일에 있으면 내부 자료구조에도 접근할 수 있으므로 내부 로직에 대한 테스트 코드를 작성하는 것도 가능해집니다.&lt;/p&gt;
&lt;p&gt;따라서 무조건 한 가지 방식만 고집하기보다, 적절하게 필요에 따라 알맞는 방식을 선택하는 것이 중요합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결론&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;뭐 다른 결론이 있을리 없을만큼 유닛 테스트와 리그레션 테스트(regression test) 등은 이미 소프트웨어 개발 분야 전반에 광범위하게 사용하고 있습니다. 다만, C 언어를 이용해 개발하는 경우 리거시(legacy) 코드가 너무 많거나, 마땅한 테스트 도구를 찾지 못했거나, 여러가지 이유로 도입하지 못하는 경우가 많은데, 함께 잘 극복하고 익숙해져서 더 좋은 방향으로 나아가야 하지 않을까&amp;hellip; 생각해 봅니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GLib 메인루프 이용하기</title>
      <link>/2009/09/21/2009-09-21-using-glib-mainloop/</link>
      <pubDate>Mon, 21 Sep 2009 00:00:00 +0000</pubDate>
      <guid>/2009/09/21/2009-09-21-using-glib-mainloop/</guid>
      <description>&lt;p&gt;GLib API를 이용한 멀티쓰레드 프로그래밍에서 비동기 메시지 큐를 이용하는 방법은 지난 
&lt;a href=&#34;/2008/08/06/glib-thread-programming/&#34;&gt;포스트&lt;/a&gt;
에서 설명한 적이 있는데, 이번에는 
&lt;a href=&#34;/2009/09/17/glib-mainloop-vs-libdispatch-of-apple-gcd/&#34;&gt;애플 GCD의 libdispatch와 비교되는 GLib의 메인루프&lt;/a&gt;
를 이용하는 방법을 정리해 보았습니다. 이 방법은 어떤 관점에서 보면 더 쉽고, 이미 많은 기능이 기본적으로 지원되기 때문에 몇몇 경우를 제외하면 더 좋은 방법입니다. 다만 API 사용법을 이해하기가 처음에 조금 까다롭다는 점이 걸림돌입니다.&lt;/p&gt;
&lt;p&gt;일반적으로 GLib / GTK 어플리케이션은 메인 쓰레드에서 실행되는 메인 이벤트 루프 기반에서 동작합니다. 키보드 / 마우스 이벤트 처리, 화면 표시, 사용자가 등록한 Idle / Timeout 함수 처리 등이 모두 이 메인 이벤트 루프에서 처리됩니다. 그런데 이 메인 이벤트 루프라는 건 마냥 개념적인게 아니라, 실제로 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-The-Main-Event-Loop.html#GMainLoop&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GMainLoop&lt;/a&gt;
 객체를 기반으로 동작합니다. 그런데 &lt;code&gt;g_main_loop_*()&lt;/code&gt; 계열 함수를 살펴보면 몇 개 안됩니다. 루프 객체를 생성하고, 참조하고, 해제하고, 돌리고[&lt;code&gt;g_main_loop_run()]&lt;/code&gt;, 종료하고[&lt;code&gt;g_main_loop_quit()]&lt;/code&gt;, 돌아가는 중인지 확인하기 등의 함수만 있습니다. 아, 하나 더 있군요. 객체를 생성할때 전달하는 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-The-Main-Event-Loop.html#GMainContext&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GMainContext&lt;/a&gt;
 객체를 얻어오는 함수[&lt;code&gt;g_main_loop_get_context()]&lt;/code&gt;가 있군요.&lt;/p&gt;
&lt;p&gt;모든 GMainLoop는 하나의 GMainContext와 함께 사용됩니다. GMainContext 객체는 실행할 소스[
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-The-Main-Event-Loop.html#GSource&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GSource&lt;/a&gt;
] 목록을 관리합니다. 소스는 파일, 파이프, 소켓 등의 디스크립터를 기반으로 한 이벤트 소스일 수도 있고, Idle / Timeout 등과 같은 시간 소스일 수도 있습니다. 컨텍스트는 실행 소스 각각을 검사해서 원하는 이벤트가 발생했는지, 아니면 실행할 시간이 되었는지를 판단해 등록한 콜백함수를 호출합니다. 참고로, 메인 쓰레드에서 동작하기 위한 컨텍스트[&lt;code&gt;g_main_context_default()&lt;/code&gt;]는 기본적으로 제공합니다. 이 기본 컨텍스트는 &lt;code&gt;gtk_main()&lt;/code&gt; 함수가 사용하는 것은 물론, &lt;code&gt;g_idle_add()&lt;/code&gt;, &lt;code&gt;g_timeout_add()&lt;/code&gt; 등과 같은 함수도 이 기본 컨텍스트를 사용합니다.&lt;/p&gt;
&lt;p&gt;아무튼 조금 더 구체적이고 자세한 내용은 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-The-Main-Event-Loop.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;공식 문서&lt;/a&gt;
를 참고하시고, 이제 이를 이용한 멀티쓰레드 프로그래밍을 해보겠습니다. 말이 길었으니 코드를 먼저 보여드리겠습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;glib.h&amp;gt;

static GThread *my_thread;
static GMainLoop *my_loop;

static void
add_idle_to_my_thread (GSourceFunc    func,
                       gpointer       data)
{
  GSource *src;

  src = g_idle_source_new ();
  g_source_set_callback (src, func, data, NULL);
  g_source_attach (src,
                   g_main_loop_get_context (my_loop));
  g_source_unref (src);
}

static void
add_timeout_to_my_thread (guint          interval,
                          GSourceFunc    func,
                          gpointer       data)
{
  GSource *src;

  src = g_timeout_source_new (interval);
  g_source_set_callback (src, func, data, NULL);
  g_source_attach (src,
                   g_main_loop_get_context (my_loop));
  g_source_unref (src);
}

static gpointer
loop_func (gpointer data)
{
  GMainLoop *loop = data;

  g_main_loop_run (loop);

  return NULL;
}

static void
start_my_thread (void)
{
  GMainContext *context;

  context = g_main_context_new ();
  my_loop = g_main_loop_new (context, FALSE);
  g_main_context_unref (context);

  my_thread = g_thread_create (loop_func, my_loop, TRUE, NULL);
}

static void
stop_my_thread (void)
{
  g_main_loop_quit (my_loop);
  g_thread_join (my_thread);
  g_main_loop_unref (my_loop);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;함수 먼저 설명하면, &lt;code&gt;start_my_thread()&lt;/code&gt; 함수는 쓰레드를 시작하고, &lt;code&gt;stop_my_thread()&lt;/code&gt; 함수는 쓰레드를 중지합니다. &lt;code&gt;add_idle_to_my_thread()&lt;/code&gt; 함수는 바로 실행되는 Idle 콜백 함수를 추가하고, &lt;code&gt;add_timeout_to_my_thread()&lt;/code&gt; 함수는 주기적으로 실행되는 Timeout 콜백 함수를 추가합니다. 마지막 두 함수의 인수는 &lt;code&gt;g_idle_add()&lt;/code&gt;, &lt;code&gt;g_timeout_add()&lt;/code&gt; 함수와 각각 동일합니다. 따라서, 콜백 함수가 &lt;code&gt;TRUE&lt;/code&gt;를 리턴하면 자동으로 반복해서 계속 실행되고, &lt;code&gt;FALSE&lt;/code&gt;를 리턴하면 한번만 실행되고 종료합니다.&lt;/p&gt;
&lt;p&gt;위 코드의 핵심은 GMainContext 객체를 만들고 이를 기반으로 GMainLoop 객체를 만든 뒤 별도 쓰레드에서 실행하도록 하는 부분입니다. 그리고, 필요한 모든 작업은 Idle / Timeout 소스 객체를 만들어 컨텍스트에 추가(attach)해서 동작하도록 하는 겁니다. 참고로, 관련 API는 모두 쓰레드에 안전합니다.&lt;/p&gt;
&lt;p&gt;물론 위 함수를 조금 더 확장하면 콜백함수가 종료될때 자동으로 호출되는 notify 함수도 등록할 수 있고, 우선순위도 조절할 수 있습니다. 또한 여러 쓰레드를 종류별로 만들어 필요한 쓰레드에게 해당 작업만 전달해도 됩니다. 하지만 그 정도는 응용하는데 별로 어려움이 없을 거라 생각하고 한가지만 더 설명하겠습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 네트워크 소켓(socket)을 하나 만들고 이 소켓에 읽을 데이터가 도착했을 경우에만 호출되는 함수를 등록하고 싶은 경우, 다음과 같은 코드를 사용하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static gboolean
socket_read (GIOChannel  *source,
             GIOCondition condition,
             gpointer data)
{
  /* Use g_io_channel_read_chars() to read data... */

  return TRUE;
}

static void
add_socket_to_my_thread (gint sock_fd)
{
  GIOChannel *channel;
  GSource *src;

  channel = g_io_channel_unix_new (sock_fd);
  src = g_io_create_watch (channel, G_IO_IN);
  g_source_set_callback (src,
                         (GSourceFunc) read_socket,
                         NULL,
                         NULL);
  g_source_attach (src,
                   g_main_loop_get_context (my_loop));
  g_source_unref (src);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;자세한 내용은 위 코드와 비슷하지만 기본 메인 이벤트 루프에서 동작하도록 하는 &lt;code&gt;g_io_add_watch()&lt;/code&gt; API 설명 부분을 참고하시기 바랍니다. 어쨌든, 기본적으로 GMainContext 객체는 유닉스 시스템의 폴링(polling) 메카니즘을 사용하기 때문에 이론적으로는 거의 모든 파일 디스크립터를 사용할 수 있습니다. 물론 비슷한 방식으로 윈도우 운영체제에서 이벤트 핸들이나 소켓 핸들도 사용할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;글머리에서 적은 것처럼 비동기 메시지 큐를 이용하는 방식보다 아주 약간의 오버헤드는 있겠지만, 훨씬 더 많은 기능을 제공하는 것 같지 않나요?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GLib 메인루프와 애플 GCD의 libdispatch</title>
      <link>/2009/09/17/2009-09-17-glib-mainloop-vs-libdispatch-of-apple-gcd/</link>
      <pubDate>Thu, 17 Sep 2009 00:00:00 +0000</pubDate>
      <guid>/2009/09/17/2009-09-17-glib-mainloop-vs-libdispatch-of-apple-gcd/</guid>
      <description>&lt;p&gt;GTK 메일링 리스트에 
&lt;a href=&#34;http://mail.gnome.org/archives/gtk-devel-list/2009-September/msg00036.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;흥미있는 포스트&lt;/a&gt;
가 있어서 정리해 봅니다.&lt;/p&gt;
&lt;p&gt;스노우 레오파드 출시와 더불어 오픈 소스로 공개되면서 요즘 한창 이슈가 되고 있는 애플의 
&lt;a href=&#34;http://arstechnica.com/open-source/news/2009/09/apple-opens-gcd-challenges-impede-adoption-on-linux.ars&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GCD(Grand Central Dispatch)&lt;/a&gt;
의 일부인 
&lt;a href=&#34;http://libdispatch.macosforge.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libdispatch&lt;/a&gt;
 라이브러리와 GLib 메인루프를 비교한 내용인데, 정리해 보면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;libdispatch는 세 종류의 실행 큐를 제공하는데 다음과 같습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span style=&#34;background-color:#ffffff;&#34;&gt;메인 큐(main queue) : GLib의 메인 이벤트 루프와 동일&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;background-color:#ffffff;&#34;&gt;전역 큐(global queue) : 쓰레드풀(thread pool) 방식으로 동작하며 모든 작업(job)은 이 큐로 보내진 다음 임의의 쓰레드에서 비동기(asynchronously) 실행됩니다&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span style=&#34;background-color:#ffffff;&#34;&gt;개인 큐(private queue) : 이 큐의 작업은 순서대로 실행됩니다.&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;개인 큐와 메인 큐는 전역 큐의 쓰레드로 동작하는데, 이 방식은 GLib에서 GSource(g_idle / g_timeout / etc) 콜백함수를  다른 쓰레드에서 처리하게 위해 GMainLoop + GThreadPool 조합을 사용하는 것보다 사용자에게 더 편한 것 같습니다. 물론 libdispatch는 GCC를 확장한 블럭(blocks)이라는 문법을 이용하므로 사용하려면 GCC 패치가 필요합니다. 참고로, 블럭(blocks)은 함수형 언어나 스크립트 언어에서 지원되는 일종의 익명(anonymous) 함수인데, GLib의 GClosure와 비슷한 역할을 합니다. 예를 들어 C 언어에서는 특정 이벤트나 시그널이 발생할때 처리를 하려면 함수를 정의하고 이 함수를 콜백함수로 등록해야 하는데, 블럭(blocks)을 사용하면 함수를 따로 정의하지 않고 코드 블럭을 직접 시그널에 연결할 수 있는 셈입니다.&lt;/p&gt;
&lt;p&gt;그런데 이 포스트에 달린 댓글을 보면 GLib을 이용해 GCD와 비슷한 역할을 하는 라이브러리인 
&lt;a href=&#34;http://git.dronelabs.com/iris&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;iris&lt;/a&gt;
와 
&lt;a href=&#34;http://git.dronelabs.com/catalina&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;catalina&lt;/a&gt;
 라이브러리도 소개하고 있군요. 어쩌면  얼마 안있어 GCD를 참고한 라이브러리나 혹은 새로운 GLib API가 추가될 지도 모른다고 예측해 봅니다. 워낙 오픈소스 쪽은 부지런한 사람이 많아서 말이죠&amp;hellip; :)&lt;/p&gt;
&lt;p&gt;얼마전에는, 작은 웹서버를 띄우고 웹페이지에서 실행중인 GTK 어플리케이션의 모든 GObject 객체를 보여주는 것은 물론 바로 객체 속성도 수정할 수 있는 
&lt;a href=&#34;http://mail.gnome.org/archives/gtk-list/2009-September/msg00044.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtkwebd 유틸리티가 소개&lt;/a&gt;
되었고, 구글 어스나 나사의 월드윈드처럼 3차원으로 지구 지도를 보여주도록 도와주는 
&lt;a href=&#34;http://mail.gnome.org/archives/gtk-list/2009-September/msg00050.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AWether 라이브러리도 공개&lt;/a&gt;
되었습니다. 물론 
&lt;a href=&#34;/2009/02/03/location-aware-softwares-in-linux/&#34;&gt;이전 포스트&lt;/a&gt;
에서 다룬 
&lt;a href=&#34;http://projects.gnome.org/libchamplain/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libchamplain&lt;/a&gt;
 라이브러리에 더 관심이 많아 그다지 흥미롭지는 않았는데, 모르고 있던 
&lt;a href=&#34;http://earthobservatory.nasa.gov/Features/BlueMarble/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Blue Marble NG&lt;/a&gt;
, 
&lt;a href=&#34;http://topex.ucsd.edu/WWW_html/srtm30_plus.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;SRTM 30 Plus&lt;/a&gt;
 등과 같은 무료 지도 데이터 정보를 알 수 있게 되어 고마울 따름입니다.&lt;/p&gt;
&lt;p&gt;아무튼 이쪽 세상은 끊임없이 상용 코드를 벤치마킹하고 모방하면서 조금씩 계속 진화하고 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (4)</title>
      <link>/2009/08/24/2009-08-24-oop-with-gobject-4/</link>
      <pubDate>Mon, 24 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/24/2009-08-24-oop-with-gobject-4/</guid>
      <description>&lt;p&gt;이전 글에 계속 이어집니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;객체 속성 정보 얻기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EdcHost 객체의 속성 정보를 실행 중에 얻어볼까 합니다.&lt;/p&gt;
&lt;p&gt;왜 또 갑자기 불필요한 예제를 꺼내냐고 물어보실 분이 있을 것 같아 말하자면, 가끔 요긴한 경우가 있기 때문입니다. 예를 들어 EdcHost 객체를 상속받은 EdcHostDoosan, EdcHostKia, EdcHostLitte 객체가 여러 개 존재할 경우, 이 객체들은 EdcHost의 공통 속성 뿐 아니라 본인의 속성도 따로 가집니다. 이러한 여러 객체를 관리할때, 특정 속성이 있는지 여부를 검사해서 관련 UI를 활성 / 비활성하거나, 편집 UI 자체를 속성 스펙과 목록을 이용해 100% 자동화하는 게 가능합니다. (Glade 처럼 말이죠) 물론 옵션 같은 플래그(flags) 변수를 정의하는 방법 등 여러가지 대안이 가능하겠지만, 최초 객체 설계시 고려하지 못했던 기능이나 속성을 나중에 계속 추가해 나가야 하는 경우 기존에 만든 객체를 매번 다시 수정하고 업그레이드하는 것보다 더 안전하고 깔끔한 방법이 될 수 있습니다. 그리고 당연히 더많은 응용이 있겠지만, 일단 알아두면 나중에 어떤 식으로든 도움이 되리라 생각합니다.&lt;/p&gt;
&lt;p&gt;일단, 다음 코드는 객체가 가지고 있는 속성 이름과 각 속성의 현재 값을 출력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void
print_properties (GObject *object)
{
  GObjectClass *oclass;
  GParamSpec **specs;
  guint n;
  guint i;

  oclass = G_OBJECT_GET_CLASS (object);
  specs = g_object_class_list_properties (oclass, &amp;amp;n);
  for (i = 0; i &amp;lt; n; i++)
    {
      GParamSpec *spec;
      GValue value = { 0 };
      gchar *str;

      spec = specs[i];

      g_value_init (&amp;amp;value, spec-&amp;gt;value_type);
      g_object_get_property (G_OBJECT (object),
                             spec-&amp;gt;name,
                             &amp;amp;value);
      str = g_strdup_value_contents (&amp;amp;value);

      g_print (&amp;quot;property &#39;%s&#39; is &#39;%s&#39;n&amp;quot;,
               spec-&amp;gt;name,
               str);

      g_value_unset (&amp;amp;value);
      g_free (str);
    }
  g_free (specs);
}

{
  EdcHost *host;

  /* ... */ 

  host = g_object_new (
           EDC_TYPE_HOST,
           &amp;quot;address&amp;quot;, &amp;quot;demo.emstone.com&amp;quot;,
           &amp;quot;port&amp;quot;, 8081,
           NULL);
  print_properties (G_OBJECT (host));
  g_object_unref (host);

  /* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드에서 분명하게 이해해야 하는 점은, 객체 인스턴스가 아닌 객체 클래스에게 속성 정보를 질의한다는 점입니다. 모든 속성의 스펙을 얻기 위해 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-list-properties&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_list_properties()&lt;/code&gt;&lt;/a&gt;
 함수를 사용하고, GValue 객체에 속성 값을 가져온 다음, 문자열로 출력하기 위해 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Generic-values.html#g-strdup-value-contents&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_strdup_value_contents()&lt;/code&gt;&lt;/a&gt;
 함수를 이용해 변환하고 있습니다.&lt;/p&gt;
&lt;p&gt;객체에 어떤 속성이 있는지 알아보려면 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-find-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_find_property()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;속성 변경 알림 시그널 이용하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;객체의 속성 값을 변경할 때 &lt;code&gt;g_object_set()&lt;/code&gt; 함수를 이용하면 좋은 점은, 값을 변경하면 자동으로 시그널(signal)이 발생한다는 점입니다. GObject 시스템에서 시그널은 특정 사건(event)이 일어나면 발생(emit)합니다. 대부분의 경우 시그널은 객체 클래스 초기화시에 정의해야 하지만, 다행히도 속성 값이 변경될때 발생하는 시그널은 특별한 작업을 해주지 않아도 기본적으로 동작합니다. 따라서 &amp;ldquo;&lt;code&gt;notify::property-name&lt;/code&gt;&amp;rdquo; 형식의 이름을 가지는 시그널에 콜백 함수를 연결하면 객체 값이 변경될때 자동으로 호출되는 함수를 등록할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void
property_notified (GObject    *object,
                   GParamSpec *pspec,
                   gpointer    data)
{
  GValue value = { 0 };
  gchar *str;

  g_value_init (&amp;amp;value, pspec-&amp;gt;value_type);
  g_object_get_property (object, pspec-&amp;gt;name, &amp;amp;value);
  str = g_strdup_value_contents (&amp;amp;value);

  g_print (&amp;quot;property &#39;%s&#39; is set to &#39;%s&#39;n&amp;quot;,
             pspec-&amp;gt;name, str);

  g_value_unset (&amp;amp;value);
  g_free (str);
}

{
  EdcHost *host;

  host = g_object_new (EDC_TYPE_HOST, NULL);

  g_signal_connect (host,
                    &amp;quot;notify::address&amp;quot;,
                    G_CALLBACK (property_notified),
                    NULL);
  g_signal_connect (host,
                    &amp;quot;notify::port&amp;quot;,
                    G_CALLBACK (property_notified),
                    NULL);

  g_object_set (host,
                &amp;quot;address&amp;quot;, &amp;quot;192.168.0.1&amp;quot;,
                &amp;quot;port&amp;quot;, 8087,
                NULL);

  edc_host_set_address (host, &amp;quot;192.168.0.22&amp;quot;);

  g_object_unref (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 이 기능은, 디자인 패턴에서 말하는 관찰자(observer) 패턴일 수도 있고, GObject 매뉴얼에서 사용하는 것처럼 일종의 메시징 시스템 역할도 합니다. 예를 들어 모델(model)의 값이 변경되면 자동으로 뷰(view) 역할을 하는 GUI에 반영하는 코드를 작성할 경우 기존 객체 구현 코드를 수정하지 않고, 다시 말해 의존성을 추가하지 않고 기능을 구현할 수 있게 도와주어 객체간 결합도를 없애 줍니다.&lt;/p&gt;
&lt;p&gt;자 그런데, 위 예제에서 &lt;code&gt;edc_host_set_address()&lt;/code&gt; 를 사용할 때는 콜백함수가 호출이 안되는 문제점이 있습니다. 왜냐하면 이 함수는 내부 address 변수를 직접 수정하기 때문에 값이 변경되었는지 여부를 GObject 시스템이 알 방법이 없기 때문입니다. 따라서 기존 코드를 수정해야 하는데, 첫번째 방법은 접근자를 이용하더라도 내부적으로 &lt;code&gt;g_object_set()&lt;/code&gt; 을 호출하도록 하는 겁니다. (여기서는 &amp;lsquo;address&amp;rsquo; 관련 API만 보여드립니다)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void
edc_host_set_address (EdcHost     *host,
                      const gchar *address)
{
  g_return_if_fail (EDC_IS_HOST (host));
  g_return_if_fail (address != NULL);

  g_object_set (host,
                &amp;quot;address&amp;quot;,  address,
                NULL);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 이 방법은 약간의 오버헤드가 있을 수 있습니다. 두번째 방법은, 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-notify&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_notify()&lt;/code&gt;&lt;/a&gt;
 함수를 이용해 직접 알려주는 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void
edc_host_set_address (EdcHost     *host,
                      const gchar *address)
{
  EdcHostPrivate *priv;

  g_return_if_fail (EDC_IS_HOST (host));
  g_return_if_fail (address != NULL);

  priv = EDC_HOST_GET_PRIVATE (host);

  g_free (priv-&amp;gt;address);
  priv-&amp;gt;address = g_strdup (address);

  g_object_notify (G_OBJECT (host), &amp;quot;address&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;edc_host_set_property()&lt;/code&gt; 함수 안에서 중복되는 코드도 정리해 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void
edc_host_set_property (GObject      *object,
                       guint         property_id,
                       const GValue *value,
                       GParamSpec   *pspec)
{
  EdcHost *host = EDC_HOST (object);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  switch (property_id)
    {
    case EDC_HOST_PROP_NAME:
      edc_host_set_name (host, g_value_get_string (value));
      break;
    case EDC_HOST_PROP_ADDRESS:
      edc_host_set_address (host, g_value_get_string (value));
      break;
    case EDC_HOST_PROP_PORT:
      edc_host_set_port (host, g_value_get_int (value));
      break;
    case EDC_HOST_PROP_USER:
      edc_host_set_user (host, g_value_get_string (value));
      break;
    case EDC_HOST_PROP_PASSWORD:
      edc_host_set_password (host, g_value_get_string (value));
      break;
    default:
      /* We don&#39;t have any other property... */
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object,
                                         property_id,
                                         pspec);
      break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;시그널이 중복 발생할 경우를 염려할 필요는 없습니다. 시그널은 GObject 내부적으로 알아서 잘 정리되어 한 번 변경하면 한 번만 시그널이 발생합니다.&lt;/p&gt;
&lt;p&gt;오늘은 여기까지입니다&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (3)</title>
      <link>/2009/08/18/2009-08-18-oop-with-gobject-3/</link>
      <pubDate>Tue, 18 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/18/2009-08-18-oop-with-gobject-3/</guid>
      <description>&lt;p&gt;이 글은 회사 개발팀 내부 세미나를 위해 작성중인 글입니다. 하지만, 블로그란 매체의 특성상 외부에도 공개되고 있는데, 댓글은 달지 않아도 접속하는 사람들 대부분이 제가 아는 분일 거라 생각하고 한마디 하자면, 세상에 공짜가 어디 있는가, 주저하지 말고 내게 연락해서 술 한 잔 사게! (언젠가부터 술 강요 청탁 협박 블로그가 되어 가고 있군&amp;hellip;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;속성 (Properties) 추가하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이제, GObject 속성(properties) 기능을 추가하려고 하는데, 왜 쓸데없이 일을 만들어서 하냐고 물으면 할 말이 있어야할 것 같아서, GObject 속성의 특징을 요약해 봤습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;단일 API로 모든 속성 값을 얻어오거나 변경하기&lt;/li&gt;
&lt;li&gt;속성 변경시 자동으로 호출되는 함수 등록하기 (시그널 이용)&lt;/li&gt;
&lt;li&gt;실행 중에 속성에 대한 정보 얻어내기&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;물론 이미 많은 언어와 라이브러리가 그 이상의 기능을 지원하기도 하고, 일정 능력 이상의 개발자라면 직접 구현하는게 아주 어려운 것도 아닙니다. 하지만 이미 잘 구현되어 검증받은 라이브러리가 있는데 굳이 새로운 바퀴를 만들 필요는 없겠지요? 아무튼, 정확한 내용은 글을 적으면서 하나씩 설명해 나가겠습니다.&lt;/p&gt;
&lt;p&gt;GObject 객체에 속성을 추가하려면 속성의 값(value)이 어떤 형(type)인지, 이름이 무엇인지, 값의 범위는 어떻게 되는지, 기본값은 무엇인지 등을 정의해서 알려주어야 합니다. (C++이나 Java에서 클래스 멤버 변수를 정의하는 것과 비슷합니다) 이러한 정보를 줄임말로 스펙(spec.)이라고 한다면, 속성을 추가한다는 건 다른 말로, 스펙으로 명시한 속성 정보를 클래스에 설치(install)하는 것을 의미합니다. 객체 인스턴스마다 속성의 실제 값(value)은 모두 다르겠지만, 어떤 속성이 있는지 그 속성은 어떻게 구성되어는지는 모두 동일하겠지요. (참고로 GObject 관련 API를 훑어보시면 정확히 모르더라도 지금 언급한 개념의 단어로 이루어진 API가 꽤 많은 걸 아시게 될 겁니다) 그렇기 때문에, 속성을 추가하는 작업은 클래스 초기화 함수에서 이루어집니다.&lt;/p&gt;
&lt;p&gt;다음은 기존 예제에서 속성을 추가한 코드입니다. (변경된 부분만 보여드립니다)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* ...[snip]... */

enum
{
  EDC_HOST_PROP_0, /* ignore */
  EDC_HOST_PROP_NAME,
  EDC_HOST_PROP_ADDRESS,
  EDC_HOST_PROP_PORT,
  EDC_HOST_PROP_USER,
  EDC_HOST_PROP_PASSWORD
};

/* ...[snip]... */

static void
edc_host_get_property (GObject    *object,
                       guint       property_id,
                       GValue     *value,
                       GParamSpec *pspec)
{
  EdcHost *host = EDC_HOST (object);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  switch (property_id)
    {
    case EDC_HOST_PROP_NAME:
      g_value_set_string (value, priv-&amp;gt;name);
      break;
    case EDC_HOST_PROP_ADDRESS:
      g_value_set_string (value, priv-&amp;gt;address);
      break;
    case EDC_HOST_PROP_PORT:
      g_value_set_int (value, priv-&amp;gt;port);
      break;
    case EDC_HOST_PROP_USER:
      g_value_set_string (value, priv-&amp;gt;user);
      break;
    case EDC_HOST_PROP_PASSWORD:
      g_value_set_string (value, priv-&amp;gt;password);
      break;
    default:
      /* We don&#39;t have any other property... */
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object,
                                         property_id,
                                         pspec);
      break;
    }
}

static void
edc_host_set_property (GObject      *object,
                       guint         property_id,
                       const GValue *value,
                       GParamSpec   *pspec)
{
  EdcHost *host = EDC_HOST (object);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  switch (property_id)
    {
    case EDC_HOST_PROP_NAME:
      g_free (priv-&amp;gt;name);
      priv-&amp;gt;name = g_value_dup_string (value);
      break;
    case EDC_HOST_PROP_ADDRESS:
      g_free (priv-&amp;gt;address);
      priv-&amp;gt;address = g_value_dup_string (value);
      break;
    case EDC_HOST_PROP_PORT:
      priv-&amp;gt;port = g_value_get_int (value);
      break;
    case EDC_HOST_PROP_USER:
      g_free (priv-&amp;gt;user);
      priv-&amp;gt;user = g_value_dup_string (value);
      break;
    case EDC_HOST_PROP_PASSWORD:
      g_free (priv-&amp;gt;password);
      priv-&amp;gt;password = g_value_dup_string (value);
      break;
    default:
      /* We don&#39;t have any other property... */
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object,
                                         property_id,
                                         pspec);
      break;
    }
}

/* ...[snip]... */

/* class initializer */
static void
edc_host_class_init (EdcHostClass *klass)
{
  GObjectClass *gobj_class;
  GParamSpec *pspec;

  gobj_class = G_OBJECT_CLASS (klass);
  gobj_class-&amp;gt;finalize = edc_host_finalize;
  gobj_class-&amp;gt;set_property = edc_host_set_property;
  gobj_class-&amp;gt;get_property = edc_host_get_property;

  g_type_class_add_private (gobj_class,
                            sizeof (EdcHostPrivate));

  pspec =
    g_param_spec_string (&amp;quot;name&amp;quot;,               /* name */
                         &amp;quot;Name&amp;quot;,               /* nick */
                         &amp;quot;the name of a host&amp;quot;, /* blurb */
                         &amp;quot;&amp;quot;,                   /* default */
                         G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_NAME,
                                   pspec);

  pspec = g_param_spec_string (&amp;quot;address&amp;quot;,
                               &amp;quot;Address&amp;quot;,
                               &amp;quot;the address of a host&amp;quot;,
                               &amp;quot;&amp;quot;,
                               G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_ADDRESS,
                                   pspec);

  pspec = g_param_spec_int (&amp;quot;port&amp;quot;,
                            &amp;quot;Port&amp;quot;,
                            &amp;quot;the port number of a host&amp;quot;,
                            0,     /* minimum */
                            65535, /* maximum */
                            0,     /* default */
                            G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_PORT,
                                   pspec);

  pspec = g_param_spec_string (&amp;quot;user&amp;quot;,
                               &amp;quot;User&amp;quot;,
                               &amp;quot;password for authetication&amp;quot;,
                               &amp;quot;&amp;quot;,
                               G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_USER,
                                   pspec);

  pspec = g_param_spec_string (&amp;quot;password&amp;quot;,
                               &amp;quot;Password&amp;quot;,
                               &amp;quot;password for authetication&amp;quot;,
                               &amp;quot;&amp;quot;,
                               G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_PASSWORD,
                                   pspec);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제일 먼저 정의된 열거형 타입에 대해 설명하자면, 클래스 내부에서 속성은 정수형 숫자로 관리됩니다. 예를 들어 1번 속성, 3번 속성처럼 직접 정수형을 사용해도 되지만, 관례적으로 가독성을 위해 열거형으로 정의합니다. 이렇게 정의한 번호를 클래스에 속성을 설치할때 지정하면 [
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-install-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_install_property()&lt;/code&gt;&lt;/a&gt;
],  &lt;code&gt;edc_host_{get/set}_property() &lt;/code&gt;속성 읽기 / 쓰기 함수의 인자로 `&lt;code&gt;property_id&lt;/code&gt;&#39;가 전달되는데, 이 ID가 바로 속성 번호입니다. 물론 속성 번호는 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-override-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_override_property()&lt;/code&gt;&lt;/a&gt;
 같은 다른 API에서도 사용합니다.[](&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-override-property&#34;&gt;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-override-property&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edc_host_class_init()&lt;/code&gt; 클래스  초기화 함수를 보면, 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_param_spec_*()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하여 각 속성의 스펙을 정의해서 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-install-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_install_property()&lt;/code&gt;&lt;/a&gt;
함수를 이용해 클래스 객체에 설치합니다. 그리고,속성 읽기 /쓰기 메쏘드를 재정의합니다. 참고로 API 문서를 확인하시면, 다양한 형(type)을 위한 스펙 정의 함수가 있는 걸 알 수 있습니다. 속성 스펙을 정의할때 마지막에 넣어주는 플래그(flags)는 속성의 특성을 정의하는데, 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-GParamSpec.html#GParamFlags&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GParamFlags&lt;/a&gt;
 설명을 한 번 읽어보시면 어렵지 않게 이해할 수 있습니다. 여기서는 모든 속성을 읽고 쓰기 가능하게 했습니다.&lt;/p&gt;
&lt;p&gt;재정의된 &lt;code&gt;edc_host_{get/set}_property() &lt;/code&gt;속성 읽기 / 쓰기 메쏘드 함수를 보면, 접근자(accessor) 함수와 동일한 작업을 합니다. 다른 점이라면 속성 ID에 따라 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Generic-values.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GValue&lt;/a&gt;
 객체에서 값을 읽거나, 값을 할당한다는 점입니다. GValue 객체는 쉽게 말해 어떤 형(type)의 값이라도 담을 수 있는 일반적인 값(generic values)입니다. 참고로 이 역시 다양한 형(type)을 위한 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_value_{set,get}_*()&lt;/code&gt;&lt;/a&gt;
 형태의 함수가 존재하므로 이를 그대로 이용하면 됩니다. (물론 더 능숙하게 사용하려면 API 문서를 한 번 훑어보는게 좋겠지요)&lt;/p&gt;
&lt;p&gt;여기까지 이해하셨다면 아시겠지만, GObject 시스템은 속성에 전반적인 틀과 관리 체계만 제공할 뿐 실제 속성을 다루는 작업은 대부분 직접 구현해야 합니다. 이는 프로그래머의 자유도를 높여 주기도 하지만, 불필요한 반복 작업을 유발하기도 합니다. 그리고 이 때문에 
&lt;a href=&#34;http://live.gnome.org/Vala&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vala&lt;/a&gt;
 같은 GObject 기반 언어가 새로 만들어지기도 했습니다.&lt;/p&gt;
&lt;p&gt;**속성 (Properties) 사용하기
**&lt;/p&gt;
&lt;p&gt;이렇게 정의한 속성을 객체 외부에서 사용하기 위해 몇 가지 방법이 있지만, 가장 쉽고 많이 사용하는 방법은 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-get&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_get()&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_set()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하는 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  EdcHost *host;
  gchar *address;
  gint port;

  g_type_init ();

  host = edc_host_new ();

  g_object_set (host,
                &amp;quot;address&amp;quot;, &amp;quot;192.168.0.100&amp;quot;,
                &amp;quot;port&amp;quot;, 8080,
                NULL);

  address = edc_host_get_address (host);
  g_assert_cmpstr (address, ==, &amp;quot;192.168.0.100&amp;quot;);
  g_free (address);

  g_object_get (host,
                &amp;quot;address&amp;quot;, &amp;amp;address,
                &amp;quot;port&amp;quot;, &amp;amp;port,
                NULL);

  g_assert_cmpstr (address, ==, &amp;quot;192.168.0.100&amp;quot;);
  g_assert_cmpint (port, ==, 8080);
  g_free (address);
  
  g_object_unref (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_new()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하여 객체를 생성할때 아예 속성을 함께 지정할 수도 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  EdcHost *host;
  gchar *address;
  gint port;

  g_type_init ();

  host = g_object_new (EDC_TYPE_HOST,
                       &amp;quot;address&amp;quot;, &amp;quot;demo.emstone.com&amp;quot;,
                       &amp;quot;port&amp;quot;, 8081,
                       NULL);
  g_object_get (host,
                &amp;quot;address&amp;quot;, &amp;amp;address,
                &amp;quot;port&amp;quot;, &amp;amp;port,
                NULL);
  g_assert_cmpstr (address, ==, &amp;quot;demo.emstone.com&amp;quot;);
  g_assert_cmpint (port, ==, 8081);
  g_free (address);

  g_object_unref (host);  

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;눈여겨 보신 분은 아시겠지만, &lt;code&gt;edc_host_new()&lt;/code&gt; 함수는 &lt;code&gt;g_object_new (EDC_TYPE_HOST, NULL)&lt;/code&gt; 호출로 만들어진 객체를 돌려주는 역할만 합니다.&lt;/p&gt;
&lt;p&gt;이렇게 대략 GObject 속성 기본 사용법을 설명한 것 같습니다. 물론 이 예제 코드에는 몇 가지 오류가 남아있는데, 이는 위에서 언급한 것처럼 객체 속성을 다루는 다른 부분을 설명하면서 보완해 나갈 예정입니다.&lt;/p&gt;
&lt;p&gt;오늘은 여기까지입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (2)</title>
      <link>/2009/08/14/2009-08-14-oop-with-gobject-2/</link>
      <pubDate>Fri, 14 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/14/2009-08-14-oop-with-gobject-2/</guid>
      <description>&lt;p&gt;첫번째 글이 당연한 내용을 너무 길게 설명했다는 의견이 있어서, 이번 글부터는 더 짧고 간결하게 정리해 보려고 노력하고 있습니다. 그리고, 이 글의 대상은 한 번이라도 GTK+ / GLib 라이브러리를 사용한 경험이 있는 개발자입니다. 그래서 정말로 기초적인 내용은 피하고 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;접근자 (Accessors)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;소프트웨어 공학에서 모듈이나 객체 설계시 기본적으로 강조하는 정보은닉(information hiding), 캡슐화(encapsulation), 결합도(coupling) 등과 같은 개념에 의하면, C 언어처럼 구조체의 필드 변수를 외부로 직접 공개하는 건 좋지 않다고 합니다. 그리고 대부분의 경우 직접 접근 방식보다 읽고 쓰는 접근자(accessors)를 제공하는 게 여러모로 좋다고 하지요. 물론 성능 문제로 직접 접근 방식을 고려해야 하는 경우도 있지만, 지금까지 경험에 비춰보면, 병목을 일으키는 부분은 프로파일러를 돌려서 정확하게 파악한 다음에 해결하는 게 대부분 좋기 때문에 처음부터 그럴 필요는 없을 것 같습니다.&lt;/p&gt;
&lt;p&gt;참고로 현재 개발 중인 
&lt;a href=&#34;http://live.gnome.org/GTK%2B/3.0/Roadmap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+ 3.0&lt;/a&gt;
에서도 기존에 공개되었던 변수들을 모조리 안으로 숨기고, GTK+ 2.x 어플리케이션의 이전(migration)을 위해 
&lt;a href=&#34;http://live.gnome.org/GnomeGoals/UseGseal&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GSEAL() 매크로&lt;/a&gt;
를 2.14 버전부터 제공하고 있습니다.&lt;/p&gt;
&lt;p&gt;아무튼 그래서, 일단 지난 글에서 예제로 사용한 호스트 객체의 필드를 숨기고 접근 API를 구현해 보았습니다. (변경되거나 수정한 부분만 보여드립니다)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct _EdcHostClass EdcHostClass;
typedef struct _EdcHost      EdcHost;

struct _EdcHost
{
  GObject parent;
};

struct _EdcHostClass
{
  GObjectClass parent_class;
};

GType        edc_host_get_type     (void) G_GNUC_CONST;
EdcHost     *edc_host_new          (void);
const gchar *edc_host_get_name     (EdcHost     *host);
void         edc_host_set_name     (EdcHost     *host,
                                    const gchar *name);
const gchar *edc_host_get_address  (EdcHost     *host);
void         edc_host_set_address  (EdcHost     *host,
                                    const gchar *address);
gint         edc_host_get_port     (EdcHost     *host);
void         edc_host_set_port     (EdcHost     *host,
                                    gint         port);
const gchar *edc_host_get_user     (EdcHost     *host);
void         edc_host_set_user     (EdcHost     *host,
                                    const gchar *user);
const gchar *edc_host_get_password (EdcHost     *host);
void         edc_host_set_password (EdcHost     *host,
                                    const gchar *password);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

typedef struct _EdcHostPrivate EdcHostPrivate;
struct _EdcHostPrivate
{
  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;
};

#define EDC_HOST_GET_PRIVATE(host) 
 G_TYPE_INSTANCE_GET_PRIVATE (host, EDC_TYPE_HOST, EdcHostPrivate)

G_DEFINE_TYPE (EdcHost, edc_host, G_TYPE_OBJECT);

EdcHost *
edc_host_new (void)
{
  return EDC_HOST (g_object_new (EDC_TYPE_HOST, NULL));
}

/* object initializer */
static void
edc_host_init (EdcHost *host)
{
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  priv-&amp;gt;name = g_strdup (&amp;quot;&amp;quot;);
  priv-&amp;gt;address = g_strdup (&amp;quot;&amp;quot;);
  priv-&amp;gt;port = 0;
  priv-&amp;gt;user = g_strdup (&amp;quot;&amp;quot;);
  priv-&amp;gt;password = g_strdup (&amp;quot;&amp;quot;);
}

/* object finalizer */
static void
edc_host_finalize (GObject *self)
{
  EdcHost *host = EDC_HOST (self);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  g_free (priv-&amp;gt;name);
  g_free (priv-&amp;gt;address);
  g_free (priv-&amp;gt;user);
  g_free (priv-&amp;gt;password);

  /* call our parent method (always do this!) */
  G_OBJECT_CLASS (edc_host_parent_class)-&amp;gt;finalize (self);
}

/* class initializer */
static void
edc_host_class_init (EdcHostClass *klass)
{
  GObjectClass *gobj_class;

  gobj_class = G_OBJECT_CLASS (klass);
  gobj_class-&amp;gt;finalize = edc_host_finalize;

  g_type_class_add_private (gobj_class, sizeof (EdcHostPrivate));
}

const gchar *
edc_host_get_name (EdcHost *host)
{
  EdcHostPrivate *priv;

  g_return_val_if_fail (EDC_IS_HOST (host), NULL);

  priv = EDC_HOST_GET_PRIVATE (host);

  return priv-&amp;gt;name;
}

void
edc_host_set_name (EdcHost     *host,
                   const gchar *name)
{
  EdcHostPrivate *priv;

  g_return_if_fail (EDC_IS_HOST (host));
  g_return_if_fail (name != NULL);

  priv = EDC_HOST_GET_PRIVATE (host);

  g_free (priv-&amp;gt;name);
  priv-&amp;gt;name = g_strdup (name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;먼저 헤더 파일을 보면, &lt;code&gt;EdcHost&lt;/code&gt; 구조체에서 공개되었던 객체 변수가 모두 사라지고, 대신 &lt;code&gt;edc_host_{get,set}_*()&lt;/code&gt; 형태의 API 선언이 추가되었습니다. 소스 파일에는 새로 &lt;code&gt;EdcHostPrivate&lt;/code&gt; 구조체를 정의하고 모든 비공개 변수를 집어 넣은 뒤, 클래스 초기화 함수[&lt;code&gt;edc_host_class_init ()&lt;/code&gt;] 마지막 부분에서 이 크기만큼의 공간을 확보하도록 합니다.[
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Type-Information.html#g-type-class-add-private&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_type_class_add_private()&lt;/code&gt;&lt;/a&gt;
] 그리고 모든 함수에서 이 구조체를 쉽게 얻어오기 위해 정의한 &lt;code&gt;EDC_HOST_GET_PRIVATE()&lt;/code&gt; 매크로를 사용해 필요한 작업을 수행합니다.&lt;/p&gt;
&lt;p&gt;부가적으로 조금만 더 설명하면, 모든 문자열을 넘겨주는 API는 문자열을 복사해서 넘겨주어 원본 문자열을 보호합니다. 따라서 API 문서에 넘겨받은 문자열을 반드시 해제하라고 명시되어 있어야 하겠죠. 또한 지난 글에서 잠시 언급한 것처럼, 공개된 함수 진입 시점에서 인수 적합성 검사를 할때 &lt;code&gt;EDC_IS_HOST()&lt;/code&gt; 매크로를 사용해 NULL 여부 뿐 아니라 정확하게 해당 객체인지 검사하도록 합니다.&lt;/p&gt;
&lt;p&gt;참고로 위 예제에서 비공개(private) 객체에 접근하는 방법은 설명을 위해 오버헤드가 존재하는 단순한 방식입니다. 따라서 실제로 사용하려면 반드시 이 
&lt;a href=&#34;/2008/12/23/reduce-accesing-overhead-for-gobject-private-data/&#34;&gt;포스트&lt;/a&gt;
를 참고하시기 바랍니다.&lt;/p&gt;
&lt;p&gt;이렇게 해서 기본적인 객체 속성에 대한 접근자를 구현했습니다. 물론 이게 다는 아니고, 다음에 설명할 GObject 속성(properties) 기능을 이용하면 사실 접근자를 구현할 필요도 없습니다. 하지만, GTK+와 같은 대부분의 GObject 기반 객체는 함수 API 기반의 접근자를 동시에 제공하고 있으므로 관례를 따르는 게 나쁘지는 않겠지요.&lt;/p&gt;
&lt;p&gt;글머리에서 언급했듯이, 계속 적다 보면 내용도 길어지고 포스팅 주기도 길어질 것 같아 오늘은 일단 여기까지만 적습니다. 다음에는 본격적으로 GObject 속성(properties)을 추가할 예정인데, 설명할 게 많아서&amp;hellip; ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (1)</title>
      <link>/2009/08/10/2009-08-10-oop-with-gobject-1/</link>
      <pubDate>Mon, 10 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/10/2009-08-10-oop-with-gobject-1/</guid>
      <description>&lt;p&gt;GTK+, Clutter 등과 같은 라이브러리는 C 언어로 구현되었지만 객체 지향 개념을 충실히 따르고 있는데, 그 중심에는 GLib 라이브러리의 GObject가 있습니다. 따라서 이러한 라이브러리를 제대로 이해하고 사용하려면 필수적으로 GObject 개념을 잘 이해하고 있어야 합니다. 그런데, 생각보다 GObject 개념은 이해하기 어렵습니다. 이해하더라도 이를 응용하려면 그만큼 시간이 또 필요합니다.&lt;/p&gt;
&lt;p&gt;그래서 이번 글을 시작으로 GObject 라이브러리를 이용한 C 언어에서 객체 지향 프로그래밍이라는 거창한 주제를 예제 형식을 이용해 다루어 보려고 합니다. 바로 새 GTK+ 위젯을 구현하거나 클러터 객체를 분석하는 방식이 아니라 왜 GObject가 이런 방식으로 설계되었는지 그 철학을 따라가 보려고 합니다. 그리고, 가능한 기존 GObject 튜토리얼의 어려운 설명이 아니라 실제 사용하는 코드를 중심으로 설명할 예정이니, 그래도 무슨 말인지 모르겠거나 더 풀어서 설명을 하는 게 좋을 것 같을 경우 의견 주시기 바랍니다.&lt;/p&gt;
&lt;p&gt;여기서 예제로 사용할 개념은 네트워크 카메라 호스트와 호스트 목록입니다. (하는 일이 이쪽 분야라서&amp;hellip; :)&lt;/p&gt;
&lt;p&gt;네트워크 카메라 호스트는 이름(name), 주소(address), 포트번호(port), 사용자(user), 비밀번호(password) 등과 같은 항목을 포함합니다. 필요한 함수로는 새 객체를 만들거나 해제, 그리고 각 필드값을 얻어오거나 변경하는 정도입니다. (아마도 나중에는 값이 변경되면 자동으로 호출되는 콜백 함수도 추가할 겁니다)&lt;/p&gt;
&lt;p&gt;모든 코드는 GLib API를 이용하여 작성합니다.&lt;/p&gt;
&lt;p&gt;**객체 (Objects) + 참조 카운터 (Reference Counter)
**&lt;/p&gt;
&lt;p&gt;소프트웨어 공학자들이 객체라고 부르기 전부터 C 언어에는 구조체(struct)가 있었습니다. GObject 시스템 역시 기본 바탕은 구조체입니다. 그러면 GObject 프로그래밍을 하기 전에, 일반 C 언어 구조체를 이용해 네트워크 카메라 호스트를 정의하면, 다음과 같은 코드가 나오지 않을까요?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct _EdcHost EdcHost;
struct _EdcHost
{
  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만일 상속이나 함수 오버로딩(overloading)을 전혀 사용하지 않는다면, 굳이 새로운 함수를 추가할 필요를 못 느끼는 분들이 많을 겁니다. 왜냐하면, 직접 구조체 크기만큼 메모리를 할당한 뒤 해제하고, 직접 모든 필드를 접근하면 되니까요. 하지만, 할당하고 해제하는 코드가 여러 곳에 분산되어 있다면 디버깅도 힘들고 유지 보수도 힘드니까 최소한 객체를 생성하고 해제하는 함수만이라도 만들어 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EdcHost *
edc_host_new (void)
{
  EdcHost *host;

  host = g_new0 (EdcHost, 1);

  return host;
}

void
edc_host_destroy (EdcHost *host)
{
  g_return_if_fail (host != NULL);

  g_free (host-&amp;gt;name);
  g_free (host-&amp;gt;address);
  g_free (host-&amp;gt;user);
  g_free (host-&amp;gt;password);
  g_free (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;간단한 코드라서 설명할 필요는 없을 것 같습니다. 참고로 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Memory-Allocation.html#g-free&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_free()&lt;/code&gt;&lt;/a&gt;
 함수는 인수가 NULL일 경우 무시하므로 NULL 검사 코드는 필요없습니다.&lt;/p&gt;
&lt;p&gt;그런데, 이 객체는 단순히 목록 관리 뿐 아니라 여러 다른 모듈에서도 사용할 예정입니다. 여기서 갑자기, 모든 모듈이 하나의 객체를 공유하고 싶은 욕망이 꿈틀대기 시작합니다. 모듈 간에 객체를 전달할때 복사할 필요도 없고, 모듈 별로 객체를 따로 만들어 정보를 보관하는 것보다 메모리를 절약할 수 있으며, 필드 하나가 변경되었을 경우 그 정보를 모든 관련 객체에 반영할 수고도 덜 수 있기 때문입니다. 그렇다고 무턱대고 모든 모듈에서 객체 주소(pointer)만 참조하게 하면 객체를 어느 시점에 할당하고 해제해야 하는지 매우 까다로워집니다. 특히 동적으로 임시 객체를 생성해 다른 모듈에게 넘겨주는 경우라면, 객체를 어느 시점에서 해제해야 하는지도 실수하기 딱 좋습니다. 더 나아가 멀티 쓰레드 환경까지 고려한다면, 단순히 포인터만 가리키는 방식은, 아마추어나 사용하는 옛날 UML 클래스 빌더가 자동으로 생성해주는 코드만으로는, 힘들 수 밖에 없습니다.&lt;/p&gt;
&lt;p&gt;이런 경우 자주 사용하는 방식이 참조 카운터(reference counter) 기법입니다. 짧게 설명하자면, 모든 모듈에서 몇 가지 원칙만 지키면 됩니다. 첫번째 원칙은, 객체(메모리)를 할당한 모듈에서 반드시 해제하기입니다. 두번째는, 모듈 관점에서 내가 필요한 시점부터 객체의 참조 카운터를 증가하고, 더이상 사용하지 않으면 객체의 참조 카운터를 감소합니다. 새로 생성된 객체는 참조 카운터 값이 1이고, 참조 카운터가 감소되어 0이 되면 객체는 자동으로 해제됩니다. 참고로, 참조 카운터 기법은 멀티미디어 프레임 버퍼, 네트워크 패킷 등과 같은 버퍼 관리에도 널리 사용하는 것은 물론, 오브젝티브-C 언어(Objective-C)의 NSObject 객체가 기본적으로 제공하는 기능이기도 합니다.&lt;/p&gt;
&lt;p&gt;자 이제, 호스트 객체를 참조 카운터 기법을 적용해 수정해 보면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_HOST_H__
#define __EDC_HOST_H__

#include &amp;lt;glib.h&amp;gt;

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

typedef struct _EdcHost EdcHost;
struct _EdcHost
{
  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;

  gint   ref_count;
};

EdcHost *edc_host_new   (void);
EdcHost *edc_host_ref   (EdcHost *host);
void     edc_host_unref (EdcHost *host);

#ifdef __cplusplus
}
#endif

#endif /* __EDC_HOST_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

EdcHost *
edc_host_new (void)
{
  EdcHost *host;

  host = g_new0 (EdcHost, 1);
  if (!host)
    return NULL;

  host-&amp;gt;ref_count = 1;

  return host;
}

static void
edc_host_destroy (EdcHost *host)
{
  g_return_if_fail (host != NULL);

  g_free (host-&amp;gt;name);
  g_free (host-&amp;gt;address);
  g_free (host-&amp;gt;user);
  g_free (host-&amp;gt;password);
  g_free (host);
}

EdcHost *
edc_host_ref (EdcHost *host)
{
  g_return_val_if_fail (host != NULL, NULL);

  g_atomic_int_inc (&amp;amp;host-&amp;gt;ref_count);

  return host;
}

void
edc_host_unref (EdcHost *host)
{
  g_return_if_fail (host != NULL);

  if (g_atomic_int_dec_and_test (&amp;amp;host-&amp;gt;ref_count))
    edc_host_destroy (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제일 먼저 설명할 부분은 역시 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Atomic-Operations.html#g-atomic-int-inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_atomic_int_inc()&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Atomic-Operations.html#g-atomic-int-dec-and-test&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_atomic_int_dec_and_test()&lt;/code&gt;&lt;/a&gt;
 함수입니다. 멀티 쓰레드에서 안전하게 카운터 변수를 증가하고 감소할 수 있게 도와주는 GLib API입니다. 이를 이용해 위에서 설명한 참조 카운터 개념을 구현하고 있습니다. 공개했던 &lt;code&gt;edc_host_destroy()&lt;/code&gt; 함수는 모듈 내부에서만 접근할 수 있도록 &lt;code&gt;static&lt;/code&gt; 키워드를 붙였습니다. 또한 C++ 소스에서 포함(include)할때 문제를 일으키지 않도록 헤더파일에 &amp;lsquo;&lt;code&gt;extern &amp;quot;c&amp;quot; {}&lt;/code&gt;&amp;rsquo; 키워드도 추가했습니다.&lt;/p&gt;
&lt;p&gt;그런데 참조 카운터가 필요한 객체마다 이렇게 구현하면 비슷한 작업을 하는 코드가 중복될 수 밖에 없습니다. 이를 일반적인 API로 분리해 다시 구현하면 재활용이 가능할테니, 다음과 같이 수정해 보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-object.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_OBJECT_H__
#define __EDC_OBJECT_H__

#include &amp;lt;glib.h&amp;gt;

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

typedef struct _EdcObject EdcObject;
struct _EdcObject
{
  gint           ref_count;
  GDestroyNotify finalize;
};

static inline gpointer
edc_object_alloc (GDestroyNotify finalize,
                  gint           obj_size)
{
  EdcObject *obj;

  obj = g_malloc (obj_size);
  if (!obj)
    return NULL;

  obj-&amp;gt;ref_count = 1;
  obj-&amp;gt;finalize = finalize;

  return obj;
}

static inline gpointer
edc_object_ref (gpointer obj)
{
  EdcObject *object = obj;

  if (object)
    g_atomic_int_inc (&amp;amp;object-&amp;gt;ref_count);

  return object;
}

static inline void
edc_object_unref (gpointer obj)
{
  EdcObject *object = obj;

  if (!obj)
    return;

  if (g_atomic_int_dec_and_test (&amp;amp;object-&amp;gt;ref_count))
    {
      if (object-&amp;gt;finalize)
        object-&amp;gt;finalize (object);
      g_free (object);
    }
}

#ifdef __cplusplus
}
#endif

#endif /* __EDC_OBJECT_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_HOST_H__
#define __EDC_HOST_H__

#include &amp;quot;edc-object.h&amp;quot;

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

typedef struct _EdcHost EdcHost;
struct _EdcHost
{
  EdcObject parent;

  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;
};

EdcHost *edc_host_new (void);

#ifdef __cplusplus
}
#endif

#endif /* __EDC_HOST_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

static void
edc_host_finalize (gpointer obj)
{
  EdcHost *host = obj;

  g_free (host-&amp;gt;name);
  g_free (host-&amp;gt;address);
  g_free (host-&amp;gt;user);
  g_free (host-&amp;gt;password);
}

EdcHost *
edc_host_new (void)
{
  EdcHost *host;

  host = edc_object_alloc (edc_host_finalize,
                           sizeof (EdcHost));
  if (!host)
    return NULL;

  host-&amp;gt;name = NULL;
  host-&amp;gt;address = NULL;
  host-&amp;gt;user = NULL;
  host-&amp;gt;password = NULL;

  return host;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;객체 지향 상속(또는 파생 객체)을 C 언어로 구현하는 가장 쉬운 방법은 위 코드에서 보는 것처럼 부모(또는 원본 객체)를 구조체 맨 앞에 두는 겁니다. 그러면 부모와 자식 API 모두 사용할 수 있게 되죠. 위 코드의 경우 개념상으로 보면 EdcObject 객체를 상속 받아 EdcHost 객체를 구현한 셈이 되죠. 따라서 다음과 같이 사용할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void
func_a (EdcHost *host)
{
  edc_object_ref (host);
  // do some stuff for long time...
  edc_object_unref (host);
}

{
  EdcHost *host;

  host = edc_host_new ();
  ...
  func_a (host);
  ...
  edc_object_unref (host); /* destroy */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 C 언어에서 `&lt;code&gt;void *&lt;/code&gt;&amp;rsquo; 형은 어떤 포인터와도 양방향 대입(assignment)을 할 수 있으므로 컴파일 경고를 피하기 위해 불필요한 형변환을 할 필요가 없습니다. (
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Basic-Types.html#gpointer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;gpointer&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Datasets.html#GDestroyNotify&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;GDestroyNotify&lt;/code&gt;&lt;/a&gt;
 API도 설명도 확인해 보시기 바랍니다)&lt;/p&gt;
&lt;p&gt;이제 지금까지 구현한 부분을 GObject 객체 기반으로 옮겨 봅니다. 자세히 보시면, 지금까지 프로그래밍한 내용과 거의 비슷한 점을 알아챌 수 있을 겁니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_HOST_H__
#define __EDC_HOST_H__

#include &amp;lt;glib-object.h&amp;gt;

G_BEGIN_DECLS

#define EDC_TYPE_HOST 
 (edc_host_get_type ())
#define EDC_HOST(obj) 
 (G_TYPE_CHECK_INSTANCE_CAST ((obj), EDC_TYPE_HOST, EdcHost))
#define EDC_HOST_CLASS(obj) 
 (G_TYPE_CHECK_CLASS_CAST ((obj), EDC_TYPE_HOST, EdcHostClass))
#define EDC_IS_HOST(obj) 
 (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EDC_TYPE_HOST))
#define EDC_IS_HOST_CLASS(obj) 
 (G_TYPE_CHECK_CLASS_TYPE ((obj), EDC_TYPE_HOST))
#define EDC_GET_HOST_CLASS(obj) 
 (G_TYPE_INSTANCE_GET_CLASS ((obj), EDC_TYPE_HOST, EdcHostClass))

typedef struct _EdcHostClass EdcHostClass;
typedef struct _EdcHost      EdcHost;

struct _EdcHost
{
 GObject parent;

 gchar  *name;
 gchar  *address;
 gint    port;
 gchar  *user;
 gchar  *password;
};

struct _EdcHostClass
{
 GObjectClass parent_class;
};

GType    edc_host_get_type (void) G_GNUC_CONST;
EdcHost *edc_host_new      (void);

G_END_DECLS

#endif /* __EDC_HOST_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

G_DEFINE_TYPE (EdcHost, edc_host, G_TYPE_OBJECT);

EdcHost *
edc_host_new (void)
{
 return EDC_HOST (g_object_new (EDC_TYPE_HOST, NULL));
}

/* object initializer */
static void
edc_host_init (EdcHost *host)
{
 host-&amp;gt;name = NULL;
 host-&amp;gt;address = NULL;
 host-&amp;gt;port = 0;
 host-&amp;gt;user = NULL;
 host-&amp;gt;password = NULL;
}

/* object finalizer */
static void
edc_host_finalize (GObject *self)
{
 EdcHost *host = EDC_HOST (self);

 g_free (host-&amp;gt;name);
 g_free (host-&amp;gt;address);
 g_free (host-&amp;gt;user);
 g_free (host-&amp;gt;password);

 /* call our parent method (always do this!) */
 G_OBJECT_CLASS (edc_host_parent_class)-&amp;gt;finalize (self);
}

/* class initializer */
static void
edc_host_class_init (EdcHostClass *klass)
{
 GObjectClass *gobject_class;

 gobject_class = G_OBJECT_CLASS (klass);
 gobject_class-&amp;gt;finalize = edc_host_finalize;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;갑자기 코드량이 증가했다고 놀랄 필요는 없습니다. 뭐든지 다 그렇지만, 알고 보면 별 거 아닙니다.&lt;/p&gt;
&lt;p&gt;먼저 헤더 파일을 설명하면,  GObject 객체를 사용하기 위해 glib-object.h 파일을 포함했습니다. 이는 EdcHost 객체가 GObject 객체만 사용하기 때문에, 더 정확히는 GObject의 파생 객체(derived objects), 다른 말로는 GObject 객체만 상속(inheritance)하기 때문에 그렇습니다. 만일 다른 객체에서 파생한다면 그 객체를 정의하는 헤더 파일을 포함해야 합니다. &amp;lsquo;&lt;code&gt;extern &amp;quot;c&amp;quot; {}&lt;/code&gt;&amp;rsquo; 키워드는 GLib의 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Miscellaneous-Macros.html#G-BEGIN-DECLS--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;G_BEGIN_DECLS&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Miscellaneous-Macros.html#G-END-DECLS--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;G_END_DECLS&lt;/code&gt;&lt;/a&gt;
 API로 대체했습니다.&lt;/p&gt;
&lt;p&gt;EdcHost 인스턴스와 EdcHostClass 클래스를 정의하고 있는 부분을 설명하면, 클래스 객체는 전역으로 하나만 존재하고 그냥 객체는 인스턴스(instance) 역할을 합니다. 또한 여기서는 인스턴스 객체의 모든 필드가 공개되어 있지만, 물론 외부에 공개하지 않는(private) 필드를 정의할 수도 있습니다. (이는 다른 글에서 따로 설명하겠습니다)&lt;/p&gt;
&lt;p&gt;복잡해 보이는 몇몇 매크로는 자주 사용하는 긴 API를 간편화한 것입니다. 런타임 중에 인스턴스가 유효하고 EdcHost 객체로 형변환까지 해주거나[&lt;code&gt;EDC_HOST(obj)&lt;/code&gt;], 인스턴스가 EdcHost 객체인지 확인하거나[&lt;code&gt;EDC_IS_HOST(obj)&lt;/code&gt;], 인스턴스의 클래스 객체를 얻어오거나[&lt;code&gt;EDC_GET_HOST_CLASS(obj)&lt;/code&gt;] 하는 등 일종의 
&lt;a href=&#34;http://en.wikipedia.org/wiki/Run-time_type_information&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RTTI&lt;/a&gt;
 관련 매크로입니다. 아마 제일 많이 사용하는 매크로는 `&lt;code&gt;EDC_HOST(obj)&lt;/code&gt;&#39;일 겁니다.&lt;/p&gt;
&lt;p&gt;소스를 살펴 보면, 제일 먼저 나오는게 `
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Type-Information.html#G-DEFINE-TYPE--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;G_DEFINE_TYPE(TN, t_n, T_P)&lt;/code&gt;&lt;/a&gt;
&amp;rsquo; 입니다. 여담이지만, 이 매크로가 추가되기 전에 작성한 GObject 기반 코드는 귀찮은 작업을 많이 해야 했는데, 이 매크로가 자동으로 해주는 기능이 많아서 불필요하게 중복되는 코드가 많이 줄어들었습니다. 그래서 GTK+ 소스 코드 중에도 가끔 그렇게 작성한 코드도 있고, GObject 관련 초기 문서를 보면 이 매크로를 사용하지 않고 구현되어 있는 경우도 있습니다.&lt;/p&gt;
&lt;p&gt;이 매크로가 하는 일은 다음과 같습니다. 지정한 `&lt;code&gt;t_n&lt;/code&gt;` 이름으로 시작하는 클래스 초기화 함수[&lt;code&gt;*_class_init()&lt;/code&gt;] / 인스턴스 초기화 함수[&lt;code&gt;*_init()&lt;/code&gt;] 모두 구현되어 있다고 가정하고 `&lt;code&gt;*_get_type()&lt;/code&gt;&amp;rsquo; 함수를 자동으로 삽입해 줍니다. 더불어 부모 클래스 객체를 가리키는 `&lt;code&gt;*_parent_class&lt;/code&gt;&amp;rsquo; 전역 변수도 만들어 줍니다. 따라서 프로그래머는 최소한 함수 두 개만 구현해 주면 되는 셈입니다. [&lt;code&gt;edc_host_init()&lt;/code&gt; / &lt;code&gt;edc_host_class_init()&lt;/code&gt;]&lt;/p&gt;
&lt;p&gt;하지만 위 예제에서는 클래스 초기화 함수에서 인스턴스 객체가 해제될때 호출되는 finalize 함수를 교체하고 있습니다. 이를 통해 객체가 해제될때 사용하던 리소스를 해제해 줍니다. 그리고, 반드시 상위 클래스의 finalize 함수를 호출해 주어야 정상적으로 부모 객체의 해제 함수가 차례대로 호출될 수 있습니다.&lt;/p&gt;
&lt;p&gt;자 이제 GObject의 핵심 기능 중 하나인 객체 참조 카운터(object reference counter) 기능을 쉽게 이용할 수 있습니다. 이렇게 작성한 객체는 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-ref&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_ref()&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_unref()&lt;/code&gt;&lt;/a&gt;
 함수 등을 이용해 참조 카운터를 제어할 수 있습니다. GObject 소스 코드를 확인해 보시면 알겠지만, 실제 객체 참조 카운터 기능은 거의 비슷하게 구현되어 있습니다. 더 많은 경우의 수를 고려하고 더 많은 기능을 제공하다보니 코드가 더 복잡한 것 뿐입니다.&lt;/p&gt;
&lt;p&gt;더 중요한 점은 모든 GObject 기반 객체, 예를 들어 GTK+ 위젯이나 클러터 객체 모두 GObject 기반이기 때문에 객체간 연결(부모-자식, 컨테이너-아이템 등)시 객체에 대한 포인터를 유지하면서 동시에 참조 카운터를 유지하여 메모리를 관리한다는 점입니다. 이 부분에 대한 더 자세한 설명은 
&lt;a href=&#34;/2008/12/28/gtk-memory-management/&#34;&gt;GTK+ 메모리 관리&lt;/a&gt;
 글에서 확인하시기 바랍니다.&lt;/p&gt;
&lt;p&gt;오늘은 일단 여기까지만&amp;hellip; ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject Property Binding 기능이 필요함</title>
      <link>/2009/04/20/2009-04-20-gobject-property-binding-required/</link>
      <pubDate>Mon, 20 Apr 2009 00:00:00 +0000</pubDate>
      <guid>/2009/04/20/2009-04-20-gobject-property-binding-required/</guid>
      <description>&lt;p&gt;맥 코코아 프레임웍을 공부하면서 GTK+ / GObject 라이브러리에도 있으면 참 좋겠다고 생각한 것 중 하나가 특정 속성(property)을 다른 객체의 속성과 결합하는(binding) 개념입니다. 이를 이용해 자동으로 모델과 뷰를 클릭 몇 번으로 연결하고, 더 나아가 객체 배열은 물론 선택한 항목까지 자동으로 동기화되는 걸 보면서 정말 잘 만들어진 프레임웍이라는 걸 새삼 느낍니다. 또한 사용자가 직접 설계한 클래스를 인터페이스 빌더의 객체로 등록해서 마우스 클릭만으로 자연스럽게 연결이 되는 걸 보면 정말 부럽습니다.&lt;/p&gt;
&lt;p&gt;물론 GObject  객체의 속성 묶기(property binding)를 지원하기 위해 
&lt;a href=&#34;/2008/12/15/exobinding/&#34;&gt;ExoBinding&lt;/a&gt;
과 같은 라이브러리도 존재하지만, 이 역시 개발자가 직접 코드를 추가해주어야 하는 방식일 뿐 Glade와 같은 인터페이스 빌더에서 직접 사용할 수는 없습니다. 아쉽게도 
&lt;a href=&#34;http://mail.gnome.org/archives/gtk-devel-list/2009-April/msg00048.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+ 3.0 로드맵&lt;/a&gt;
 / 
&lt;a href=&#34;http://mail.gnome.org/archives/gtk-devel-list/2009-February/msg00039.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GLib 2.22 예정&lt;/a&gt;
에도 없는 걸 보면 GTK+ 개발자들은 아무래도 직접 코딩하는 걸 더 선호하거나 혹은 필요성을 못 느끼거나, 또는 아직 괜찮다고 생각하는 구현이 없는 거라고 생각하고 싶을 뿐입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GLib과 GTK&#43;도 Subversion에서 Git으로 이동</title>
      <link>/2009/04/01/2009-04-01-glib-gtk-moved-to-git/</link>
      <pubDate>Wed, 01 Apr 2009 00:00:00 +0000</pubDate>
      <guid>/2009/04/01/2009-04-01-glib-gtk-moved-to-git/</guid>
      <description>&lt;p&gt;2009년 4월 1일을 기준으로 GNOME 프로젝트의 핵심이 되는 glib, gtk, pango, atk 프로젝트가 기존 서브버전에서 
&lt;a href=&#34;http://mail.gnome.org/archives/gtk-devel-list/2009-March/msg00206.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;git으로 소스 버전 관리 시스템을 변경&lt;/a&gt;
했습니다. 한동안 어떤 버전 관리 시스템을 사용할지 논의가 많았는데, 결국 대세를 거를 수는 없었던 모양입니다. 달라진 사용법은 
&lt;a href=&#34;http://live.gnome.org/GitMigration&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Git이전하기&lt;/a&gt;
 위키 페이지에 계속 정리되고 있으니 참고하시기 바랍니다.&lt;/p&gt;
&lt;p&gt;참고로, 초기 버전과 달리 최신 버전의 git은 이진(binary) 파일 처리 / 외부(external) 프로젝트 연결 등을 지원합니다. 또한 기존 서브버전 저장소와 동시에 유지할 수 있는 방법(git-svn)도 존재합니다. 하지만 아직 아쉬운 점은 멀티플랫폼 지원, 물론 커맨드 라인 방식으로는 지금도 가능하지만, 하지만 윈도우 탐색기 인터페이스에서 벗어나기 싫어하는 게으른 개발자들에게 커맨드 라인 방식을 강요할 근거가 아직은 부족한 것 같습니다. 윈도우 플랫폼에서 TortoiseSVN처럼 탐색기와 통합된 git 클라이언트만 있다면 지금 당장이라도 회사 개발 프로젝트에 도입할 수 있을 것 같은데&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GTK&#43; 2.16 릴리스</title>
      <link>/2009/03/23/2009-03-23-gtk-216-release/</link>
      <pubDate>Mon, 23 Mar 2009 00:00:00 +0000</pubDate>
      <guid>/2009/03/23/2009-03-23-gtk-216-release/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://mail.gnome.org/archives/gtk-devel-list/2009-March/msg00101.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+ 2.16 버전이 릴리스&lt;/a&gt;
되었는데, 추가된 기능 중에서 관심 있는 부분만 우리말로 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;새로 추가된 API&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;가로 / 세로 방향성을 가지는 위젯이 모두 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/gtk-Orientable.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkOrientable&lt;/a&gt;
 인터페이스를 기반으로 다시 구현되었습니다. &lt;span class=&#34;link&#34;&gt;상자(GtkBox), 버튼상자(GtkButtonBox), 스케일(GtkScale), 볼륨버튼(GtkVolumeButton), 스크롤바(GtkScrollBar), 구분자(GtkSeparator) 등을 비롯한 다수의 위젯을 이제 &lt;/span&gt;
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/gtk-Orientable.html#gtk-orientable-set-orientation&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;gtk_orientable_set_orientation()&lt;/code&gt;&lt;/a&gt;
 API를 이용하면 실행중에도 쉽게 방향을 변경할 수 있습니다.&lt;/li&gt;
&lt;li&gt;메뉴 / 툴바 등을 하나의 사용자 액션으로 통합 관리하는데 매우 효율적인 GtkAction 객체와 연결할 수 있는 위젯을 사용자가 쉽게 구현할 수 있도록 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkActivatable.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkActivatable&lt;/a&gt;
 인터페이스가 새로 추가되었습니다. 즉, 이제 메뉴와 툴바 버튼이 아닌 다른 어떤 위젯도 액션과 연결할 수 있게 된 셈입니다.  더불어 이전에는 직접 GtkAction 객체의 속성을 조절해야 했던 레이블 / 툴팁 등을 수정할 수 있는 API도 추가되었습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;GtkEntry 기능 강화&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;엔트리 양쪽 끝에 아이콘을 표시할 수 있게 되었습니다. 클릭할 수도 있고, 드래그 앤 드롭도 지원합니다. 자주 사용하던 
&lt;a href=&#34;http://www.chipx86.com/w/index.php/Libsexy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libsexy&lt;/a&gt;
 GTK+ 위젯 라이브러리의 SexyIconEntry 위젯이 이제서야 공식적으로 포함된 셈입니다.&lt;/li&gt;
&lt;li&gt;엔트리에 표시된 텍스트 뒤로 진행 상태(progress information)를 표시할 수도 있습니다.&lt;/li&gt;
&lt;li&gt;비밀 번호 입력시 사용할 문자를 지정할 수 있게 되었고, &amp;lsquo;Caps Lock&#39;키가 눌려 있으면 경고 메시지도 보여줍니다. 더불어 GdkKeymap 객체는 &amp;lsquo;Cap Lock&#39;키 상태가 변경될 때마다 &amp;ldquo;
&lt;a href=&#34;http://library.gnome.org/devel/gdk/stable/gdk-Keyboard-Handling.html#GdkKeymap-state-changed&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;state-changed&lt;/a&gt;
&amp;rdquo; 시그널로 알려줍니다.&lt;/li&gt;
&lt;li&gt;어플리케이션 윈도우 단위가 아닌 위젯 단위로 다른 입력기를 사용할 수 있도록 개선되었습니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;GtkScale 추가 기능&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkScale.html#gtk-scale-add-mark&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;gtk_scale_add_mark()&lt;/code&gt;&lt;/a&gt;
 API를 이용하여 표식(mark)을 추가할 수 있게 되었습니다. 어떻게 응용할 수 있는지는 아래 그림을 보면 될 것 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/gtkscale-marks.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;모든 기능은 Ubuntu 9.04 / Fedora 11 배포판의 GNOME 데스크탑과 함께 사용이 가능합니다. 물론 윈도우에서는 지금도 
&lt;a href=&#34;http://ftp.acc.umu.se/pub/gnome/binaries/win32/gtk&amp;#43;/2.16/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;다운로드&lt;/a&gt;
해서 개발에 사용할 수 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GTK&#43; 글자 외곽선 효과 (GtkOutlineLabel)</title>
      <link>/2009/03/06/2009-03-06-gtk-outline-label/</link>
      <pubDate>Fri, 06 Mar 2009 00:00:00 +0000</pubDate>
      <guid>/2009/03/06/2009-03-06-gtk-outline-label/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://mail.gnome.org/archives/gtk-list/2009-March/msg00031.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+ 메일링 리스트&lt;/a&gt;
에서 카이로(cairo) API를 이용해 깔끔하게 
&lt;a href=&#34;http://live.gnome.org/OutlineLabel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;외곽선 효과&lt;/a&gt;
를 구현하는 방법의 글을 보고 테스트 삼아 위젯으로 만들어 보았습니다. 이름하여 &amp;lsquo;GtkOutlineLabel&amp;rsquo; 위젯, 실행 화면은 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/gtk-outline-label.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;API는 간단하게 외곽선 색상과 굵기를 지정할 수 있는 기능만 있습니다. 다음은 테스트 프로그램의 일부입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int
main (int argc, char **argv)
{
  GtkWidget *window;
  GtkWidget *label;
  GtkWidget *vbox;

  gtk_init (&amp;amp;argc, &amp;amp;argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  make_transparent_window (window);
  gtk_widget_show (window);

  vbox = gtk_vbox_new (FALSE, 0);
  gtk_widget_show (vbox);
  gtk_container_add (GTK_CONTAINER (window), vbox);

  label = gtk_outline_label_new (&amp;quot;&amp;lt;span font=&amp;quot;Bold 50&amp;quot;&amp;gt;Hello, 안녕?&amp;lt;/span&amp;gt;&amp;quot;);
  gtk_widget_show (label);
  gtk_box_pack_start (GTK_BOX (vbox), label, TRUE, TRUE, 0);

  label = gtk_outline_label_new (&amp;quot;&amp;lt;span font=&amp;quot;Bold 30&amp;quot; color=&amp;quot;red&amp;quot;&amp;gt;Hello, 안녕?&amp;lt;/span&amp;gt;&amp;quot;);
  gtk_widget_show (label);
  gtk_box_pack_start (GTK_BOX (vbox), label, TRUE, TRUE, 0);

  gtk_outline_label_set_line_color (GTK_OUTLINE_LABEL (label), &amp;quot;#000000&amp;quot;);
  gtk_outline_label_set_line_width (GTK_OUTLINE_LABEL (label), 1.0);

  gtk_main ();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>리눅스에서 위치 인식 소프트웨어</title>
      <link>/2009/02/03/2009-02-03-location-aware-softwares-in-linux/</link>
      <pubDate>Tue, 03 Feb 2009 00:00:00 +0000</pubDate>
      <guid>/2009/02/03/2009-02-03-location-aware-softwares-in-linux/</guid>
      <description>&lt;p&gt;&amp;lsquo;
&lt;a href=&#34;http://arstechnica.com/open-source/news/2009/01/location-awareness-comes-to-the-linux-platform.ars&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Location-aware software comes to the Linux platform&lt;/a&gt;
&amp;rsquo; 글에서 모바일 위치 정보와 지도 렌더링을 오픈소스 리눅스 플랫폼에서 처리하는 방법을 정리해 놓았는데, 나중을 위해 간략하게 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;가장 먼저 소개하는 프레임웍은 
&lt;a href=&#34;http://www.freedesktop.org/wiki/Software/GeoClue&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GeoClue&lt;/a&gt;
입니다. GeoClue는 로컬에 장착된 GPS 장치 뿐 아니라 GSMLoc 등과 같은 여러가지 위치 정보를 일종의 표준화된 형식으로 D-Bus를 통해 알려줍니다. (GSMLoc은 이 글을 통해 처음 알게된 건데 GSM 방식 휴대폰의 무선기지국 위치를 측정해 현재 휴대폰의 위치를 판단하는 기법이라고 합니다) GeoClue는 이미 Glib 기반 C API도 제공하고 있기 때문에 이를 이용한 위치 정보 어플리케이션을 개발하면 여러가지 GPS 장치 뿐 아니라 GeoClue 방식을 따르는 다양한 위치 정보를 이용할 수 있다는 장점이 있습니다.&lt;/p&gt;
&lt;p&gt;이렇게 얻어진 위치 정보를 표시하기 위해 가장 관심받고 있는 라이브러리는 
&lt;a href=&#34;http://blog.pierlux.com/projects/libchamplain/en/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libchamplain&lt;/a&gt;
입니다. OpenStreetMap이나 OpenAerialMap 같은 인터넷 지도 서버를 이용하면서, 렌더링에는 
&lt;a href=&#34;http://www.clutter-project.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Clutter&lt;/a&gt;
라이브러리를 사용하지만 GTK+ 위젯 기반이기 때문에 쉽게 그놈 / GTK+ 어플리케이션에도 사용이 가능합니다. 이미 그놈 프로젝트의 기본 이미지 보기 프로그램인 EOG에도 플러그인이 추가되었고, 인스턴트 메신저에도 적용되고 있습니다. (예를 들어 iPhone이나 최신 디지털 카메라는 촬영시 GPS 정보를 이미지에 저장하는데, 이를 읽어들여 이미지를 볼때 이미지를 촬영한 장소의 지도 이미지를 함께 보여줍니다. 또한 메신저 친구 목록에서 친구를 클릭하면 현재 친구가 위치한 장소가 어디인지 알려주고 지도에 표시해 주기도 하는 거죠. 허락없이 무단링크한 다음 스크린샷을 확인해 보시길&amp;hellip;)&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/eog-champlain.png&#34; alt=&#34;&#34; title=&#34;EOG에서 champlain 플러그인 사용 화면&#34;&gt;&lt;/p&gt;
&lt;p&gt;참고로, 이 소프트웨어들은 일반 데스크탑이나 서버 뿐 아니라 휴대폰, PDA 등과 같은 모바일 장치에서도 사용할 수 있습니다. 따라서 앞으로는 웹서비스 뿐 아니라 일반 어플리케이션도 위치 정보와 지도 서비스를 활용해 계속 진화하지 않을까 예측해 봅니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GTK&#43; 멀티 포인터 X 지원</title>
      <link>/2009/01/21/2009-01-21-mpx-gtk-multi-pointer-x-support/</link>
      <pubDate>Wed, 21 Jan 2009 00:00:00 +0000</pubDate>
      <guid>/2009/01/21/2009-01-21-mpx-gtk-multi-pointer-x-support/</guid>
      <description>&lt;p&gt;&amp;lsquo;
&lt;a href=&#34;http://www.phoronix.com/scan.php?page=news_item&amp;amp;px=NzAwNw&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Multi-Pointer X Support For GTK+&lt;/a&gt;
&amp;rsquo; 기사를 보면 이미 GTK+ 라이브러리에 멀티 포인터 기능을 지원하기 위한 작업이 진행중입니다. 비록 X 서버는 Ubuntu 9.04 버전에 탑재될 1.6 버전에 멀티 포인터 기능이 이미 포함되어 있지만 기본적으로 비활성화되어 있고, 올해 말 즈음에 릴리스할 1.7 버전에 X Input 2.0 스펙과 함께 포함되면서 공식적으로 지원이 될 것 같습니다.&lt;/p&gt;
&lt;p&gt;Windows 7이 멀티 터치 인터페이스를 공식적으로 지원하고, 
&lt;a href=&#34;http://www.idg.co.kr/newscenter/common/newCommonView.do?newsId=53180&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;멀티 터치를 지원하는 LCD 모니터&lt;/a&gt;
까지 등장하고 있으니 이제는 일반 데스크탑 GUI 어플리케이션도 멀티 터치를 고려해서 인터페이스가 만들어져야 하겠네요.&lt;/p&gt;
&lt;p&gt;아, 프로그래머의 피곤한 삶이여&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GTK&#43; 반투명 배경 만들기 (OSD 효과)</title>
      <link>/2009/01/14/2009-01-14-gtk-osd-semi-transparent/</link>
      <pubDate>Wed, 14 Jan 2009 00:00:00 +0000</pubDate>
      <guid>/2009/01/14/2009-01-14-gtk-osd-semi-transparent/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://bloc.eurion.net/archives/2009/standalone-pygtk-desktop-widgets/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PyGTK를 이용해 데스크탑 위젯을 만드는 블로그&lt;/a&gt;
를 보고 이를 C 언어로 바꾸어 보았습니다. Compiz나 Metacity의 컴포지팅(compositing) 기능이 활성화되어 있을 경우에만 제대로 동작합니다. 먼저 스크린샷부터.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/trans-test.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;여기서 사용한 기법을 요약하면, 윈도우 바탕에 RGBA 컬러맵을 할당하고 배경화면을 직접 그리도록 설정한뒤 &amp;ldquo;expose-event&amp;rdquo; 발생시 Cairo API를 이용하여 원하는 투명 배경을 그리는 겁니다. 소스 코드는 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;gtk/gtk.h&amp;gt;

static void
make_desktop_window (GtkWidget *window)
{
  gtk_window_set_type_hint (GTK_WINDOW (window), GDK_WINDOW_TYPE_HINT_DOCK);
  gtk_window_set_keep_below (GTK_WINDOW (window), TRUE);
  gtk_window_set_decorated (GTK_WINDOW (window), FALSE);
  gtk_window_stick (GTK_WINDOW (window));
}

static gboolean
window_exposed (GtkWidget      *widget,
                GdkEventExpose *event,
                gpointer        user_data)
{
  cairo_t   *cr;

  cr = gdk_cairo_create (widget-&amp;gt;window);

  /* Make it transparent */
  cairo_set_operator (cr, CAIRO_OPERATOR_CLEAR);
  gdk_cairo_region (cr, event-&amp;gt;region);
  cairo_fill_preserve (cr);

  /* Make it semi-transparent */
  cairo_set_source_rgba (cr, 0.0, 0.0, 0.0, 0.5);
  cairo_set_operator (cr, CAIRO_OPERATOR_OVER);
  cairo_fill (cr);

  cairo_destroy (cr);

  return FALSE;
}

static void
make_transparent_window (GtkWidget *window)
{
  GdkScreen *screen;
  GdkColormap *colormap;

  screen = gtk_widget_get_screen (window);
  if (!screen)
    {
      g_warning (&amp;quot;failed to get window&#39;s screen&amp;quot;);
      return;
    }

  colormap = gdk_screen_get_rgba_colormap (screen);
  if (!colormap)
    {
      g_warning (&amp;quot;failed to get RGBA colormap&amp;quot;);
      return;
    }

  gtk_widget_set_colormap (window, colormap);
  gtk_widget_set_app_paintable (window, TRUE);
  g_signal_connect (window, &amp;quot;expose-event&amp;quot;, G_CALLBACK (window_exposed), NULL);
}

static void
button_clicked (GtkButton *button,
gpointer   user_data)
{
  static gint counter = 0;
  GtkWidget  *label = user_data;
  gchar      *str;

  str = g_strdup_printf (&amp;quot;&amp;lt;span size=&#39;larger&#39; &amp;quot; 
                         &amp;quot;weight=&#39;bold&#39; &amp;quot; 
                         &amp;quot;color=&#39;white&#39;&amp;gt;안녕하신가? %d&amp;lt;/span&amp;gt;&amp;quot;,
                         ++counter);
  gtk_label_set_markup (GTK_LABEL (label), str);
  g_free (str);
}

int
main (int argc, char **argv)
{
  GtkWidget *window;
  GtkWidget *vbox;
  GtkWidget *label;
  GtkWidget *button;

  gtk_init (&amp;amp;argc, &amp;amp;argv);

  window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  make_transparent_window (window);
  if (0) make_desktop_window (window);
  gtk_widget_show (window);

  vbox = gtk_vbox_new (TRUE, 10);
  gtk_widget_show (vbox);
  gtk_container_add (GTK_CONTAINER (window), vbox);

  label = gtk_label_new (&amp;quot;안녕하신가?&amp;quot;);
  gtk_widget_show (label);
  gtk_box_pack_start (GTK_BOX (vbox), label, TRUE, TRUE, 10);

  button = gtk_button_new_with_label (&amp;quot;Click Here!&amp;quot;);
  gtk_widget_show (button);
  gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 10);

  g_signal_connect (button, &amp;quot;clicked&amp;quot;, G_CALLBACK (button_clicked), label);

  gtk_main ();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로, 이를 더 응용하면 필요한 위젯은 모두  반투명하게 만들 수도 있겠지만, 제대로 하려면 Murrine 등과 같은 테마 엔진처럼 GTK+ 테마에서 처리하는게 더 바른 선택일 것 같습니다.&lt;/p&gt;
&lt;p&gt;**[업데이트 - 2009.01.16]
**&lt;/p&gt;
&lt;p&gt;GTK+ 테마 엔진 &amp;ldquo;pixmap&amp;quot;을 이용하고 투명도를 지원하는 PNG / SVG 형식의 이미지를 사용하면 버튼 등과 같은 위젯도 투명도가 적용됩니다. 다음은 위 테스트 프로그램을 이러한 테마를 이용했을때 스크린샷입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/gtk-pixmap-engine-transpareny.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;GTK+ 테마 엔진을 새로 구현할 필요없이 pixmap 엔진만 사용해도 어플리케이션 전체적으로 반투명 효과를 얻을 수 있습니다. 그런데 pixmap 엔진 관련된 문서가 별로 없어서&amp;hellip; 그나마 찾아낸 건 이 정도 뿐입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;a href=&#34;//live.gnome.org/GnomeArt/Tutorials/GtkThemes&#34;&gt;http://live.gnome.org/GnomeArt/Tutorials/GtkThemes&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;//stage.maemo.org/svn/maemo/projects/haf/trunk/sapwood/README&#34;&gt;https://stage.maemo.org/svn/maemo/projects/haf/trunk/sapwood/README&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;//www.nabble.com/Pixmap-Theme-Engine-options-td18393063.html&#34;&gt;http://www.nabble.com/Pixmap-Theme-Engine-options-td18393063.html&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>GTK&#43; 투명 배경 만들기 (OSD 효과)</title>
      <link>/2009/01/14/2009-01-14-gtk-transparent-background-osd-effect/</link>
      <pubDate>Wed, 14 Jan 2009 00:00:00 +0000</pubDate>
      <guid>/2009/01/14/2009-01-14-gtk-transparent-background-osd-effect/</guid>
      <description>&lt;p&gt;이번에는 컴피즈와 같은 비디오 카드 3D 기능이 필요하지 않은 기법으로 OSD 효과를 만들어 보겠습니다. 물론 부드러운 반투명 배경 등의 효과는 불가능하지만, 윈도우의 특정 영역을 아예 마스킹(masking)해서 비워버리는 방식이기 때문에 마우스 입력도 통과해 버립니다. 이번에도 역시 스크린샷 먼저!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/osd-test.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;여기서 사용한 기법은 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkWidget.html#gtk-widget-shape-combine-mask&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtk_widget_shape_combine_mask()&lt;/a&gt;
 함수를 이용해 위젯(윈도우)의 유효 영역을 비트맵으로 지정하는 것입니다. 여기서 비트맵이란 1비트가 하나의 픽셀을 가리키는 그래픽 형식으로, 위젯의 특정 좌표 픽셀이 유효한 영역인지는 비트맵의 해당 좌표 픽셀 비트가 1인지 여부에 따라 결정됩니다. 즉, 일반적인 경우 X 서버는 사각 형태로만 윈도우 영역을 판단하지만, 비트맵 정보가 전달되면 사각형이 아닌 복잡한 형태의 윈도우로 처리하는 것입니다. 가끔 특이한 모양의 윈도우 형태를 가진 어플리케이션이 있다면 아마도 대부분 이 기능을 이용한 것입니다. 더 정확히는  X 윈도우 Shape 확장(extension)에서 제공하는 XShapeCombineMask() API를 이용합니다. (행복하게도 이 GTK+ API는 윈도우 플랫폼에서도 정상 동작합니다)&lt;/p&gt;
&lt;p&gt;gtk_widget_shape_combine_mask() API는 비트맵 정보로 GdkBitmap 객체를 사용하는데 이 객체를 만들기 위해서는 
&lt;a href=&#34;http://library.gnome.org/devel/gdk/stable/gdk-Bitmaps-and-Pixmaps.html#gdk-bitmap-create-from-data&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gdk_bitmap_create_from_data()&lt;/a&gt;
 함수와 
&lt;a href=&#34;http://library.gnome.org/devel/gdk/stable/gdk-Pixbufs.html#gdk-pixbuf-render-pixmap-and-mask-for-colormap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gdk_pixbuf_render_pixmap_and_mask_for_colormap()&lt;/a&gt;
 함수를 사용해야 합니다. 두번째 함수는 GdkPixbuf 객체로부터 추출하는 방식이기 때문에, 이 테스트 프로그램에서는 첫번째 함수를 이용합니다. 그런데 이 함수가 이용하는 데이터가 
&lt;a href=&#34;http://en.wikipedia.org/wiki/XBM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;XBM&lt;/a&gt;
 형식이라서 따로 라이브러리를 사용하지 않고 간단하게 GdkPixmap에서 추출합니다. 하지만 GdkPixmap에서 직접 픽셀 정보를 얻을 수 없으므로 GdkImage 객체로 변환한 뒤에 픽셀 정보를 얻어옵니다.&lt;/p&gt;
&lt;p&gt;카이로(cairo) API를 사용하는 것이 대세이긴 하지만 여기서는 간단하게 
&lt;a href=&#34;http://library.gnome.org/devel/gdk/stable/gdk-Drawing-Primitives.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GDK Drawing API&lt;/a&gt;
를 이용해서 사각형과 텍스트를 표시했습니다. 텍스트는 안티 엘리어싱(anti-aliasing) 효과 때문에 테두리가 약간 지저분하지만 그럭저럭 볼만합니다. 물론, 카이로 API를 이용하면 안티 엘리어싱 효과를 끌 수 있습니다. (그런데 gnome-osd 프로그램은 어떻게 해서 깔끔하게 나오는 건지 궁금하네요)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;** 업데이트 (2009.03.06) **&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://library.gnome.org/devel/gdk/stable/gdk-Drawing-Primitives.html#gdk-draw-layout&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gdk_draw_layout()&lt;/a&gt;
을 이용해 텍스트를 그리는 코드와 더불어 
&lt;a href=&#34;http://live.gnome.org/OutlineLabel&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;여기&lt;/a&gt;
를 참고해 카이로(cairo) 방식도 추가해 보았습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/osd-with-cairo.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>클러터(Clutter) 사용하기 (1)</title>
      <link>/2009/01/14/2009-01-14-using-clutter-1/</link>
      <pubDate>Wed, 14 Jan 2009 00:00:00 +0000</pubDate>
      <guid>/2009/01/14/2009-01-14-using-clutter-1/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://www.clutter-project.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;클러터(Clutter)&lt;/a&gt;
는 C 언어로 구현한 2D 그래픽 사용자 인터페이스 라이브러리입니다. 2D임에도 불구하고 OpenGL 또는 OpenGL ES를 렌더링에 사용하며, GLib의 GObject 기반으로 API가 구성되어 있습니다. 뭐, 소개하자면 끝이 없고, 더 궁금한 분은 공식 홈페이지를 참고하기 바랍니다. 이 글은 
&lt;a href=&#34;http://www.openismus.com/documents/clutter_tutorial/0.8/docs/tutorial/html/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;클러터 튜토리얼&lt;/a&gt;
을 중심으로 실제 사용하는 방법을 몇 차례에 나누어 정리하려 합니다. (현재 1.0 버전이 활발하게 개발 중이지만, 일단 0.8 버전을 기준으로 작성합니다)&lt;/p&gt;
&lt;p&gt;**소개 / 설치 / 컴파일
**&lt;/p&gt;
&lt;p&gt;제일 먼저, 클러터 세상에서 존재하는 몇가지 개념부터 설명해야겠군요. 첫번째로 설명할 녀석은 액터(actors)입니다. 말 그대로 배우 역할을 하는 다양한 객체입니다. 그 다음에는 스테이지(stage), 즉 무대입니다. 배우가 온갖 연기를 펼치는 공간(canvas)입니다. 클러터는 카이로(cairo) 라이브러리처럼 공간이 보여질때마다 매번 그려야 하는 방식이 아니라 모든 액터의 상태가 유지되는 방식으로, 프로그래머는 액터를 움직이거나 회전시키기만 하면 그려주는 건 클러터 라이브러리가 알아서 합니다. (부분적으로 Z축 이동도 가능합니다)&lt;/p&gt;
&lt;p&gt;3D 엔진을 사용함에도 클러터 라이브러리가 2D 라이브러리라고 표방하는 이유는 사용자 인터페이스에는 아직까지 3D 효과가 가미된 2D 인터페이스가 더 실용적이기 때문입니다. 미려한 2D 인터페이스를 쉽게 구현하도록 애니메이션과 타임라인 등과 같은 기능도 제공합니다. 그리고 임베디드 시스템에서 사용 가능하도록 OpenGL ES를 사용하기 때문에 데스크탑 뿐 아니라 다양한 플랫폼에 적용할 수 있습니다. (물론 아직까지는 리눅스 기반일 뿐입니다)&lt;/p&gt;
&lt;p&gt;클러터를 설치하는 가장 쉬운 방법은 우분투 최신 배포판을 설치하고 libclutter* 패키지를 모두 설치하는 것입니다. 아니라면 각 배포판의 패키지를 찾아보거나 홈페이지에서 언급한 방법대로 설치하시기 바랍니다. (보통 대부분의 라이브러리 설명 문서나 책은 설치에만 몇십 페이지를 할애하지만, 지금 이 글은 목적이 다르기 때문에&amp;hellip;)&lt;/p&gt;
&lt;p&gt;컴파일에 필요한 옵션은 &amp;lsquo;&lt;code&gt;pkg-config clutter-0.8 --cflags&lt;/code&gt;&amp;rsquo;, 링크에 필요한 옵션은 &amp;lsquo;&lt;code&gt;pkg-config clutter-0.8 --libs&lt;/code&gt;&amp;rsquo; 명령으로 얻을 수 있습니다. 따라서 이 내용을 적당히 Makefile이나 관련 빌드 스크립트에 추가하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;스테이지 (Stage) - 무대&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;클러터 어플리케이션은 최소한 하나의 ClutterStage 객체가 있어야 합니다. 이 스테이지는 사각형, 이미지, 텍스트와 같은 액터(actors)를 가집니다. 아이러니하게도(?) ClutterStage 객체는 ClutterActor 객체에서 파생되었습니다. 따라서 모든 GTK+ 위젯이 GtkWidget 객체를 상속받기 때문에 &lt;code&gt;gtk_widget_*()&lt;/code&gt; API를 사용할 수 있듯이, ClutterStage 객체에도 모든 &lt;code&gt;clutter_actor_*()&lt;/code&gt; API를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;클러터를 초기화하기 위해서 항상 제일 먼저 
&lt;a href=&#34;http://clutter-project.org/docs/clutter/stable/clutter-General.html#clutter-init&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;clutter_init()&lt;/code&gt;&lt;/a&gt;
을 호출합니다. 그러면 
&lt;a href=&#34;http://clutter-project.org/docs/clutter/stable/ClutterStage.html#clutter-stage-get-default&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;clutter_stage_get_default()&lt;/code&gt;&lt;/a&gt;
를 이용하여 기본 스테이지를 얻을 수 있으며, 하나의 윈도우와 연결되어 있습니다. 물론 GtkClutterEmbed 위젯을 이용하면 GTK+ 어플리케이션에서 하나의 위젯처럼 마음껏 스테이지를 사용할 수 있습니다. (하지만 실제로 마음껏은 아니고, 백엔드 엔진이 다중 스테이지를 지원하지는 여부를 &lt;code&gt;clutter_feature_available()&lt;/code&gt;를 이용해 확인해야 합니다)&lt;/p&gt;
&lt;p&gt;너무 설명이 길었군요. 마우스 버튼에 반응하는 클러터 스테이지를 한번 만들어 봅시다. (여담이지만, 튜토리얼 코드는 무조건 직접 입력해보시기 바랍니다. 가장 빨리 익숙해지는 방법입니다)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;clutter/clutter.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

static gboolean
on_stage_button_press (ClutterStage *stage, ClutterEvent *event, gpointer data)
{
  gint x = 0;
  gint y = 0;

  clutter_event_get_coords (event, &amp;amp;x, &amp;amp;y);

  g_print (&amp;quot;Stage clicked at (%d, %d)n&amp;quot;, x, y);

  return TRUE; /* 다른 핸들러가 이 이벤트를 처리하지 않게 합니다. */
}

int main(int argc, char *argv[])
{
  ClutterColor stage_color = { 0x00, 0x00, 0x00, 0xff }; /* 검정색 */

  clutter_init (&amp;amp;argc, &amp;amp;argv);

  /* 스테이지를 얻어 크기와 색상을 정합니다. */
  ClutterActor *stage = clutter_stage_get_default ();
  clutter_actor_set_size (stage, 200, 200);
  clutter_stage_set_color (CLUTTER_STAGE (stage), &amp;amp;stage_color);

  /* 스테이지를 보이게 합니다. */
  clutter_actor_show (stage);

  /* 스테이지를 마우스 버튼으로 클릭하면 처리할 시그널 핸들러를 연결합니다. */
  g_signal_connect (stage, &amp;quot;button-press-event&amp;quot;,
                    G_CALLBACK (on_stage_button_press), NULL);

  /* 메인 이벤트 루프를 시작합니다. */
  clutter_main ();

  return EXIT_SUCCESS;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;컴파일하는 방법은 다음과 같습니다. (파일 이름이 &lt;code&gt;stage.c&lt;/code&gt;일 경우)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -Wall -g stage.c -o stage `pkg-config clutter-0.8 --cflags --libs`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;뭐 싱겁지만, 이렇게 클러터 프로그래밍이 시작되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(참고)&lt;/strong&gt; 몇몇 그래픽 카드에서 Compiz 환경에서 실행시 오동작한다면 Compiz를 사용하지 않도록 설정을 변경해야 합니다. 왜냐하면 클러터도 3D 하드웨어 가속을 사용하고 Compiz도 사용하기 때문에 충돌이 발생할 수 있기 때문입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;스테이지 위젯 (Stage Widget) - GTK+ 어플리케이션 속으로&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;앞에서 잠깐 언급한 것처럼, GtkClutterEmbed 위젯은 ClutterStage 객체를 GTK+ 윈도우 안에 하나의 위젯처럼 넣을 수 있게 합니다. 
&lt;a href=&#34;http://www.clutter-project.org/docs/clutter-gtk/stable/GtkClutterEmbed.html#gtk-clutter-embed-new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;gtk_clutter_embed_new()&lt;/code&gt;&lt;/a&gt;
로 위젯을 만들어 다른 위젯처럼 컨테이너 안에 넣은 뒤, 
&lt;a href=&#34;http://www.clutter-project.org/docs/clutter-gtk/stable/GtkClutterEmbed.html#gtk-clutter-embed-get-stage&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;gtk_clutter_embed_get_stage()&lt;/code&gt;&lt;/a&gt;
로 ClutterStage 객체를 얻을 수 있습니다. 다만 GtkClutterEmbed 위젯을 사용할때는 &lt;code&gt;clutter_init()&lt;/code&gt; 대신 
&lt;a href=&#34;http://www.clutter-project.org/docs/clutter-gtk/stable/clutter-gtk-Utility-Functions.html#gtk-clutter-init&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;gtk_clutter_init()&lt;/code&gt;&lt;/a&gt;
를 호출해서 초기화해야 하고, &lt;code&gt;clutter_main()&lt;/code&gt; 대신 &lt;code&gt;gtk_main()&lt;/code&gt; 함수로 메인 루프를 실행합니다.&lt;/p&gt;
&lt;p&gt;다음 예제는 앞의 예제를 조금 확장해서 GtkClutterEmbed 위젯을 사용하고 버튼을 클릭할때마다 배경 색상을 바꿉니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;gtk/gtk.h&amp;gt;
#include &amp;lt;clutter/clutter.h&amp;gt;
#include &amp;lt;clutter-gtk/gtk-clutter-embed.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

ClutterActor *stage = NULL;

static gboolean
on_button_clicked (GtkButton *button, gpointer user_data)
{
  static gboolean already_changed = FALSE;

  if(already_changed)
    {
      ClutterColor stage_color = { 0x00, 0x00, 0x00, 0xff }; /* 검정 */
      clutter_stage_set_color (CLUTTER_STAGE (stage), &amp;amp;stage_color);
    }
  else
    {
      ClutterColor stage_color = { 0x20, 0x20, 0xA0, 0xff }; /* 파랑? */
      clutter_stage_set_color (CLUTTER_STAGE (stage), &amp;amp;stage_color);
    }

  already_changed = !already_changed;

  return TRUE; /* 다른 핸들러가 이 이벤트를 처리하지 않게 합니다. */
}

static gboolean
on_stage_button_press (ClutterStage *stage, ClutterEvent *event, gpointer user_data)
{
  gint x = 0;
  gint y = 0;

  clutter_event_get_coords (event, &amp;amp;x, &amp;amp;y);

  g_print (&amp;quot;Stage clicked at (%d, %d)n&amp;quot;, x, y);

  return TRUE; /* 다른 핸들러가 이 이벤트를 처리하지 않게 합니다. */
}

int main(int argc, char *argv[])
{
  ClutterColor stage_color = { 0x00, 0x00, 0x00, 0xff }; /* 검정색 */

  gtk_clutter_init (&amp;amp;argc, &amp;amp;argv);

  /* 윈도우와 자식 위젯을 만듭니다. */
  GtkWidget *window = gtk_window_new (GTK_WINDOW_TOPLEVEL);

  GtkWidget *vbox = gtk_vbox_new (FALSE, 6);
  gtk_container_add (GTK_CONTAINER (window), vbox);
  gtk_widget_show (vbox);

  GtkWidget *button = gtk_button_new_with_label (&amp;quot;Change Color&amp;quot;);
  gtk_box_pack_end (GTK_BOX (vbox), button, FALSE, FALSE, 0);
  gtk_widget_show (button);

  g_signal_connect (button, &amp;quot;clicked&amp;quot;,
                    G_CALLBACK (on_button_clicked), NULL);

  /* 윈도우가 닫히면 어플리케이션을 종료합니다. */
  g_signal_connect (window, &amp;quot;hide&amp;quot;,
                    G_CALLBACK (gtk_main_quit), NULL);

  /* 클러터 위젯을 만들어 넣습니다. */
  GtkWidget *clutter_widget = gtk_clutter_embed_new ();
  gtk_box_pack_start (GTK_BOX (vbox), clutter_widget, TRUE, TRUE, 0);
  gtk_widget_show (clutter_widget);

  /* 클러터 위젯 크기를 변경합니다.
   * 왜냐하면 GtkClutterEmbed 위젯을 사용할때는 직접 변경할 수 없기 때문입니다.
   */
  gtk_widget_set_size_request (clutter_widget, 200, 200);

  /* 스테이지를 얻어 크기와 색상을 정합니다. */
  stage = gtk_clutter_embed_get_stage (GTK_CLUTTER_EMBED (clutter_widget));
  clutter_stage_set_color (CLUTTER_STAGE (stage), &amp;amp;stage_color);

  /* 스테이지를 보이게 합니다. */
  clutter_actor_show (stage);

  /* 스테이지를 마우스 버튼으로 클릭하면 처리할 시그널 핸들러를 연결합니다. */
  g_signal_connect (stage, &amp;quot;button-press-event&amp;quot;,
                    G_CALLBACK (on_stage_button_press), NULL);

  /* GTK+ 윈도우를 보이게 합니다. */
  gtk_widget_show (GTK_WIDGET (window));

  /* 메인 이벤트 루프를 시작합니다. */
  gtk_main ();

  return EXIT_SUCCESS;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;컴파일하는 방법은 다음과 같습니다. (파일 이름이 &lt;code&gt;stage-embed.c&lt;/code&gt;일 경우)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcc -Wall -g stage-embed.c -o stage-embed 
    `pkg-config clutter-0.8 clutter-gtk-0.8--cflags --libs`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;뭐 싱겁지만, 이렇게 클러터 프로그래밍이 시작되었습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GTK&#43; 메모리 관리</title>
      <link>/2008/12/28/2008-12-28-gtk-memory-management/</link>
      <pubDate>Sun, 28 Dec 2008 00:00:00 +0000</pubDate>
      <guid>/2008/12/28/2008-12-28-gtk-memory-management/</guid>
      <description>&lt;p&gt;GTK+ 포럼에 
&lt;a href=&#34;http://www.gtkforums.com/viewtopic.php?t=2412&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+ 메모리 관리하기&lt;/a&gt;
라는 글이 올라왔는데 내용이 간결해서 이를 참고로 다시 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;참조 카운터 (Reference Counting)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;모든 GTK 객체는 GObject를 상속하고 있는데, GObject는 메모리 관리를 위해 참조 카운터 기능을 기본적으로 지원합니다. GObject가 새로 생성되면 참조 카운터는 1입니다. 이 참조 카운터는 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-ref&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;g_object_ref()&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;g_object_unref()&lt;/a&gt;
 함수를 이용해 증가시키거나 감소시킬 수 있습니다. 말 그대로 객체를 사용중이라면(참조하고 있다면) 참조 카운터를 증가시키면 되고, 더 이상 사용하지 않는다면(참조를 안한다면) 참조 카운터를 감소시키면 됩니다. 참조 카운터가 0이 되면 당연히 객체의 모든 리소스는 자동으로 해제됩니다. 하지만 언제나 그렇듯이 예외가 존재하는데 이런 경우 조심하지 않으면 그대로 메모리 누수가 발생하기 쉽상입니다.&lt;/p&gt;
&lt;p&gt;첫번째 경우는 객체간에 결합할 때입니다. 가장 흔한 경우가 GtkTreeModel 인터페이스를 구현한 GtkTreeStore / GtkListStore 객체와 GtkTreeView / GtkComboBox 객체를 연결할 때입니다. 예를 들어 gtk_list_store_new() 함수로 만들어진 GtkListStore 객체의 참조 카운터는 1입니다. 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkTreeView.html#gtk-tree-view-set-model&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtk_tree_view_set_model()&lt;/a&gt;
 함수로 트리뷰 객체에 리스트 스토어 객체를 연결하면 참조 카운터는 2가 됩니다. 왜냐하면 트리뷰 객체가 리스트 스토어 객체를 참조하기 때문입니다. 많은 예제 프로그램에서 이 함수를 호출한 뒤 g_object_unref() 함수를 이용해 리스트 스토어 객체의 참조 카운터를 감소하는 이유는, 이후 리스트 스토어 객체에 대한 메모리 관리를 더 이상 프로그래머가 할 필요 없이, 트리뷰 객체가 없어질때 리스트 스트어 객체의 참조 카운터를 감소하면서 자동으로 리소스가 정리되도록 하기 위해서입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;객체 복사 (Object Copying)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;두번째 경우는 객체 데이터를 저장하거나 가져올 때입니다. GtkTreeStore / GtkListStore 객체에서 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkTreeModel.html#gtk-tree-model-get&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtk_tree_model_get()&lt;/a&gt;
 함수로 데이터를 가져오거나 gtk_list_store_set() / gtk_tree_store_set() 등으로 저장할때, 즉 데이터가 복사될때는 데이터 타입이 GObject 기반이라면 참조 카운터가 증가됩니다. 이미지 데이터를 관리하는데 많이 사용하는 GdkPixbuf 객체도 그 중 하나입니다. 따라서 이러한 객체를 가져온 뒤 사용이 다 끝났다면 g_object_unref() 함수를 이용해 반드시 참조 카운터를 해제해야 합니다.  객체 속성(property)를 설정하거나 가져올때도 마찬가지로 객체 복사 규칙이 적용됩니다. 따라서 g_object_set() / g_object_get() 함수를 사용했을 때도 사용이 끝난 객체에 대한 참조 카운터를 감소해 주어야 합니다. 마찬가지로, GtkCellRenderer 객체의 속성도 동일한 규칙이 적용되므로 유의해야 합니다.&lt;/p&gt;
&lt;p&gt;참고로, 객체 복사시 정수 / 실수 타입 등은 무관하지만 문자열은 항상 새로 할당된 메모리에 복사된 문자열이 전달되기 때문에 사용이 끝나면 g_free() 함수로 해제해야 합니다. 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Boxed-Types.html#g-boxed-copy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GBoxed&lt;/a&gt;
 타입은 참조 카운터가 없기 때문에 항상 새로 할당된 메모리에 복사된 자료 구조가 전달되므로 마지막에 해당 객체의 해제 함수로 리소스를 정리해야 합니다. (
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Boxed-Types.html#G-TYPE-DATE--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;G_TYPE_DATE&lt;/a&gt;
, 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Boxed-Types.html#G-TYPE-STRV--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;G_TYPE_STRV&lt;/a&gt;
, 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Boxed-Types.html#G-TYPE-GSTRING--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;G_TYPE_GSTRING&lt;/a&gt;
, &amp;hellip;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GInitiallyUnowned 상속 객체 (Descendants of GInitiallyUnowned)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GTK 객체 중에서 GObject를 직접 상속하지 않고, GtkObject 객체를 상속받는 객체들이 있습니다. GtkWidget / GtkAdjustment / GtkCellRenderer 등이 대표적이므로, GtkWidget을 상속하는 대부분의 위젯이 이러한 객체입니다. 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkObject.html#GtkObject.object-hierarchy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkObject 상속도&lt;/a&gt;
를 보면 특이하게 GInitiallyUnowned 객체를 상속받는데 이 객체의 참조 카운터 동작 방식은 위에서 설명한 것과 조금 다르기 때문에 더 깊은 이해가 필요합니다.&lt;/p&gt;
&lt;p&gt;GInitiallyUnowned 객체는 생성되면 초기에 참조 카운터가 0입니다. 대신 부동 참조(floating reference) 상태에 있게 됩니다. 누군가가 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-ref-sink&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;g_object_ref_sink()&lt;/a&gt;
 함수를 호출하면 떠있는(floating) 참조가 참조 카운터로 변환되며 닻을 내리게(sink) 됩니다. 이후에는 일반적인 GObject 참조 카운터와 동일하게 동작합니다. 여기서 누군가는 대부분 객체를 자식(child)으로 갖는 부모(parent) 객체입니다. 즉, gtk_container_add() / gtk_box_pack_start() 등과 같은 함수를 이용하여 위젯을 결합하면 상위 위젯이 g_object_ref_sink() 함수를 호출합니다.&lt;/p&gt;
&lt;p&gt;GTK+ 프로그래밍시 위젯을 만들고 상위 위젯에 넣는 작업은 매우 빈번한데 만일 이 과정에 생성하는 모든 위젯 객체 리소스를 프로그래머가 관리해야 한다면 끔찍해질 겁니다. 부동 참조(floating reference) 개념은 이러한 수고를 덜어주는데 유용합니다. 모든 위젯은 생성 후 상위 위젯에 추가되어도 참조 카운터는 1밖에 안되고, gtk_widget_destroy() 등을 이용하여 최상위 위젯을 없애면 모든 하위 위젯 객체는 자동으로 참조 카운터가 0이 되어 메모리가 해제됩니다.&lt;/p&gt;
&lt;p&gt;참고로, 어떤  위젯을 부모 위젯에서 떼어낸 뒤 다른 부모 위젯에 넣기 위해서는 제일 먼저 해당 위젯의 참조 카운터를 증가시켜야 합니다. 왜냐하면 부모 위젯에서 떼어낼 때도 참조 카운터가 자동으로 감소하기 때문에, 떼어내는 순간 객체가 사라지기 때문입니다. 부모 위젯이 더 이상 자식 위젯을 참조 하지 않기 때문에 떼어내는 순간 자식 위젯의 참조 카운터가 감소됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;문자열 / 문자열 배열 / 리스트 (Strings, String Arrays and Lists)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GLib 라이브러리는 매우 많은 문자열 관련 API를 제공합니다. 또한 특정 객체에서 어떤 결과나 내부 자료를 얻어올때는 문자열 배열이나 리스트(GList) 등도 많이 사용합니다. 이 경우 프로그래머는 반드시 자신이 사용하는 API 문서를 꼼꼼하게 잘 읽어야 합니다. 대부분의 API 문서는 결과로 넘겨지는 데이터 사용이 끝난 뒤 어떻게 해야 하는지를 분명히 명시하고 있기 때문에 이에 따라 리소스를 처리 해야합니다.&lt;/p&gt;
&lt;p&gt;따라서 예전부터 GLib / GTK+ 프로그래밍시에는 편집기의 자동 완성 (auto-complete) 기능을 잊어버리고, 번거롭더라도 DevHelp프로그램이나 웹브라우저를 이용해 API 리퍼런스를 분명히 열람한 뒤 정확하게 API를 사용할 것을 권장하고 있습니다.&lt;/p&gt;
&lt;p&gt;만일, API 문서에 명확하게 메모리 관리 / 객체 참조 카운터 방식이 명시되지 않았거나 무언가 개운치 않다면, 해당 API 소스 코드를 참고하는 것이 가장 확실한 방법입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject Private 데이터 접근 오버헤드 줄이기</title>
      <link>/2008/12/23/2008-12-23-reduce-accesing-overhead-for-gobject-private-data/</link>
      <pubDate>Tue, 23 Dec 2008 00:00:00 +0000</pubDate>
      <guid>/2008/12/23/2008-12-23-reduce-accesing-overhead-for-gobject-private-data/</guid>
      <description>&lt;p&gt;GTK+ 개발자 메일링 리스트에서 
&lt;a href=&#34;http://mail.gnome.org/archives/gtk-devel-list/2008-December/thread.html#00061&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+ 속도 관련 질의 응답&lt;/a&gt;
이 오가는 걸 지켜보는 도중 g_type_class_add_private() + g_type_instance_get_private() 조합을 사용하면 편하지만, 오버헤드가 크고 느리기 때문에 이를 
&lt;a href=&#34;http://mail.gnome.org/archives/gtk-devel-list/2008-December/msg00072.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;줄일 수 있는 다른 방법을 소개한 내용&lt;/a&gt;
이 있어 결론만 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;그 방법은, 
&lt;a href=&#34;http://developer.gnome.org/doc/guides/programming-guidelines/binary.html#PRIVATE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;그놈 프로그래밍 가이드라인&lt;/a&gt;
에서도 명시했듯이,  객체 데이터 선언시 &amp;lsquo;priv&amp;rsquo; 등과 같은 필드를 선언하고, g_type_instance_get_private() 함수로 내부 데이터 주소를 얻어 &amp;lsquo;priv&amp;rsquo; 필드에 저장해 둡니다. 그리고 다음부터는 그 필드를  이용하여 내부 데이터(Private Data)에 직접 접근하는 방식입니다.&lt;/p&gt;
&lt;p&gt;예를 들어 기존의 코드가 다음과 같다면,&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* foo-object.h */
typedef struct _FooObject FooObject;
struct _FooObject
{
  GObject parent;
};

gint foo_object_do_something (FooObject *foo);

/* foo-object.c */
typedef struct _FooObjectPrivate FooObjectPrivate;
struct _FooObjectPrivate
{
  gboolean eating;
  gint size;
};

#define FOO_OBJECT_GET_PRIVATE(obj) 
  (G_TYPE_INSTANCE_GET_PRIVATE ((obj), 
   FOO_TYPE_OBJECT, 
   FooObjectPrivate))

static void
foo_object_class_init (FooObjectClass *klass)
{
  /* ... */
  g_type_class_add_private (G_OBJECT_CLASS (klass), 
                            sizeof (FooBarPrivate));
} 

gint
foo_object_do_something (FooObject *foo)
{
  FooObjectPrivate *priv;

  priv = FOO_OBJECT_GET_PRIVATE (foo);
  priv-&amp;gt;eating = TRUE;
  /* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음과 같이 변경하면, 매번 g_type_instance_get_private() 함수를 호출하는 오버헤드를 줄일 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* foo-object.h */
typedef struct _FooObjectPrivate FooObjectPrivate;
typedef struct _FooObject FooObject;
struct _FooObject
{
  GObject parent;
  FooObjectPrivate *priv;
};

gint foo_object_do_something (FooObject *foo);

/* foo-object.c */
struct _FooObjectPrivate
{
  gboolean eating;
  gint size;
};

#define FOO_OBJECT_GET_PRIVATE(obj) 
  (((FooObject *) (obj))-&amp;gt;priv)

static void
foo_object_class_init (FooObjectClass *klass)
{
  /* ... */
  g_type_class_add_private (G_OBJECT_CLASS (klass), 
                            sizeof (FooBarPrivate));
} 

static void
foo_object_init (FooObject *obj)
{
  /* ... */
  obj-&amp;gt;priv = 
    G_TYPE_INSTANCE_GET_PRIVATE (obj, 
                                 FOO_TYPE_OBJECT, 
                                 FooObjectPrivate);
}

gint
foo_object_do_something (FooObject *foo)
{
  FooObjectPrivate *priv;

  priv = FOO_OBJECT_GET_PRIVATE (foo);
  priv-&amp;gt;eating = TRUE;
  /* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 위에서 설명한 방식 대신 객체 초기화시 내부 데이터(private)를 아예 따로 할당해서 관리하는  방식도 비슷하지만, g_type_class_add_private() 함수를 통해 추가한 메모리는 GLib 라이브러리가 알아서 관리해주기 때문에 더 편합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ExoBinding 소개</title>
      <link>/2008/12/15/2008-12-15-exobinding/</link>
      <pubDate>Mon, 15 Dec 2008 00:00:00 +0000</pubDate>
      <guid>/2008/12/15/2008-12-15-exobinding/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://www.xfce.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Xfce&lt;/a&gt;
 프로젝트에서 사용하는 라이브러리에 포함되어 있는 
&lt;a href=&#34;http://www.xfce.org/documentation/api/exo/exo-Binding-Properties-Functions.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ExoBinding&lt;/a&gt;
 이라는 (객체)함수가 있는데, 매우 흥미로워서 소개합니다. (참고로, &amp;lsquo;
&lt;a href=&#34;http://mbarnes.livejournal.com/1899.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ExoBinding and Settings Management&lt;/a&gt;
&amp;rsquo; 블로그를 통해 알게된 내용입니다)&lt;/p&gt;
&lt;p&gt;ExoBinding 함수는 기본적으로 GObject 기반 두 객체의 속성(properties) 값을 동기화합니다. 즉, 속성을 묶는(binding) 역할을 합니다. 속성 묶음(binding)의 한쪽 속성이 바뀌면 다른쪽 속성을 자동적으로 새로운 값으로 변경합니다. 단방향(uni-directional) 뿐 아니라 상호(mutual) 바인딩도 지원하는데, 필요할 경우 변환(transform) 함수를 지정할 수도 있습니다. 또한 복수 객체가 복잡하게 묶여 있어도 무한 루프를 자동으로 제거합니다.&lt;/p&gt;
&lt;p&gt;예를 들어 (기혼자일 경우에만 배우자 이름을 입력받도록 하는 경우처럼) 사용자에게 문자열을 입력받는 GtkEntry 위젯이 있고, 이 위젯의 활성화(sensitive) 여부를 결정하는 GtkCheckButton 위젯이 있을 경우 다음과 같은 코드 한 줄이면 모든게 해결됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  GtkWidget *button;
  GtkWidget *entry;

  button = gtk_check_button_new_with_label (&amp;quot;Are you married?&amp;quot;);
  entry = gtk_entry_new ();

  exo_binding_new (G_OBJECT (button), &amp;quot;active&amp;quot;,
                   G_OBJECT (entry), &amp;quot;sensitive&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드처럼, 엔트리 위젯의 &amp;lsquo;sensitive&#39;를 체크버튼 위젯의 &amp;lsquo;active&#39;에 연결만 하면 됩니다. 시그널 핸들러를 작성해서 복잡하게 처리할 필요가 전혀 없어져 버립니다. 내부적으로 묶음(binding)에 사용한 정보는 둘 중 하나의 객체가 사라지면 자동적으로 사라지므로, 메모리 누수를 걱정할 필요도 없습니다.&lt;/p&gt;
&lt;p&gt;이 객체에 관심을 가지는 이유는 활용도가 무궁무진하기 때문입니다. 특히 복잡한 설정 화면을 만들때 여러가지 조건으로 활성화 / 비활성화, 보여주기 / 안보여주기, 같은 값으로 위젯 간 동기화 등의 기능을 시그널 핸들러와 API를 이용해 직접 코딩하면 실수도 많고 코드 분량도 많아지는데, 위 방식을 이용하면 매우 깔끔하게 처리가 가능합니다. 더 나아가 
&lt;a href=&#34;http://wiki.openmoko.org/wiki/Libgconf-bridge&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libgconf-bridge&lt;/a&gt;
처럼 GConf 설정 내용을 그대로 GObject 속성에 반영하는 라이브러리와 결합할 경우, 설정 화면 만드는 일은 더욱 더 간편해질 수 있습니다.&lt;/p&gt;
&lt;p&gt;만일 이 기능이 Glade에 통합될 수 있다면, 정말로 UI 부분만 따로 프로그래밍할 수 있는 여건이 마련될 수도 있을 것 같은데&amp;hellip; 조만간에 소스 코드를 분석해서 프로젝트에 활용할 방법을 찾아볼 예정입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GtkCellRenderer 이해하기</title>
      <link>/2008/12/01/2008-12-01-understanding-gtktreeview-cellrenderer/</link>
      <pubDate>Mon, 01 Dec 2008 00:00:00 +0000</pubDate>
      <guid>/2008/12/01/2008-12-01-understanding-gtktreeview-cellrenderer/</guid>
      <description>&lt;p&gt;GTK+ 프로그램 개발시 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkTreeView.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkTreeView&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkComboBox.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkComboBox&lt;/a&gt;
 위젯은 상당히 많이 사용함에도 불구하고, 주위를 둘러보면 그저 이미 만들어져 있는 코드를 복사 붙여넣기 식으로 개발하는 사람이 많습니다. 그래서 조금만 고급 기능(?)이 필요한 경우 어디부터 시작해야할 지 몰라 당황하는 사람이 대부분인 것 같습니다. 그래서, 이 글에서는 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkTreeView.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkTreeView&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkComboBox.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkComboBox&lt;/a&gt;
 위젯 등에서 데이터를 표시하는데 사용하는 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkCellLayout.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkCellLayout&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkCellRenderer.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkCellRenderer&lt;/a&gt;
 객체가 어떤 방식으로 동작하는지 간략하게 설명하려 합니다.&lt;/p&gt;
&lt;h3 id=&#34;gtkcellrenderers-in-gtkcelllayout-in-gtktreeview&#34;&gt;GtkCellRenderers in GtkCellLayout in GtkTreeView&lt;/h3&gt;
&lt;p&gt;먼저 GtkTreeView 위젯이 표시될때 객체가 어떻게 구성되는지 설명합니다.&lt;/p&gt;
&lt;p&gt;GtkCellRenderer 객체는 데이터 하나를 표시하는데 사용합니다. 그림 하나, 텍스트 하나, 컴보박스 하나 등등&amp;hellip; 하지만 GtkCellRenderer 객체를 GtkTreeView 같은 위젯에 바로 넣을 수는 없고, 여러 GtkCellRenderer 객체를 하나의 GtkCellLayout 객체에 넣을 수 있습니다. 그리고 다시 GtkCellLayout 객체를 GtkTreeView 객체에 넣을 수 있습니다. 이 관계를 일종의 수식으로 표현하면 아래와 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GtkCellLayout1 &amp;lt;- GtkCellRenderer1 + GtkCellRenderer2 + GtkCellRenderer3
GtkCellLayout2 &amp;lt;- GtkCellRednerer4 + GtkCellRenderer5
GtkTreeView &amp;lt;- GtkCellLayout1 + GtkCellLayout2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GtkCellLayout 객체는 GtkTreeView 위젯에 표시될때 하나의 컬럼(column)으로 표시됩니다. 사용하는 GTK+ 테마에 따라 컬럼 단위로 구분선이 그어질 수도 있고, 제목을 클릭하면 정렬(sort)하는 기능을 구현하면 컬럼 단위로 정렬됩니다. 사실 GtkCellLayout은 직접 사용할 수 있는 객체가 아니고 인터페이스(interface) 역할만 하며, 이 인터페이스를 구현한 객체를 실제로 사용합니다. 예를 들면 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkTreeViewColumn.html&#34; title=&#34;GtkTreeViewColumn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkTreeViewColumn&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkIconView.html&#34; title=&#34;GtkIconView&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkIconView&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkCellView.html&#34; title=&#34;GtkCellView&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkCellView&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkEntryCompletion.html&#34; title=&#34;GtkEntryCompletion&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkEntryCompletion&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkComboBox.html&#34; title=&#34;GtkComboBox&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkComboBox&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkComboBoxEntry.html&#34; title=&#34;GtkComboBoxEntry&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkComboBoxEntry&lt;/a&gt;
 등입니다. 따라서 위 수식은 GtkComboBox 위젯 등에도 동일하게 적용됩니다.&lt;/p&gt;
&lt;p&gt;중요한 점은 GtkCellLayout 객체는 실제로 데이터를 표시하는 객체가 아니라 일종의 컨테이너 역할만 하고, 실제로 데이터를 표시하는 작업은 GtkCellRenderer 객체가 담당한다는 점입니다. 그리고 더 중요한 사실은, 이렇게 구성할때 행(row)에 대한 레이아웃과 렌더러만 구성할 수 있다는 점입니다. 즉 GtkTreeModel 객체에 들어있는 모든 데이터를 행(row) 단위 레이아웃을 거쳐 표시합니다.&lt;/p&gt;
&lt;h3 id=&#34;gtkcellrenderer-렌더링&#34;&gt;GtkCellRenderer 렌더링&lt;/h3&gt;
&lt;p&gt;프로그래머가 GtkCellRenderer 객체를 직접 사용하는 경우는 거의 없습니다. 대부분 이를 상속한 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkCellRendererText.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkCellRendererText&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkCellRendererPixbuf.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkCellRendererPixbuf&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkCellRendererProgress.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkCellRendererProgresss&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkCellRendererToggle.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkCellRendererToggle&lt;/a&gt;
 등의 객체를 사용합니다.&lt;/p&gt;
&lt;p&gt;GtkCellRenderer 객체는 기본적으로 상태 정보가 없습니다. 대신 객체 속성(properties)을 기준으로 표시하고 프로그래머 역시 속성을 변경해서 원하는 내용을 표시합니다. GTK+ 위젯 시스템은 당연히 데이터 표시가 필요할때만  GtkCellRenderer 객체 속성을 변경해서 원하는 내용을 원하는 위치에 표시합니다.&lt;/p&gt;
&lt;p&gt;예를 들어 GtkTreeModel 객체에 100개의 행(row) 데이터가 있고, 현재 화면에는 1번째부터 10번째까지 행의 데이터만 표시된다고 가정하면 GTK+는 먼저 첫번째 행의 데이터에 대하여 모든 레이아웃, 다시 레이아웃의 모든 렌더러에게 데이터를 표시할 좌표를 알려주고, 렌더러의 속성을 트리모델의 데이터 값으로 변경합니다. 그러면 렌더러는 속성이 변경되었므로 그 속성에 따라 내용을 표시합니다. 그리고 2번째 행으로 이동해 동일한 작업을 수행합니다. 이 작업을 화면에 보이는 10번째 행까지만 반복합니다. 참고로, 이 작업은 EXPOSE 이벤트나 스크롤 이벤트가 발생했을 경우에도 필요한 영역의 데이터만 표시하기 위해 동일하게 동작합니다.&lt;/p&gt;
&lt;p&gt;이제 무심코 사용하는 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkTreeViewColumn.html#gtk-tree-view-column-new-with-attributes&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtk_tree_view_column_new_with_attributes()&lt;/a&gt;
 API를 한번 분석해 봅시다. 문서에서는 다음과 같이 설명하고 있습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Creates a new 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkTreeViewColumn.html&#34; title=&#34;GtkTreeViewColumn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkTreeViewColumn&lt;/a&gt;
 with a number of default values. This is equivalent to calling 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkTreeViewColumn.html#gtk-tree-view-column-set-title&#34; title=&#34;gtk_tree_view_column_set_title ()&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;gtk_tree_view_column_set_title()&lt;/code&gt;&lt;/a&gt;
, 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkTreeViewColumn.html#gtk-tree-view-column-pack-start&#34; title=&#34;gtk_tree_view_column_pack_start ()&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;gtk_tree_view_column_pack_start()&lt;/code&gt;&lt;/a&gt;
, and 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkTreeViewColumn.html#gtk-tree-view-column-set-attributes&#34; title=&#34;gtk_tree_view_column_set_attributes ()&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;gtk_tree_view_column_set_attributes()&lt;/code&gt;&lt;/a&gt;
 on the newly created 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkTreeViewColumn.html&#34; title=&#34;GtkTreeViewColumn&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkTreeViewColumn&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s a simple example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; enum { TEXT_COLUMN, COLOR_COLUMN, N_COLUMNS };
 ...
 {
   GtkTreeViewColumn *column;
   GtkCellRenderer   *renderer = gtk_cell_renderer_text_new ();

   column = gtk_tree_view_column_new_with_attributes (&amp;quot;Title&amp;quot;,
                                                      renderer,
                                                      &amp;quot;text&amp;quot;, TEXT_COLUMN,
                                                      &amp;quot;foreground&amp;quot;, COLOR_COLUMN,
                                                      NULL);
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|
| &lt;em&gt;&lt;code&gt;title&lt;/code&gt; :&lt;/em&gt; |
| &lt;em&gt;&lt;code&gt;cell&lt;/code&gt;&lt;/em&gt; :  |
| &lt;em&gt;&lt;code&gt;...&lt;/code&gt;&lt;/em&gt; :   |
| &lt;em&gt;Returns&lt;/em&gt; : |&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;기본값으로 GtkTreeViewColumn 객체를 만드는데, 이는 gtk_tree_view_column_new()로 새로운 객체를 만들고gtk_tree_view_column_set_title()로 제목을 정한 다음, gtk_tree_view_colunn_pack_start()로 렌더러를 추가한 뒤, gtk_tree_view_column_set_attributes()로 어트리뷰트를 설정한다고 되어있습니다.&lt;/p&gt;
&lt;p&gt;여기서 말하는 어트리뷰트(attribute)는, 위 예제에서 보는 것처럼, 렌더러의 속성(property)과(&amp;ldquo;text&amp;rdquo;, &amp;ldquo;foreground&amp;rdquo;), 트리모델에서 해당 데이터가 위치한 컬럼 번호(TEXT_COLUMN, COLOR_COLUMN)로 구성됩니다. 즉, 앞서 설명한 루프 작업시 어트리뷰트 정보를 이용해 렌더러의 속성을 트리모델의 해당 컬럼 데이터를 가져와서 매번 g_object_set() API를 이용해 설정하면 렌더러가 해당 좌표에 표시하게 됩니다.&lt;/p&gt;
&lt;h3 id=&#34;gtkcellrenderer-advanced&#34;&gt;GtkCellRenderer Advanced?&lt;/h3&gt;
&lt;p&gt;모든 GtkCellRenderer 객체가 반드시 어트리뷰트 방식으로 동작할 필요는 없습니다. 예를 들어 컴보박스에 표시되는 텍스트 앞에 동일한 아이콘을 표시하기 위해 굳이 트리모델에 새로운 컬럼을 추가할 필요는 없습니다. 다만 다음과 같은 방식으로 텍스트 렌더러를 추가하기 전에 처리해주면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;c = gtk_cell_renderer_pixbuf_new ();
g_object_set (G_OBJECT (c), &amp;quot;stock-id&amp;quot;, GTK_STOCK_HARDDISK, NULL);
gtk_tree_view_column_set_pack_start (treeview_column, c, FALSE);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 위 예제에서는 &amp;ldquo;stock-id&amp;rdquo; 속성을 사용했지만, 당연히 다른 속성을 사용해도 됩니다.&lt;/p&gt;
&lt;p&gt;또한 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/GtkCellLayout.html#gtk-cell-layout-set-cell-data-func&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtk_cell_layout_set_cell_data_func()&lt;/a&gt;
 함수를 이용하면, 렌더러 실행시 호출할 함수를 등록할 수 있습니다. 따라서 반드시 트리모델 데이터 뿐 아니라 외부 데이터나 조건을 기준으로 렌더러의 속성을 가공할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 GtkComboBox를 이용해 트리구조 데이터를 서브메뉴 방식으로 표시하다보면, 기본적으로 서브메뉴 위에 상위 항목이 제목처럼 선택할 수 있게 표시됩니다. 이 항목이 불필요한 경우가 있는데, 다음과 같은 코드를 사용하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void
combo_box_cell_data_func(GtkCellLayout   *cell_layout,
                         GtkCellRenderer *cell,
                         GtkTreeModel    *tree_model,
                         GtkTreeIter     *iter,
                         gpointer        data)
{
  gboolean sensitive;
  sensitive = !gtk_tree_model_iter_has_child (tree_model, iter);
  g_object_set (cell, &amp;quot;sensitive&amp;quot;, sensitive, NULL);
}

...
gtk_cell_layout_set_cell_data_func (GTK_CELL_LAYOUT (combobox),
                                    renderer,
                                    combo_box_cell_data_func,
                                    NULL, NULL);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제, 다른 어플리케이션 소스나 GTK+ 문서를 한번 정독하면 GtkTreeView / GtkComboBox 위젯을 다루는 작업은 더이상 어렵지 않을까요?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GTK&#43; / GLib 경고 메시지 추적하기</title>
      <link>/2008/11/14/2008-11-14-tracing-gtk-glib-warning-messages/</link>
      <pubDate>Fri, 14 Nov 2008 00:00:00 +0000</pubDate>
      <guid>/2008/11/14/2008-11-14-tracing-gtk-glib-warning-messages/</guid>
      <description>&lt;p&gt;GTK+ 또는 GLib 기반 프로그래밍을 할때 g_warning() / g_return_if_fail() 등과 같은 API를 사용한 경고 메시지가 어디서 발생했는지 찾기 어려운 경우가 있습니다. 더 나아가 해당 함수를 호출하는 부분을 알아야 하는데, 사실 메시지만으로는 찾기가 매우 어려운 경우가 많습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 수만라인짜리 프로그램이 실행 도중 다음과 같은 메시지를 출력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Gtk-CRITICAL **: gtk_widget_set_sensitive: 
assertion `GTK_IS_WIDGET (widget)&#39; failed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;아, gtk_widget_set_sensitive() 함수를 호출할때 첫번째 인수를 잘못 넘겨준 건 알겠는데, 문제는 gtk_widget_set_sensitve() 함수를 호출하는 부분이 수십군데입니다. 마땅히 실행 도중이라 어떤 모듈에서 호출하는지도 애매합니다. 다음에 설명할 방법을 모른다면, 리누스 토발즈의 말 그대로, 모든 소스 코드를 직접 검토할 수 밖에 없죠&amp;hellip;&lt;/p&gt;
&lt;p&gt;만일 이 메시지가 발생하는 시점에서 gdb의 backtrace 명령으로 함수 호출 스택을 알아낼 수 있다면 인생은 편해집니다. 그리고 이를 위해 GLib에는 당연하다는듯이 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Message-Logging.html#g-log-set-always-fatal&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;g_log_set_always_fatal()&lt;/a&gt;
 이라는 API가 존재합니다. 이 API는 설정하는 레벨의 로그 메시지가 발생하면 강제로 코어 덤프를 발생하고 프로그램 실행을 중지합니다. gdb에서 동작할 경우 해당 지점에서 정확하게 멈춥니다.&lt;/p&gt;
&lt;p&gt;위 예에서 우리가 원하는 레벨은 CRITICAL 레벨인 경우이므로 다음 코드를 프로그램 시작 부분에 넣어주면 위 메시지가 출력되는 시점에서 정확하게 프로그램이 멈추게 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;g_log_set_always_fatal (G_LOG_LEVEL_ERROR |
                        G_LOG_LEVEL_CRITICAL);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 gdb에서 backtrace 명령을 실행하면, 정확하게 문제를 일으키는 코드를 찾아낼 수 있겠죠?&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GLib 쓰레드 프로그래밍</title>
      <link>/2008/08/06/2008-08-06-glib-thread-programming/</link>
      <pubDate>Wed, 06 Aug 2008 00:00:00 +0000</pubDate>
      <guid>/2008/08/06/2008-08-06-glib-thread-programming/</guid>
      <description>&lt;p&gt;소프트웨어를 개발하면서 멀티 쓰레드 방식을 사용하는 경우는 많습니다. 하지만 그만큼 복잡도가 증가해서 세심하게 고려하여 설계하지 않으면 디버깅 재앙을 얻는 경우가 많습니다. 이 글은 &amp;lsquo;
&lt;a href=&#34;/2008/12/28/gtk-memory-management/&#34;&gt;멀티쓰레드 프로그래밍 규칙&lt;/a&gt;
&amp;lsquo;에서 이어지는 내용입니다. 
&lt;a href=&#34;/2006/01/20/multi-thread-gtk-programming/&#34;&gt;GTK+ 쓰레드 관련 잡설&lt;/a&gt;
은 이미 언급한 적이 있으니까, 오늘은 별도의 쓰레드로 동작하는 간단한 예제 모듈을 만들면서 몇가지 유용한 GLib 쓰레드 API를 설명하겠습니다.&lt;/p&gt;
&lt;h3 id=&#34;리소스-resources&#34;&gt;리소스 (Resources)&lt;/h3&gt;
&lt;p&gt;한 개 이상의 쓰레드가 동작하는 방식의 소프트웨어를 설계할 경우 가장 염두에 두어야 하는 점은 **자원(resources)**입니다. 자원, 즉 리소스는 쉽게 말해 소프트웨어가 사용하는 데이터를 의미합니다. 전역 변수, 디스크 파일, 네트웍 소켓, 외부 장치 심지어 비디오 카드 같은 그래픽 장치 등이 모두 리소스입니다. 물론 넓은 의미에서 보면 리소스는 하나의 기능이나 세부 작업을 나타낼 수도 있습니다.&lt;/p&gt;
&lt;p&gt;멀티쓰레드 프로그래밍에서 가능한 지켜야 하는 가장 중요한 원칙은 &amp;lsquo;&lt;strong&gt;하나의 쓰레드만 하나의 리소스에 접근할 수 있어야 한다&lt;/strong&gt;&amp;lsquo;입니다. 아무 생각없이 하나의 리소스에 여러 쓰레드가 동시에 접근하도록 설계할 경우, 어쩔 수 없이 뮤텍스(mutex) 계열 API를 이용해 접근할 때마다 임계 구역을 보호해야 합니다. 그리고 이러한 기법은 소스 코드가 복잡해지고 커질수록 버그가 많아지고, 디버깅도 점점 어려워집니다. 물론, 쓰레드-풀(thread-pool) 기법처럼 성능 최적화나 확장성을 위해 멀티쓰레드를 사용하는 경우처럼 예외도 사실 많지만, 일단 이 글에서는 무시합니다.&lt;/p&gt;
&lt;p&gt;앞서 예를 들었던 GTK+ 쓰레드 프로그래밍도 리소스 관점에서 보면, 무조건 모든 쓰레드에서 GTK+ / GDK API 호출 전후에 gdk_threads_*() 계열 API를 남용해서 지독한 데드락과 이중락에 고생하던가, 아니면 GTK+ / GDK API 호출을 메인 쓰레드에서만 호출하도록 g_idle_add() / g_timeout_add() API만 이용하는 방법이 있습니다. 두번째 방법을 모델-뷰(Model-View) 개념으로 생각하면 마지막 GTK+ / GDK API 호출을 뷰(view) 갱신으로 볼 수 있고, g_idle_add() 계열 API는 일종의 메시지 전달로 생각할 수도 있습니다. (참고로 Sentry24DVR 2.x 버전은 첫번째 방식을, Sentry24CMS 2.x 버전은 두번째 방식을 사용합니다)&lt;/p&gt;
&lt;h3 id=&#34;쓰레드-시작--정지--실행&#34;&gt;쓰레드 시작 / 정지 / 실행&lt;/h3&gt;
&lt;p&gt;가장 먼저 쓰레드를 만들고 종료하는 루틴을 만들어 봅시다. 편의상 모듈 이름은 &amp;lsquo;drink&#39;라고 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;glib.h&amp;gt;

typedef struct _Drink Drink;
struct _Drink
{
  GThread *thread;
  gint running;
  GAsyncQueue *queue;
  gchar *host;
  gint port;
};

static gpointer
drink_process (gpointer data)
{
  Drink *drink = data;

  while (g_atomic_int_get (&amp;amp;drink-&amp;gt;running))
    {
      // do something...
    }

  return NULL;
}

Drink *
drink_new (const gchar *host, gint port)
{
  Drink *drink;

  g_return_val_if_fail (host != NULL, NULL);
  g_return_val_if_fail (port &amp;gt; 0, NULL);

  drink = g_new (Drink, 1);
  drink-&amp;gt;host = g_strdup (host);
  drink-&amp;gt;port = port;
  drink-&amp;gt;queue = g_async_queue_new ();

  g_atomic_int_set (&amp;amp;drink-&amp;gt;running, 1);
  drink-&amp;gt;thread = g_thread_new (drink_process, drink, TRUE, NULL);

  return drink;
}

void
drink_destroy (Drink *drink)
{
  g_return_if_fail (drink != NULL);

  g_atomic_int_set (&amp;amp;drink-&amp;gt;running, 0);
  g_thread_join (drink-&amp;gt;thread);

  g_async_queue_unref (disk-&amp;gt;queue);
  g_free (drink-&amp;gt;host);
  g_free (drink);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;drink_new() 함수는 지정한 호스트 / 포트 번호를 이용하여 새로운 Drink 객체를 만듭니다. 그리고 앞으로 나올 모든 데이터는 각각 자신이 속한 Drink 객체만 접근합니다. 즉, Drink 객체를 하나의 리소스로 여기면 됩니다. drink_destroy() 함수는 쓰레드가 종료할때까지 기다렸다가 Drink 객체를 해제하고 마무리합니다.&lt;/p&gt;
&lt;p&gt;쓰레드 함수 무한 루프는 간단하게 정수형 변수를 플래그처럼 사용합니다. 제대로 하려면 플래그 변수 역시 뮤텍스 API로 보호해주어야 하지만 대부분의 경우 간단한 원자연산자(atomic operator)로 처리가 가능합니다. 일단 이렇게 만들어 둡시다.&lt;/p&gt;
&lt;p&gt;마지막으로 설명할 API가 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Asynchronous-Queues.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GAsyncQueue&lt;/a&gt;
 객체인데, 가장 중요한 역할을 담당하는 물건입니다. 설명 그대로 이 API는 쓰레드간 비동기 통신(asynchronous communication between threads)을 하는데 사용합니다. 이 객체를 생성하는데는 g_async_queue_new(), 없애기 위해서는 g_async_queue_unref() 함수를 이용하는데, 일단 지금은 만들어만 놓습니다.&lt;/p&gt;
&lt;h3 id=&#34;api-추가--메시지-전달&#34;&gt;API 추가 + 메시지 전달&lt;/h3&gt;
&lt;p&gt;제일 먼저 하고 싶은 일은 미리 지정한 서버에 TCP 연결을 하거나, 끊고 싶습니다. 이를 비동기큐를 이용해서 간단하게 구현해 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum
{
  DRINK_MSG_CONNECT = 1,
  DRINK_MSG_SHUTDOWN = 2,
};

void
drink_connect (Drink *drink)
{
  g_return_if_fail (drink != NULL);

  g_async_queue_push (drink-&amp;gt;queue,
                      GINT_TO_POINTER (DRINK_MSG_CONNECT));
}

void
drink_shutdown (Drink *drink)
{
  g_return_if_fail (drink != NULL);

  g_async_queue_push (drink-&amp;gt;queue,
                      GINT_TO_POINTER (DRINK_MSG_SHUTDOWN));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이렇게 하면 drink_connect() / drink_shutdown() 함수를 호출하면 g_async_queue_push() 함수를 이용해 메시지를 큐에 넣기만 하고 아무 일도 안합니다. (참고 : 모듈 외부에서 볼때는 내부 구현에 쓰레드를 사용하는지, 메시지 큐를 이용하는지 등은 공개되지도 않고, 공개할 필요도 없습니다) 이제 drink_process() 함수를 다음과 같이 수정합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static gpointer
drink_process (gpointer data)
{
  Drink *drink = data;

  while (g_atomic_int_get (&amp;amp;drink-&amp;gt;running))
    {
      do {
        GTimeVal tval;
        gpointer msg;

        /* wait for messages */
        g_get_current_time (&amp;amp;tval);
        g_timeval_add (&amp;amp;tval, 10000); /* 10msec */
        msg = g_async_queue_timed_pop (drink-&amp;gt;queue, &amp;amp;tval);
        if (!msg)
          break;

        switch (GPOINTER_TO_INT (msg))
          {
          case DRINK_MSG_CONNECT:
            // do connect work...
            break;
          case DRINK_MSG_SHUTDOWN:
            // do shutdown work...
            break;
          default:
            g_warning (&amp;quot;unknown drink msg&amp;quot;);
            break;
          }
      } while (1);

      // do something else ...
    }

  return NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;보는 바와 같이 메시지 큐에서 메시지를 꺼내어 메시지에 해당하는 작업을 처리합니다. 만일 메시지 큐를 사용하지 않고 drink_connect() 함수에서 직접 연결 작업을 수행하면 쓰레드 부분과 공유하는 부분을 모두 뮤텍스로 보호해야 하지만 이처럼 모든 작업을 담당 쓰레드가 처리하도록 메시지만 전송하면 실행 순서도 맞고 쓰레드가 자료 공유를 걱정할 필요도 없게 됩니다.&lt;/p&gt;
&lt;p&gt;여기서 사용한 g_async_queue_timed_pop() 함수는 지정한 시간 동안 아무 메시지도 없으면 NULL을 돌려줍니다. 비슷한 함수로 g_async_queue_pop() 함수는 메시지가 올때까지 무한정 기다랍니다. g_async_queue_try_pop() 함수는 메시지가 없을 경우 바로 NULL을 돌려줍니다. 만일 쓰레드 함수 자체적인 작업은 없고 100% 외부에서 메시지가 올때만 작업이 수행된다면 g_async_queue_pop() 함수를 사용하는 것이 더 좋습니다. 프로세스 동기화나 수면 상태(sleep) 등을 다른 작업을 하면서 자체적으로 하는 경우라면 g_async_queue_try_pop() 함수가 유용합니다.&lt;/p&gt;
&lt;p&gt;이 예제에서는 단순하게 10 밀리초 여유를 두고 메시지를 확인하고, 그외 다른 작업을 처리하도록 했습니다.&lt;/p&gt;
&lt;h3 id=&#34;쓰레드-종료-다듬기&#34;&gt;쓰레드 종료 다듬기&lt;/h3&gt;
&lt;p&gt;예제 처음에 있던 쓰레드 종료 코드가 너무 단순해서 조금 불안할 지도 모르겠네요. 메시지 큐에 데이터가 있을때 종료되면 메모리 누수도 있을 것 같고&amp;hellip; 그래서 쓰레드 종료도 하나의 메시지로 처리하도록 하려고 합니다. 수정하는 부분은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enum
{
  DRINK_MSG_STOP_THREAD = -1,
  DRINK_MSG_CONNECT = 1,
  DRINK_MSG_SHUTDOWN = 2,
};

static gpointer
drink_process (gpointer data)
{
  Drink *drink = data;

  while (TRUE)
    {
      GTimeVal tval;
      gpointer msg;

      /* wait for messages */
      g_get_current_time (&amp;amp;tval);
      g_timeval_add (&amp;amp;tval, 10000); /* 10msec */
      msg = g_async_queue_timed_pop (drink-&amp;gt;queue, &amp;amp;tval);
      if (msg)
        {
          if (msg == GINT_TO_POINTER (DRINK_MSG_STOP_THREAD)) break;

          switch (GPOINTER_TO_INT (msg))
            {
            case DRINK_MSG_CONNECT:
              // do connect work...
              break;
            case DRINK_MSG_SHUTDOWN:
              // do shutdown work...
              break;
            default:
              g_warning (&amp;quot;unknown drink msg&amp;quot;);
              break;
            }
        }

      // do something else ...
    }

void
drink_destroy (Drink *drink)
{
  g_return_if_fail (drink != NULL);

  g_async_queue_push (drink-&amp;gt;queue, GINT_TO_POINTER (DRINK_MSG_STOP_THREAD));
  g_thread_join (drink-&amp;gt;thread);

  g_async_queue_unref (disk-&amp;gt;queue);
  g_free (drink-&amp;gt;host);
  g_free (drink);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;쓰레드 함수 무한루프 조건문이 조금 변경되었을 뿐 기본적인 원리는 동일합니다.&lt;/p&gt;
&lt;h3 id=&#34;마지막-조금-더-개선&#34;&gt;마지막, 조금 더 개선&amp;hellip;&lt;/h3&gt;
&lt;p&gt;이놈의 메시지 방식을 사용하면 대부분 프로그래머는 쉽게 switch() 문의 유혹을 떨쳐버리지 못합니다. 근데, 만일 당신이 매우 성능 좋은 메시징 서비스를 만들고 있다면 이런 방식의 코드는 유지보수도 힘들고 성능도 나쁠 수 있습니다. 메시지-함수 테이블을 유지해도 되고, 여러가지 방법이 있겠지만 여기서는 약간 가독성(readability)과 유지보수에 중점을 둔 방식을 설명하려 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct _DrinkMsg DrinkMsg;
struct _DrinkMsg
{
  void (*func) (Drink *drink, gpointer data1, gpointer data2);
  gpointer data1;
  gpointer data2;
};

static gpointer
drink_process (gpointer data)
{
  ...
  DrinkMsg *msg;

  msg = g_async_queue_try_pop (drink-&amp;gt;queue);
  if (msg)
    {
      if (msg == GINT_TO_POINTER (-1))
        break;
      msg-&amp;gt;func (drink, msg-&amp;gt;data1, msg-&amp;gt;data2);
      g_slice_free1 (msg);
    }
  ...
}

void
drink_destroy (Drink *drink)
{
  ...
  g_async_queue_push (drink-&amp;gt;queue, GINT_TO_POINTER (-1));
  g_thread_join (drink-&amp;gt;thread);
  ...
}

static void
drink_connect_real (Drink *drink, gpointer data1, gpointer data2)
{
  gchar *host = data1;
  gint port = GPOINTER_TO_INT (data2);

  // do connect work...

  g_free (host);
}

void
drink_connect (Drink *drink, const gchar *host, gint port)
{
  DrinkMsg *msg;

  msg = g_slice_new (DrinkMsg);
  msg-&amp;gt;func = drink_connect_real;
  msg-&amp;gt;data1 = g_strdup (host);
  msg-&amp;gt;data2 = GINT_TO_POINRTER (port);
  g_async_queue_push (drink-&amp;gt;queue, msg);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;뭐&amp;hellip; 더 이상의 설명은 피곤해서&amp;hellip;&lt;/p&gt;
&lt;p&gt;궁금한 API는 직접 매뉴얼을 한 번 뒤져보시길&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Glade 카탈로그 작성 / 설치하기</title>
      <link>/2008/07/24/2008-07-24-glade-catalog/</link>
      <pubDate>Thu, 24 Jul 2008 00:00:00 +0000</pubDate>
      <guid>/2008/07/24/2008-07-24-glade-catalog/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://glade.gnome.org/docs/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;글레이드(Glade) 매뉴얼&lt;/a&gt;
에서 
&lt;a href=&#34;http://glade.gnome.org/docs/catalog.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;카탈로그(Catalog)&lt;/a&gt;
 소개 부분을 날림 번역한 내용입니다.&lt;/p&gt;
&lt;h3 id=&#34;소개-introduction&#34;&gt;소개 (Introduction)&lt;/h3&gt;
&lt;p&gt;사용자 위젯은 여러 방법으로 지원할 수 있는데, 패키지를 만들어 이를 시스템 디렉토리에 설치하거나, 사용자 디렉토리 또는 프로젝트 디렉토리에서 직접 추가적인 카탈로그를 읽어들일 수 있습니다. 라이브러리에 보이는 객체 종류(object type)를 나타내기 위해 필요한 아이콘(icons)을 지원하는 코드를 만들수도 있고, 다음에 설명할 부모(parent) 속성(property)을 이용하여 처리할 수도 있습니다. 인스펙터(inspector)와 팔레트(pallette)가 사용할 아이콘을 제공하지 않으면 글레이드는 단순하게 경고 메시지를 출력하고 기본 아이콘을 사용합니다. 카탈로그 파일은 XML 형식으로 작성되며, DTD 파일은 글레이드 압축파일에서 plugins/ 디렉토리에서 찾을 수 있습니다.
대부분의 경우 GTK+ 파생 위젯은 적은 노력으로 추가할 수 있으며 간단하게 위젯 종류를 명시하는 것으로 충분합니다. 글레이드는 속성(properties)과 시그널(signals)을 조사합니다(introspection). 하지만 위젯 툴킷 구조상의 본질로 인해 예외는 있습니다. 이 문서는 몇가지 기본 예제와 UI 편집을 강화하고 예외를 처리하는데 사용할 수 있는 풍부한 옵션을 제공할 것입니다.&lt;/p&gt;
&lt;p&gt;카탈로그 파일은 카탈로그 이름과 사용할 플러그인 라이브러리를 지정하면서 시작합니다. 다음 예제에서는 &amp;ldquo;Foo&amp;quot;라는 이름공간(namespace)을 가지면서 &amp;ldquo;Frobnicator&amp;rdquo; 객체를 통합한다고 가정합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;glade-catalog name=&amp;quot;foo&amp;quot; library=&amp;quot;foo&amp;quot; depends=&amp;quot;gtk+&amp;quot;&amp;gt;
  &amp;lt;init-function&amp;gt;my_catalog_init&amp;lt;/init-function&amp;gt;
  &amp;lt;glade-widget-classes&amp;gt;
    &amp;lt;glade-widget-class name=&amp;quot;FooFrobnicator&amp;quot;
                        generic-name=&amp;quot;frobnicator&amp;quot;
                        title=&amp;quot;Frobnicator&amp;quot;/&amp;gt;
    ... widget classes go here
  &amp;lt;/glade-widget-classes&amp;gt;
  &amp;lt;glade-widget-group name=&amp;quot;foo&amp;quot; title=&amp;quot;Foo&amp;quot;&amp;gt;
    &amp;lt;glade-widget-class-ref name=&amp;quot;FooFrobnicator&amp;quot;/&amp;gt;
    ... widget class references go here
  &amp;lt;/glade-widget-group&amp;gt;
  ... widget groups go here
&amp;lt;/glade-catalog&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;최상위-카탈로그-속성과-태그-toplevel-catalog-properties-and-tags&#34;&gt;최상위 카탈로그 속성과 태그 (Toplevel catalog properties and tags)&lt;/h3&gt;
&lt;p&gt;카탈로그를 정의할때 &amp;lsquo;glade-catalog&amp;rsquo; 태그의 &amp;lsquo;name&amp;rsquo;, &amp;lsquo;library&amp;rsquo; 속성은 반드시 정의되어야 합니다. &amp;lsquo;icon-prefix&amp;rsquo;, &amp;lsquo;depends&amp;rsquo;, &amp;lsquo;domain&amp;rsquo; 속성은 선택사항입니다.&lt;/p&gt;
&lt;p&gt;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;-|
| &lt;span class=&#34;term&#34;&gt;name&lt;/span&gt;          | 카탈로그 문자열 식별자, 카탈로그를 식별하는데 사용하며 카탈로그간 의존성을 관리하는데 필요합니다.                                                                                                                                                                                                                                                           |
| &lt;span class=&#34;term&#34;&gt;version&lt;/span&gt;       | &amp;lsquo;major.minor&amp;rsquo; 형식의 버전 설명. ([예] &lt;code&gt;version=&amp;quot;1.0&amp;quot;&lt;/code&gt;) 동작하기 위한 버전을 검사하는데 필요하지만, 선택사항입니다.                                                                                                                                                                                                                                          |
| &lt;span class=&#34;term&#34;&gt;targetable&lt;/span&gt;    | 쉼표(comma)로 구분하는 &amp;lsquo;major.minor&amp;rsquo; 형식 버전 목록. 현재 버전 이전 중에서 지원하는 버전을 명시합니다.                                                                                                                                                                                                                                                      |
| &lt;span class=&#34;term&#34;&gt;icon-prefix&lt;/span&gt;   | 위젯의 아이콘 이름을 구성하는데 사용. 이 속성의 기본값은 &amp;lsquo;name&amp;rsquo; 속성 값을 사용합니다.                                                                                                                                                                                                                                                                       |
| &lt;span class=&#34;term&#34;&gt;library&lt;/span&gt;       | 형식(type)을 읽어들이고 속성(properties)을 조사하는데 사용. 글레이드가 이 라이브러리를 로드하는데 사용하는데, 위젯을 포함하는 라이브러리 이름일 수도 있고 위젯 라이브러리에 암묵적으로 링크되는 플러그인 라이브러리 이름일 수도 있습니다. 이 라이브러리는 사용자가 지정한 경로나 시스템 플러그인 디렉토리(&lt;code&gt;$prefix/lib/glade-3/modules/)&lt;/code&gt;에서 읽어들입니다. |
| &lt;span class=&#34;term&#34;&gt;depends&lt;/span&gt;       | 지 원 코드 상속이 제대로 동작하는데 사용. 즉, 객체가 GTK+ 라이브러리 객체에서 파생한다면 위젯을 가능하도록 하기 위해 gladegtk 플러그인의 기본 지원 코드를 사용합니다. 이 속성은 설치된 다른 글레이드 플러그인의 &amp;lsquo;name&amp;rsquo; 속성입니다. 대개는 &amp;lsquo;depends=&amp;quot;gtk+&amp;rdquo;&amp;lsquo;를 사용할 것입니다.                                                                               |
| &lt;span class=&#34;term&#34;&gt;domain&lt;/span&gt;        | 번역 문자열을 검색하는데 사용할 도메인. 카탈로그의 모든 문자열은 이 도메인을 이용해 번역되어 표시됩니다. 지정하지 않으면 &amp;lsquo;library&amp;rsquo; 속성을 사용합니다.                                                                                                                                                                                                       |
| &lt;span class=&#34;term&#34;&gt;book&lt;/span&gt;          | devhelp 문서 라이브러리를 검색하는데 사용할 이름공간을 지정. (특히, gtk-doc Makefile.am 파일에서 $(DOC_MODULE) 항목으로 지정된 이름).                                                                                                                                                                                                                      |
| &lt;span class=&#34;term&#34;&gt;init-function&lt;/span&gt; | 플러그인 전역 시작점을 가져오는데 사용. 백엔드(backend) 초기화 등에 사용하며, 위젯 클래스 인스턴스가 생성되기 전에 호출됩니다.                                                                                                                                                                                                                              |&lt;/p&gt;
&lt;h3 id=&#34;확인하기-설치하기-validating-and-installing&#34;&gt;확인하기/ 설치하기 (Validating and installing)&lt;/h3&gt;
&lt;p&gt;글레이드와 함께 설치되는 DTD 파일은 카탈로그 파일을 검사하는데 사용할 수 있습니다. 유의할 점은 속성(properties)이 DTD에 정의된 것과 같은 순서로 입력되어야합니다.&lt;/p&gt;
&lt;p&gt;파일을 검사하려면 다음과 같이 합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;xmllint --dtdvalid glade-catalog.dtd --noout my-catalog.xml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위젯 플러그인을 설치하기 위해서는 먼저 카탈로그 XML 파일을 카탈로그 디렉토리에 복사해야 합니다. 이 디렉토리는 다음과 같이 얻을 수 있습니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pkg-config --variable=catalogdir gladeui-1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;팔레트에 사용하는 아이콘은 pixmap 디렉토리에 들어갑니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pkg-config --variable=pixmapdir gladeui-1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;플러그인 라이브러리는 modules 디렉토리에 설치되어야 합니다:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pkg-config --variable=moduledir gladeui-1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;환경변수에 추가 경로를 지정함으로써 사용자 디렉토리에서 카탈로그를 읽어들 수도 있습니다. 예를 들면:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GLADE_CATALOG_PATH=~/mycatalogs:~/work/foo/glade
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;같은 방식으로 플러그인 라이브러리 경로도 지정할 수 있습니다::&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GLADE_MODULE_PATH=~/work/foo/src
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;설치하지 않은 아이콘 읽어들이기는 아직 지원하지 않습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GtkTreeModel 확장하기</title>
      <link>/2008/07/15/2008-07-15-leveraging-gtktreemodel/</link>
      <pubDate>Tue, 15 Jul 2008 00:00:00 +0000</pubDate>
      <guid>/2008/07/15/2008-07-15-leveraging-gtktreemodel/</guid>
      <description>&lt;p&gt;GTK+ 프로그래밍에서 많이 사용하는 GtkTreeModel(GtkListStore / GtkTreeStore)에는 일반적으로 데이터(객체)에서 표시할 내용만 추가해서 사용합니다. 따라서 실제로 데이터가 변경되면 그때마다 GtkTreeModel 내용을 변경해주어야 합니다.(일종의 동기화) 하지만 이러한 프로그래밍 방식은 매우 귀찮고 개발 시간도 오래 걸리는 것은 물론 런타임 오버헤드도 발생할 수 밖에 없습니다. 아예 GtkTreeModel에서 하나의 컬럼에 데이터(객체)를 넣고 관리하는 방법도 있지만, 이 역시 이러한 오버헤드와 비효율은 피할 수 없습니다.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://davyd.livejournal.com/252351.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;leveraging GtkTreeModel&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;위 글에서 저자는 기존 GtkListStore / GtkTreeStore 객체를 상속받은 새로운 GtkTreeModel 인터페이스를 구현하는 방법을 이용해 이러한 오버헤드를 줄이는 방법을 설명하고 있습니다.&lt;/p&gt;
&lt;p&gt;방법은 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;먼저 GtkTreeModel 객체에는 실제 데이터(객체) 하나만 넣습니다. 그리고 외부에 공개하는 컬럼 갯수와 각 컬럼의 종류(type), 값(value)을 에뮬레이션하기 위해 다음 세가지 API를 오버라이딩(overriding)합니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;get_n_columns ()&lt;/li&gt;
&lt;li&gt;get_column_type ()&lt;/li&gt;
&lt;li&gt;get_value ()&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위 세 API는 GtkTreeModel 외부에서 원하는 행(row)의 컬럼(column) 값을 가져올때만 호출됩니다. 특히 GtkTreeView 등과 같은 위젯에 연결되어 있을 경우 행이 열 개이거나 백만 개이거나 상관없이 현재 화면에 보이는 행의 값만 가져오기 위해 호출됩니다.&lt;/p&gt;
&lt;p&gt;물론 문자열 조합이 복잡하거나 연산이 복잡한 경우 약간의 오버헤드가 발생할 수 있지만, 메모리 사용량은 확 줄어들고 동기화 걱정 자체가 없다는 장점이 더 큽니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GTK&#43; Animation Effects</title>
      <link>/2007/07/25/2007-07-25-gtk-animation-effects/</link>
      <pubDate>Wed, 25 Jul 2007 00:00:00 +0000</pubDate>
      <guid>/2007/07/25/2007-07-25-gtk-animation-effects/</guid>
      <description>&lt;p&gt;점점 화려해지는 GUI 추세를 이제서야 인식했는지, GTK+ / GNOME 에서도 애니메이션 효과에 대한 논의와 구현이 점점 활발해지고 있는 것 같다. 아직 GTK+ 메인 소스에 반영되려면 시간이 더 걸릴 것 같지만 
&lt;a href=&#34;http://bugzilla.gnome.org/show_bug.cgi?id=444659&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkTimeline&lt;/a&gt;
 이라는 기본적인 시간 관리 객체가 이미 논의 중이고, 이를 기반으로 여러 개발자들이 여기저기에 적용해보기도 하고 있다. (
&lt;a href=&#34;http://blogs.gnome.org/carlosg/2007/06/06/animateinanimate/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GtkPathBar 스크롤 효과&lt;/a&gt;
, 
&lt;a href=&#34;http://micke.hallendal.net/archives/2007/07/bling_in_gtk.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;iPhone 방식 슬라이드 효과&lt;/a&gt;
, 
&lt;a href=&#34;http://codeposts.blogspot.com/2007/07/iphone-like-virtual-keyboard.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;iPhone 방식 가상키보드&lt;/a&gt;
)&lt;/p&gt;
&lt;p&gt;GtkTimeline API가 참고한 소스 중 하나라고 하는 
&lt;a href=&#34;http://clutter-project.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Clutter&lt;/a&gt;
 라이브러리는 OpenGL을 렌더링 엔진으로 사용하는데, GObject 기반으로 GTK+와 친근한 방식의 API를 제공하여 이미 여러 프로젝트에서 사용하고 있는 것 같다. 
&lt;a href=&#34;http://butterfeet.org/?p=38&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Clutter를 이용한 간단한 프리젠테이션 도구&lt;/a&gt;
, 
&lt;a href=&#34;http://butterfeet.org/?p=39&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;휴대폰 인터페이스&lt;/a&gt;
 등과 같은 예제도 점점 늘어나고 있다. 하지만 OpenGL 기반이라 임베디드 시스템이나 그래픽칩셋이 3D 가속을 지원하지 않는 환경에서는 활용하기 어렵다는 점이 아쉽다. 아직
&lt;a href=&#34;http://blogs.gnome.org/timj/2007/07/17/17072007-opengl-for-gdkgtk/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OpenGL API로 모든 2D 그래픽을 대체하는 건 시기상조일 수도 있다는 얘기&lt;/a&gt;
도 심심챦게 나오고 있고&amp;hellip;&lt;/p&gt;
&lt;p&gt;참고로 더 나열해보자면, QT 계열에서는 이미 
&lt;a href=&#34;http://zrusin.blogspot.com/2007/07/scripter.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;코딩하면서 바로 캔버스 API를 테스트할 수 있는 스크립트 엔진&lt;/a&gt;
도 지원한다. 
&lt;a href=&#34;http://www.enlightenment.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;E17&lt;/a&gt;
의 
&lt;a href=&#34;http://www.enlightenment.org/p.php?p=about/libs&amp;amp;l=en&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EFL 라이브러리&lt;/a&gt;
는 이미 오래전부터 Evas, Edje 등으로 조금 앞선 플랫폼을 제공하더니 이제는 
&lt;a href=&#34;http://www.fluffyspider.com/demos/live_videos/live_videos.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;EFL 기반 솔루션을 제공하는 업체&lt;/a&gt;
도 생겨났다. 최근의 
&lt;a href=&#34;http://www.mizi.com/content/view/4/5/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;미지리서치 Prizm 플랫폼&lt;/a&gt;
도 휴대폰에서 화려한 UI 효과를 쉽게 구현하도록 도와주고 있다.(glib 기반이라 반가웠다)&lt;/p&gt;
&lt;p&gt;물론 좋은 오픈소스 라이브러리와 플랫폼이 참 많지만, 이미 오랜 시간을 GTK+와 함께 해왔더니 쉽게 다른 플랫폼으로 바꾸기가 어려운 것 같다. 하지만, 언제나 그렇듯이 잘 설계되고 잘 구현된 오픈 소스 프로젝트를 들여다보는 일은 즐겁다. 가능하면 참여중인 프로젝트에 적용해보고도 싶고, 더 나아가 프로젝트에 직접 참여해보기도 싶지만, 언제나 그렇듯이&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject - Glib object system</title>
      <link>/2007/02/05/2007-02-05-gobject-glib-object-system/</link>
      <pubDate>Mon, 05 Feb 2007 00:00:00 +0000</pubDate>
      <guid>/2007/02/05/2007-02-05-gobject-glib-object-system/</guid>
      <description>&lt;p&gt;오랜만에 Glib 객체 시스템인 GObject에 대한 글들을 다시 정독해 보았다. 아무 것도 모르고 처음 읽었을때와 몇년동안 GTK+와 친숙해진뒤 다시 읽어볼때는 역시 차이가 있는 법, 이제 GObject 객체를 프로젝트에 하나씩 적용해볼 생각이다.&lt;/p&gt;
&lt;p&gt;참고 사이트:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;http://developer.gnome.org/doc/API/2.0/gobject/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GObject 공식 리퍼런스와 튜토리얼&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://developer.gnome.org/doc/tutorials/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GNOME 개발자 설명서 모음&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Gobject&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;위키피디아에 있는 간략한 GObject 소개&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://docs.programmers.ch/index.php/HOWTO_gobject&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GObject Tutorial Copyright Ryan McDougall (2004)&lt;/a&gt;
 - C 언어로 객체지향을 구현하기 위해 GObject를 어떤 이유와 근거로 설계했는지를 단계별로 하나씩 설명해주는 튜토리얼&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://le-hacker.org/papers/gobject/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;The Glib Object system&lt;/a&gt;
 - 공식(?) GObject 튜토리얼&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.jirka.org/gob.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GOB(GObject Builder)&lt;/a&gt;
 - 쉽게 GObject C 코드를 생성해주는 전처리기&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://hellocity.net/%7Eiolo/files/gnome/BeginningGTK2Programming/BeginningGTK2Programming.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Beginning GTK+ Programming&lt;/a&gt;
 - 훌륭한 GTK+, GObject 프로그래밍 관련 컨퍼런스 자료&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Pango 1.15.2 한글 표시 문제</title>
      <link>/2006/12/23/2006-12-23-pango-1152-hangul-display-problem/</link>
      <pubDate>Sat, 23 Dec 2006 00:00:00 +0000</pubDate>
      <guid>/2006/12/23/2006-12-23-pango-1152-hangul-display-problem/</guid>
      <description>&lt;p&gt;한글 메일링 리스트에서 pango 라이브러리 최적화 논의가 오고 가더니 그 결과가 최신 버전에 이미 반영된 모양이다. 엊그제(?) 우분투 개발 버전에 새로 1.15.2-0ubuntu1 버전 패키지가 올라왔는데, 릴리스 변동 사항에 포함되어 있었다. 문제는 몇몇 한글 글자가 흩어져서(?) 표시되는 현상이 발생하길래, 조금 있으면 버그가 수정되어 올라오겠지 기다리다가 참지 못하고 오늘 결국 직접 원인을 찾아보았더니, 의외로 빨리 해결책을 얻을 수 있었다.&lt;/p&gt;
&lt;p&gt;그놈 버그질라에 이미 &amp;lsquo;
&lt;a href=&#34;http://bugzilla.gnome.org/show_bug.cgi?id=388581&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Composing jamo is broken in pango-1.15.2&amp;rsquo;&lt;/a&gt;
 항목으로 같은 현상이 보고되어 있었고 거기에 추가된 패치를 적용해보니 다시 정상적으로 한글이 표시된다.&lt;/p&gt;
&lt;p&gt;이런 경우가 내겐, 오픈소스의 매력을 느끼는 순간이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>E-페이퍼에 GTK&#43; 사용</title>
      <link>/2006/12/18/2006-12-18-gtk-for-epaper-device/</link>
      <pubDate>Mon, 18 Dec 2006 00:00:00 +0000</pubDate>
      <guid>/2006/12/18/2006-12-18-gtk-for-epaper-device/</guid>
      <description>&lt;p&gt;iRex 테크놀로지에서 만든 E-페이퍼, 종이처럼 구부러지면서 컴퓨터 화면처럼 동작하는 디스플레이 장치에 들어가는 소프트웨어 개발자들이 GTK+ 라이브러리를 이용한다고 한다. 여러가지 이유로 GTK+ 라이브러리를 거의 모든 회사 프로젝트에 이용하고 있는 입장으로 반갑기도 하고, 놀라운 점도 있다.&lt;/p&gt;
&lt;p&gt;참고:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;http://pvanhoof.be/blog/index.php/2006/12/03/irex-technologies-is-using-gtk-for-an-epaper-device&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;iRex technologies is using gtk+ for an epaper device&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>멀티쓰레드 GTK&#43; 프로그래밍</title>
      <link>/2006/01/20/2006-01-20-multi-thread-gtk-programming/</link>
      <pubDate>Fri, 20 Jan 2006 00:00:00 +0000</pubDate>
      <guid>/2006/01/20/2006-01-20-multi-thread-gtk-programming/</guid>
      <description>&lt;p&gt;대부분의 프로젝트를 GTK+를 이용하지만, 잊어버릴만 하면 부딪히는 문제 중 하나가 바로 멀티쓰레드 프로그램에서 GTK+ 위젯을 다룰때 발생하는 여러가지 현상들이다.&lt;/p&gt;
&lt;p&gt;우선 가장 쉽게 만나는 패턴은 XLib에서 Sync 에러를 내면서 프로그램 종료, 아니면 반대로 GUI가 블럭킹되어 아무 것도 동작안하는 현상이다. 그 다음으로는 해제된 위젯에 접근하거나, 아직 초기화가 덜된 위젯에 접근할 경우 발생하는 무수한 오동작 현상이 있지만, 이는 어플리케이션 설계의 문제이기도 하다.&lt;/p&gt;
&lt;p&gt;첫번째 패턴은 GTK+를 멀티쓰레드에서 이용할 경우 처음 사용하는 사람은 누구나 만나게 된다. X 윈도우는 프로세스별로 접근은 제어해주지만, 쓰레드별 접근은 제어를 해주지 않기 때문에 이는 상위 라이브러리나 프로그래머가 처리해야 한다는 점을 모를 경우 말이다.&lt;/p&gt;
&lt;p&gt;물론 
&lt;a href=&#34;http://library.gnome.org/devel/gdk/stable/gdk-Threads.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+ 매뉴얼에는 친절하게 설명&lt;/a&gt;
이 되어 있다. 시그널 핸들러를 통해 호출되는 콜백 함수는 항상 GDK 쓰레드가 잠겨서 호출되지만, g_idle_add(), g_timeout_add() 등을 통해 호출되는 콜백 함수는 프로그래머가 해주어야 한다. 또한 메인 GTK+ 쓰레드가 아닌 쓰레드에서 GTK+ 위젯을 접근하려면 g_idle_add() 또는 다른 메시징 방식을 이용해 메인 쓰레드에서 처리하도록 하거나, 매번 GDK 쓰레드 잠금/해제를 프로그래머가 해주어야 한다. gtk_main_iteration() 등의 도움을 받기도 한다.&lt;/p&gt;
&lt;p&gt;하지만, 내가 말하고 싶은 건, 그럼에도 불구하고 너무 복잡하다. GTK+의 많은 부분을 좋아하지만 이 부분만큼은 정말 GTK+가 알아서 해주면 얼마나 좋을까라는 생각을 몇 년째 하고 있다. 수십 개의 쓰레드가 존재하고, 외부 명령을 호출하여 그 결과를 GUI에 반영하면서 다른 GUI 부분들도 정상적으로 동작해야 하는데, 기능 외적인 부분에 항상 너무 많은 시간이 소모된다. 모든 경우를 위와 같은 방식으로 해결할 수도 없다. 4년 넘게 GTK+ 어플리케이션을 만들어 프로젝트를 진행하고 있지만, 기능이 추가될때마다 똑같은 홍역을 겪고 있다.&lt;/p&gt;
&lt;p&gt;이제, 다른 대안을 찾아야 할 시기일까&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
