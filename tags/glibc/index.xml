<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>glibc | 대체로 무해함</title>
    <link>/tags/glibc/</link>
      <atom:link href="/tags/glibc/index.xml" rel="self" type="application/rss+xml" />
    <description>glibc</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>ko-kr</language><copyright>© lethean</copyright><lastBuildDate>Tue, 17 Feb 2015 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>glibc</title>
      <link>/tags/glibc/</link>
    </image>
    
    <item>
      <title>리눅스에서 시간 변경 감지하기</title>
      <link>/2015/02/17/2015-02-17-detect-time-change-with-timerfd-in-linux/</link>
      <pubDate>Tue, 17 Feb 2015 00:00:00 +0000</pubDate>
      <guid>/2015/02/17/2015-02-17-detect-time-change-with-timerfd-in-linux/</guid>
      <description>&lt;p&gt;&lt;code&gt;systemd&lt;/code&gt; 데몬은 가끔 &amp;ldquo;Time has been changed&amp;quot;라는 로그 메시지를 출력합니다. 그래서 과연 어떤 방식으로 시간이 변경되는 이벤트를 감지하는지 궁금해서 
&lt;a href=&#34;http://cgit.freedesktop.org/systemd/systemd/tree/src/core/manager.c#n1920&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;소스 코드&lt;/a&gt;
를 한 번 들여다보았습니다.&lt;/p&gt;
&lt;p&gt;일반적으로 
&lt;a href=&#34;http://man7.org/linux/man-pages/man2/timerfd_create.2.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;timerfd_create()&lt;/code&gt;&lt;/a&gt;
 함수는 지연되어 실행하거나 주기적으로 처리해야 작업을 실행할 때 사용합니다. 맨 페이지의 예제 소스는 이러한 용도로 완벽합니다. 그런데 &lt;code&gt;systemd&lt;/code&gt;에서는 &lt;code&gt;timerfd_settime()&lt;/code&gt; 함수를 호출할 때 두 번째 인수에 &lt;code&gt;TFD_TIMER_CANCEL_ON_SET&lt;/code&gt; 값을 전달합니다. 이 값은 맨 페이지에도 없어서 구글 검색을 해보니 
&lt;a href=&#34;http://man7.org/tlpi/api_changes/#Linux-3.0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;glibc API 변경 문서&lt;/a&gt;
에서 다음과 같이 설명된 부분을 찾을 수 있었습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The timerfd_settime() system call adds a TFD_TIMER_CANCEL_ON_SET flag.
If this flag is set for a CLOCK_REALTIME absolute (TFD_TIMER_ABSTIME) timer,
then the timer is expired if the clock is reset.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;즉, 커널 내부 시계(clock)가 초기화(reset)되면 타이머가 만기되어(expired) 이벤트가 발생한다는 내용입니다. 그리고 눈으로 읽는 것만으로는 역시 잊어버릴 것 같아서, 
&lt;a href=&#34;https://gist.github.com/lethean/446cea944b7441228298#file-timechange-c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;예제 프로그램을 간단하게 수정&lt;/a&gt;
해서 시간이 변경되는 여러 경우를 실험해보니, 직접 시간을 변경하거나 NTP 시간 동기화로 인한 시간 변경은 감지하는데, 시간대(time zone) 변경은 감지하지 못하는군요. 게다가 사람이 보기에는 같지만 아주 조금만 달라져도, 추측하기에는 시간 변경 함수가 호출만 되어도, 이벤트가 발생합니다. 게다가 시간이 앞으로 이동했는지 뒤로 이동했는지도 알 방법이 없고&amp;hellip;&lt;/p&gt;
&lt;p&gt;아무튼, 오늘도 역시 여전히 아는 것보다 모르는 게 더 많다는 사실을 새삼 깨닫게 된 하루입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 IP 주소 / 링크 상태 변경 여부 감지하기</title>
      <link>/2012/03/19/2012-03-19-detect-change-of-ip-address-and-link-status-in-linux/</link>
      <pubDate>Mon, 19 Mar 2012 00:00:00 +0000</pubDate>
      <guid>/2012/03/19/2012-03-19-detect-change-of-ip-address-and-link-status-in-linux/</guid>
      <description>&lt;p&gt;리눅스에서 IP 주소가 변경되었거나 링크 상태 변경 여부(예를 들어 랜선이 꽂히거나 빠졌을때)를 자동으로 감지하는 C 코드입니다. &lt;code&gt;ifconfig&lt;/code&gt; 명령등의 결과를 파싱하는 방법이 아닌 리눅스 커널 &lt;code&gt;rtnetlink(7)&lt;/code&gt; 프로토콜과 &lt;code&gt;getifaddrs()&lt;/code&gt; 함수를 이용해 직접 처리합니다. 참조한 소스는 여러군데가 있는데 모두 구글링이 가능하므로 결과물만 기록으로 남겨둡니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;ifaddrs.h&amp;gt;
#include &amp;lt;net/if.h&amp;gt;
#include &amp;lt;netdb.h&amp;gt;
#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;linux/netlink.h&amp;gt;
#include &amp;lt;linux/rtnetlink.h&amp;gt;

static int
create_sock (const char *nic)
{
  struct sockaddr_nl addr;
  int                sock;

  memset (&amp;amp;addr, 0, sizeof (addr));
  addr.nl_family = AF_NETLINK;
  addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV6_IFADDR;

  sock = socket (PF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
  if (sock &amp;lt; 0)
    {
      fprintf (stderr, &amp;quot;failed to open NETLINK_ROUTE socket for %s - %s(%d)&amp;quot;,
               nic, strerror (errno), errno);
      return -1;
    }

  if (bind (sock, (struct sockaddr *)&amp;amp;addr, sizeof(addr)) &amp;lt; 0)
    {
      fprintf (stderr, &amp;quot;failed to bind NETLINK_ROUTE socket for %s - %s(%d)&amp;quot;,
                 nic, strerror (errno), errno);
      close (sock);
      return -1;
    }

  return sock;
}

static int
ip_changed (int         sock,
            const char *nic)
{
  struct nlmsghdr   *nlh;
  char               buffer[4096];
  int                len;
  int                idx;
  int                found;

  len = recv (sock, buffer, sizeof (buffer), 0);
  if (len &amp;lt;= 0)
    {
      fprintf (stderr, &amp;quot;NETLINK_ROUTE socket recv() failedn&amp;quot;);
      return -1;
    }

  found = 0;
  idx = if_nametoindex (nic);

  for (nlh = (struct nlmsghdr *)buffer;
       NLMSG_OK (nlh, len);
       nlh = NLMSG_NEXT (nlh, len))
    {
      if (nlh-&amp;gt;nlmsg_type == NLMSG_DONE)
        break;
      if (nlh-&amp;gt;nlmsg_type == NLMSG_ERROR)
        continue;
      if (!(NLMSG_OK (nlh, len)))
        continue;

      switch (nlh-&amp;gt;nlmsg_type)
        {
        case RTM_NEWADDR:
          {
            struct ifaddrmsg *ifa = (struct ifaddrmsg *)NLMSG_DATA (nlh);

            if (ifa-&amp;gt;ifa_index == idx)
              found = 1;
          }
          break;
        case RTM_NEWLINK:
          {
            struct ifinfomsg *ifi = (struct ifinfomsg *)NLMSG_DATA (nlh);

            if (ifi-&amp;gt;ifi_index == idx)
              found = 1;
          }
          break;
        default:
          break;
        }
    }

  return found;
}

static int
get_nic_addr (const char     *nic,
              struct ifaddrs *ifaddr,
              int             wanted_family,
              char           *host,
              int             host_len,
              int            *active)
{
  struct ifaddrs *ifa;

  for (ifa = ifaddr; ifa != NULL; ifa = ifa-&amp;gt;ifa_next)
    {
      int family;
      int s;

      if (ifa-&amp;gt;ifa_addr == NULL)
        continue;

      if (strcmp (ifa-&amp;gt;ifa_name, nic))
        continue;

      /* Skip unwanted families. */
      family = ifa-&amp;gt;ifa_addr-&amp;gt;sa_family;
      if (family != wanted_family)
        continue;

      *active = (ifa-&amp;gt;ifa_flags &amp;amp; IFF_RUNNING) ? 1 : 0;

      s = getnameinfo (ifa-&amp;gt;ifa_addr,
                       family == AF_INET ? sizeof (struct sockaddr_in) :
                                           sizeof (struct sockaddr_in6),
                       host,
                       host_len,
                       NULL,
                       0,
                       NI_NUMERICHOST);
      if (s != 0)
        {
          fprintf (stderr, &amp;quot;failed to getnameinfo() for &#39;%s - %s(%d)&amp;quot;,
                   ifa-&amp;gt;ifa_name, strerror (errno), errno);
          continue;
        }

      /* Get the address of only the first network interface card. */
      return 1;
    }

  return 0;
}

static void
print_ip (const char *nic)
{
  struct ifaddrs *ifaddr;
  char            addr[NI_MAXHOST];
  int             active;

  if (getifaddrs (&amp;amp;ifaddr) == -1)
    {
      fprintf (stderr, &amp;quot;failed to getifaddrs() - %s(%d)&amp;quot;, strerror (errno), errno);
      return;
    }

  if (!get_nic_addr (nic, ifaddr, AF_INET, addr, sizeof (addr), &amp;amp;active))
    if (!get_nic_addr (nic, ifaddr, AF_INET6, addr, sizeof (addr), &amp;amp;active))
      {
        strcpy (addr, &amp;quot;127.0.0.1&amp;quot;);
        active = 0;
      }

  freeifaddrs (ifaddr);

  fprintf (stdout, &amp;quot;%s is %s (link %s)n&amp;quot;,
           nic, addr, active ? &amp;quot;active&amp;quot; : &amp;quot;inactive&amp;quot;);
}

int
main (void)
{
  char *nic = &amp;quot;eth0&amp;quot;;
  int   sock;

  print_ip (nic);

  sock = create_sock (nic);
  if (sock &amp;lt; 0)
    return -1;

  while (1)
    {
      int ret;

      ret = ip_changed (sock, nic);
      if (ret &amp;lt; 0)
        return -1;

      if (ret)
        print_ip (nic);
    }

  close (sock);

  return 0;
}

/*
  Local Variables:
   mode:c
   c-file-style:&amp;quot;gnu&amp;quot;
   indent-tabs-mode:nil
  End:
  vim:autoindent:filetype=c:expandtab:shiftwidth=2:softtabstop=2:tabstop=8
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 위 소스에서 네트웍 인터페이스 설정 변경을 감지하기 위해 사용한 소켓 파일 디스크립터(socket file descriptor)는 &lt;code&gt;select()&lt;/code&gt; / &lt;code&gt;poll()&lt;/code&gt; 등을 이용해 비동기적으로 감시하는 것도 가능합니다. 당연하지만, 
&lt;a href=&#34;/2009/09/21/using-glib-mainloop/&#34;&gt;GLib 메인루프&lt;/a&gt;
의 &lt;code&gt;g_io_add_watch()&lt;/code&gt; 등을 이용해도 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[UPDATE 2012-03-21]&lt;/strong&gt; &lt;code&gt;rtnetlink(7)&lt;/code&gt; 프로토콜의 기반이 되는 &lt;code&gt;netlink(7)&lt;/code&gt; 프로토콜에 대해 더 자세히 알고 싶다면 
&lt;a href=&#34;http://www.infradead.org/~tgr/libnl/doc/core.html#core_netlink_fundamentals&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netlink 라이브러리의 Netlink 프로토콜 기초 문서&lt;/a&gt;
를 참고하기 바랍니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>eventfd 소개</title>
      <link>/2011/07/07/2011-07-07-eventfd/</link>
      <pubDate>Thu, 07 Jul 2011 00:00:00 +0000</pubDate>
      <guid>/2011/07/07/2011-07-07-eventfd/</guid>
      <description>&lt;p&gt;리눅스에서 비단 부모 자식 프로세스간 통신 뿐 아니라, 쓰레드간 메시지 전달에도 
&lt;a href=&#34;http://www.kernel.org/doc/man-pages/online/pages/man2/pipe.2.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;pipe()&lt;/a&gt;
를 자주 이용합니다. 읽거나 쓸때 별도로 뮤텍스로 보호해줄 필요가 없기 때문이기도 하지만, 무엇보다도 poll(), select(), epoll() 등과 함께 사용할 수 있기 때문입니다. 예를 들어 예전에 적었던 
&lt;a href=&#34;/2008/08/06/glib-thread-programming/&#34;&gt;GLib 쓰레드 프로그래밍&lt;/a&gt;
에서 쓰레드간 통신에 g_async_queue()를 이용하는데, 이 방법의 단점은 쓰레드가 오직 이 메시지가 도착했을때만 깨어난다는 점입니다. 만일 이 쓰레드가 네트웍 소켓 작업이나 파일 읽기 쓰기 작업을 비동기적으로 계속 처리해야 한다면 타임아웃을 주어 처리하거나 반대로 다시 주기적으로 메시지큐를 검사하는 방법밖에 없습니다. 하지만, 리눅스에서 모든 소켓 작업, 파일 작업은 디스크립터(descriptor)로 단일화되어 있기 때문에 pipe()로 생성된 디스크립터와 실제 작업 디스크립터를 한꺼번에 epoll() 등을 이용해 처리하면 불필요한 오버헤드 없이 정확하게 작업을 처리해야할 시점에 깨어나 필요한 작업을 처리하게 됩니다. 즉, 메시지큐에 실제 메시지를 넣고 파이프의 쓰기 디스크립터에 더미 데이터를 쓰면, 작업 쓰레드에서는 파이프 읽기 디스크립터에 내용이 있을 경우 poll() 등이 감지하기 때문에 자동으로 깨어나 처리하는 방식입니다. 심지어, 파이프 전송시 더미 데이터가 아닌 메시지 내용 혹은 주소(pointer)를 쓰고, 읽는 쓰레드에서 이를 읽어 처리하면 별도의 메시지큐도 불필요하게 됩니다.&lt;/p&gt;
&lt;p&gt;이 글에서 소개하려는 
&lt;a href=&#34;http://www.kernel.org/doc/man-pages/online/pages/man2/eventfd.2.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;eventfd()&lt;/a&gt;
는 파이프 역할을 어느 정도 대체하기 위해 최근(?) 리눅스 커널에 추가된 API입니다. 읽고 쓰기에 각각 다른 두 개의 파일 디스크립터를 사용하는 파이프와 달리 eventfd는 한 개의 파일 디스크립터를 가지고 동시에 읽고 쓰기 작업을 처리합니다. 또한 별도 커널 버퍼와 복사 과정이 필요한 파이프와 달리 정수 값을 더하고(쓰고) 읽는 작업만 처리하기 때문에 성능도 훨씬 좋다고 합니다. 물론 파일 디스크립터이기 때문에 poll() 등과 함께 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;동작 방식을 간단하게 설명하면, write() 호출시 64비트 정수값을 쓰면 내부 버퍼 값에 더하면서, read() 호출시 내부 버퍼 값이 0일 경우 기다리다가, 값이 바뀌면 그 값을 읽어오고 0으로 초기화합니다.(세마포어 방식일 경우 1을 읽어오고 그 값에서 1을 감소합니다) 즉, 읽기 작업에 대한 poll() 호출은 내부 버퍼 값이 0일 경우 입력이 없는 것으로, 1 이상의 값일 경우 입력이 있는 것으로 간주하고 디스크립터를 감지하게 됩니다. (예제 코드는 매뉴얼 페이지에 포함된 코드를 확인하시길&amp;hellip; 물론 예제 코드는 쓰레드간 통신에도 잘 동작합니다)&lt;/p&gt;
&lt;p&gt;매뉴얼에 의하면 리눅스 커널 2.6.22, glibc 2.8 버전부터 eventfd() 함수를 지원합니다. 대부분의 요즘 리눅스 데스크탑 / 서버 배포판에서는 당연히 사용할 수 있지만 임베디드 시스템에서는 버전을 확인해야할 필요가 있습니다. 물론, eventfd가 메시지 내용 자체를 전송할 수 없다는 단점도 있지만, 이와 함께 리눅스 커널이 제공하는 
&lt;a href=&#34;http://www.kernel.org/doc/man-pages/online/pages/man2/signalfd.2.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;signalfd()&lt;/a&gt;
, 
&lt;a href=&#34;http://www.kernel.org/doc/man-pages/online/pages/man2/timerfd_create.2.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;timerfd()&lt;/a&gt;
, 
&lt;a href=&#34;http://linux.die.net/man/4/epoll&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;epoll()&lt;/a&gt;
 등을 함께 사용하면 고전 유닉스 프로그래밍의 한계에서 벗어나 마음껏 이벤트 기반 코드를 만들 수 있습니다.&lt;/p&gt;
&lt;p&gt;물론 이미 잘 만들어진 
&lt;a href=&#34;/2009/09/21/using-glib-mainloop/&#34;&gt;GLib 메인루프&lt;/a&gt;
나 
&lt;a href=&#34;http://bebop.emstone.com/2011/05/18/libevent/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libevent&lt;/a&gt;
 등과 같은 라이브러리를 사용하는 것도 좋지만&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>도메인 메일 호스트(MX) 주소 얻기</title>
      <link>/2011/04/05/2011-04-05-get-domain-mx-host-name/</link>
      <pubDate>Tue, 05 Apr 2011 00:00:00 +0000</pubDate>
      <guid>/2011/04/05/2011-04-05-get-domain-mx-host-name/</guid>
      <description>&lt;p&gt;예를 들어 &lt;a href=&#34;mailto:nobody@hades.net&#34;&gt;nobody@hades.net&lt;/a&gt;이라는 메일 주소의 서버는 hades.net인 것 같지만 실제로 메일을 호스팅하는 서버는 해당 도메인 서버에 질의해서 MX 레코드에 기록된 호스트를 찾아야 합니다. 그리고 이 작업을 위해 DNS 관련 프로토콜을 직접 구현하거나. 
&lt;a href=&#34;http://cr.yp.to/djbdns.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;djbdns&lt;/a&gt;
 등과 같은 라이브러리를 이용합니다.&lt;/p&gt;
&lt;p&gt;그런데, 요즘 기존 코드를 리팩토링하면서 가능한 오래된(?) 라이브러리에 대한 의존성을 없애고 있는데 위에서 설명한 작업을 하는 함수가 리눅스 기본 glibc 라이브러리가 &lt;em&gt;당연히&lt;/em&gt; 제공하는 걸 알게 되어 잠시 허탈했습니다.&lt;/p&gt;
&lt;p&gt;다음은 도메인 이름을 인수로 주면 해당 도메인의 MX 레코드, 즉 메일서버 호스트를 glibc API를 이용해 작성한 코드입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;netinet/in.h&amp;gt;
#include &amp;lt;arpa/nameser.h&amp;gt;
#include &amp;lt;resolv.h&amp;gt;

static char *
lookup_mx (const char *name)
{
  unsigned char response[NS_PACKETSZ];  /* big enough, right? */
  ns_msg        handle;
  int           ns_index;
  int           len;

  len = res_search (name, C_IN, T_MX, response, sizeof (response));
  if (len &amp;lt; 0)
    {
      /* failed to search MX records */
      return strdup (name);
    }
  if (ns_initparse (response, len, &amp;amp;handle) &amp;lt; 0)
    {
      /* failed to parse MX records for &#39;%s&#39;&amp;quot;, name); */
      return strdup (name);
    }
  len = ns_msg_count (handle, ns_s_an);
  if (len &amp;lt;= 0)
    {
      /* no mx records */
      return strdup (name);
    }
  for (ns_index = 0; ns_index &amp;lt; len; ns_index++)
    {
      ns_rr rr;
      char  dispbuf[4096];

      if (ns_parserr (&amp;amp;handle, ns_s_an, ns_index, &amp;amp;rr))
        {
          /* WARN: ns_parserr failed */
          continue;
        }
      ns_sprintrr (&amp;amp;handle, &amp;amp;rr, NULL, NULL, dispbuf, sizeof (dispbuf));
      if (ns_rr_class (rr) == ns_c_in &amp;amp;&amp;amp; ns_rr_type (rr) == ns_t_mx)
        {
          char mxname[MAXDNAME];

          dn_expand (ns_msg_base (handle),
                     ns_msg_base (handle) + ns_msg_size (handle),
                     ns_rr_rdata(rr) + NS_INT16SZ,
                     mxname,
                     sizeof (mxname));
          return strdup (mxname);
        }
    }
  return strdup (name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;관련 자료는 
&lt;a href=&#34;http://stackoverflow.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stack Overflow&lt;/a&gt;
에서 본 것 같기도 하고&amp;hellip; 아무튼, 명색이 전문 리눅스 C 프로그래머로서 15년 넘게 버티고 있으면서도 아직까지도 기본 C 라이브러리가 제공하는 함수도 제대로 알지 못하는 스스로를 돌아보게 됩니다. :(&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>파일 공간 미리 할당하기</title>
      <link>/2011/01/12/2011-01-12-allocate-file-space-in-advance/</link>
      <pubDate>Wed, 12 Jan 2011 00:00:00 +0000</pubDate>
      <guid>/2011/01/12/2011-01-12-allocate-file-space-in-advance/</guid>
      <description>&lt;p&gt;비단 비트토런트(BitTorrent)나 어뮬(aMule) 같은 P2P 응용 프로그램이 아니라도 파일 크기를 (대략이라도) 미리 알고 있을 경우, 디스크 공간을 미리 할당해서 단편화(fragmentation)를 줄이는 것은 물론 용량 부족으로 인한 쓰기 오류를 미리 막는 기법은 종종 필요합니다.&lt;/p&gt;
&lt;p&gt;예전에는 이를 위해 파일을 생성한뒤 원하는 크기의 0으로 채워진 파일을 미리 만들어 두는 무식한 방법을 사용하거나, &lt;code&gt;lseek()&lt;/code&gt; 함수를 이용해 원하는 크기만큼 뒤로 이동한 뒤 더미 1바이트르 쓰는 기법 등을 사용했습니다. 물론 이 기법은 지금도 유용합니다.&lt;/p&gt;
&lt;p&gt;그런데 요즘 리눅스 커널에서 주로 사용하는 파일시스템이 이런 기능을 근본적으로 지원하게 되면서 쉽게 사용할 수 있는 API가 추가되었는데, 다름아닌 &lt;code&gt;fallocate()&lt;/code&gt; / &lt;code&gt;posix_fallocate()&lt;/code&gt; 함수입니다. 매뉴얼에 의하면 리눅스 커널 2.6.23 버전, glibc 2.10 버전 이후부터 btrfs, ext4, ocfs2, xfs 파일시스템에서 지원한다고 하는데, 해당 파일시스템이 직접 지원하지 않을 경우 커널이 알아서 비효율적인 방법으로 처리해 주는 것 같습니다.&lt;/p&gt;
&lt;p&gt;터미널이나 콘솔에서 직접 지정한 크기의 파일을 만들 수 있는 &lt;code&gt;fallocate&lt;/code&gt; 명령어도 요즘 리눅스 배포판에는 기본적으로 포함되어 있습니다. 사용해 보면 알겠지만, 아무리 큰 파일도 매우 빨리 만들어 줍니다. 그리고, 매뉴얼에는 명시되어 있지 않지만, 큰 파일을 지원하기 위한 &lt;code&gt;fallocate64()&lt;/code&gt; / &lt;code&gt;posix_fallocate64()&lt;/code&gt; 함수도 사용할 수 있습니다. 자세한 함수와 명령어 사용법은 매뉴얼(man) 페이지를 참고하면 쉽게 알 수 있기 때문에 자세한 사용법은 생략합니다.&lt;/p&gt;
&lt;p&gt;참고로, 멀티플랫폼 비트토런트 클라이언트인 
&lt;a href=&#34;https://trac.transmissionbt.com/browser/trunk/libtransmission/fdlimit.c#L106&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Transmission 소스&lt;/a&gt;
를 보면 다양한 플랫폼에서 동일한 기능을 어떻게 사용하는지 알 수 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 / 맥오에스에서 CPU 갯수 얻기</title>
      <link>/2009/12/27/2009-12-27-get-number-of-cpu-on-linux-and-macosx/</link>
      <pubDate>Sun, 27 Dec 2009 00:00:00 +0000</pubDate>
      <guid>/2009/12/27/2009-12-27-get-number-of-cpu-on-linux-and-macosx/</guid>
      <description>&lt;p&gt;Linux / MacOS X 플랫폼에서 CPU 갯수를 얻어오는 함수입니다. 잊어버릴까봐 기록해 둡니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#ifdef __linux__
#include &amp;lt;sys/sysinfo.h&amp;gt;
#else
#ifdef __APPLE__
#include &amp;lt;sys/param.h&amp;gt;
#include &amp;lt;sys/sysctl.h&amp;gt;
#else
#error &amp;quot;Only Linux or OSX is supported!&amp;quot;
#endif /* __APPLE__ */
#endif /* __linux__ */

static int
get_cpu_nr (void)
{
#ifdef __linux__
  return get_nprocs ();
#endif
#ifdef __APPLE__
  int i = 0;
  size_t s = sizeof (i);
  if (sysctlbyname (&amp;quot;hw.ncpu&amp;quot;, &amp;amp;i, &amp;amp;s, NULL, 0))
    return 1;
  return i;
#endif
}

int
main (int argc, char **argv)
{
  printf (&amp;quot;cpu_nr:%dn&amp;quot;, get_cpu_nr ());

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;출처는 
&lt;a href=&#34;http://github.com/chergert/dukes_of_hazard/raw/master/main.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;이 소스&lt;/a&gt;
입니다. 참고로 리눅스의 &lt;code&gt;/usr/include/sys/sysinfo.h&lt;/code&gt; 파일을 들여다보면 램 크기 / 스왑 크기 / 물리 페이지 크기 등과 같은 시스템 관련 정보를 얻을 수 있는 함수가 여럿 보이는군요. &lt;code&gt;/proc&lt;/code&gt; 정보를 파싱하는 것보다 더 편리할 것 같습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCMalloc 구글 성능 도구를 이용한 메모리 누수 디버깅</title>
      <link>/2009/06/18/2009-06-18-debugging-memory-leaks-with-tcmalloc-google-perftools/</link>
      <pubDate>Thu, 18 Jun 2009 00:00:00 +0000</pubDate>
      <guid>/2009/06/18/2009-06-18-debugging-memory-leaks-with-tcmalloc-google-perftools/</guid>
      <description>&lt;p&gt;리눅스에서 메모리 침범이나 메모리 누수, 혹은 복잡한 메모리 접근 관련 오류를 디버깅할때는 대부분 
&lt;a href=&#34;http://valgrind.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Valgrind&lt;/a&gt;
 도구를 이용합니다. 하지만 Valgrind는 많은 메모리를 사용하고 실행 속도가 현저하게 느려지기 때문에, 별도의 타겟 장비에서 제한된 조건으로 동작하는 어플리케이션에는 조금 무리가 있습니다. 게다가 Valgrind의 메모리 검사 도구는 프로그램이 종료된 시점에서 누수된 메모리만 찾기 때문에, 실행 중에는 엄청나게 메모리를 사용하다가 정상적인 객체 해제 루틴이 호출되면 모든 메모리가 정리되어 찾을 수 없는 경우는 발견하지 못합니다.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;/2009/04/29/tcmalloc-google-perftools/&#34;&gt;구글 성능 도구&lt;/a&gt;
를 다시 검토하고 사용하게 된 이유도 바로 여기에 있습니다. 현재 디버깅 중인 프로그램의 문제가 대략 이렇습니다. 몇날 며칠이고 문제없이 가동해야 하는 프로그램이 특정 설정을 적용한 후에는, 자고 일어나면 10~20메가씩 메모리 점유율이 한꺼번에 올라갑니다. 하지만 Valgrind 도구를 사용해도 어느 부분이 문제인지 찾을 수가 없습니다. 지난 글에서 TCMalloc 메모리 할당자로 교체한 후 문제가 해결된 줄 알았던 바로 그 패턴이기도 합니다. 그래서 이번에는 프로파일 기능을 이용해 직접 메모리 누수를 디버깅 해보고, 나중을 위해 그 과정을 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;디버깅 환경&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;디버깅 환경은 우분투 9.04 x86_32 플랫폼입니다. x86_64 플랫폼에서는 이상하게 호출 그래프가 그려지지 않아서 일단 무시했습니다. 사용한 버전은 
&lt;a href=&#34;http://code.google.com/p/google-perftools/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;공식 홈페이지&lt;/a&gt;
에서 다운로드 받은 1.2 버전입니다. 1.3 버전은 이상하게 프로파일 기능이 동작하지 않아 역시 무시했습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCMalloc 도구 설치 및 연결&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;호출 그래프를 생성하기 위해 &lt;code&gt;dot&lt;/code&gt; 프로그램이 필요한데 이 프로그램은 graphviz 패키지에 들어있으므로 설치해야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt-get install graphviz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;우선, 공식 홈페이지에서 google-perftools 압축 파일을 다운로드 한 뒤 다음과 같이 빌드하고 설치합니다. &lt;strong&gt;[2011.05.02 추가]&lt;/strong&gt; INSTALL 문서에도 명시되어 있듯이, x86_64 환경에서는 
&lt;a href=&#34;http://www.nongnu.org/libunwind/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libunwind&lt;/a&gt;
 라이브러리를 미리 설치한 뒤 빌드해야 정상적으로 동작합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cd google-perftools*
$ ./configure --prefix=/usr
$ make
$ sudo make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TCMalloc 라이브러리를 연결하는 방법은 
&lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/doc/heapprofile.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;공식 문서&lt;/a&gt;
에도 나와 있듯이 디버깅할 프로그램 링크 마지막에 &amp;lsquo;&lt;code&gt;-ltcmalloc&lt;/code&gt;&amp;rsquo; 옵션을 추가하거나, 실행할때 프로그램 앞에 &amp;lsquo;&lt;code&gt;LD_PRELOAD=/usr/lib/libtcmalloc.so execute-file&lt;/code&gt;&amp;rsquo; 처럼 라이브러리를 먼저 로드해주면 됩니다. &lt;del&gt;저는 첫번째 방법을 사용했습니다.&lt;/del&gt; &lt;strong&gt;[2011.05.02 갱신]&lt;/strong&gt; 언제부터인지는 확실치 않지만 첫번째 방법은 동작하지 않고 두번째 방법으로 해야 메모리 프로파일이 정상적으로 동작합니다.&lt;/p&gt;
&lt;p&gt;참고로, 디버깅할 프로그램을 컴파일할때는 디버깅 심볼 옵션(&lt;code&gt;-g&lt;/code&gt;)이 있어야 호출 그래프에서 정확한 함수 이름이 표시됩니다. 또한 최적화 옵션(&lt;code&gt;-O2&lt;/code&gt; 등)을 사용 안하면 더 정확한 함수 호출 그래프를 얻을 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로파일 데이터 얻기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCMalloc 라이브러리를 연결해도 기본적으로 프로파일 기능은 동작하지 않습니다. &lt;code&gt;HEAPPROFILE&lt;/code&gt; 환경변수에 프로파일 정보를 주기적으로 덤프할 파일 이름 접두사(prefix)를 지정해야만 동작합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ HEAPPROFILE=/tmp/profile execute-file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;접두사는 파일 절대 경로로 디렉토리를 포함할 수 있습니다.&lt;/p&gt;
&lt;p&gt;만일 덤프 파일이 너무 자주 생성되거나 반대로 너무 드물게 생성된다면 환경 변수를 통해 간격을 조절할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ HEAPPROFILE=/tmp/profile 
  HEAP_PROFILE_ALLOCATION_INTERVAL=107374182400 
  execute-file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;더 자세한 옵션은 
&lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/doc/heapprofile.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;공식 문서&lt;/a&gt;
를 확인해 보시기 바랍니다.&lt;/p&gt;
&lt;p&gt;위 예제에서 지정한 방식대로 프로그램을 실행하면 &lt;code&gt;/tmp/profile.0001.heap&lt;/code&gt;, &lt;code&gt;/tmp/profile.0002.heap&lt;/code&gt;, &lt;code&gt;/tmp/profile.0003.heap&lt;/code&gt; 등과 같은 프로파일 덤프 파일이 실행 도중 계속 생성됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결과 그래프 얻기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;포스트스크립트(PostScript) 파일 형식으로 메모리 프로파일 정보를 포함한 함수 호출 그래프를 얻으려면 다음과 같이 형식으로 pprof 프로그램을 실행하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pprof --ps --lines 
    execute-file 
    /tmp/profile.0001.heap 
    &amp;gt; profile-0001.ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로파일 덤프 파일에 대하여 하나씩 그래프를 생성해 직접 눈과 손으로 비교하는 것도 나쁘지 않지만, 두 프로파일의 차이점만 그래프로 만들어주는 옵션이 있으므로 이를 사용하면 더 편리합니다. 즉, 시간대별 메모리 사용량의 달라진 부분이 정확하게 어느 함수 호출 때문인지 알 수 있게 해줍니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pprof --ps --lines 
    --base /tmp/profile.0001.heap 
    execute-file 
    /tmp/profile.0002.heap 
    &amp;gt; profile-0002-diff.ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론, PDF(&lt;code&gt;--pdf&lt;/code&gt;), GIF(&lt;code&gt;--gif&lt;/code&gt;) 등과 같은 다른 형식으로 그래프 파일을 얻을 수도 있습니다. 더 자세한 옵션은 &amp;lsquo;&lt;code&gt;pprof --help&lt;/code&gt;&#39;를 참고하시면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결론&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;며칠간 디버깅에 적용해보니 문제가 발생한 패턴이 무엇이었는지도 찾아내고, 간과했던 작은 메모리 누수 버그들도 함께 발견할 수 있었습니다. 하지만, 언제나 그렇듯이, 디버깅 사태까지 오기 전에 더 튼튼하게 설계하고, 더 꼼꼼하게 프로그래밍하고, 더 철저하게 코드 리뷰와 테스트를 거치는 게 정도임을 새삼 깨닫습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TCMalloc, 구글 성능 도구</title>
      <link>/2009/04/29/2009-04-29-tcmalloc-google-perftools/</link>
      <pubDate>Wed, 29 Apr 2009 00:00:00 +0000</pubDate>
      <guid>/2009/04/29/2009-04-29-tcmalloc-google-perftools/</guid>
      <description>&lt;p&gt;장기간 실행되면서 빈번하게 메모리를 할당 / 해제하는 것은 물론 수십 개의 쓰레드가 동작하는 프로그램에서는 어쩔 수 없이 메모리 단편화(Memory Fragmentation)가 발생합니다. 메모리 단편화가 많을 경우 어플리케이션 로직에 메모리 누수(memork leak)가 없어도 C 라이브러리 메모리 관리자가 메모리를 커널에 반환하지 않기 때문에 프로세스의 메모리 사용량은 계속 늘어납니다.(참고로 이러한 경우인지 여부는 주기적으로 &lt;code&gt;mallinfo()&lt;/code&gt; 정보를 확인하면 됩니다) 물론 이를 회피하기 위한 기법이나 아키텍쳐는 많이 있지만, 그리 쉽게 원하는 성능과 효율을 얻기는 힘들더군요.&lt;/p&gt;
&lt;p&gt;그런데, 며칠 동안 이와 비슷한 문제를 디버깅하다가 예전에 무심코 지나쳤던 
&lt;a href=&#34;http://code.google.com/p/google-perftools/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Performance Tools&lt;/a&gt;
 라이브러리를 다시 발견하고, 그 안에 들어 있는 
&lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/doc/tcmalloc.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TCMalloc(Thread-Caching Malloc)&lt;/a&gt;
 모듈을 사용해 보았는데 사용하지 않을 때와 비교해 놀랄만큼 많은 차이를 보이는군요. 문서에 보면 성능과 효율을 동시에 향상시킨다고 하는데 성능은 사실 잘 모르겠지만,  장기간 실행시 메모리 사용량 변동률은 너무나 맘에 듭니다.&lt;/p&gt;
&lt;p&gt;간단하게 TCMalloc의 동작 방식을 설명하면, 일단 중앙 메모리 관리자와 쓰레드별 메모리 관리자를 구분합니다. 작은 크기(32K 이하)의 메모리 할당 / 해제 요청은  쓰레드별 메모리 관리자가 처리하고, 부족할 경우 중앙 메모리 관리자에서 얻어오는 방식입니다. 따라서 메모리 할당시 불필요한 동기화 과정이 이론상 거의 없어 성능 향상을 얻을 수 있습니다.  메모리 크기를 60개의 클래스로 나누어 관리하게 때문에 단편화도 줄어듧니다. 큰 메모리(32K 이상)는 전역 관리자에서 페이지 크기(4K) 단위로 클래스를 나누어 mmap()을 이용하여 할당하는 것을 제외하고 전체적으로 비슷하게 처리합니다.&lt;/p&gt;
&lt;p&gt;소스를 빌드하고 프로젝트에 라이브러리를 링크하는 방법은 
&lt;a href=&#34;http://code.google.com/p/google-perftools/wiki/GooglePerformanceTools&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;위키페이지&lt;/a&gt;
에 설명되어 있으며, 문제가 발생하거나 더 복잡한 튜닝을 원한다면 소스 묶음 안에 있는 
&lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/README&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;README&lt;/a&gt;
, 
&lt;a href=&#34;http://google-perftools.googlecode.com/svn/trunk/INSTALL&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;INSTALL&lt;/a&gt;
 파일 등을 참고하면 됩니다. (특히 리눅스 x86_64 환경에서는 &lt;code&gt;configure&lt;/code&gt; 실행시 &amp;lsquo;&lt;code&gt;--enable-frame-pointers&lt;/code&gt;&amp;rsquo; 옵션을 추가하는 것이 좋습니다)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>우분투에서 C 라이브러리 맨페이지(manpage) 설치하기</title>
      <link>/2009/04/08/2009-04-08-pthread-man-pages-in-ubuntu-or-debian/</link>
      <pubDate>Wed, 08 Apr 2009 00:00:00 +0000</pubDate>
      <guid>/2009/04/08/2009-04-08-pthread-man-pages-in-ubuntu-or-debian/</guid>
      <description>&lt;p&gt;리눅스에서 개발할때 &amp;lsquo;man&amp;rsquo; 명령을 이용해 매뉴얼 페이지를 많이 참고하는데, 자주 시스템을 다시 설치하다 보니 설치되지 않은 매뉴얼 때문에 매번 구글을 찾는라 귀찮은 적이 많아 적어둡니다. 우분투나 데비안에서만 유효합니다.&lt;/p&gt;
&lt;p&gt;기본적인 C 라이브러리 관련 매뉴얼 패이지는 `manpages-dev&amp;rsquo; 패키지를 설치하면 되고, pthread_*()  류의 함수는 `glibc-doc&amp;rsquo; 패키지를 설치하면 됩니다. 즉, 터미널에서 다음과 같이 입력하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install manpages-dev glibc-doc
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>리눅스 멀티쓰레드(futex) 호출 디버깅</title>
      <link>/2006/12/21/2006-12-21-linux-multithread-futex-call-debugging/</link>
      <pubDate>Thu, 21 Dec 2006 00:00:00 +0000</pubDate>
      <guid>/2006/12/21/2006-12-21-linux-multithread-futex-call-debugging/</guid>
      <description>&lt;p&gt;리눅스 커널 2.6 이후, 즉 최신 리눅스 환경에서 어플리케이션을 개발할때 멀티쓰레드인 경우 데드락이나 블럭킹 현상을 디버깅하려면 매우 골치가 아프다. strace나 gdb 백트레이스를 추적하다보면 결국 &lt;code&gt;futex()&lt;/code&gt; 시스템콜을 호출하고, 여기서 멈춰있는 경우가 대부분이다. 이 경우 대부분 이 시스템콜은 pthread 라이브러리가 호출하는 것이다. 이 경우 정확히 어떤 공유 라이브러리와 연관이 있는지 확인하기 힘든데 
&lt;a href=&#34;http://galathilion.livejournal.com/91051.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;여기&lt;/a&gt;
 블로그에 달린 댓글을 보면 다음 2가지 방법을 권하고 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;export LD_ASSUME_KERNEL=2.4.1&lt;/code&gt;식으로 커널 버전을 명시하여 glibc가 NPTL 대신 futex() 를 사용하지 않는 이전 LinuxThread 방식을 사용하도록 하여 디버깅하기&lt;/li&gt;
&lt;li&gt;ltrace 프로그램을 이용하여 라이브러리 호출 감시하기&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;하지만, 뭐 그런다고 쉽게 풀리지는 않는게 멀티쓰레드 프로그래밍인지라&amp;hellip;&lt;/p&gt;
&lt;p&gt;참고:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;http://galathilion.livejournal.com/91051.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Jeremy Kolb: futex headaches&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>glibc 메모리 할당 방식 튜닝</title>
      <link>/2006/03/17/2006-03-17-glibc-memory-allocation-tune/</link>
      <pubDate>Fri, 17 Mar 2006 00:00:00 +0000</pubDate>
      <guid>/2006/03/17/2006-03-17-glibc-memory-allocation-tune/</guid>
      <description>&lt;p&gt;&amp;lsquo;Malloc 연구 : 과도한 마이너 폴트 사례 (
&lt;a href=&#34;http://www.usenix.org/publications/library/proceedings/als01/ezolt.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A Study in Malloc: A Case of Excessive Minor Faults&lt;/a&gt;
&amp;lsquo;라는 논문은 개발자가 흔히 부딪힐 수 있는 문제에 대하여 원인 추적 및 해결 과정을 흥미롭게 보여준다. 더불어 리눅스에서 GNU libc의 메모리 관리자를 튜닝하는 방법을 이용해 코드 재작성 없이 어플리케이션 성능을 향상시키는 방법에 대해 논하고 있다.&lt;/p&gt;
&lt;p&gt;컴팩(Compaq)의 CXML이라는 확장 수학 라이브러리를 이용해 어플리케이션을 개발하는 사용자로부터 다음과 같은 문의가 들어왔다. 똑같은 코드와 똑같은 사양의 하드웨어를 기반으로 할때 기존 유닉스(Tru64 UNIX) 환경보다 리눅스(Linux/Alpha)에서 어플리케이션 실행 시간이 너무 많이 차이가 난다는 것이다.&lt;/p&gt;
&lt;p&gt;이 글의 저자는 여러가지 도구를 이용하여 원인이 리눅스 커널의 메모리 관리와 연관이 있다는 것을 밝혀낸다. 그리고, 더 나아가 커널의 메모리 관리가 아닌 GNU libc의 &lt;code&gt;malloc()&lt;/code&gt;/&lt;code&gt;free()&lt;/code&gt; 구현이 기존 유닉스나 FreeBSD 등과도 다르다는 점을 밝혀낸다.&lt;/p&gt;
&lt;p&gt;일반적으로 &lt;code&gt;brk()&lt;/code&gt; 시스템콜을 이용해 힙(heap) 영역을 확장하는 다른 유닉스 시스템과 달리 리눅스가 사용하는 glibc는 일정 크기 이상의 메모리 영역은 &lt;code&gt;mmap()&lt;/code&gt;을 이용해 할당한다. 이렇게 할당한 메모리는 사용자가 해제했을때 바로 시스템으로 돌아가고, 전체적으로 시스템은 효율적으로 메모리를 사용할 수 있다는 장점이 있지만, &lt;code&gt;mmap()&lt;/code&gt; 시스템콜 자체가 커널 영역 페이지 폴트 메카니즘을 사용하기 때문에 이 부분에서 많은 성능 저하가 발생하게 된다.&lt;/p&gt;
&lt;p&gt;이 논문의 제목인 마이너 폴트(minor faults)란, 아예 할당할 메모리가 없어 스왑(swap)이 필요한 경우가 아닌(major faults), COW(copy-on-write) 기법이나 일반적인 디바이스 메모리 맵핑 등과 같이 물리적인 메모리를 가상 메모리에 맵핑할때 발생하는 페이지 폴트를 의미한다.&lt;/p&gt;
&lt;p&gt;저자는 매우 자세하고 친절하게 몇가지 증상에서 원인을 찾아가는 과정을 설명하고 있다. 여기서 든 예제의 경우 128K 이상의 메모리를 할당하고 해제하는 과정을 반복할 경우 발생하는 이러한 마이너폴트를 줄이기 위해 결론적으로 다음과 같은 방법을 제시하고 있다.&lt;/p&gt;
&lt;p&gt;첫번째 방법은 소스 코드를 수정해 &lt;code&gt;mmap()&lt;/code&gt;을 쓰지 않도록 GNU libc의 메모리 관리자에게 알려주는 것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mallopt (M_MMAP_MAX, 0);
mallopt (M_TRIM_THRESHOLD, -1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;두번째 방법은 어플리케이션을 실행하기 전에 환경변수에 이 값을 설정하는 방법이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export MALLOC_MMAP_MAX_=0
export MALLOC_TRIM_THRESHOLD_=-1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;더 자세한 내용은 
&lt;a href=&#34;http://www.gnu.org/software/libc/manual/html_node/Malloc-Tunable-Parameters.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;mallopt()&lt;/a&gt;
 함수를 참고하면 된다.&lt;/p&gt;
&lt;p&gt;그런데, 요즘 커널과 요즘 glibc에도 그대로 적용이 가능한지는 확인해봐야 할 것 같다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GCC와 GLIBC로 최적화하기</title>
      <link>/2006/03/13/2006-03-13-optimizing-applications-with-gcc-and-glibc/</link>
      <pubDate>Mon, 13 Mar 2006 00:00:00 +0000</pubDate>
      <guid>/2006/03/13/2006-03-13-optimizing-applications-with-gcc-and-glibc/</guid>
      <description>&lt;p&gt;gcc와 glibc로 어플리케이션 최적화하기 (
&lt;a href=&#34;http://people.redhat.com/drepper/optimtut1.ps.gz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Optimizing Applications with gcc &amp;amp; glibc&lt;/a&gt;
)&lt;/p&gt;
&lt;p&gt;glibc 개발자인 
&lt;a href=&#34;http://people.redhat.com/drepper/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ulrich Drepper&lt;/a&gt;
가 1999년에 작성한 40페이지 분량의 글이다. 대략 관심있는 내용을 정리해본다.&lt;/p&gt;
&lt;span style=&#34;font-weight:bold;&#34;&gt;
 사용 안되는 코드 컴파일시 제거 &lt;/span&gt;
&lt;p&gt;다음 코드는 주어진 타입에 따라 다른 작업을 하는데, &lt;code&gt;int&lt;/code&gt;형과 &lt;code&gt;long int&lt;/code&gt;형이 같은 플랫폼일 경우 좋지 않은 성능을 보인다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long intadd (long int a, void *ptr, int type)
{
  if (type == 0)
    return a + *(int *)ptr;
  else
    return a + *(long int *)ptr;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드는 다음과 같이 최적화할 수 있다. 이는 컴파일러가 알아서 최적화해준다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long intadd (long int a, void *ptr, int type)
{
  if (sizeof(int) == sizeof(long int) || type == 0)
    return a + *(int *)ptr;
  else
    return a + *(long int *)ptr;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;다음과 같은 방법을 이용하면 전처리기(preprocessor)가 알아서 최적화해준다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;long intadd (long int a, void *ptr, int type)
{
#if LONG_MAX != INT_MAX
  if (type == 0)
    return a + *(int *)ptr;
  else
#endif
  return a + *(long int *)ptr;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;span style=&#34;font-weight:bold;&#34;&gt;
 컴파일러 내부 함수(intrinsics) 이용하기&lt;/span&gt;
&lt;p&gt;gcc 2.96 이후부터 많은 &lt;code&gt;__builtin_*&lt;/code&gt; 함수가 존재한다. 이 함수들은 컴파일시에 컴파일러가 판단하여 인수가 상수이거나 정해진 크기 등일 경우 최적화된 코드를 생성해 준다. 이 함수들은 매크로인 경우도 있고 컴파일시 정적으로 링크되는 라이브러리일 수도 있다. 어떤 함수들은 컴파일러 내부 함수를 이용해 최적화되어 있다. 따라서 가능한 이러한 함수들은 별도 랩핑을 두지 않고 헤더파일을 포함하여 그대로 사용하면 더 좋은 성능의 코드를 얻을 수 있다. 내부 함수를 이용하는 함수 중에 대표적인 것들은 다음과 같은 것들이 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;alloca()
memcpy(), memcmp(), memset()
strcmp(), strcpy(), strlen()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;더 많은 함수는 원문을 참고하면 된다.&lt;/p&gt;
&lt;span style=&#34;font-weight:bold;&#34;&gt;
 strcpy()와 memcpy()&lt;/span&gt;
&lt;p&gt;문자열의 크기를 이미 알고 있다면 &lt;code&gt;str*()&lt;/code&gt; 류의 함수보다 &lt;code&gt;mem*()&lt;/code&gt; 류의 함수를 이용하는 것이 좋다. 우선 매 바이트마다 문자열 끝 코드인 0x00을 검사하는 코드가 없어 빠르고, 무엇보다도 &lt;code&gt;memcpy()&lt;/code&gt;는 플랫폼 기본 단위(예를 들어 32비트 플랫폼에서는 4바이트) 연산을 하기 때문에, 항상 바이트 단위로 작업하는 &lt;code&gt;strcpy()&lt;/code&gt; 또는 &lt;code&gt;strncpy()&lt;/code&gt;보다 빠를 수 밖에 없다.&lt;/p&gt;
&lt;span style=&#34;font-weight:bold;&#34;&gt;
 strcat(), strncat()&lt;/span&gt;
&lt;p&gt;절대로 &lt;code&gt;strcat()&lt;/code&gt;, &lt;code&gt;strncat()&lt;/code&gt; 함수는 사용하지 말아야 한다. 문자열을 합치는데 이 함수를 이용하는 것은 성능에 치명적이다. 내부적으로 &lt;code&gt;strlen()&lt;/code&gt;을 호출하는 것 뿐 아니라 문자열을 처리하기 위한 여러 조건을 검사하기 때문에 매우 느리다. 이보다는 직접 &lt;code&gt;strlen()&lt;/code&gt;으로 문자열 길이를 구한 뒤 &lt;code&gt;memcpy()&lt;/code&gt;를 이용해 해당 위치에 복사하거나 필요한 작업을 하는 것이 더 현명한 방법이다.&lt;/p&gt;
&lt;p&gt;다음은 이에 대한 샘플 코드이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  char *buf = ...;
  size_t bufmax = ...;

  /* Add &#39;s&#39; to the string in buffer &#39;buf&#39;. */
  if (strlen(buf) + strlen(s) + 1 &amp;gt; bufmax)
    buf = (char *)realloc(buf, (bufmax *= 2));
  strcat(buf, s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로그래머 관점에서 이 코드는 괜찮아 보이지만, 성능은 최악이다. 다음과 같이 고치면 더 좋은 성능을 낼 수 있다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  char *buf = ...;
  size_t bufmax = ...;
  size_t slen, buflen;

  /* Add &#39;s&#39; to the string in buffer &#39;buf&#39;. */
  slen = strlen(s) + 1;
  buflen = strlen(buf);

  if (buflen + slen &amp;gt; bufmax)
    buf = (char *)realloc(buf, (bufmax *= 2));

  memcpy(buf + buflen, s, slen);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;span style=&#34;font-weight:bold;&#34;&gt;
 메모리 할당 최적화&lt;/span&gt;
&lt;p&gt;&lt;code&gt;malloc()&lt;/code&gt;과 &lt;code&gt;calloc()&lt;/code&gt;의 차이점을 모르는 프로그래머는 없겠지만, 그래서 &lt;code&gt;calloc()&lt;/code&gt;보다 직접 &lt;code&gt;malloc()&lt;/code&gt; 호출 이후 &lt;code&gt;memset()&lt;/code&gt; 등을 이용해 0으로 초기화하는 방법을 많이 이용하기도 한다. 하지만 &lt;code&gt;calloc()&lt;/code&gt;은 커널 페이지에서 이미 0으로 초기화되어 있는 영역이 있을 경우 불필요한 초기화 과정을 건너뛰기 때문에 더 좋은 성능을 낼 수 있다.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;alloca()&lt;/code&gt; 함수를 모르는 사람도 많은데, 이 함수는 지정한 크기의 영역을 현재 스택 영역에 할당한다. 메모리 관리자를 거치지 않고 단순히 스택 포인터 레지스터 조작만으로 할당 작업이 이루어지기 때문에 매우 성능이 좋을 뿐 아니라, 따로 해제하지 않아도 함수가 끝나는 시점에서 자동으로 해제된다. 따라서 함수 내부에서 임시로 할당하여 사용하는 많은 구현에서 &lt;code&gt;malloc()&lt;/code&gt; 보다 &lt;code&gt;alloca()&lt;/code&gt; 를 사용한 코드의 성능은 매우 향상된다. glibc에서 확장으로 제공하는 &lt;code&gt;strdupa()&lt;/code&gt;, &lt;code&gt;strndupa()&lt;/code&gt; 등의 API는 모두 이 방법을 이용한 최적화된 성능을 보장한다.&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;font-weight:bold;&#34;&gt;그외&amp;hellip;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;기타 이 글에서는 gprof, sprof 등을 이용한 코드 프로파일링 방법과 GCC 컴파일러 확장을 이용한 다양한 최적화 방법을 제시하고 있다. 더불어 저자는 같은 내용에 조금 더 내용이 보강된 
&lt;a href=&#34;http://people.redhat.com/drepper/optimtut2.ps.gz&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Application Optimization on Linux&lt;/a&gt;
 글에서 프로필과 관련된 더 자세한 정보를 제공하고 있다.&lt;/p&gt;
&lt;p&gt;이 글에서도 언급한 내용이지만, 많은 프로그래머는 자신이 작성한 프로그램이 정말 잘 쓰여지고 성능이 좋다고 생각하지만, 불행하게도 아닌 경우가 대부분이다. 최적화된 프로그램을 작성하는 것은 항상 진행중인 배우는 과정(learning process)이다. 항상 새로운 테크닉을 배우고, 자신의 코드를 검토하고, 상호작용하는 라이브러리와 프로세서에 대해 생각해야 한다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>라이브러리 설계, 구현, 유지에 좋은 습관</title>
      <link>/2006/02/24/2006-02-24-good-practices-in-library-design-implementation-and-maintenance/</link>
      <pubDate>Fri, 24 Feb 2006 00:00:00 +0000</pubDate>
      <guid>/2006/02/24/2006-02-24-good-practices-in-library-design-implementation-and-maintenance/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://www.gnu.org/software/libc/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;glibc(GNU libc)&lt;/a&gt;
 관리자이며 개발자인 
&lt;a href=&#34;http://people.redhat.com/drepper/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Ulrich Drepper&lt;/a&gt;
의 글 중에 &amp;lsquo;
&lt;a href=&#34;http://people.redhat.com/drepper/goodpractice.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Good Practices in Library Design, Implementation, and Maintenance&amp;rsquo;&lt;/a&gt;
 는 비단 라이브러리 개발 뿐 아니라 일반 프로젝트를 진행할때도 유용한 여러 가이드라인을 제시한다. 간략하게 정리해보면 다음과 같다.&lt;/p&gt;
&lt;p&gt;&lt;span style=&#34;font-weight:bold;&#34;&gt;인터페이스 설계하기&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;가능한 API에 변수를 포함하지 말라. 대신 내부 변수를 처리하는 get-/set-함수를 구현하라.&lt;/li&gt;
&lt;li&gt;라이브러리가 제공하는 모든 인터페이스, 변수, 함수, 자료구조에 접두사(prefix)를 붙여라. 모든 객체에 반드시 같은 접두사를 사용할 필요는 없으며, 한 라이브러리가 여러 접두사를 사용해도 된다.&lt;/li&gt;
&lt;li&gt;C/C++ 라이브러리 설치시 함께 제공하는 헤더파일은 인터페이스를 정의하는데 필요한 정의(definition)와 선언(declaration)만 포함해야 한다.&lt;/li&gt;
&lt;li&gt;사용자가 직접 객체를 할당하지 않는 불완전한 형식(incomplete type)을 사용한다면 선정의(forward declaration)를 이용하는 것이 맞다.&lt;/li&gt;
&lt;li&gt;컴파일 설정(configuration)이 변경되더라도 라이브러리 헤더 파일은 변하면 안된다.&lt;/li&gt;
&lt;li&gt;어쩔 수 없이 불완전하게 정의한 데이터 타입을 제공해야 한다면, 나중에 커질 부분을 고려하여 최소한의 패딩을 만들어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span style=&#34;font-weight:bold;&#34;&gt;라이브러리 구현하기&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;가능한 많은 함수와 변수를 &amp;lsquo;static&#39;을 이용하여 오브젝트 파일에 지역적으로(local) 정의하라.&lt;/li&gt;
&lt;li&gt;외부로 보여지는(export) 심볼은 최대한 줄여라. 가장 좋은 경우는 문서화된 인터페이스만 보여지는 것이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span style=&#34;font-weight:bold;&#34;&gt;라이브러리 유지하기&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;이전 버전에 없었던 새로운 인터페이스는 따로 표시해야 새로운 인터페이스를 사용하는 어플리케이션이 아예 동작하지 못하도록 할 수 있다.&lt;/li&gt;
&lt;li&gt;오류를 수정하는게 아닌 다른 이유로 인터페이스가 변경되더라도 이전 인터페이스는 그대로 존재해야 한다.&lt;/li&gt;
&lt;li&gt;문서화된 라이브러리 인터페이스의 모든 면은 문서화해야 한다. 인터페이스가 변경되어야 한다면, 이전 동작이 그대로 유지된다는 것을 보장하기 위해 최소한 새 테스트가 추가되어야 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;키워드만 정리한 것이지만, 10쪽 분량밖에 안되는 글이므로 가능한 원본을 읽어보는 것이 좋을 것이다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>linux-gate.so.1</title>
      <link>/2006/01/17/2006-01-17-linux-gateso1/</link>
      <pubDate>Tue, 17 Jan 2006 00:00:00 +0000</pubDate>
      <guid>/2006/01/17/2006-01-17-linux-gateso1/</guid>
      <description>&lt;p&gt;데비안 패키지 glibc-2.3.5 이후부터 &lt;code&gt;ldd&lt;/code&gt; 명령의 결과에 예전에 없던 &amp;lsquo;linux-gate.so.1&amp;rsquo; 공유 라이브러리가 포함되어 있어 궁금했다. 다음 예에서 첫번째 줄이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ldd /bin/sh
linux-gate.so.1 =&amp;gt;  (0xffffe000)
libdl.so.2 =&amp;gt; /lib/libdl.so.2 (0xb7fb2000)
libc.so.6 =&amp;gt; /lib/libc.so.6 (0xb7e7c000)
/lib/ld-linux.so.2 (0xb7fba000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Google에서 찾아본 결과 &amp;ldquo;
&lt;a href=&#34;http://www.trilithium.com/johan/2005/08/linux-gate/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;What is linux-gate.so.1?&lt;/a&gt;
&amp;rdquo; 문서가 가장 잘 설명해주고 있었다. 2.5 커널부터 시스템콜 호출을 전통적인 &lt;code&gt;&#39;int 0x80&#39;&lt;/code&gt;이 아닌 인텔 펜티엄 II 이후에 추가된 &lt;code&gt;sysenter&lt;/code&gt; 인스트럭션을 이용하여 오버헤드를 줄이고, 64비트 머신과의 일관성을 유지하기 위해 고안된 방법이었다. 이 공유라이브러리는 커널이 마치 DSO처럼 제공하는 시스템콜 라이브러리인 셈이다. 그래서 파일시스템에는 실제 이 파일이 없다. &amp;lsquo;&lt;em&gt;linux-gate&lt;/em&gt;&amp;rsquo; 라는 이름은 커널과 사용자 프로세스간의 통로라는 뜻에서 그렇게 붙인 것 같다.&lt;/p&gt;
&lt;p&gt;몇년 동안 2.6 커널을 사용해왔는데 왜 모르고 있었을까. 이유를 조금 더 조사해 보니, 다음에 보는 것처럼 glibc 버전과 상관없이 커널은 이미 지원하고 있었다. 다음은 glibc-2.3.5가 아니고 커널만 2.6인 시스템에서 출력한 결과다. 여기서 가장 마지막의 &amp;lsquo;&lt;code&gt;[vdso]&lt;/code&gt;&amp;rsquo; 부분이 바로 그것이다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[lethean@lethean ~]$ cat /proc/self/maps
08048000-0804c000 r-xp 00000000 03:01 758909     /bin/cat
0804c000-0804d000 rw-p 00003000 03:01 758909     /bin/cat
0804d000-0806e000 rw-p 0804d000 00:00 0          [heap]
...
b7f23000-b7f38000 r-xp 00000000 03:01 734436     /lib/ld-2.3.6.so
b7f38000-b7f39000 rw-p 00014000 03:01 734436     /lib/ld-2.3.6.so
bf923000-bf938000 rw-p bf923000 00:00 0          [stack]
ffffe000-fffff000 ---p 00000000 00:00 0          [vdso]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;단지 glibc-2.3.5 버전에 포함된 &lt;code&gt;ldd&lt;/code&gt;가 이를 &amp;lsquo;linux-gate.so.1&amp;rsquo; 이라는 표시하기 시작한 것이다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
