<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Agile | 대체로 무해함</title>
    <link>/tags/agile/</link>
      <atom:link href="/tags/agile/index.xml" rel="self" type="application/rss+xml" />
    <description>Agile</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>ko-kr</language><copyright>© lethean</copyright><lastBuildDate>Fri, 24 Feb 2012 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>Agile</title>
      <link>/tags/agile/</link>
    </image>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (5)</title>
      <link>/2012/02/24/oop-with-gobject-5/</link>
      <pubDate>Fri, 24 Feb 2012 00:00:00 +0000</pubDate>
      <guid>/2012/02/24/oop-with-gobject-5/</guid>
      <description>&lt;p&gt;거의 2년만에 GObject 객체 지향 프로그래밍 연재 글을 포스팅합니다. 사실 이 글의 일부는 예전에 작성해 둔 것인데, 이번 
&lt;a href=&#34;http://gnome-kr.blogspot.com/2012/02/2-gnome-tech-talks.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GNOME Tech Talks&lt;/a&gt;
에서 발표 하나를 맡게 되면서, 슬라이드 자료를 따로 만들 시간은 없고 그렇다고 오래된 자료를 재탕하는 건 실례인 것 같아 조금 보완해서 작성했습니다. 참고로, GObject 개념을 잘 모르는 분이라면 이전 연재 글을 먼저 읽어 보시면 도움이 될 수 있습니다. :)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;/2009/08/10/oop-with-gobject-1/&#34; title=&#34;GObject 객체 지향 프로그래밍 (1)&#34;&gt;GObject 객체 지향 프로그래밍 (1)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;/2009/08/14/oop-with-gobject-2/&#34; title=&#34;GObject 객체 지향 프로그래밍 (2)&#34;&gt;GObject 객체 지향 프로그래밍 (2)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;/2009/08/18/oop-with-gobject-3/&#34; title=&#34;GObject 객체 지향 프로그래밍 (3)&#34;&gt;GObject 객체 지향 프로그래밍 (3)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;/2009/08/24/oop-with-gobject-4/&#34; title=&#34;GObject 객체 지향 프로그래밍 (4)&#34;&gt;GObject 객체 지향 프로그래밍 (4)&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;/2010/02/11/how-to-make-a-gobject-singleton/&#34; title=&#34;싱글턴(Singleton) GObject 객체 만들기&#34;&gt;싱글턴(Singleton) GObject 객체 만들기&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;/2010/04/07/serialize-gobject-properties/&#34; title=&#34;GObject 속성 직렬화(Serialization)하기&#34;&gt;GObject 속성 직렬화(Serialization)하기&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;GObject 객체 지향 시스템을 구성하는 여러가지 개념 중 상속(inheritance), 참고 카운터(reference counting), 속성(properties) 등에 대해서는 지난 글에서 이미 소개했습니다. 아직 GObject 라이브러리에서 소개하지 않은 개념이 아직 많이 남아 있지만, 그 중에서 가장 중요한 것 중 하나는 바로 시그널(signals)이 아닐까 생각합니다. 속성이 변경되었을때 자동으로 호출되는 콜백 함수를 등록해서 사용하는 방법을 설명할 때 약간 소개했지만, 아무래도 그걸로는 부족하기 때문에 이번 글은 시그널의 개념과 사용 방법, 그리고 속성 바인딩을 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;간단한 클러터 기반 시계&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/myclock-screenshot.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;언제나 그렇듯이 재미없는 예제 소스를 먼저 보여드립니다. 이 소스를 컴파일해서 실행하면 위 그림과 같은 시계가 동작합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* myclock1.c */

/*****************************************************************************/

#include &amp;lt;glib-object.h&amp;gt;

#define MY_TYPE_CLOCK (my_clock_get_type ())
#define MY_CLOCK(obj) 
  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_CLOCK, MyClock))
#define MY_CLOCK_CLASS(klass) 
  (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_CLOCK, MyClockClass))
#define MY_IS_CLOCK(obj) 
  (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_CLOCK))
#define MY_IS_CLOCK_CLASS(klass) 
  (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_CLOCK))
#define MY_CLOCK_GET_CLASS(obj) 
  (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_CLOCK, MyClockClass))

typedef struct _MyClock        MyClock;
typedef struct _MyClockClass   MyClockClass;
typedef struct _MyClockPrivate MyClockPrivate;

struct _MyClock
{
  GObject         parent;
  MyClockPrivate *priv;
};

struct _MyClockClass
{
  GObjectClass parent_class;
};

enum
{
  PROP_0,
  PROP_DATE_TIME,
  PROP_LAST
};

struct _MyClockPrivate
{
  GDateTime *datetime;
  guint      timeout;
};

G_DEFINE_TYPE (MyClock, my_clock, G_TYPE_OBJECT);

static GParamSpec *props[PROP_LAST];

GDateTime *
my_clock_get_date_time (MyClock *clock_)
{
  g_return_val_if_fail (MY_IS_CLOCK (clock_), NULL);

  return g_date_time_ref (clock_-&amp;gt;priv-&amp;gt;datetime);
}

static void
my_clock_set_date_time (MyClock   *clock_,
                        GDateTime *datetime)
{
  g_date_time_unref (clock_-&amp;gt;priv-&amp;gt;datetime);
  clock_-&amp;gt;priv-&amp;gt;datetime = g_date_time_ref (datetime);
  g_object_notify_by_pspec (G_OBJECT (clock_), props[PROP_DATE_TIME]);
}

static gboolean
my_clock_update (gpointer data)
{
  MyClock   *clock_ = data;
  GTimeVal   now;
  GDateTime *datetime;
  guint      interval;

  g_get_current_time (&amp;amp;now);

  datetime = g_date_time_new_from_timeval_local (&amp;amp;now);
  my_clock_set_date_time (clock_, datetime);
  g_date_time_unref (datetime);

  interval = (1000000L - now.tv_usec) / 1000L;
  clock_-&amp;gt;priv-&amp;gt;timeout =
    g_timeout_add_full (G_PRIORITY_HIGH_IDLE,
                        interval,
                        my_clock_update,
                        g_object_ref (clock_),
                        g_object_unref);

  return FALSE;
}

static void
my_clock_set_property (GObject      *object,
                       guint         param_id,
                       const GValue *value,
                       GParamSpec   *pspec)
{
  switch (param_id)
    {
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec);
      break;
    }
}

static void
my_clock_get_property (GObject   *object,
                       guint      param_id,
                       GValue     *value,
                       GParamSpec *pspec)
{
  MyClock *clock_ = MY_CLOCK (object);

  switch (param_id)
    {
    case PROP_DATE_TIME:
      g_value_set_boxed (value, clock_-&amp;gt;priv-&amp;gt;datetime);
      break;
    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec);
      break;
    }
}

static void
my_clock_finalize (GObject *gobject)
{
  MyClockPrivate *priv = MY_CLOCK (gobject)-&amp;gt;priv;

  g_date_time_unref (priv-&amp;gt;datetime);
  g_source_remove (priv-&amp;gt;timeout);

  G_OBJECT_CLASS (my_clock_parent_class)-&amp;gt;finalize (gobject);
}

static void
my_clock_class_init (MyClockClass *klass)
{
  GObjectClass *obj_class = G_OBJECT_CLASS (klass);
  GParamSpec   *pspec;

  obj_class-&amp;gt;set_property = my_clock_set_property;
  obj_class-&amp;gt;get_property = my_clock_get_property;
  obj_class-&amp;gt;finalize     = my_clock_finalize;

  g_type_class_add_private (klass, sizeof (MyClockPrivate));

  pspec = g_param_spec_boxed (&amp;quot;datetime&amp;quot;,
                              &amp;quot;Date and Time&amp;quot;,
                              &amp;quot;The date and time to show in the clock&amp;quot;,
                              G_TYPE_DATE_TIME,
                              G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
  props[PROP_DATE_TIME] = pspec;
  g_object_class_install_property (obj_class, PROP_DATE_TIME, pspec);
}

static void
my_clock_init (MyClock *clock_)
{
  MyClockPrivate *priv;

  priv = clock_-&amp;gt;priv =
    G_TYPE_INSTANCE_GET_PRIVATE (clock_,
                                 MY_TYPE_CLOCK,
                                 MyClockPrivate);

  priv-&amp;gt;datetime = g_date_time_new_now_local ();
  priv-&amp;gt;timeout = 0;

  my_clock_update (clock_);
}

MyClock *
my_clock_new (void)
{
  return g_object_new (MY_TYPE_CLOCK, NULL);
}

/*****************************************************************************/

#include &amp;lt;clutter/clutter.h&amp;gt;

static void
clock_datetime_changed (GObject    *object,
                        GParamSpec *pspec,
                        gpointer    data)
{
  MyClock      *clock_ = MY_CLOCK (object);
  ClutterActor *text   = data;
  GDateTime    *datetime;
  gchar        *str;

  datetime = my_clock_get_date_time (clock_);
  str = g_date_time_format (datetime, &amp;quot;%xn%H:%M:%S&amp;quot;);

  clutter_text_set_text (CLUTTER_TEXT (text), str);

  g_free (str);
  g_date_time_unref (datetime);
}

int
main (int    argc,
      char **argv)
{
  ClutterActor      *stage;
  ClutterActor      *text;
  ClutterConstraint *constraint;
  MyClock           *clock_;

  if (clutter_init (&amp;amp;argc, &amp;amp;argv) != CLUTTER_INIT_SUCCESS)
    return -1;

  /* stage */
  stage = clutter_stage_get_default ();
  clutter_actor_set_size (stage, 320, 240);
  clutter_stage_set_color (CLUTTER_STAGE (stage), CLUTTER_COLOR_Black);
  clutter_stage_set_user_resizable (CLUTTER_STAGE (stage), TRUE);

  /* text */
  text = clutter_text_new_full (&amp;quot;Sans Bold 20&amp;quot;,
                                &amp;quot;NOW&amp;quot;,
                                CLUTTER_COLOR_LightButter);
  clutter_container_add_actor (CLUTTER_CONTAINER (stage), text);
  clutter_text_set_line_alignment (CLUTTER_TEXT (text), PANGO_ALIGN_CENTER);

  /* align text in center of stage */
  constraint =
    clutter_align_constraint_new (stage, CLUTTER_ALIGN_X_AXIS, 0.5);
  clutter_actor_add_constraint (text, constraint);

  constraint =
    clutter_align_constraint_new (stage, CLUTTER_ALIGN_Y_AXIS, 0.5);
  clutter_actor_add_constraint (text, constraint);

  /* clock */
  clock_ = my_clock_new ();
  g_signal_connect (clock_,
                    &amp;quot;notify::datetime&amp;quot;,
                    G_CALLBACK (clock_datetime_changed),
                    text);

  clutter_actor_show (stage);

  clutter_main ();

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;소스 코드를 간단하게 설명하면, &lt;code&gt;MyClock&lt;/code&gt; 객체가 1초 간격으로 현재 시간을 얻어와 자신의 &lt;code&gt;datetime&lt;/code&gt; 속성을 갱신하면[&lt;code&gt;my_clock_update()&lt;/code&gt;], 속성이 변경되었을때(&lt;code&gt;notify::datetime&lt;/code&gt;) 자동으로 호출되는 콜백 함수를[&lt;code&gt;clock_datetime_changed()&lt;/code&gt;] 등록해 자동으로 클러터 텍스트(&lt;code&gt;ClutterText&lt;/code&gt;)를 이용해 화면에 표시합니다.&lt;/p&gt;
&lt;p&gt;이제 이 소스 코드를 두 가지 방법으로 확장하려고 합니다. 첫번째 방법은 속성 바인딩(property binding)을 이용해 시그널을 사용하지 않는 방법이고, 두번째 방법은 시간이 변경되었을때 호출되는 진짜(!) 시그널을 추가하는 것입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;속성 바인딩 (Property Binding)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;속성 바인딩(property binding)이란 두 GObject 객체간의 두 속성을 묶는 걸 말합니다. 여기서 묶는다는 의미는, 한 객체의 속성 값이 변하면 다른 객체의 속성 값도 자동으로 변한다는 의미입니다. 물론 묶으려는 두 속성은 같은 형(type)이어야 합니다. 그런데, 위 예제의 경우 &lt;code&gt;MyClock:``datetime&lt;/code&gt; 속성과 
&lt;a href=&#34;http://developer.gnome.org/clutter/stable/ClutterText.html#ClutterText--text&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;ClutterText:``text&lt;/code&gt;&lt;/a&gt;
 속성은 형(type)이 다릅니다. 그래서, 위 소스를 다음과 같이 수정합니다. (변경된 부분만 보여 드립니다)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* myclock2.c */

/* ... */

enum
{
  PROP_0,
  PROP_DATE_TIME,
  PROP_TEXT,
  PROP_LAST
};

struct _MyClockPrivate
{
  GDateTime *datetime;
  guint      timeout;
  gchar     *text;
};

/* ... */

const gchar *
my_clock_get_text (MyClock *clock_)
{
  g_return_val_if_fail (MY_IS_CLOCK (clock_), NULL);

  return clock_-&amp;gt;priv-&amp;gt;text;
}

static void
my_clock_set_date_time (MyClock   *clock_,
                        GDateTime *datetime)
{
  g_date_time_unref (clock_-&amp;gt;priv-&amp;gt;datetime);
  clock_-&amp;gt;priv-&amp;gt;datetime = g_date_time_ref (datetime);
  g_object_notify_by_pspec (G_OBJECT (clock_), props[PROP_DATE_TIME]);

  g_free (clock_-&amp;gt;priv-&amp;gt;text);
  clock_-&amp;gt;priv-&amp;gt;text = g_date_time_format (datetime, &amp;quot;%xn%H:%M:%S&amp;quot;);
  g_object_notify_by_pspec (G_OBJECT (clock_), props[PROP_TEXT]);
}

/* ... */

static void
my_clock_finalize (GObject *gobject)
{
  /* ... */
  g_free (priv-&amp;gt;text);
  /* ... */
}

static void
my_clock_class_init (MyClockClass *klass)
{
  /* ... */

  pspec = g_param_spec_string (&amp;quot;text&amp;quot;,
                               &amp;quot;Text&amp;quot;,
                               &amp;quot;The text of the date and time&amp;quot;,
                               NULL,
                               G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
  props[PROP_TEXT] = pspec;
  g_object_class_install_property (obj_class, PROP_TEXT, pspec);
}

static void
my_clock_init (MyClock *clock_)
{
  /* ... */
  priv-&amp;gt;text = NULL;
  /* ... */
}

/* ... */

int
main (int    argc,
      char **argv)
{
  /* ... */

  /* clock */
  clock_ = my_clock_new ();
  g_object_bind_property (clock_, &amp;quot;text&amp;quot;,
                          text,  &amp;quot;text&amp;quot;,
                          G_BINDING_SYNC_CREATE);

  /* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드에서 변경된 내용은, &lt;code&gt;MyClock&lt;/code&gt;에 문자열 형식의 &lt;code&gt;text&lt;/code&gt; 속성을 추가하고[&lt;code&gt;my_clock_class_init()&lt;/code&gt;], &lt;code&gt;datetime&lt;/code&gt; 속성을 갱신할때 &lt;code&gt;text&lt;/code&gt; 속성도 함께 갱신하도록 한 다음[&lt;code&gt;my_clock_set_date_time()&lt;/code&gt;], 기존 속성 변경(&lt;code&gt;notify::datetime&lt;/code&gt;)에 대한 &lt;code&gt;g_signal_connect()&lt;/code&gt; 함수 호출 대신 &lt;code&gt;g_object_bind_property()&lt;/code&gt; 함수를 이용해 두 객체의 속성을 묶었다는 점입니다. 여기서 핵심은 물론 &lt;code&gt;g_object_bind_property()&lt;/code&gt; 함수인데, 이 함수는 
&lt;a href=&#34;/2010/10/02/glib-2-26-0-release/&#34;&gt;GLib 2.26 버전에 추가&lt;/a&gt;
되었으며 
&lt;a href=&#34;/2008/12/15/exobinding/&#34;&gt;예전에 소개한 ExoBinding&lt;/a&gt;
과 사용법이 거의 유사합니다. 물론, 옵션을 통해 바인딩하는 시점부터 값을 동기화할 지(&lt;code&gt;G_BINDING_SYNC_CREATE&lt;/code&gt;), 단방향이 아닌 양방향으로 동기화할 지(&lt;code&gt;G_BINDING_BIDIRECTIONAL&lt;/code&gt;) 등을 지정할 수도 있습니다. 이처럼, 위의 코드에서 볼 수 있듯이, 속성 바인딩을 이용하면 매번 콜백함수를 만들지 않고도 간단하게 코드 몇 줄로 원하는 객체 속성간의 동기화(synchronization)를 처리할 수 있습니다.&lt;/p&gt;
&lt;p&gt;여담이지만, 처음 이 기능을 접했을때 맥, 아이폰 응용 프로그램을 개발하기 위해 XCode에서 마우스 드래그 만으로 객체 속성간 바인딩이 지원되는 것처럼, 코딩이 아닌, Glade 같은 GUI 도구에서 위젯 속성간 바인딩이 지원되면 참 편하지 않을까 하는 생각이 들었던 적도 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;시그널 (Signals)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://developer.gnome.org/gobject/stable/chapter-signal.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GObject 공식 매뉴얼&lt;/a&gt;
에 의하면 시그널(signals)은 메시지 전달 시스템을 구성하는 두가지 기술 중 하나입니다. 하나는 클로저(closures)이고 다른 하나가 시그널(signals)인데, 클로저가 콜백(callback) 함수를 자료구조로 정의한 거라면, 시그널은 이 콜백함수를 등록하고 호출하는 알고리즘을 정의한 것이라고 이해해도 무방합니다.&lt;/p&gt;
&lt;p&gt;클로저를 다시 정의하지 않고 함수 포인터를 직접 사용해도 될 것 같은데 이를 객체로 정의한 이유는 여러가지가 있지만, 무엇보다도 콜백함수에 전달되는 인자(parameters) 목록과 인자 형(type)에 대한 처리(marshalling) 때문입니다. C/C++ 언어에서 함수 호출시 스택에 쌓이는 인자를 가공하는 것 뿐 아니라, GObject가 지원하는 여러 언어에 대한 바인딩을 위해 더 일반화된 클로저(closure) 객체가 필요합니다.&lt;/p&gt;
&lt;p&gt;아무튼, 이론적인 설명은 그만하고 다시 본론으로 돌아와서, 위 예제에서 구현한 &lt;code&gt;MyClock&lt;/code&gt; 객체가 생각보다 잘 설계되고 동작하는 바람에(&amp;hellip;) 프로그램 전체에서 이 객체를 사용하기로 결정했다고 가정해 봅시다. 수많은 모듈과 수많은 객체에서 전역 시계 객체에 속성 알림(notify) 시그널을 연결합니다. 그리고 그때마다 &lt;code&gt;my_clock_get_date_time()&lt;/code&gt;을 호출해 현재 시간을 가져와서 처리합니다. 물론 이 예제에서 전달되는 &lt;code&gt;GDateTime&lt;/code&gt; 구조체는 참조 카운터 방식으로 관리되기 때문에 구조체 전달시  많은 오버헤드가 없지만, 문자열을 복사하거나 많은 데이터가 전달되는 경우라면 무시할 수 없는 상황이 발생합니다. 그래서, 위 첫번째 소스를 다음과 같이 조금 수정합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;/* myclock3.c */

/* ... */

struct _MyClockClass
{
  GObjectClass parent_class;

  /* signals */
  void (*changed) (MyClock   *clock_,
                   GDateTime *datetime);
};

enum
{
  SIGNAL_CHANGED,
  SIGNAL_LAST
};

/* ... */

static guint       signals[SIGNAL_LAST];

/* ... */

static void
my_clock_set_date_time (MyClock   *clock_,
                        GDateTime *datetime)
{
  /* ... */
}

static void
my_clock_real_changed (MyClock   *clock_,
                       GDateTime *datetime)
{
  my_clock_set_date_time (clock_, datetime);
}

static gboolean
my_clock_update (gpointer data)
{
  /* ... */

  datetime = g_date_time_new_from_timeval_local (&amp;amp;now);
  g_signal_emit (clock_, signals[SIGNAL_CHANGED], 0, datetime);
  g_date_time_unref (datetime);

  /* ... */
}

static void
my_clock_class_init (MyClockClass *klass)
{
  /* ... */

  klass-&amp;gt;changed = my_clock_real_changed;

  signals[SIGNAL_CHANGED] =
    g_signal_new (&amp;quot;changed&amp;quot;,
                  G_TYPE_FROM_CLASS (klass),
                  G_SIGNAL_RUN_LAST,
                  G_STRUCT_OFFSET (MyClockClass, changed),
                  NULL,
                  NULL,
                  g_cclosure_marshal_VOID__POINTER,
                  G_TYPE_NONE,
                  1,
                  G_TYPE_POINTER);
}

/* ... */

static void
clock_changed (MyClock   *clock_,
               GDateTime *datetime,
               gpointer   user_data)
{
  ClutterActor *text = user_data;
  gchar        *str;

  str = g_date_time_format (datetime, &amp;quot;%xn%H:%M:%S&amp;quot;);
  clutter_text_set_text (CLUTTER_TEXT (text), str);
  g_free (str);
}

int
main (int    argc,
      char **argv)
{
  /* ... */

  /* clock */
  clock_ = my_clock_new ();
  g_signal_connect (clock_,
                    &amp;quot;changed&amp;quot;,
                    G_CALLBACK (clock_changed),
                    text);

  /* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;바로 위 코드에 보이는 것처럼 &lt;code&gt;g_signal_connect()&lt;/code&gt; 호출시 연결하는 시그널 이름과 콜백 함수[&lt;code&gt;clock_changed()&lt;/code&gt;]가 더 단순하고 효율적으로 변경된 걸 확인할 수 있습니다. 콜백 함수 호출시 전달되는 인수를 그냥 사용하면 되니까 오버헤드가 매우 많이 줄어들 수 밖에 없습니다. 하지만 시그널을 정의해서 사용하는게 단순히 성능과 효율 때문만은 아닙니다. 위 예제에서는 속성이 변경되었을 때 발생하는 시그널을 정의했지만, 일반적으로 시그널은 속성 만으로 표현할 수 없는 객체의 상태 변화를 알리기 위해서 많이 사용합니다.(예: &lt;code&gt;ClutterActor::enter-event&lt;/code&gt; 시그널) 또한 속성의 변화를 통해 알 수 있더라도 더 쉽고 명확하게 이를 전파하기 위해서도 사용합니다.(예: &lt;code&gt;ClutterActor::hide&lt;/code&gt; 시그널과 &lt;code&gt;ClutterActor:visible&lt;/code&gt; 속성)&lt;/p&gt;
&lt;p&gt;더 나아가, 시그널은 상태 변화 뿐 아니라 객체의 동작 방식을 외부에서 제어할 수 있도록 유연성을 제공하는데도 사용합니다. 더 자세한 이해를 위해 시그널 함수 포인터부터 설명하자면, 클래스 구조체 안에 선언된 시그널 함수 포인터[&lt;code&gt;MyClockClass::changed()&lt;/code&gt;]는 일종의 가상 함수(virtual function) 역할을 하면서, 시그널이 발생하면(emit) &lt;code&gt;g_signal_connect()&lt;/code&gt;를 이용해 등록된 사용자 콜백함수가 모두 실행된 뒤 맨 나중에 실행되거나 혹은 사용자 콜백 함수보다 먼저 실행됩니다. 따라서 필요 없을 경우 그냥 &lt;code&gt;NULL&lt;/code&gt;로 내버려두어도 상관없지만, 위 예제에서는 클래스 생성시 &lt;code&gt;my_clock_real_changed()&lt;/code&gt; 함수를 등록시켰습니다. &lt;code&gt;my_clock_real_changed()&lt;/code&gt;는 다시  실제로 &lt;code&gt;datetime&lt;/code&gt; 속성을 갱신하는 작업을 처리하는 &lt;code&gt;my_clock_set_date_time()&lt;/code&gt;을 호출합니다. 그리고, 기존 시간 갱신 함수[&lt;code&gt;my_clock_update()&lt;/code&gt;]에서는 직접 &lt;code&gt;my_clock_set_date_time()&lt;/code&gt;을 호출하지 않고, 시그널을 발생시켜[&lt;code&gt;g_signal_emit()&lt;/code&gt;] 작업을 처리합니다.&lt;/p&gt;
&lt;p&gt;왜 이렇게 복잡하게 일을 나누어 처리할까요? 이렇게 구현하면 몇 가지 장점이 있기 때문입니다. 예를 들어 위 예제에서는 &lt;code&gt;datetime&lt;/code&gt; 속성이 읽기 전용으로 선언되어 있기 때문에 외부에서 그 값을 변경할 수 없습니다. 하지만, 외부에서 직접 &lt;code&gt;g_signal_emit_by_name()&lt;/code&gt; 등을 이용해 시그널을 발생시키면 시그널에 연결된 모든 콜백 함수 뿐 아니라 &lt;code&gt;my_clock_real_changed()&lt;/code&gt; 함수까지도 간접적으로 호출되어 작업을 처리하도록 할 수 있습니다. 게다가 만일 시그널에 연결된 콜백 함수 중 하나가 어떤 이유로 &lt;code&gt;g_signal_stop_emission_by_name()&lt;/code&gt; 등을 호출하면 이후 실행될 콜백 함수나 &lt;code&gt;my_clock_real_changed()&lt;/code&gt; 함수가 호출되지 않게 할 수도 있고, 심지어 객체의 클래스에 등록된 함수 포인터에 직접 자신만의 콜백 함수를 등록해서 원래 작업이 아예 수행되지 않게 할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;참고로, GTK+ / Clutter 등과 같은 GObject 기반 그래픽 툴킷 시스템은 대부분 이 시그널 콜백 함수 메커니즘을 이용해 커스텀 위젯을 만들거나 기존 액터를 상속받아 사용자가 마음껏 기능을 확장할 수 있는 길을 열어 두었습니다.(예: 
&lt;a href=&#34;http://git.gnome.org/browse/clutter/tree/clutter/clutter-actor.c#n4856&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;clutter_actor.c:clutter_actor_real_paint()&lt;/code&gt;&lt;/a&gt;
 소스 참고)&lt;/p&gt;
&lt;p&gt;시그널 객체는 &lt;code&gt;g_signal_new()&lt;/code&gt; 함수를 이용해 생성한 뒤 전역 &lt;code&gt;signals[]&lt;/code&gt; 배열에 ID를 저장해 둡니다. 이렇게 저장한 시그널 ID는 &lt;code&gt;g_signal_emit()&lt;/code&gt; 함수 호출시 사용합니다. 물론 이렇게 ID를 따로 저장하지 않고 &lt;code&gt;g_signal_emit_by_name()&lt;/code&gt;을 사용해 시그널 이름으로 직접 시그널을 발생시켜도 되지만, 어차피 내부적으로 시그널 이름을 ID로 변환하는 과정을 거치기 때문에 효율을 위해 객체 구현시 관례적으로 이런식으로 작성합니다. 물론 객체 외부에서는 시그널 ID를 모르기 때문에 어쩔 수 없이  &lt;code&gt;g_signal_emit_by_name()&lt;/code&gt;을 사용해야 합니다.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;g_signal_new()&lt;/a&gt;
 함수의 인자 중에서 중요한 항목만 설명하면, 첫번째 항목은 시그널 이름을 정의하고, 세번째 항목은 시그널 함수 포인터가 맨 나중에 실행될 지(&lt;code&gt;G_SIGNAL_RUN_LAST&lt;/code&gt;), 또는 가장 먼저 실행될 지(&lt;code&gt;G_SIGNAL_RUN_FIRST&lt;/code&gt;) 등을 지정합니다. 네번째 항목은 클래스 구조체에 정의된 시그널 함수 포인터 위치를 지정하고, 여덟번째는 시그널 콜백 함수의 리턴 형(type), 아홉번째는 콜백 함수에게 전달할 인자의 갯수, 열번째부터는 전달될 인자의 형(types)을 차례대로 정의합니다.&lt;/p&gt;
&lt;p&gt;
&lt;a href=&#34;http://developer.gnome.org/gobject/stable/gobject-Signals.html#g-signal-new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;g_signal_new()&lt;/a&gt;
 함수의 일곱번째 인자는 함수 호출시 인자를 처리하는 마샬링(marshalling) 함수를 지정하는데, 함수의 리턴 형(type)과 인자 목록, 인자의 각 형(type)이 정확히 일치되는 함수를 지정해야 합니다. 그런데 원하는 형태의 마샬링 함수를 GLib에서 기본으로 제공하지 않을 경우 &lt;code&gt;glib-genmarshal&lt;/code&gt; 프로그램을 이용해 직접 C 소스 코드를 생성해서 사용해야 했는데, GLib 2.30 버전부터는 그냥 &lt;code&gt;NULL&lt;/code&gt;을 지정하면 
&lt;a href=&#34;http://sourceware.org/libffi/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;libffi&lt;/a&gt;
 라이브러리를 이용해 구현한 &lt;code&gt;g_cclosure_marshal_generic()&lt;/code&gt; 함수가 기본으로 호출되어, 알아서 자동으로 마샬링을 처리합니다.&lt;/p&gt;
&lt;p&gt;정리하자면, GObject 시그널은 모델-뷰(model-view) 구조나 관찰자 패턴(observer pattern)을 구현하는데 사용하기도 하지만, 더 복잡한 객체 지향 시스템을 설계할 때도 유용합니다. 하지만, 여기서는 시그널의 특징과 개념만 설명하느라 전체 기능의 반의 반도 소개되지 않은 셈입니다. 따라서 더 깊은 이해와 활용을 원하시면 반드시 참고 매뉴얼을 한 번 정독하시길 권합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그리고&amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;다른 프로그래머가 왜 C++, Java, Python 처럼 좋은 언어 놔두고 C 언어 기반에서 복잡한 GObject 같은 걸 가지고 객체 지향 프로그래밍을 할려고 애쓰냐고 물어본다면,  
&lt;a href=&#34;http://www.tux.org/lkml/#s15-3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;리눅스 커널 메일링 리스트 FAQ&lt;/a&gt;
에 있는 유명한 다음 구절을 해석해서 미소지으며 알려주시기 바랍니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What&amp;rsquo;s important about object-oriented programming is the techniques, not the languages used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;뭐, 모든 도구는 필요한 곳이 반드시 있으니까 계속 존재합니다. 다만 내가 아직 그 쓰임새를 알지 못할 뿐이죠&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>라자냐 코드 (Lasagna Code)</title>
      <link>/2011/06/10/lasagna-code/</link>
      <pubDate>Fri, 10 Jun 2011 00:00:00 +0000</pubDate>
      <guid>/2011/06/10/lasagna-code/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/figures/400px-lasagna_nih.jpg&#34; alt=&#34;&#34;&gt;
요즘은 예전에 작성한 
&lt;a href=&#34;http://en.wikipedia.org/wiki/Spaghetti_code#Lasagna_code&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;라자냐 코드(Lasagna Code)&lt;/a&gt;
의 굴레에서 벗어나기 위해 노력하고 있습니다. 스파게티 코드(Spaghetti Code)가 아닌 라자냐 코드라고? 처음 들어보시는 분을 위해 위키피디어 설명을 날림으로 번역해 보면 다음과 같습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;라자냐 코드는 일종의 프로그램 구조인데, 잘 정의되어 분리된 여러 계층(layer)을 가지는 것이 특징입니다. 각각의 코드 계층은 잘 정의된 인터페이스를 통해 아래 계층의 서비스에 접근합니다. 이 용어는 프로그램 구조를 파스타에 비유하는 스파케티 코드와 비교되곤 하는데, 다른 재료(고기, 소스, 채소, 치즈 등)가 각각 파스타 조각으로 분리되어 하나의 접시에 담긴 라자냐의 계층 구조에 기인합니다.&lt;/p&gt;
&lt;p&gt;라자냐 코드의 흔한 예 중 하나는 다른 하부 시스템 , 가령 웹 어플리케이션과 비즈니스 로직, 관계형 데이터베이스 사이에 존재하는 인터페이스입니다. 또한 프로그래밍 기법 중에, 프로그램 전체 구조에서 레벨마다 다른 프로그래밍 언어를 사용하는 경우에도 이를 연결하는 계층이 존재하는데 이 역시 라자냐 코드의 일종입니다. 일반적인 클라이언트-서버 응용 프로그램 역시 대부분 잘 정의된 인터페이스를 통해 통신하므로 라자냐 코드라고 할 수 있습니다.&lt;/p&gt;
&lt;p&gt;대개 라자냐 코드는 다른 계층간에 인캡슐레이션(encapsulation)을 강요하기 때문에, 문제의 하부 시스템은 잘 정의된 메카니즘(SQL, RPC, FFI 등)을 제외한 다른 통신 수단이 없습니다. 물론, 시스템의 개별적인 레이어는 덜 구조화되어 있거나 엉망으로 조직화되어 있을 수도 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;위 설명을 보면 라자냐 코드는 전혀 나쁜 것 같지 않은데 도대체 무슨 굴레를 벗어난다고 하는 걸까, 모든 진리가 말하듯이, 과하면 부족함만 못한 법입니다. 너무 많은 계층화는 성능 개선 / 기능 확장 / 유지 보수 디버깅에 오히려 방해가 되어 버리고 맙니다. 예를 들어 GNOME 2 플랫폼에서는 용도별로 개발된 수많은 libgnome* 라이브러리가 존재했지만 GNOME 3 개발 과정에서 대부분 기능을 GLib / GTK+ 라이브러리에 통합한 이유 중 하나도 마찬가지일 겁니다. 여담이지만, 사실 그래서 GTK+는 모든 기능이 종합 선물 셋트처럼 제공되는 QT 애호가들에게 많은 비난을 받아왔었던 것도 사실입니다. 무슨 라이브러리 의존성이 이렇게 많고 복잡한지&amp;hellip; 물론 아직도 GTK+ 툴킷 자체는 여전히 기능별 라이브러리에 의존하고 있지만 예전에 비해 정말 많이 정리된 셈입니다.&lt;/p&gt;
&lt;p&gt;아무튼, 스스로 만든 라자냐 코드의 굴레 중에서 가장 문제가 되는 부분은, 멀티 플랫폼을 고려하는 것과 더불어 향후 라이브러리 교체시 수고를 덜기 위해 어떤 라이브러리 API를 그대로 사용하지 않고 일종의 확장성있는 랩퍼(wrapper) API를 따로 만들어 사용한 점입니다.  결과적으로, 라이브러리 자체도 계속 업그레이드 되기 때문에 이를 반영해야 하고, 다른 라이브러리로 교체하는 경우도 별로 없고, 성능 개선이나 기능 추가를 위해 끊임없이 랩퍼 API를 추가하면서, 디버깅할 때는 한 동작을 위해 두 세 단계 이상의 계층을 따라 가야하고&amp;hellip; 배보다 배꼽이 더 커지는 경우가 발생해 버리는 상황에 이르게 됩니다.&lt;/p&gt;
&lt;p&gt;두번째로 문제가 되는 부분은, 기능 하나를 구현할때 구성 모듈을 너무 세분하게 나눈 점입니다. 특히, 수평적이 아닌 수직적으로 기능을 나눌때 적절한 범위를 넘어가버리면, 새 기능 추가시 매우 많은 모듈에 대한 의존성 검사, 부작용 검사 등의 작업이 몇 배나 어렵습니다. 예를 들어 상위 계층에 있는 기능을 하위 계층에서 사용해야 하는 경우가 발생하면 이를 위한 인터페이스를 설계하는데 시간이 더 걸리는 경우도 많습니다. 그냥 간단하게 하나의 모듈로 작성하면 되었을 걸&amp;hellip;&lt;/p&gt;
&lt;p&gt;과하면 부족함만 못하다&amp;hellip; 언제 어떻게 무엇이 될 지 모르는 미래를 위해 미리 고민해서 확장성 있는 구조를 설계하는데 노력하는 것보다, 지금 당장의 요구 사항 수준에서 아무 문제없이 잘 돌아가는, 향후 쉽게 이해하고 확장할 수 있는 간단한 구조의 코드를 작성하는게 맞는 것 같습니다. 게다가 향후 발생할 요구사항을 미리 알 지 못하는데 미리 확장성있게 설계한다는 것 자체가 모순이 아닌가 하는 생각도 들고&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Gource 소스 저장소 시각화 프로그램</title>
      <link>/2010/04/23/gource-source-visualization/</link>
      <pubDate>Fri, 23 Apr 2010 00:00:00 +0000</pubDate>
      <guid>/2010/04/23/gource-source-visualization/</guid>
      <description>&lt;p&gt;LWN.net 기사 중에서 
&lt;a href=&#34;http://lwn.net/Articles/382468/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;소스 코드 작업 시각화 관련 기사&lt;/a&gt;
를 보고 재미있을 것 같아 
&lt;a href=&#34;http://code.google.com/p/gource/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gource&lt;/a&gt;
 프로그램을 이용해 회사에서 진행중인 프로젝트에 적용해 보았습니다.&lt;/p&gt;
&lt;iframe width=&#34;480&#34; height=&#34;360&#34; src=&#34;http://www.youtube.com/embed/RUwDxM28EBA&#34;&gt;&lt;/iframe&gt;
&lt;p&gt;만드는 방법은 우선 필요한 패키지를 설치하고(Ubuntu 기준)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ sudo apt-get install gource ffmpeg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git 저장소가 있는 디렉토리로 이동해서 다음과 같이 실행합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gource 
    -s 0.01 
    --auto-skip-seconds 0.1 
    --file-idle-time 500 
    --disable-progress 
    --output-framerate 25 
    --highlight-all-users 
    -800x600 
    --stop-at-end 
    --output-ppm-stream - | 
  ffmpeg 
    -y 
    -b 1000K 
    -r 17 
    -f image2pipe 
    -vcodec ppm 
    -i - 
    -vcodec mpeg4 
    gource-edc-20100423.avi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;프로젝트에 참여했던 사람들 이름이 나타났다 사라지는 걸 보면 기분이 약간 묘해지는 것 같습니다 ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 속성 직렬화(Serialization)하기</title>
      <link>/2010/04/07/serialize-gobject-properties/</link>
      <pubDate>Wed, 07 Apr 2010 00:00:00 +0000</pubDate>
      <guid>/2010/04/07/serialize-gobject-properties/</guid>
      <description>&lt;p&gt;GObject 객체의 속성(properties)을 자동으로 저장하고 다시 자동으로 불러들이는 일련의 작업을 자동화할 수 있다면 편하지 않을까 생각해 본 적이 있을겁니다. 이러한 과정을 
&lt;a href=&#34;http://en.wikipedia.org/wiki/Serialization&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;직렬화(serialization)&lt;/a&gt;
라고 부른다면, 오브젝티브-C, 자바 등과 같은 많은 언어가 이미 기본적으로 직렬화를 지원하거나 관련 라이브러리를 제공하고 있는만큼, GObject 객체 직렬화 라이브러리가 없을리가 없습니다. 예를 들어, 
&lt;a href=&#34;http://live.gnome.org/JsonGlib&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JSON-GLib&lt;/a&gt;
, 
&lt;a href=&#34;http://git.dronelabs.com/catalina/about&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Catalina&lt;/a&gt;
 등과 같은 라이브러리를 사용하면 됩니다.&lt;/p&gt;
&lt;p&gt;그런데, 여기서 드는 의문은, 왜 GObject 라이브러리 자체에는 정작 이 기능이 없을까입니다. 그리고, 잠깐 생각해보고 내린 결론은, 특정한 형식을 제한하기보다는, 직렬화를 위한 기본 기능만 지원하고, 어플리케이션 특성에 맞게 직렬화는 프로그래머의 자유에 맡긴게 아닌가 합니다. 위에서 언급한 라이브러리도 기능은 강력하지만, 특정 용도에서 사용하기 위해 만들어지다 보니 불필요하거나 어려운 부분이 조금 있습니다.&lt;/p&gt;
&lt;p&gt;그래서 이 글에서는 
&lt;a href=&#34;/2009/08/24/oop-with-gobject-4/&#34;&gt;이전 글&lt;/a&gt;
에서 잠깐 언급한 객체 속성 정보 얻는 방법을 이용하여 간단한 GObject 속성 직렬화 코드를 구현하는데 필요한 몇 가지 기법을 소개하려고 합니다. 실제 직렬화 기능은 용도와 방식에 맞게 구현하면 되리라 생각합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;직렬화 대상 속성 지정하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;직렬화하려는 속성을 매번 지정하는 것보다 객체 설계시 아예 지정해버릴 수 있는 방법이 있으면 자동화에 편합니다. 이때 사용할 수 있는 기법이 &lt;code&gt;G_PARAM_USER_SHIFT&lt;/code&gt; 매크로입니다. 객체 클래스 초기화 함수에서 속성을 추가(install)할때 보통 &lt;code&gt;G_PARAM_READABLE&lt;/code&gt;, &lt;code&gt;G_PARAM_READWRITE&lt;/code&gt; 등과 같은 미리 정의되어 있는 특성을 지정하는데, &lt;code&gt;G_PARAM_USER_SHIFT&lt;/code&gt; 매크로를 이용해 사용자가 임의의 특성을 더 추가할 수 있습니다. 예를 들어 다음과 같이 정의하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define G_PARAM_SERIALIZABLE (1 &amp;lt;&amp;lt; (G_PARAM_USER_SHIFT + 1))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제, 속성 스팩을 만들때(&lt;code&gt;g_param_spec_*()&lt;/code&gt;)  &lt;code&gt;G_PARAM_SERIALIZABLE&lt;/code&gt; 플래그를 함께 지정할 수 있습니다. 예를 들면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;pspec = g_param_spec_int (&amp;quot;id&amp;quot;,
                          &amp;quot;ID&amp;quot;,
                          &amp;quot;unique ID of the device&amp;quot;,
                          0,
                          G_MAXINT32,
                          0,
                          G_PARAM_READWRITE | G_PARAM_SERIALIZABLE);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;주의할 점은, &lt;code&gt;G_PARAM_USER_SHIFT&lt;/code&gt; 매크로를 응용하는 다른 라이브러리가 있을 수 있으므로 충돌 여부를 확인해야 합니다. 예를 들어 GStreamer 라이브러리의 &lt;code&gt;GST_PARAM_USER_SHIFT&lt;/code&gt; 매크로도 비슷한 역할을 합니다. 따라서 구현하려는 객체가 Gstreamer 객체를 상속받는다면 다른 값을 지정해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;직렬화 대상 속성 목록 얻기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;g_object_class_list_properties()&lt;/code&gt; 함수를 이용하면 객체 클래스의 모든 속성 목록을 얻을 수 있습니다. 이 함수 프로토타입을 흉내내어 직렬화 대상 속성만 추출하는 함수를 만들면 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;GParamSpec **
list_serializable_properties (GObject *serializable,
                              guint   *n_properties)
{
  GParamSpec **specs;
  GParamSpec **new_specs;
  guint        n_specs;
  guint        i;
  guint        total;

  g_return_val_if_fail (G_IS_OBJECT (serializable), NULL);

  specs = g_object_class_list_properties (G_OBJECT_GET_CLASS (serializable), &amp;amp;n_specs);
  new_specs = g_new0 (GParamSpec *, n_specs + 1);
  for (i = 0, total = 0; i &amp;lt; n_specs; i++)
    {
      GParamSpec *spec = specs[i];

      if (!(spec-&amp;gt;flags &amp;amp; ECC_PARAM_SERIALIZABLE))
        continue;

      new_specs[total] = spec;
      total++;
    }
  g_free (specs);

  if (n_properties)
    *n_properties = total;

  return new_specs;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이제 이 함수가 돌려주는 속성 스펙 목록을 이용해 텍스트 파일이나 데이터베이스, 또는 GConf 등을 이용하여 속성 값을 불러오거나 저장하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;속성값 변환하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;하지만 속성은 정수형, 실수형, 문자열 등 여러가지 타입인데 모든 종류의 타입을 하나씩 문자열로 변환해서 저장하는 건 비효율적 과정입니다. 이때 사용할 수 있는 함수가 &lt;code&gt;g_value_transform()&lt;/code&gt;인데, 이 함수는 기본적으로 두 GValue 간 내용을 적절하게(?) 변환해 줍니다. 다음은 이 함수를 이용하여 간단하게 &amp;lsquo;key=value&amp;rdquo; 형식으로 저장한 문자열을 돌려주는 코드입니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;gchar *
serialize_properties (GObject *serializable)
{
  GParamSpec **specs;
  GString     *string;
  gchar       *str;
  guint        i;

  g_return_val_if_fail (G_IS_OBJECT (serializable), NULL);

  string = g_string_new (NULL);

  specs = list_properties (serializable, NULL);
  for (i = 0; specs[i] != NULL; i++)
    {
      GParamSpec *spec = specs[i];
      GValue      value = { 0 };
      GValue      value_str = { 0 };

      g_value_init (&amp;amp;value, spec-&amp;gt;value_type);
      g_value_init (&amp;amp;value_str, G_TYPE_STRING);
      g_object_get_property (G_OBJECT (serializable), spec-&amp;gt;name, &amp;amp;value);
      if (g_value_transform (&amp;amp;value, &amp;amp;value_str))
        g_string_append_printf (string,
                                &amp;quot;%s=%sn&amp;quot;,
                                spec-&amp;gt;name,
                                g_value_get_string (&amp;amp;value_str));
      else
        g_warning (&amp;quot;failed to transform property &#39;%s&#39; to string&amp;quot;, spec-&amp;gt;name);
      g_value_unset (&amp;amp;value);
      g_value_unset (&amp;amp;value_str);
    }
  g_free (specs);

  str = string-&amp;gt;str;
  g_string_free (string, FALSE);

  return str;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그런데 한 가지 문제가 있습니다. &lt;code&gt;g_value_transform()&lt;/code&gt; 함수는 기본적으로 모든 GValue 사이의 변환을 지원하지 않는다는 점입니다. 위에서 예를 든 코드는 C 언어 기본 타입을 문자열로 변환하는데, 다행히도 이 변환은 기본적으로 지원합니다. 하지만, 반대로 문자열에서 다른 타입으로 변환하는 기능은 제한적으로 지원합니다. 그래서 다음과 같이 필요한 변환 함수를 미리 등록해야 합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static void
tranform_string_to_int (const GValue *src_value,
                        GValue       *dest_value)
{
  gint64 value;

  value = g_ascii_strtoll (g_value_get_string (src_value), NULL, 10);
  g_value_set_int (dest_value, value);
}

static void
tranform_string_to_boolean (const GValue *src_value,
                            GValue       *dest_value)
{
  gboolean value;

  value = g_ascii_strncasecmp (g_value_get_string (src_value), &amp;quot;TRUE&amp;quot;, 4) == 0 ? TRUE : FALSE;
  g_value_set_boolean (dest_value, value);
}

static void
tranform_string_to_double (const GValue *src_value,
                           GValue       *dest_value)
{
  gdouble value;

  value = g_ascii_strtod (g_value_get_string (src_value), NULL);
  g_value_set_double (dest_value, value);
}

static void
register_transform_funcs (void)
{
  struct
  {
    GType src_type;
    GType dest_type;
    GValueTransform transform_func;
  } transformers[] =
  {
    { G_TYPE_STRING, G_TYPE_INT, tranform_string_to_int },
    { G_TYPE_STRING, G_TYPE_BOOLEAN, tranform_string_to_boolean },
    { G_TYPE_STRING, G_TYPE_DOUBLE, tranform_string_to_double }
  };
  gint i;

  for (i = 0; i &amp;lt; G_N_ELEMENTS (transformers); i++)
    if (!g_value_type_transformable (transformers[i].src_type,
                                     transformers[i].dest_type))
      g_value_register_transform_func (transformers[i].src_type,
                                       transformers[i].dest_type,
                                       transformers[i].transform_func);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;당연히, 속성 타입이 C 언어 기본 타입이 아닐 경우라도 위와 같은 방식으로 변환 함수를 등록해 주면 알아서 동작합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그외&amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;실제 프로젝트에서는 위와 같은 기능과 몇가지 도우미 API를 지원하는 인터페이스(GInterface) 객체를 정의해서, 각 객체가 그 인터페이스 객체를 구현(implementation)하도록 했습니다. 왜냐하면, 객체의 속성(properties)으로 나타나지 않는 내부 정보도 직렬화할 수 있기 때문입니다. 예를 들어 장치 목록 객체는 여러 장치 객체를 참조합니다. 그래서 장치 목록 객체를 직렬화하는 함수를 호출하면 실제로 장치 목록 객체는 목록에 포함된 장치 객체의 직렬화 함수를 다시 호출해 문자열을 얻어와 조합된 문자열을 돌려줍니다.&lt;/p&gt;
&lt;p&gt;:)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GLib 테스트 프레임워크 사용하기</title>
      <link>/2010/02/12/using-glib-test-framework/</link>
      <pubDate>Fri, 12 Feb 2010 00:00:00 +0000</pubDate>
      <guid>/2010/02/12/using-glib-test-framework/</guid>
      <description>&lt;p&gt;GLib 라이브러리 2.16 버전부터 지원하는 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;테스트 프레임워크&lt;/a&gt;
는 C 언어용 
&lt;a href=&#34;http://en.wikipedia.org/wiki/Unit_testing&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;유닛테스트&lt;/a&gt;
 도구입니다. 물론 많은 유닛 테스트 도구가 이미 존재하지만, GLib 라이브러리 기반 C 언어 프로그램이라면 굳이 다른 라이브러리를 사용하는 것보다는 이미 지원하는 훌륭한 도구를 사용하는게 더 좋겠지요. 참고로,
&lt;a href=&#34;http://www.gtk.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+&lt;/a&gt;
, 
&lt;a href=&#34;http://clutter-project.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Clutter&lt;/a&gt;
 등 같은 프로젝트도 이미 이 기능을 이용해 테스트 코드를 작성하고 있으므로 알아두면 도움이 됩니다. 모든게 그렇지만, 알고나면 별게 아니므로 기본 개념과 API 사용법만 충실히 이해하면 됩니다.&lt;/p&gt;
&lt;p&gt;**기본 개념 및 사용법
**&lt;/p&gt;
&lt;p&gt;유닛테스트 개념은 스몰토크, 자바, C++처럼 언어적으로 객체지향 개념을 지원하는 언어에서 시작했기 때문에 C 언어에 그대로 적용하기에는 조금 까다로운 점이 많습니다. 그래서 GLib 테스트 프레임워크는 유닛테스트에서 기본 개념과 테스트 실행 방식만 빌려옵니다. 우선 알아야하는 기본 개념은 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;테스트 케이스 (Test Case) : 가장 기본이 되는 하나의 테스트 단위입니다. GLib에서는 하나의 테스트 함수(function)가 이 역할을 합니다.&lt;/li&gt;
&lt;li&gt;픽스쳐 (Fixture) : 고정 설치된 물건이라는 뜻처럼, 테스트 케이스 실행 전후에 항상 실행하는 함수를 의미합니다. 실제로는, 테스트 함수를 실행하기 위해 필요한 환경을 미리 구축하거나(setup) 실행 후 리소스를 정리하는(teardown) 함수, 그리고 이와 함께 사용되는 사용자 데이터(data)로 구성됩니다. 참고로, GLib에서는 각 테스트간 의존성을 피하기 위해 모든 테스트 케이스를 실행할때마다 매번 픽스쳐를 새로 구성하는 방식(fresh fixture)을 사용합니다.&lt;/li&gt;
&lt;li&gt;테스트 슈트 (Test Suite) : 여러 테스트 케이스를 묶은 그룹입니다. 트리 구조처럼 테스트 슈트 여러개를 묶어 더 큰 테스트 슈트를 구성할 수도 있습니다. GLib에서는 테스트 경로(path)라는 개념으로 사용합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;개념은 조금 복잡한 것 같지만, 복잡하고 다양한 테스트 케이스를 그룹화하면 나중에 테스트 슈트별로 테스트를 진행할 수도 있는 등 많은 장점이 있습니다. 그리고 GLib이 제공하는 커맨드라인 도구를 이용하면 테스트 결과를 XML로 출력할 수도 있고, HTML 문서로 자동 변환할 수도 있는데 이 경우에도 테스트 슈트를 구성해 두면 많은 도움이 됩니다.&lt;/p&gt;
&lt;p&gt;물론 GLib은 정교하게 테스트 슈트와 테스트 케이스, 픽스쳐를 구성할 수 있는 많은 API를 제공하지만, 복잡한 과정을 API 호출 하나로 처리할 수 있는 기능도 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;g_test_add_func (&amp;quot;/onvif/nvc-connections&amp;quot;, test_onvif_nvc_connections);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 예제에서 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-add-func&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_add_func()&lt;/code&gt;&lt;/a&gt;
 함수는 &amp;ldquo;onvif&amp;rdquo; 테스트 슈트 밑에 &amp;ldquo;nvc-connections&amp;rdquo; 이름의 테스트 케이스를 추가합니다. 테스트시 실행할 함수는 사용자가 직접 구현한 &lt;code&gt;test_onvif_nvc_connections()&lt;/code&gt; 함수입니다. &lt;code&gt;g_test_add_func()&lt;/code&gt; 함수가 테스트 슈트를 자동으로 생성해 주기 때문에 별도의 추가 작업이 불필요합니다. 비슷한 기능의 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-add-data-func&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_add_data_func()&lt;/code&gt;&lt;/a&gt;
 함수는 테스트 함수에 데이터를 전달할 수 있어서, 한 함수로 데이터만 바꿔서 테스트하고자 할때 유용합니다. 하지만, 두 API는 픽스쳐를 지정할 수 없으므로, 픽스쳐를 사용하려면 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-add&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_add()&lt;/code&gt;&lt;/a&gt;
 함수를 이용해야 합니다.일단, 간단한 예제 코드를 보여드리면 다음과 같습니다. (&amp;quot;
&lt;a href=&#34;http://blogs.gnome.org/timj/2008/06/24/23062008-writing-unit-tests-with-glib/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Writing Unit Tests with GLib&lt;/a&gt;
&amp;rdquo; 글에서 발췌했습니다)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;glib.h&amp;gt;

static void
simple_test_case (void)
{
  /* a suitable test */
  g_assert (g_bit_storage (1) == 1);

  /* a test with verbose error message */
  g_assert_cmpint (g_bit_storage (1), ==, 1);
}

int
main (int argc, char **argv)
{
  /* initialize test program */
  g_test_init (&amp;amp;argc, &amp;amp;argv, NULL);

  /* hook up your test functions */
  g_test_add_func (&amp;quot;/Simple Test Case&amp;quot;, simple_test_case);

  /* run tests from the suite */
  return g_test_run ();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 코드를 &lt;code&gt;g-test-sample1.c&lt;/code&gt; 파일로 저장하고 컴파일 후 실행하면 다음과 같은 결과를 볼 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gcc -o g-test-sample1 g-test-sample1.c `pkg-config --cflags --libs glib-2.0`
$ ./g-test-sample1
/Simple Test Case: OK
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 결과를 재활용하기 위해 XML 형식으로 저장하거나, HTML 문서로 만들고 싶다면 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/gtester.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtester&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/gtester-report.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gtester-report&lt;/a&gt;
 프로그램을 사용하면 됩니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ gtester -o sample-log.xml g-test-sample1
TEST: g-test-sample1... (pid=2771)
PASS: g-test-sample1
$ gtester-report sample-log.xml &amp;gt; sample-log.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위와 같이 실행하여 생성한 HTML 문서 결과는 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/figures/gtester-report-screenshot.png&#34; alt=&#34;&#34; title=&#34;gtester-report screenshot&#34;&gt;&lt;/p&gt;
&lt;p&gt;참고로, gtester 프로그램의 인수로 여러 테스트 실행 파일을 한꺼번에 전달하면 모든 테스트 실행 파일의 테스트 슈트가 하나의 결과로 통합됩니다.&lt;/p&gt;
&lt;p&gt;위 코드에서 사용한 테스트 코드를 보면 제일 먼저 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-init&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_init()&lt;/code&gt;&lt;/a&gt;
 함수가 나타납니다. 이 함수는 테스트 기능을 초기화하는데, 리퍼런스 매뉴얼을 보시면 프로그램 실행 인수를 통해 사용자가 여러 테스트 옵션을 지정할 수 있는 걸 알 수 있습니다. 물론 특정 테스트 슈트만 실행하게 하는 옵션도 인수로 지정할 수 있습니다.&lt;/p&gt;
&lt;p&gt;테스트 함수를 보면 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-assert-cmpint&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_assert_cmpint()&lt;/code&gt;&lt;/a&gt;
라는 다소 생소한 API가 보이는데, GLib은 테스트 코드를 위해 이와 비슷한 매크로를 더 제공합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#define g_assert             (expr)
#define g_assert_not_reached ()
#define g_assert_cmpstr      (s1, cmp, s2)
#define g_assert_cmpint      (n1, cmp, n2)
#define g_assert_cmpuint     (n1, cmp, n2)
#define g_assert_cmphex      (n1, cmp, n2)
#define g_assert_cmpfloat    (n1,cmp,n2)
#define g_assert_no_error    (err)
#define g_assert_error       (err, dom, c)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 매크로를 사용하여 테스트 코드를 작성하면 더 친절하고 자세한 에러 메시지를 출력합니다. 예를 들어 다음 코드는,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;gchar *string = &amp;quot;foo&amp;quot;; g_assert_cmpstr (string, ==, &amp;quot;bar&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 메시지를 출력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;ERROR: assertion failed (string == &amp;quot;bar&amp;quot;): (&amp;quot;foo&amp;quot; ==  &amp;quot;bar&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론 기본적으로 실패한 경우에만 메시지를 보여줍니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;그 외 더 많은&amp;hellip;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;지금까지 설명한 기본 기능 외에도 표준출력 / 표준에러 메시지를 표시하지 않도록 한 뒤 이 메시지에서 특정 문자열을 확인한다든가, 항상 동일한 패턴의 난수를 생성하여 이를 테스트에 이용하거나,  테스트에 시간이 얼마나 더 걸리는지 측정할 수도 있습니다. 프로그램을 종료시키는 치명적인 에러가 발생하는 경우도 테스트할 수 있고, 여러가지 테스트 모드(quick / slow / performace 등)를 두어 프로그램 인자를 이용해 원하는 테스트 코드만 실행할 수도 있습니다.&lt;/p&gt;
&lt;p&gt;더 많은 활용 예제가 GLib 자체 테스트 코드에(
&lt;a href=&#34;http://git.gnome.org/browse/glib/tree/glib/tests/testing.c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;glib/tests/testing.c&lt;/a&gt;
) 있으므로, 별로 길지 않으니, 직접 확인해 보시기 바랍니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;프로젝트에 활용하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MVP 개발 모델과 TDD + 유닛테스트 도구를 이용하여 응용 프로그램을 개발하면(
&lt;a href=&#34;/2008/12/17/presenter-first-development/&#34;&gt;Presenter First 개발&lt;/a&gt;
) 더 빠르고 쉽게 튼튼한 코드를 만들 수 있으니, 한 번 검토해 보시기 바랍니다. 개발자가 TDD 방법론을 주저하는 이유 중 하나가 테스트 코드까지 만들다 보니 늘어나는 코드량과 늘어나는 개발 시간 때문인데, 테스트 코드를 그대로 실제 코드로 재활용할 수 있다면 얘기가 달라지겠죠.&lt;/p&gt;
&lt;p&gt;프로젝트 일일빌드시 테스트 루틴도 동작하도록 한뒤 자동으로 테스트 결과를 웹사이트에 게재하는 것도 좋은 개발 습관입니다. 아예 코드 수정 후 저장소에 커밋하면 반드시 모든 테스트 케이스를 통과해야만 커밋되도록 저장소를 설정할 수도 있지만, 엄청난 서버 부하를 야기할 수 있으므로, 테스트 케이스를 통과한 코드만 커밋할 수 있도록 가이드라인을 규정하는 것도 좋습니다.&lt;/p&gt;
&lt;p&gt;유닛테스트는 특정 객체나 모듈의 모든 API가 항상 정상적으로 동작하는지를 검사하기 위해 사용합니다. 그래서 가장 기본적인 사용법은 공개 함수를 다양한 인수로 호출한 뒤 그 결과값을 확인하는 방식입니다. 하지만 실무에서는 그렇게 단순한(?) 버그만 존재하는게 아니라서, 특정 시나리오나 특정 조건을 만족할 경우에만 버그 현상이 재현되는 경우도 많습니다. 이러한 경우, 버그에 대한 테스트 케이스를 추가하고 이 케이스에 대한 테스트가 통과할때까지 디버깅을 합니다. 이렇게 해두면 동일한 버그가 나중에 재발하는 걸 방지할 수 있습니다. 대부분 회사에서는 버그(이슈)관리시스템을 사용하므로 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-bug&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_bug()&lt;/code&gt;&lt;/a&gt;
 API를 사용하면 편리합니다.&lt;/p&gt;
&lt;p&gt;참고로, GTK+ 라이브러리는 GLib 테스트 프레임워크를 기반으로 마우스 버튼 동작이나 키보드 입력을 에뮬레이션하는 기능처럼 
&lt;a href=&#34;http://library.gnome.org/devel/gtk/stable/gtk-Testing.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GUI 프로그램 테스트용 API&lt;/a&gt;
를 제공합니다. 더불어 
&lt;a href=&#34;http://en.wikipedia.org/wiki/Xvfb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Xvfb&lt;/a&gt;
 같은 더미 X서버를 이용하면 원격 터미널이나 cron 작업처럼 실제 X서버가 없는 환경에서도 GUI 프로그램 테스트 진행이 가능합니다. 꼭 GTK+ 프로그램이 아니더라도, 폰트 렌더링 루틴이 정확한 그래픽 비트맵을 생성하는지, 특정 항목을 선택하고 특정 행동을 취했을때 정상적으로 문자열이 표시되는지 등도 테스트 케이스로 작성할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;테스트 케이스 실행 방식 및 테스트 코드 위치&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;위 예제처럼 테스트 케이스를 특정 주제별로 나누어 각각의 실행파일로 만들어도 되지만, 테스트 케이스를 초기화하는 부분을 잘 정리하여 테스트 케이스를 여러 모듈로 분리한 뒤,  모든 테스트 케이스를 통째로 하나의 실행파일로 만들어도 됩니다. 이렇게 하면 추가적인 스크립트나 도구의 도움없이도 명령어 한번 실행으로 모든 테스트 케이스를 실행할 수 있기 때문에 더 편리할 수 있습니다. 또는 Clutter 프로젝트처럼 테스트 모듈을 각각 공유라이브러리로 만들어 플러그인처럼 로드해서 실행하는 방법도 있습니다.&lt;/p&gt;
&lt;p&gt;하지만, 위 방식은 모두 실제 코드와 테스트 코드가 서로 다른 파일에 존재하는 방식입니다. 테스트 코드가 실제 코드와 하나의 파일에 존재한다면 테스트 코드 작성이 더 일상화되고 자연스러워질 수 있습니다. 그러므로, 프로그램 실행 파일 크기가 별로 문제가 되지 않는다면, 또는 릴리스 / 디버그 모드를 분리하여 컴파일하도록 구성된 프로젝트라면,  프로그램에 특정 옵션을 주었을 경우에만 테스트 케이스 실행 모드로 동작하게 하면 됩니다. 물론 특정 테스트 프로그램은 예제로 사용하기 위해 분리할 수도 있겠지만, 모듈이나 객체의 고유 기능만 테스트하는 코드라면 같은 파일에 있는게 더 자연스러울 수 있습니다. 예를 들어 GObject 객체라면, 속성(properties) / 시그널(signal) 이름이 갑자기 변경되었을때 이를 참조하는 모듈이 문제를 일으키지 않도록 하기 위해, &amp;lsquo;validate-properties&amp;rsquo;, &amp;lsquo;validate-signals&amp;rsquo; 등의 테스트 케이스를 추가한뒤 통과하지 못했을 경우 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Testing.html#g-test-message&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_test_message()&lt;/code&gt;&lt;/a&gt;
 등을 이용해 이를 참조하는 모듈을 찾아 수정하라는 강조 메시지를 표시하는 것도 가능합니다. 또한 특정 시그널이 정상적으로 발생하는지, 순서대로 발생하는지 확인할 수 있습니다. 그리고 무엇보다도, 같은 파일에 있으면 내부 자료구조에도 접근할 수 있으므로 내부 로직에 대한 테스트 코드를 작성하는 것도 가능해집니다.&lt;/p&gt;
&lt;p&gt;따라서 무조건 한 가지 방식만 고집하기보다, 적절하게 필요에 따라 알맞는 방식을 선택하는 것이 중요합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;결론&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;뭐 다른 결론이 있을리 없을만큼 유닛 테스트와 리그레션 테스트(regression test) 등은 이미 소프트웨어 개발 분야 전반에 광범위하게 사용하고 있습니다. 다만, C 언어를 이용해 개발하는 경우 리거시(legacy) 코드가 너무 많거나, 마땅한 테스트 도구를 찾지 못했거나, 여러가지 이유로 도입하지 못하는 경우가 많은데, 함께 잘 극복하고 익숙해져서 더 좋은 방향으로 나아가야 하지 않을까&amp;hellip; 생각해 봅니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>싱글턴(Singleton) GObject 객체 만들기</title>
      <link>/2010/02/11/how-to-make-a-gobject-singleton/</link>
      <pubDate>Thu, 11 Feb 2010 00:00:00 +0000</pubDate>
      <guid>/2010/02/11/how-to-make-a-gobject-singleton/</guid>
      <description>&lt;p&gt;좋은 
&lt;a href=&#34;http://blogs.gnome.org/xclaesse/2010/02/11/how-to-make-a-gobject-singleton/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;블로그 포스트&lt;/a&gt;
가 올라왔길래, 우리말로 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;GObject 기반 객체 지향 프로그래밍에서 싱글턴 패턴을 사용하려면 대개 다음과 같은 함수를 추가합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;FooBar*
foo_bar_get_default (void)
{
  static FooBar *self = NULL;

  if (self == NULL)
    self = foo_bar_new ();

  return self;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 이렇게 구현할 경우 몇가지 단점이 있는데, 돌려받은 객체를 실수로 해제할 경우 문제를 일으킬 수 있고, 프로그램이 종료할때까지 객체가 소멸되지 않아 메모리 누수가 발생할 수 있습니다. 또한 사용자가 &lt;code&gt;g_object_new(FOO_TYPE_BAR, NULL)&lt;/code&gt; 방식으로 객체를 생성하면 결국 새 객체가 만들어지기 때문에 싱글턴 객체로 동작하지 않습니다.&lt;/p&gt;
&lt;p&gt;그래서, 
&lt;a href=&#34;http://live.gnome.org/Empathy&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Empathy&lt;/a&gt;
 프로젝트에서는 다음과 같이 싱글턴 객체를 구현하고 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;static GObject*
constructor (GType type,
             guint n_construct_params,
             GObjectConstructParam *construct_params)
{
  static GObject *self = NULL;

  if (self == NULL)
    {
      self = G_OBJECT_CLASS (foo_bar_parent_class)-&amp;gt;constructor (
        type, n_construct_params, construct_params);
      g_object_add_weak_pointer (self, (gpointer) &amp;amp;self);
      return self;
    }

  return g_object_ref (self);
}

static void
foo_bar_class_init (FooBarClass *klass)
{
  GObjectClass *object_class = G_OBJECT_CLASS (klass);

  object_class-&amp;gt;constructor = constructor;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이 방식을 이용하면 &lt;code&gt;g_object_new()&lt;/code&gt;를 이용해 객체를 만들어도 항상 동일한 객체를 돌려줍니다. 더불어 객체의 참조카운터를 증가해서 돌려주기 때문에, 일반 객체처럼, 사용이 끝나면 &lt;code&gt;g_object_unref()&lt;/code&gt;를 호출해 객체를 해제하면 됩니다. 물론 마지막 사용이 끝나는 시점에서는 자동으로 객체가 소멸되고 객체 포인터도 NULL값으로 초기화됩니다.(
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-add-weak-pointer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;g_object_add_weak_pointer()&lt;/a&gt;
 함수가 이 역할을 합니다)&lt;/p&gt;
&lt;p&gt;물론 빈번한 객체 생성 / 소멸 호출을 막기 위해 프로그램 전반적으로 객체를 유지하든, 필요한 때만 생성해서 사용하도록 할 지 여부는 이 객체를 사용하는 프로그램이 선택할 수 있습니다. 따라서 라이브러리 코드를 작성할 경우 반드시 이 방식으로 싱글턴 객체를 제공하는게 좋습니다.&lt;/p&gt;
&lt;p&gt;참고로, 위 구현은 멀티쓰레드가 동시에 접근하는 경우 안전하지 않습니다. 그러므로, 필요하다면, 뮤텍스나 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Threads.html#g-once&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;g_once()&lt;/a&gt;
 등을 이용해 객체 포인터를 보호해야 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (4)</title>
      <link>/2009/08/24/oop-with-gobject-4/</link>
      <pubDate>Mon, 24 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/24/oop-with-gobject-4/</guid>
      <description>&lt;p&gt;이전 글에 계속 이어집니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;객체 속성 정보 얻기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EdcHost 객체의 속성 정보를 실행 중에 얻어볼까 합니다.&lt;/p&gt;
&lt;p&gt;왜 또 갑자기 불필요한 예제를 꺼내냐고 물어보실 분이 있을 것 같아 말하자면, 가끔 요긴한 경우가 있기 때문입니다. 예를 들어 EdcHost 객체를 상속받은 EdcHostDoosan, EdcHostKia, EdcHostLitte 객체가 여러 개 존재할 경우, 이 객체들은 EdcHost의 공통 속성 뿐 아니라 본인의 속성도 따로 가집니다. 이러한 여러 객체를 관리할때, 특정 속성이 있는지 여부를 검사해서 관련 UI를 활성 / 비활성하거나, 편집 UI 자체를 속성 스펙과 목록을 이용해 100% 자동화하는 게 가능합니다. (Glade 처럼 말이죠) 물론 옵션 같은 플래그(flags) 변수를 정의하는 방법 등 여러가지 대안이 가능하겠지만, 최초 객체 설계시 고려하지 못했던 기능이나 속성을 나중에 계속 추가해 나가야 하는 경우 기존에 만든 객체를 매번 다시 수정하고 업그레이드하는 것보다 더 안전하고 깔끔한 방법이 될 수 있습니다. 그리고 당연히 더많은 응용이 있겠지만, 일단 알아두면 나중에 어떤 식으로든 도움이 되리라 생각합니다.&lt;/p&gt;
&lt;p&gt;일단, 다음 코드는 객체가 가지고 있는 속성 이름과 각 속성의 현재 값을 출력합니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void
print_properties (GObject *object)
{
  GObjectClass *oclass;
  GParamSpec **specs;
  guint n;
  guint i;

  oclass = G_OBJECT_GET_CLASS (object);
  specs = g_object_class_list_properties (oclass, &amp;amp;n);
  for (i = 0; i &amp;lt; n; i++)
    {
      GParamSpec *spec;
      GValue value = { 0 };
      gchar *str;

      spec = specs[i];

      g_value_init (&amp;amp;value, spec-&amp;gt;value_type);
      g_object_get_property (G_OBJECT (object),
                             spec-&amp;gt;name,
                             &amp;amp;value);
      str = g_strdup_value_contents (&amp;amp;value);

      g_print (&amp;quot;property &#39;%s&#39; is &#39;%s&#39;n&amp;quot;,
               spec-&amp;gt;name,
               str);

      g_value_unset (&amp;amp;value);
      g_free (str);
    }
  g_free (specs);
}

{
  EdcHost *host;

  /* ... */ 

  host = g_object_new (
           EDC_TYPE_HOST,
           &amp;quot;address&amp;quot;, &amp;quot;demo.emstone.com&amp;quot;,
           &amp;quot;port&amp;quot;, 8081,
           NULL);
  print_properties (G_OBJECT (host));
  g_object_unref (host);

  /* ... */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;위 코드에서 분명하게 이해해야 하는 점은, 객체 인스턴스가 아닌 객체 클래스에게 속성 정보를 질의한다는 점입니다. 모든 속성의 스펙을 얻기 위해 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-list-properties&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_list_properties()&lt;/code&gt;&lt;/a&gt;
 함수를 사용하고, GValue 객체에 속성 값을 가져온 다음, 문자열로 출력하기 위해 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Generic-values.html#g-strdup-value-contents&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_strdup_value_contents()&lt;/code&gt;&lt;/a&gt;
 함수를 이용해 변환하고 있습니다.&lt;/p&gt;
&lt;p&gt;객체에 어떤 속성이 있는지 알아보려면 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-find-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_find_property()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;속성 변경 알림 시그널 이용하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;객체의 속성 값을 변경할 때 &lt;code&gt;g_object_set()&lt;/code&gt; 함수를 이용하면 좋은 점은, 값을 변경하면 자동으로 시그널(signal)이 발생한다는 점입니다. GObject 시스템에서 시그널은 특정 사건(event)이 일어나면 발생(emit)합니다. 대부분의 경우 시그널은 객체 클래스 초기화시에 정의해야 하지만, 다행히도 속성 값이 변경될때 발생하는 시그널은 특별한 작업을 해주지 않아도 기본적으로 동작합니다. 따라서 &amp;ldquo;&lt;code&gt;notify::property-name&lt;/code&gt;&amp;rdquo; 형식의 이름을 가지는 시그널에 콜백 함수를 연결하면 객체 값이 변경될때 자동으로 호출되는 함수를 등록할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void
property_notified (GObject    *object,
                   GParamSpec *pspec,
                   gpointer    data)
{
  GValue value = { 0 };
  gchar *str;

  g_value_init (&amp;amp;value, pspec-&amp;gt;value_type);
  g_object_get_property (object, pspec-&amp;gt;name, &amp;amp;value);
  str = g_strdup_value_contents (&amp;amp;value);

  g_print (&amp;quot;property &#39;%s&#39; is set to &#39;%s&#39;n&amp;quot;,
             pspec-&amp;gt;name, str);

  g_value_unset (&amp;amp;value);
  g_free (str);
}

{
  EdcHost *host;

  host = g_object_new (EDC_TYPE_HOST, NULL);

  g_signal_connect (host,
                    &amp;quot;notify::address&amp;quot;,
                    G_CALLBACK (property_notified),
                    NULL);
  g_signal_connect (host,
                    &amp;quot;notify::port&amp;quot;,
                    G_CALLBACK (property_notified),
                    NULL);

  g_object_set (host,
                &amp;quot;address&amp;quot;, &amp;quot;192.168.0.1&amp;quot;,
                &amp;quot;port&amp;quot;, 8087,
                NULL);

  edc_host_set_address (host, &amp;quot;192.168.0.22&amp;quot;);

  g_object_unref (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 이 기능은, 디자인 패턴에서 말하는 관찰자(observer) 패턴일 수도 있고, GObject 매뉴얼에서 사용하는 것처럼 일종의 메시징 시스템 역할도 합니다. 예를 들어 모델(model)의 값이 변경되면 자동으로 뷰(view) 역할을 하는 GUI에 반영하는 코드를 작성할 경우 기존 객체 구현 코드를 수정하지 않고, 다시 말해 의존성을 추가하지 않고 기능을 구현할 수 있게 도와주어 객체간 결합도를 없애 줍니다.&lt;/p&gt;
&lt;p&gt;자 그런데, 위 예제에서 &lt;code&gt;edc_host_set_address()&lt;/code&gt; 를 사용할 때는 콜백함수가 호출이 안되는 문제점이 있습니다. 왜냐하면 이 함수는 내부 address 변수를 직접 수정하기 때문에 값이 변경되었는지 여부를 GObject 시스템이 알 방법이 없기 때문입니다. 따라서 기존 코드를 수정해야 하는데, 첫번째 방법은 접근자를 이용하더라도 내부적으로 &lt;code&gt;g_object_set()&lt;/code&gt; 을 호출하도록 하는 겁니다. (여기서는 &amp;lsquo;address&amp;rsquo; 관련 API만 보여드립니다)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void
edc_host_set_address (EdcHost     *host,
                      const gchar *address)
{
  g_return_if_fail (EDC_IS_HOST (host));
  g_return_if_fail (address != NULL);

  g_object_set (host,
                &amp;quot;address&amp;quot;,  address,
                NULL);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 이 방법은 약간의 오버헤드가 있을 수 있습니다. 두번째 방법은, 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-notify&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_notify()&lt;/code&gt;&lt;/a&gt;
 함수를 이용해 직접 알려주는 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void
edc_host_set_address (EdcHost     *host,
                      const gchar *address)
{
  EdcHostPrivate *priv;

  g_return_if_fail (EDC_IS_HOST (host));
  g_return_if_fail (address != NULL);

  priv = EDC_HOST_GET_PRIVATE (host);

  g_free (priv-&amp;gt;address);
  priv-&amp;gt;address = g_strdup (address);

  g_object_notify (G_OBJECT (host), &amp;quot;address&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;edc_host_set_property()&lt;/code&gt; 함수 안에서 중복되는 코드도 정리해 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static void
edc_host_set_property (GObject      *object,
                       guint         property_id,
                       const GValue *value,
                       GParamSpec   *pspec)
{
  EdcHost *host = EDC_HOST (object);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  switch (property_id)
    {
    case EDC_HOST_PROP_NAME:
      edc_host_set_name (host, g_value_get_string (value));
      break;
    case EDC_HOST_PROP_ADDRESS:
      edc_host_set_address (host, g_value_get_string (value));
      break;
    case EDC_HOST_PROP_PORT:
      edc_host_set_port (host, g_value_get_int (value));
      break;
    case EDC_HOST_PROP_USER:
      edc_host_set_user (host, g_value_get_string (value));
      break;
    case EDC_HOST_PROP_PASSWORD:
      edc_host_set_password (host, g_value_get_string (value));
      break;
    default:
      /* We don&#39;t have any other property... */
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object,
                                         property_id,
                                         pspec);
      break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;시그널이 중복 발생할 경우를 염려할 필요는 없습니다. 시그널은 GObject 내부적으로 알아서 잘 정리되어 한 번 변경하면 한 번만 시그널이 발생합니다.&lt;/p&gt;
&lt;p&gt;오늘은 여기까지입니다&amp;hellip; :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (3)</title>
      <link>/2009/08/18/oop-with-gobject-3/</link>
      <pubDate>Tue, 18 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/18/oop-with-gobject-3/</guid>
      <description>&lt;p&gt;이 글은 회사 개발팀 내부 세미나를 위해 작성중인 글입니다. 하지만, 블로그란 매체의 특성상 외부에도 공개되고 있는데, 댓글은 달지 않아도 접속하는 사람들 대부분이 제가 아는 분일 거라 생각하고 한마디 하자면, 세상에 공짜가 어디 있는가, 주저하지 말고 내게 연락해서 술 한 잔 사게! (언젠가부터 술 강요 청탁 협박 블로그가 되어 가고 있군&amp;hellip;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;속성 (Properties) 추가하기&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;이제, GObject 속성(properties) 기능을 추가하려고 하는데, 왜 쓸데없이 일을 만들어서 하냐고 물으면 할 말이 있어야할 것 같아서, GObject 속성의 특징을 요약해 봤습니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;단일 API로 모든 속성 값을 얻어오거나 변경하기&lt;/li&gt;
&lt;li&gt;속성 변경시 자동으로 호출되는 함수 등록하기 (시그널 이용)&lt;/li&gt;
&lt;li&gt;실행 중에 속성에 대한 정보 얻어내기&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;물론 이미 많은 언어와 라이브러리가 그 이상의 기능을 지원하기도 하고, 일정 능력 이상의 개발자라면 직접 구현하는게 아주 어려운 것도 아닙니다. 하지만 이미 잘 구현되어 검증받은 라이브러리가 있는데 굳이 새로운 바퀴를 만들 필요는 없겠지요? 아무튼, 정확한 내용은 글을 적으면서 하나씩 설명해 나가겠습니다.&lt;/p&gt;
&lt;p&gt;GObject 객체에 속성을 추가하려면 속성의 값(value)이 어떤 형(type)인지, 이름이 무엇인지, 값의 범위는 어떻게 되는지, 기본값은 무엇인지 등을 정의해서 알려주어야 합니다. (C++이나 Java에서 클래스 멤버 변수를 정의하는 것과 비슷합니다) 이러한 정보를 줄임말로 스펙(spec.)이라고 한다면, 속성을 추가한다는 건 다른 말로, 스펙으로 명시한 속성 정보를 클래스에 설치(install)하는 것을 의미합니다. 객체 인스턴스마다 속성의 실제 값(value)은 모두 다르겠지만, 어떤 속성이 있는지 그 속성은 어떻게 구성되어는지는 모두 동일하겠지요. (참고로 GObject 관련 API를 훑어보시면 정확히 모르더라도 지금 언급한 개념의 단어로 이루어진 API가 꽤 많은 걸 아시게 될 겁니다) 그렇기 때문에, 속성을 추가하는 작업은 클래스 초기화 함수에서 이루어집니다.&lt;/p&gt;
&lt;p&gt;다음은 기존 예제에서 속성을 추가한 코드입니다. (변경된 부분만 보여드립니다)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* ...[snip]... */

enum
{
  EDC_HOST_PROP_0, /* ignore */
  EDC_HOST_PROP_NAME,
  EDC_HOST_PROP_ADDRESS,
  EDC_HOST_PROP_PORT,
  EDC_HOST_PROP_USER,
  EDC_HOST_PROP_PASSWORD
};

/* ...[snip]... */

static void
edc_host_get_property (GObject    *object,
                       guint       property_id,
                       GValue     *value,
                       GParamSpec *pspec)
{
  EdcHost *host = EDC_HOST (object);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  switch (property_id)
    {
    case EDC_HOST_PROP_NAME:
      g_value_set_string (value, priv-&amp;gt;name);
      break;
    case EDC_HOST_PROP_ADDRESS:
      g_value_set_string (value, priv-&amp;gt;address);
      break;
    case EDC_HOST_PROP_PORT:
      g_value_set_int (value, priv-&amp;gt;port);
      break;
    case EDC_HOST_PROP_USER:
      g_value_set_string (value, priv-&amp;gt;user);
      break;
    case EDC_HOST_PROP_PASSWORD:
      g_value_set_string (value, priv-&amp;gt;password);
      break;
    default:
      /* We don&#39;t have any other property... */
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object,
                                         property_id,
                                         pspec);
      break;
    }
}

static void
edc_host_set_property (GObject      *object,
                       guint         property_id,
                       const GValue *value,
                       GParamSpec   *pspec)
{
  EdcHost *host = EDC_HOST (object);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  switch (property_id)
    {
    case EDC_HOST_PROP_NAME:
      g_free (priv-&amp;gt;name);
      priv-&amp;gt;name = g_value_dup_string (value);
      break;
    case EDC_HOST_PROP_ADDRESS:
      g_free (priv-&amp;gt;address);
      priv-&amp;gt;address = g_value_dup_string (value);
      break;
    case EDC_HOST_PROP_PORT:
      priv-&amp;gt;port = g_value_get_int (value);
      break;
    case EDC_HOST_PROP_USER:
      g_free (priv-&amp;gt;user);
      priv-&amp;gt;user = g_value_dup_string (value);
      break;
    case EDC_HOST_PROP_PASSWORD:
      g_free (priv-&amp;gt;password);
      priv-&amp;gt;password = g_value_dup_string (value);
      break;
    default:
      /* We don&#39;t have any other property... */
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object,
                                         property_id,
                                         pspec);
      break;
    }
}

/* ...[snip]... */

/* class initializer */
static void
edc_host_class_init (EdcHostClass *klass)
{
  GObjectClass *gobj_class;
  GParamSpec *pspec;

  gobj_class = G_OBJECT_CLASS (klass);
  gobj_class-&amp;gt;finalize = edc_host_finalize;
  gobj_class-&amp;gt;set_property = edc_host_set_property;
  gobj_class-&amp;gt;get_property = edc_host_get_property;

  g_type_class_add_private (gobj_class,
                            sizeof (EdcHostPrivate));

  pspec =
    g_param_spec_string (&amp;quot;name&amp;quot;,               /* name */
                         &amp;quot;Name&amp;quot;,               /* nick */
                         &amp;quot;the name of a host&amp;quot;, /* blurb */
                         &amp;quot;&amp;quot;,                   /* default */
                         G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_NAME,
                                   pspec);

  pspec = g_param_spec_string (&amp;quot;address&amp;quot;,
                               &amp;quot;Address&amp;quot;,
                               &amp;quot;the address of a host&amp;quot;,
                               &amp;quot;&amp;quot;,
                               G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_ADDRESS,
                                   pspec);

  pspec = g_param_spec_int (&amp;quot;port&amp;quot;,
                            &amp;quot;Port&amp;quot;,
                            &amp;quot;the port number of a host&amp;quot;,
                            0,     /* minimum */
                            65535, /* maximum */
                            0,     /* default */
                            G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_PORT,
                                   pspec);

  pspec = g_param_spec_string (&amp;quot;user&amp;quot;,
                               &amp;quot;User&amp;quot;,
                               &amp;quot;password for authetication&amp;quot;,
                               &amp;quot;&amp;quot;,
                               G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_USER,
                                   pspec);

  pspec = g_param_spec_string (&amp;quot;password&amp;quot;,
                               &amp;quot;Password&amp;quot;,
                               &amp;quot;password for authetication&amp;quot;,
                               &amp;quot;&amp;quot;,
                               G_PARAM_READWRITE);
  g_object_class_install_property (gobj_class,
                                   EDC_HOST_PROP_PASSWORD,
                                   pspec);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제일 먼저 정의된 열거형 타입에 대해 설명하자면, 클래스 내부에서 속성은 정수형 숫자로 관리됩니다. 예를 들어 1번 속성, 3번 속성처럼 직접 정수형을 사용해도 되지만, 관례적으로 가독성을 위해 열거형으로 정의합니다. 이렇게 정의한 번호를 클래스에 속성을 설치할때 지정하면 [
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-install-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_install_property()&lt;/code&gt;&lt;/a&gt;
],  &lt;code&gt;edc_host_{get/set}_property() &lt;/code&gt;속성 읽기 / 쓰기 함수의 인자로 `&lt;code&gt;property_id&lt;/code&gt;&#39;가 전달되는데, 이 ID가 바로 속성 번호입니다. 물론 속성 번호는 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-override-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_override_property()&lt;/code&gt;&lt;/a&gt;
 같은 다른 API에서도 사용합니다.[](&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-override-property&#34;&gt;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-override-property&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;edc_host_class_init()&lt;/code&gt; 클래스  초기화 함수를 보면, 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_param_spec_*()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하여 각 속성의 스펙을 정의해서 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-class-install-property&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_class_install_property()&lt;/code&gt;&lt;/a&gt;
함수를 이용해 클래스 객체에 설치합니다. 그리고,속성 읽기 /쓰기 메쏘드를 재정의합니다. 참고로 API 문서를 확인하시면, 다양한 형(type)을 위한 스펙 정의 함수가 있는 걸 알 수 있습니다. 속성 스펙을 정의할때 마지막에 넣어주는 플래그(flags)는 속성의 특성을 정의하는데, 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-GParamSpec.html#GParamFlags&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GParamFlags&lt;/a&gt;
 설명을 한 번 읽어보시면 어렵지 않게 이해할 수 있습니다. 여기서는 모든 속성을 읽고 쓰기 가능하게 했습니다.&lt;/p&gt;
&lt;p&gt;재정의된 &lt;code&gt;edc_host_{get/set}_property() &lt;/code&gt;속성 읽기 / 쓰기 메쏘드 함수를 보면, 접근자(accessor) 함수와 동일한 작업을 합니다. 다른 점이라면 속성 ID에 따라 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Generic-values.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GValue&lt;/a&gt;
 객체에서 값을 읽거나, 값을 할당한다는 점입니다. GValue 객체는 쉽게 말해 어떤 형(type)의 값이라도 담을 수 있는 일반적인 값(generic values)입니다. 참고로 이 역시 다양한 형(type)을 위한 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Standard-Parameter-and-Value-Types.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_value_{set,get}_*()&lt;/code&gt;&lt;/a&gt;
 형태의 함수가 존재하므로 이를 그대로 이용하면 됩니다. (물론 더 능숙하게 사용하려면 API 문서를 한 번 훑어보는게 좋겠지요)&lt;/p&gt;
&lt;p&gt;여기까지 이해하셨다면 아시겠지만, GObject 시스템은 속성에 전반적인 틀과 관리 체계만 제공할 뿐 실제 속성을 다루는 작업은 대부분 직접 구현해야 합니다. 이는 프로그래머의 자유도를 높여 주기도 하지만, 불필요한 반복 작업을 유발하기도 합니다. 그리고 이 때문에 
&lt;a href=&#34;http://live.gnome.org/Vala&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Vala&lt;/a&gt;
 같은 GObject 기반 언어가 새로 만들어지기도 했습니다.&lt;/p&gt;
&lt;p&gt;**속성 (Properties) 사용하기
**&lt;/p&gt;
&lt;p&gt;이렇게 정의한 속성을 객체 외부에서 사용하기 위해 몇 가지 방법이 있지만, 가장 쉽고 많이 사용하는 방법은 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-get&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_get()&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-set&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_set()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하는 겁니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  EdcHost *host;
  gchar *address;
  gint port;

  g_type_init ();

  host = edc_host_new ();

  g_object_set (host,
                &amp;quot;address&amp;quot;, &amp;quot;192.168.0.100&amp;quot;,
                &amp;quot;port&amp;quot;, 8080,
                NULL);

  address = edc_host_get_address (host);
  g_assert_cmpstr (address, ==, &amp;quot;192.168.0.100&amp;quot;);
  g_free (address);

  g_object_get (host,
                &amp;quot;address&amp;quot;, &amp;amp;address,
                &amp;quot;port&amp;quot;, &amp;amp;port,
                NULL);

  g_assert_cmpstr (address, ==, &amp;quot;192.168.0.100&amp;quot;);
  g_assert_cmpint (port, ==, 8080);
  g_free (address);
  
  g_object_unref (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_new()&lt;/code&gt;&lt;/a&gt;
 함수를 이용하여 객체를 생성할때 아예 속성을 함께 지정할 수도 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  EdcHost *host;
  gchar *address;
  gint port;

  g_type_init ();

  host = g_object_new (EDC_TYPE_HOST,
                       &amp;quot;address&amp;quot;, &amp;quot;demo.emstone.com&amp;quot;,
                       &amp;quot;port&amp;quot;, 8081,
                       NULL);
  g_object_get (host,
                &amp;quot;address&amp;quot;, &amp;amp;address,
                &amp;quot;port&amp;quot;, &amp;amp;port,
                NULL);
  g_assert_cmpstr (address, ==, &amp;quot;demo.emstone.com&amp;quot;);
  g_assert_cmpint (port, ==, 8081);
  g_free (address);

  g_object_unref (host);  

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;눈여겨 보신 분은 아시겠지만, &lt;code&gt;edc_host_new()&lt;/code&gt; 함수는 &lt;code&gt;g_object_new (EDC_TYPE_HOST, NULL)&lt;/code&gt; 호출로 만들어진 객체를 돌려주는 역할만 합니다.&lt;/p&gt;
&lt;p&gt;이렇게 대략 GObject 속성 기본 사용법을 설명한 것 같습니다. 물론 이 예제 코드에는 몇 가지 오류가 남아있는데, 이는 위에서 언급한 것처럼 객체 속성을 다루는 다른 부분을 설명하면서 보완해 나갈 예정입니다.&lt;/p&gt;
&lt;p&gt;오늘은 여기까지입니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (2)</title>
      <link>/2009/08/14/oop-with-gobject-2/</link>
      <pubDate>Fri, 14 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/14/oop-with-gobject-2/</guid>
      <description>&lt;p&gt;첫번째 글이 당연한 내용을 너무 길게 설명했다는 의견이 있어서, 이번 글부터는 더 짧고 간결하게 정리해 보려고 노력하고 있습니다. 그리고, 이 글의 대상은 한 번이라도 GTK+ / GLib 라이브러리를 사용한 경험이 있는 개발자입니다. 그래서 정말로 기초적인 내용은 피하고 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;접근자 (Accessors)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;소프트웨어 공학에서 모듈이나 객체 설계시 기본적으로 강조하는 정보은닉(information hiding), 캡슐화(encapsulation), 결합도(coupling) 등과 같은 개념에 의하면, C 언어처럼 구조체의 필드 변수를 외부로 직접 공개하는 건 좋지 않다고 합니다. 그리고 대부분의 경우 직접 접근 방식보다 읽고 쓰는 접근자(accessors)를 제공하는 게 여러모로 좋다고 하지요. 물론 성능 문제로 직접 접근 방식을 고려해야 하는 경우도 있지만, 지금까지 경험에 비춰보면, 병목을 일으키는 부분은 프로파일러를 돌려서 정확하게 파악한 다음에 해결하는 게 대부분 좋기 때문에 처음부터 그럴 필요는 없을 것 같습니다.&lt;/p&gt;
&lt;p&gt;참고로 현재 개발 중인 
&lt;a href=&#34;http://live.gnome.org/GTK%2B/3.0/Roadmap&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GTK+ 3.0&lt;/a&gt;
에서도 기존에 공개되었던 변수들을 모조리 안으로 숨기고, GTK+ 2.x 어플리케이션의 이전(migration)을 위해 
&lt;a href=&#34;http://live.gnome.org/GnomeGoals/UseGseal&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;GSEAL() 매크로&lt;/a&gt;
를 2.14 버전부터 제공하고 있습니다.&lt;/p&gt;
&lt;p&gt;아무튼 그래서, 일단 지난 글에서 예제로 사용한 호스트 객체의 필드를 숨기고 접근 API를 구현해 보았습니다. (변경되거나 수정한 부분만 보여드립니다)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct _EdcHostClass EdcHostClass;
typedef struct _EdcHost      EdcHost;

struct _EdcHost
{
  GObject parent;
};

struct _EdcHostClass
{
  GObjectClass parent_class;
};

GType        edc_host_get_type     (void) G_GNUC_CONST;
EdcHost     *edc_host_new          (void);
const gchar *edc_host_get_name     (EdcHost     *host);
void         edc_host_set_name     (EdcHost     *host,
                                    const gchar *name);
const gchar *edc_host_get_address  (EdcHost     *host);
void         edc_host_set_address  (EdcHost     *host,
                                    const gchar *address);
gint         edc_host_get_port     (EdcHost     *host);
void         edc_host_set_port     (EdcHost     *host,
                                    gint         port);
const gchar *edc_host_get_user     (EdcHost     *host);
void         edc_host_set_user     (EdcHost     *host,
                                    const gchar *user);
const gchar *edc_host_get_password (EdcHost     *host);
void         edc_host_set_password (EdcHost     *host,
                                    const gchar *password);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

typedef struct _EdcHostPrivate EdcHostPrivate;
struct _EdcHostPrivate
{
  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;
};

#define EDC_HOST_GET_PRIVATE(host) 
 G_TYPE_INSTANCE_GET_PRIVATE (host, EDC_TYPE_HOST, EdcHostPrivate)

G_DEFINE_TYPE (EdcHost, edc_host, G_TYPE_OBJECT);

EdcHost *
edc_host_new (void)
{
  return EDC_HOST (g_object_new (EDC_TYPE_HOST, NULL));
}

/* object initializer */
static void
edc_host_init (EdcHost *host)
{
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  priv-&amp;gt;name = g_strdup (&amp;quot;&amp;quot;);
  priv-&amp;gt;address = g_strdup (&amp;quot;&amp;quot;);
  priv-&amp;gt;port = 0;
  priv-&amp;gt;user = g_strdup (&amp;quot;&amp;quot;);
  priv-&amp;gt;password = g_strdup (&amp;quot;&amp;quot;);
}

/* object finalizer */
static void
edc_host_finalize (GObject *self)
{
  EdcHost *host = EDC_HOST (self);
  EdcHostPrivate *priv;

  priv = EDC_HOST_GET_PRIVATE (host);

  g_free (priv-&amp;gt;name);
  g_free (priv-&amp;gt;address);
  g_free (priv-&amp;gt;user);
  g_free (priv-&amp;gt;password);

  /* call our parent method (always do this!) */
  G_OBJECT_CLASS (edc_host_parent_class)-&amp;gt;finalize (self);
}

/* class initializer */
static void
edc_host_class_init (EdcHostClass *klass)
{
  GObjectClass *gobj_class;

  gobj_class = G_OBJECT_CLASS (klass);
  gobj_class-&amp;gt;finalize = edc_host_finalize;

  g_type_class_add_private (gobj_class, sizeof (EdcHostPrivate));
}

const gchar *
edc_host_get_name (EdcHost *host)
{
  EdcHostPrivate *priv;

  g_return_val_if_fail (EDC_IS_HOST (host), NULL);

  priv = EDC_HOST_GET_PRIVATE (host);

  return priv-&amp;gt;name;
}

void
edc_host_set_name (EdcHost     *host,
                   const gchar *name)
{
  EdcHostPrivate *priv;

  g_return_if_fail (EDC_IS_HOST (host));
  g_return_if_fail (name != NULL);

  priv = EDC_HOST_GET_PRIVATE (host);

  g_free (priv-&amp;gt;name);
  priv-&amp;gt;name = g_strdup (name);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;먼저 헤더 파일을 보면, &lt;code&gt;EdcHost&lt;/code&gt; 구조체에서 공개되었던 객체 변수가 모두 사라지고, 대신 &lt;code&gt;edc_host_{get,set}_*()&lt;/code&gt; 형태의 API 선언이 추가되었습니다. 소스 파일에는 새로 &lt;code&gt;EdcHostPrivate&lt;/code&gt; 구조체를 정의하고 모든 비공개 변수를 집어 넣은 뒤, 클래스 초기화 함수[&lt;code&gt;edc_host_class_init ()&lt;/code&gt;] 마지막 부분에서 이 크기만큼의 공간을 확보하도록 합니다.[
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Type-Information.html#g-type-class-add-private&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_type_class_add_private()&lt;/code&gt;&lt;/a&gt;
] 그리고 모든 함수에서 이 구조체를 쉽게 얻어오기 위해 정의한 &lt;code&gt;EDC_HOST_GET_PRIVATE()&lt;/code&gt; 매크로를 사용해 필요한 작업을 수행합니다.&lt;/p&gt;
&lt;p&gt;부가적으로 조금만 더 설명하면, 모든 문자열을 넘겨주는 API는 문자열을 복사해서 넘겨주어 원본 문자열을 보호합니다. 따라서 API 문서에 넘겨받은 문자열을 반드시 해제하라고 명시되어 있어야 하겠죠. 또한 지난 글에서 잠시 언급한 것처럼, 공개된 함수 진입 시점에서 인수 적합성 검사를 할때 &lt;code&gt;EDC_IS_HOST()&lt;/code&gt; 매크로를 사용해 NULL 여부 뿐 아니라 정확하게 해당 객체인지 검사하도록 합니다.&lt;/p&gt;
&lt;p&gt;참고로 위 예제에서 비공개(private) 객체에 접근하는 방법은 설명을 위해 오버헤드가 존재하는 단순한 방식입니다. 따라서 실제로 사용하려면 반드시 이 
&lt;a href=&#34;/2008/12/23/reduce-accesing-overhead-for-gobject-private-data/&#34;&gt;포스트&lt;/a&gt;
를 참고하시기 바랍니다.&lt;/p&gt;
&lt;p&gt;이렇게 해서 기본적인 객체 속성에 대한 접근자를 구현했습니다. 물론 이게 다는 아니고, 다음에 설명할 GObject 속성(properties) 기능을 이용하면 사실 접근자를 구현할 필요도 없습니다. 하지만, GTK+와 같은 대부분의 GObject 기반 객체는 함수 API 기반의 접근자를 동시에 제공하고 있으므로 관례를 따르는 게 나쁘지는 않겠지요.&lt;/p&gt;
&lt;p&gt;글머리에서 언급했듯이, 계속 적다 보면 내용도 길어지고 포스팅 주기도 길어질 것 같아 오늘은 일단 여기까지만 적습니다. 다음에는 본격적으로 GObject 속성(properties)을 추가할 예정인데, 설명할 게 많아서&amp;hellip; ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GObject 객체 지향 프로그래밍 (1)</title>
      <link>/2009/08/10/oop-with-gobject-1/</link>
      <pubDate>Mon, 10 Aug 2009 00:00:00 +0000</pubDate>
      <guid>/2009/08/10/oop-with-gobject-1/</guid>
      <description>&lt;p&gt;GTK+, Clutter 등과 같은 라이브러리는 C 언어로 구현되었지만 객체 지향 개념을 충실히 따르고 있는데, 그 중심에는 GLib 라이브러리의 GObject가 있습니다. 따라서 이러한 라이브러리를 제대로 이해하고 사용하려면 필수적으로 GObject 개념을 잘 이해하고 있어야 합니다. 그런데, 생각보다 GObject 개념은 이해하기 어렵습니다. 이해하더라도 이를 응용하려면 그만큼 시간이 또 필요합니다.&lt;/p&gt;
&lt;p&gt;그래서 이번 글을 시작으로 GObject 라이브러리를 이용한 C 언어에서 객체 지향 프로그래밍이라는 거창한 주제를 예제 형식을 이용해 다루어 보려고 합니다. 바로 새 GTK+ 위젯을 구현하거나 클러터 객체를 분석하는 방식이 아니라 왜 GObject가 이런 방식으로 설계되었는지 그 철학을 따라가 보려고 합니다. 그리고, 가능한 기존 GObject 튜토리얼의 어려운 설명이 아니라 실제 사용하는 코드를 중심으로 설명할 예정이니, 그래도 무슨 말인지 모르겠거나 더 풀어서 설명을 하는 게 좋을 것 같을 경우 의견 주시기 바랍니다.&lt;/p&gt;
&lt;p&gt;여기서 예제로 사용할 개념은 네트워크 카메라 호스트와 호스트 목록입니다. (하는 일이 이쪽 분야라서&amp;hellip; :)&lt;/p&gt;
&lt;p&gt;네트워크 카메라 호스트는 이름(name), 주소(address), 포트번호(port), 사용자(user), 비밀번호(password) 등과 같은 항목을 포함합니다. 필요한 함수로는 새 객체를 만들거나 해제, 그리고 각 필드값을 얻어오거나 변경하는 정도입니다. (아마도 나중에는 값이 변경되면 자동으로 호출되는 콜백 함수도 추가할 겁니다)&lt;/p&gt;
&lt;p&gt;모든 코드는 GLib API를 이용하여 작성합니다.&lt;/p&gt;
&lt;p&gt;**객체 (Objects) + 참조 카운터 (Reference Counter)
**&lt;/p&gt;
&lt;p&gt;소프트웨어 공학자들이 객체라고 부르기 전부터 C 언어에는 구조체(struct)가 있었습니다. GObject 시스템 역시 기본 바탕은 구조체입니다. 그러면 GObject 프로그래밍을 하기 전에, 일반 C 언어 구조체를 이용해 네트워크 카메라 호스트를 정의하면, 다음과 같은 코드가 나오지 않을까요?&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;typedef struct _EdcHost EdcHost;
struct _EdcHost
{
  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;만일 상속이나 함수 오버로딩(overloading)을 전혀 사용하지 않는다면, 굳이 새로운 함수를 추가할 필요를 못 느끼는 분들이 많을 겁니다. 왜냐하면, 직접 구조체 크기만큼 메모리를 할당한 뒤 해제하고, 직접 모든 필드를 접근하면 되니까요. 하지만, 할당하고 해제하는 코드가 여러 곳에 분산되어 있다면 디버깅도 힘들고 유지 보수도 힘드니까 최소한 객체를 생성하고 해제하는 함수만이라도 만들어 봅시다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;EdcHost *
edc_host_new (void)
{
  EdcHost *host;

  host = g_new0 (EdcHost, 1);

  return host;
}

void
edc_host_destroy (EdcHost *host)
{
  g_return_if_fail (host != NULL);

  g_free (host-&amp;gt;name);
  g_free (host-&amp;gt;address);
  g_free (host-&amp;gt;user);
  g_free (host-&amp;gt;password);
  g_free (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;간단한 코드라서 설명할 필요는 없을 것 같습니다. 참고로 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Memory-Allocation.html#g-free&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_free()&lt;/code&gt;&lt;/a&gt;
 함수는 인수가 NULL일 경우 무시하므로 NULL 검사 코드는 필요없습니다.&lt;/p&gt;
&lt;p&gt;그런데, 이 객체는 단순히 목록 관리 뿐 아니라 여러 다른 모듈에서도 사용할 예정입니다. 여기서 갑자기, 모든 모듈이 하나의 객체를 공유하고 싶은 욕망이 꿈틀대기 시작합니다. 모듈 간에 객체를 전달할때 복사할 필요도 없고, 모듈 별로 객체를 따로 만들어 정보를 보관하는 것보다 메모리를 절약할 수 있으며, 필드 하나가 변경되었을 경우 그 정보를 모든 관련 객체에 반영할 수고도 덜 수 있기 때문입니다. 그렇다고 무턱대고 모든 모듈에서 객체 주소(pointer)만 참조하게 하면 객체를 어느 시점에 할당하고 해제해야 하는지 매우 까다로워집니다. 특히 동적으로 임시 객체를 생성해 다른 모듈에게 넘겨주는 경우라면, 객체를 어느 시점에서 해제해야 하는지도 실수하기 딱 좋습니다. 더 나아가 멀티 쓰레드 환경까지 고려한다면, 단순히 포인터만 가리키는 방식은, 아마추어나 사용하는 옛날 UML 클래스 빌더가 자동으로 생성해주는 코드만으로는, 힘들 수 밖에 없습니다.&lt;/p&gt;
&lt;p&gt;이런 경우 자주 사용하는 방식이 참조 카운터(reference counter) 기법입니다. 짧게 설명하자면, 모든 모듈에서 몇 가지 원칙만 지키면 됩니다. 첫번째 원칙은, 객체(메모리)를 할당한 모듈에서 반드시 해제하기입니다. 두번째는, 모듈 관점에서 내가 필요한 시점부터 객체의 참조 카운터를 증가하고, 더이상 사용하지 않으면 객체의 참조 카운터를 감소합니다. 새로 생성된 객체는 참조 카운터 값이 1이고, 참조 카운터가 감소되어 0이 되면 객체는 자동으로 해제됩니다. 참고로, 참조 카운터 기법은 멀티미디어 프레임 버퍼, 네트워크 패킷 등과 같은 버퍼 관리에도 널리 사용하는 것은 물론, 오브젝티브-C 언어(Objective-C)의 NSObject 객체가 기본적으로 제공하는 기능이기도 합니다.&lt;/p&gt;
&lt;p&gt;자 이제, 호스트 객체를 참조 카운터 기법을 적용해 수정해 보면 다음과 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_HOST_H__
#define __EDC_HOST_H__

#include &amp;lt;glib.h&amp;gt;

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

typedef struct _EdcHost EdcHost;
struct _EdcHost
{
  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;

  gint   ref_count;
};

EdcHost *edc_host_new   (void);
EdcHost *edc_host_ref   (EdcHost *host);
void     edc_host_unref (EdcHost *host);

#ifdef __cplusplus
}
#endif

#endif /* __EDC_HOST_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

EdcHost *
edc_host_new (void)
{
  EdcHost *host;

  host = g_new0 (EdcHost, 1);
  if (!host)
    return NULL;

  host-&amp;gt;ref_count = 1;

  return host;
}

static void
edc_host_destroy (EdcHost *host)
{
  g_return_if_fail (host != NULL);

  g_free (host-&amp;gt;name);
  g_free (host-&amp;gt;address);
  g_free (host-&amp;gt;user);
  g_free (host-&amp;gt;password);
  g_free (host);
}

EdcHost *
edc_host_ref (EdcHost *host)
{
  g_return_val_if_fail (host != NULL, NULL);

  g_atomic_int_inc (&amp;amp;host-&amp;gt;ref_count);

  return host;
}

void
edc_host_unref (EdcHost *host)
{
  g_return_if_fail (host != NULL);

  if (g_atomic_int_dec_and_test (&amp;amp;host-&amp;gt;ref_count))
    edc_host_destroy (host);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;제일 먼저 설명할 부분은 역시 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Atomic-Operations.html#g-atomic-int-inc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_atomic_int_inc()&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Atomic-Operations.html#g-atomic-int-dec-and-test&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_atomic_int_dec_and_test()&lt;/code&gt;&lt;/a&gt;
 함수입니다. 멀티 쓰레드에서 안전하게 카운터 변수를 증가하고 감소할 수 있게 도와주는 GLib API입니다. 이를 이용해 위에서 설명한 참조 카운터 개념을 구현하고 있습니다. 공개했던 &lt;code&gt;edc_host_destroy()&lt;/code&gt; 함수는 모듈 내부에서만 접근할 수 있도록 &lt;code&gt;static&lt;/code&gt; 키워드를 붙였습니다. 또한 C++ 소스에서 포함(include)할때 문제를 일으키지 않도록 헤더파일에 &amp;lsquo;&lt;code&gt;extern &amp;quot;c&amp;quot; {}&lt;/code&gt;&amp;rsquo; 키워드도 추가했습니다.&lt;/p&gt;
&lt;p&gt;그런데 참조 카운터가 필요한 객체마다 이렇게 구현하면 비슷한 작업을 하는 코드가 중복될 수 밖에 없습니다. 이를 일반적인 API로 분리해 다시 구현하면 재활용이 가능할테니, 다음과 같이 수정해 보겠습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-object.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_OBJECT_H__
#define __EDC_OBJECT_H__

#include &amp;lt;glib.h&amp;gt;

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

typedef struct _EdcObject EdcObject;
struct _EdcObject
{
  gint           ref_count;
  GDestroyNotify finalize;
};

static inline gpointer
edc_object_alloc (GDestroyNotify finalize,
                  gint           obj_size)
{
  EdcObject *obj;

  obj = g_malloc (obj_size);
  if (!obj)
    return NULL;

  obj-&amp;gt;ref_count = 1;
  obj-&amp;gt;finalize = finalize;

  return obj;
}

static inline gpointer
edc_object_ref (gpointer obj)
{
  EdcObject *object = obj;

  if (object)
    g_atomic_int_inc (&amp;amp;object-&amp;gt;ref_count);

  return object;
}

static inline void
edc_object_unref (gpointer obj)
{
  EdcObject *object = obj;

  if (!obj)
    return;

  if (g_atomic_int_dec_and_test (&amp;amp;object-&amp;gt;ref_count))
    {
      if (object-&amp;gt;finalize)
        object-&amp;gt;finalize (object);
      g_free (object);
    }
}

#ifdef __cplusplus
}
#endif

#endif /* __EDC_OBJECT_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_HOST_H__
#define __EDC_HOST_H__

#include &amp;quot;edc-object.h&amp;quot;

#ifdef __cplusplus
extern &amp;quot;C&amp;quot; {
#endif

typedef struct _EdcHost EdcHost;
struct _EdcHost
{
  EdcObject parent;

  gchar *name;
  gchar *address;
  gint   port;
  gchar *user;
  gchar *password;
};

EdcHost *edc_host_new (void);

#ifdef __cplusplus
}
#endif

#endif /* __EDC_HOST_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

static void
edc_host_finalize (gpointer obj)
{
  EdcHost *host = obj;

  g_free (host-&amp;gt;name);
  g_free (host-&amp;gt;address);
  g_free (host-&amp;gt;user);
  g_free (host-&amp;gt;password);
}

EdcHost *
edc_host_new (void)
{
  EdcHost *host;

  host = edc_object_alloc (edc_host_finalize,
                           sizeof (EdcHost));
  if (!host)
    return NULL;

  host-&amp;gt;name = NULL;
  host-&amp;gt;address = NULL;
  host-&amp;gt;user = NULL;
  host-&amp;gt;password = NULL;

  return host;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;객체 지향 상속(또는 파생 객체)을 C 언어로 구현하는 가장 쉬운 방법은 위 코드에서 보는 것처럼 부모(또는 원본 객체)를 구조체 맨 앞에 두는 겁니다. 그러면 부모와 자식 API 모두 사용할 수 있게 되죠. 위 코드의 경우 개념상으로 보면 EdcObject 객체를 상속 받아 EdcHost 객체를 구현한 셈이 되죠. 따라서 다음과 같이 사용할 수 있습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void
func_a (EdcHost *host)
{
  edc_object_ref (host);
  // do some stuff for long time...
  edc_object_unref (host);
}

{
  EdcHost *host;

  host = edc_host_new ();
  ...
  func_a (host);
  ...
  edc_object_unref (host); /* destroy */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;참고로 C 언어에서 `&lt;code&gt;void *&lt;/code&gt;&amp;rsquo; 형은 어떤 포인터와도 양방향 대입(assignment)을 할 수 있으므로 컴파일 경고를 피하기 위해 불필요한 형변환을 할 필요가 없습니다. (
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Basic-Types.html#gpointer&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;gpointer&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Datasets.html#GDestroyNotify&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;GDestroyNotify&lt;/code&gt;&lt;/a&gt;
 API도 설명도 확인해 보시기 바랍니다)&lt;/p&gt;
&lt;p&gt;이제 지금까지 구현한 부분을 GObject 객체 기반으로 옮겨 봅니다. 자세히 보시면, 지금까지 프로그래밍한 내용과 거의 비슷한 점을 알아챌 수 있을 겁니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;edc-host.h&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#ifndef __EDC_HOST_H__
#define __EDC_HOST_H__

#include &amp;lt;glib-object.h&amp;gt;

G_BEGIN_DECLS

#define EDC_TYPE_HOST 
 (edc_host_get_type ())
#define EDC_HOST(obj) 
 (G_TYPE_CHECK_INSTANCE_CAST ((obj), EDC_TYPE_HOST, EdcHost))
#define EDC_HOST_CLASS(obj) 
 (G_TYPE_CHECK_CLASS_CAST ((obj), EDC_TYPE_HOST, EdcHostClass))
#define EDC_IS_HOST(obj) 
 (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EDC_TYPE_HOST))
#define EDC_IS_HOST_CLASS(obj) 
 (G_TYPE_CHECK_CLASS_TYPE ((obj), EDC_TYPE_HOST))
#define EDC_GET_HOST_CLASS(obj) 
 (G_TYPE_INSTANCE_GET_CLASS ((obj), EDC_TYPE_HOST, EdcHostClass))

typedef struct _EdcHostClass EdcHostClass;
typedef struct _EdcHost      EdcHost;

struct _EdcHost
{
 GObject parent;

 gchar  *name;
 gchar  *address;
 gint    port;
 gchar  *user;
 gchar  *password;
};

struct _EdcHostClass
{
 GObjectClass parent_class;
};

GType    edc_host_get_type (void) G_GNUC_CONST;
EdcHost *edc_host_new      (void);

G_END_DECLS

#endif /* __EDC_HOST_H__ */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;edc-host.c&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;quot;edc-host.h&amp;quot;

G_DEFINE_TYPE (EdcHost, edc_host, G_TYPE_OBJECT);

EdcHost *
edc_host_new (void)
{
 return EDC_HOST (g_object_new (EDC_TYPE_HOST, NULL));
}

/* object initializer */
static void
edc_host_init (EdcHost *host)
{
 host-&amp;gt;name = NULL;
 host-&amp;gt;address = NULL;
 host-&amp;gt;port = 0;
 host-&amp;gt;user = NULL;
 host-&amp;gt;password = NULL;
}

/* object finalizer */
static void
edc_host_finalize (GObject *self)
{
 EdcHost *host = EDC_HOST (self);

 g_free (host-&amp;gt;name);
 g_free (host-&amp;gt;address);
 g_free (host-&amp;gt;user);
 g_free (host-&amp;gt;password);

 /* call our parent method (always do this!) */
 G_OBJECT_CLASS (edc_host_parent_class)-&amp;gt;finalize (self);
}

/* class initializer */
static void
edc_host_class_init (EdcHostClass *klass)
{
 GObjectClass *gobject_class;

 gobject_class = G_OBJECT_CLASS (klass);
 gobject_class-&amp;gt;finalize = edc_host_finalize;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;갑자기 코드량이 증가했다고 놀랄 필요는 없습니다. 뭐든지 다 그렇지만, 알고 보면 별 거 아닙니다.&lt;/p&gt;
&lt;p&gt;먼저 헤더 파일을 설명하면,  GObject 객체를 사용하기 위해 glib-object.h 파일을 포함했습니다. 이는 EdcHost 객체가 GObject 객체만 사용하기 때문에, 더 정확히는 GObject의 파생 객체(derived objects), 다른 말로는 GObject 객체만 상속(inheritance)하기 때문에 그렇습니다. 만일 다른 객체에서 파생한다면 그 객체를 정의하는 헤더 파일을 포함해야 합니다. &amp;lsquo;&lt;code&gt;extern &amp;quot;c&amp;quot; {}&lt;/code&gt;&amp;rsquo; 키워드는 GLib의 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Miscellaneous-Macros.html#G-BEGIN-DECLS--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;G_BEGIN_DECLS&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/glib/stable/glib-Miscellaneous-Macros.html#G-END-DECLS--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;G_END_DECLS&lt;/code&gt;&lt;/a&gt;
 API로 대체했습니다.&lt;/p&gt;
&lt;p&gt;EdcHost 인스턴스와 EdcHostClass 클래스를 정의하고 있는 부분을 설명하면, 클래스 객체는 전역으로 하나만 존재하고 그냥 객체는 인스턴스(instance) 역할을 합니다. 또한 여기서는 인스턴스 객체의 모든 필드가 공개되어 있지만, 물론 외부에 공개하지 않는(private) 필드를 정의할 수도 있습니다. (이는 다른 글에서 따로 설명하겠습니다)&lt;/p&gt;
&lt;p&gt;복잡해 보이는 몇몇 매크로는 자주 사용하는 긴 API를 간편화한 것입니다. 런타임 중에 인스턴스가 유효하고 EdcHost 객체로 형변환까지 해주거나[&lt;code&gt;EDC_HOST(obj)&lt;/code&gt;], 인스턴스가 EdcHost 객체인지 확인하거나[&lt;code&gt;EDC_IS_HOST(obj)&lt;/code&gt;], 인스턴스의 클래스 객체를 얻어오거나[&lt;code&gt;EDC_GET_HOST_CLASS(obj)&lt;/code&gt;] 하는 등 일종의 
&lt;a href=&#34;http://en.wikipedia.org/wiki/Run-time_type_information&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;RTTI&lt;/a&gt;
 관련 매크로입니다. 아마 제일 많이 사용하는 매크로는 `&lt;code&gt;EDC_HOST(obj)&lt;/code&gt;&#39;일 겁니다.&lt;/p&gt;
&lt;p&gt;소스를 살펴 보면, 제일 먼저 나오는게 `
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-Type-Information.html#G-DEFINE-TYPE--CAPS&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;G_DEFINE_TYPE(TN, t_n, T_P)&lt;/code&gt;&lt;/a&gt;
&amp;rsquo; 입니다. 여담이지만, 이 매크로가 추가되기 전에 작성한 GObject 기반 코드는 귀찮은 작업을 많이 해야 했는데, 이 매크로가 자동으로 해주는 기능이 많아서 불필요하게 중복되는 코드가 많이 줄어들었습니다. 그래서 GTK+ 소스 코드 중에도 가끔 그렇게 작성한 코드도 있고, GObject 관련 초기 문서를 보면 이 매크로를 사용하지 않고 구현되어 있는 경우도 있습니다.&lt;/p&gt;
&lt;p&gt;이 매크로가 하는 일은 다음과 같습니다. 지정한 `&lt;code&gt;t_n&lt;/code&gt;` 이름으로 시작하는 클래스 초기화 함수[&lt;code&gt;*_class_init()&lt;/code&gt;] / 인스턴스 초기화 함수[&lt;code&gt;*_init()&lt;/code&gt;] 모두 구현되어 있다고 가정하고 `&lt;code&gt;*_get_type()&lt;/code&gt;&amp;rsquo; 함수를 자동으로 삽입해 줍니다. 더불어 부모 클래스 객체를 가리키는 `&lt;code&gt;*_parent_class&lt;/code&gt;&amp;rsquo; 전역 변수도 만들어 줍니다. 따라서 프로그래머는 최소한 함수 두 개만 구현해 주면 되는 셈입니다. [&lt;code&gt;edc_host_init()&lt;/code&gt; / &lt;code&gt;edc_host_class_init()&lt;/code&gt;]&lt;/p&gt;
&lt;p&gt;하지만 위 예제에서는 클래스 초기화 함수에서 인스턴스 객체가 해제될때 호출되는 finalize 함수를 교체하고 있습니다. 이를 통해 객체가 해제될때 사용하던 리소스를 해제해 줍니다. 그리고, 반드시 상위 클래스의 finalize 함수를 호출해 주어야 정상적으로 부모 객체의 해제 함수가 차례대로 호출될 수 있습니다.&lt;/p&gt;
&lt;p&gt;자 이제 GObject의 핵심 기능 중 하나인 객체 참조 카운터(object reference counter) 기능을 쉽게 이용할 수 있습니다. 이렇게 작성한 객체는 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-ref&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_ref()&lt;/code&gt;&lt;/a&gt;
 / 
&lt;a href=&#34;http://library.gnome.org/devel/gobject/stable/gobject-The-Base-Object-Type.html#g-object-unref&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;g_object_unref()&lt;/code&gt;&lt;/a&gt;
 함수 등을 이용해 참조 카운터를 제어할 수 있습니다. GObject 소스 코드를 확인해 보시면 알겠지만, 실제 객체 참조 카운터 기능은 거의 비슷하게 구현되어 있습니다. 더 많은 경우의 수를 고려하고 더 많은 기능을 제공하다보니 코드가 더 복잡한 것 뿐입니다.&lt;/p&gt;
&lt;p&gt;더 중요한 점은 모든 GObject 기반 객체, 예를 들어 GTK+ 위젯이나 클러터 객체 모두 GObject 기반이기 때문에 객체간 연결(부모-자식, 컨테이너-아이템 등)시 객체에 대한 포인터를 유지하면서 동시에 참조 카운터를 유지하여 메모리를 관리한다는 점입니다. 이 부분에 대한 더 자세한 설명은 
&lt;a href=&#34;/2008/12/28/gtk-memory-management/&#34;&gt;GTK+ 메모리 관리&lt;/a&gt;
 글에서 확인하시기 바랍니다.&lt;/p&gt;
&lt;p&gt;오늘은 일단 여기까지만&amp;hellip; ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>실행 안되는 crontab 작업 디버깅하기</title>
      <link>/2009/07/17/debugging-crontab-job-not-running/</link>
      <pubDate>Fri, 17 Jul 2009 00:00:00 +0000</pubDate>
      <guid>/2009/07/17/debugging-crontab-job-not-running/</guid>
      <description>&lt;p&gt;리눅스를 비롯한 유닉스 방식 운영체제에서 주기적인 작업을 수행하기 위해 cron 데몬을 많이 사용합니다. 루트 권한으로 시스템 관리에 필요한 작업을 예약할 수도 있지만, 일반 사용자 계정도 &amp;lsquo;&lt;code&gt;crontab -e&lt;/code&gt;&amp;rsquo; 명령으로 작업 예약이 가능합니다. 현재 활발하게 개발 중인 프로젝트의 일일 빌드(daily build)를 위해 crontab 작업을 다음과 같이 예약했는데, 문제는 동일한 설정이 한 장비에서만 동작을 안한다는 점입니다. (dooly 계정으로 작업한다고 가정합니다)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# m h  dom mon dow   command
0 23 * * * /home/dooly/build-cms.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;빌드 스크립트(&lt;code&gt;/home/dooly/build-cms.sh&lt;/code&gt;) 내용은 다음과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh
cd /home/dooly/svn/dooly
svn update &amp;amp;&amp;amp; 
sudo make install-depends &amp;amp;&amp;amp; 
make clean &amp;amp;&amp;amp; 
make &amp;amp;&amp;amp; 
make packages &amp;amp;&amp;amp; 
make upload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;인터넷을 찾아보니 다음과 같이 수정하여 로그 파일을 분석하라고 해서 따라해 보았습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# m h  dom mon dow   command
* * * * * /home/dooly/build-cms.sh &amp;gt;&amp;gt; /home/dooly/cron.log 2&amp;gt;&amp;amp;1
* * * * * env &amp;gt; /home/dooly/env.log 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;로그 파일을 분석하니, 환경 변수 LANG이 ko_KR.UTF-8 로 설정되지 않아서 서브버전 갱신(update) 도중 에러가 발생하고 있었습니다. 그래서 스크립트를 다음과 같이 수정해서 일단 문제는 해결했습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/sh
export LANG=ko_KR.UTF-8
cd /home/dooly/svn/dooly
svn update &amp;amp;&amp;amp; 
sudo make install-depends &amp;amp;&amp;amp; 
make clean &amp;amp;&amp;amp; 
make &amp;amp;&amp;amp; 
make packages &amp;amp;&amp;amp; 
make upload
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;하지만 향후 문제 발생시 디버깅을 위해 다음과 같이 crontab 항목도 아예 변경해 두었습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# m h  dom mon dow   command
0 23 * * * /home/dooly/build-cms.sh &amp;gt; /home/dooly/cron.log 2&amp;gt;&amp;amp;1
#* * * * * env &amp;gt; /home/dooly/env.log 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;물론, 자동으로 메일을 전송하도록 하거나 하는 다른 추가 기능도 가능하겠지만, 일단 이 정도 수준에서 만족하고 현재는 잘 동작하고 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>코딩 잘하는 방법?</title>
      <link>/2009/07/06/how-to-code-well/</link>
      <pubDate>Mon, 06 Jul 2009 00:00:00 +0000</pubDate>
      <guid>/2009/07/06/how-to-code-well/</guid>
      <description>&lt;p&gt;저는 개발자(developer)보다 프로그래머(programmer)라고 부르는 걸 더 좋아합니다. 왜냐하면 프로그래머라는 단어는 프로그램(program)을 만드는 이라고 명확하게 나타내주기 때문입니다. 개발자라는 단어는 어쩐지 프로그래머라는 직업이 단순 코더(coder)로 인식되기 시작하면서, 그보다 더 많은 일을 하고 있다고 포장하기 위해 그럴듯한 단어로 대체한 것처럼 느껴집니다.&lt;/p&gt;
&lt;p&gt;프로그램은 코드(code)입니다. 아무리 많은 기술과 기법을 사용했어도 그 마지막 결과물은 결국 코드입니다. 그래서 저한테 프로그래밍(programming)이란 곧 코딩(coding)을 의미합니다. 또한 코딩은 머릿속 추상적인 개념이 구체화되는 과정이기도 합니다.  언제부터 소프트웨어 공학이 프로그래밍에서 설계와 구현(코딩)을  구분했는지는 모르지만, 제게는 코딩이 곧 프로그래밍의 중심입니다. 나머지는 코딩을 더 잘하기 위해 필요한 도구이며 과정일 뿐입니다. (물론 디버깅도 프로그래밍의 큰 과정 중 하나입니다. 정확하게 요구사항을 분석하는 것, 코딩을 시작하기 위한 기본 개념을 선택하고 설계하는 것 등도 당연히 프로그래머의 일입니다. 하지만, 이 글에서는 코딩이 주인공이라서 다른 부분은 과소평가 할테니 소프트웨어 공학 하시는 분은 태클 걸지 말아 주시길 :)&lt;/p&gt;
&lt;p&gt;아무튼, 댓가를 받고 업으로 프로그래밍을 하기 시작한지 약 15년 즈음 되는 지금, 언젠가부터 현업 프로그래머 중에서는 선배보다 후배들이 많아지다 보니, 가끔 술자리에서 실력도 안되는 제게 어려운 질문을 하는 후배들에게 항상 취중에 중언부언하던 개인적인 생각을, (역시 취중에) 대략 세 가지로 &lt;strong&gt;감히&lt;/strong&gt; 정리해 보았습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;좋은 코드를 작성하려면 다른 사람의 코드를 많이 읽어야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;글 쓰는 사람이 책 한 권을 쓰기 위해 열 배 백 배 이상의 독서를 하듯이, 프로그래머도 많은 코드를 읽어야 합니다.  좋은 코드에서는 배움을 얻고, 나쁜 코드에서는 금해야 할 게 무엇인지 알게 됩니다. 그런데, 유독 프로그래머는 다른 사람의 코드를 읽는 일에 인색합니다. 심지어 매뉴얼이나 API 문서에 나온 예제 코드도 읽지 않고, 동료가 작성한 코드도 읽지 않으며 오직 자신이 만든 코드만 읽고 또 읽습니다.&lt;/p&gt;
&lt;p&gt;모든 프로그래밍은 모방에서 시작합니다. 우리 용어로 하면 카피 앤 페이스트(copy &amp;amp; paste) 쯤 되겠지요. 하지만, 보는 만큼 아는 만큼 프로그래밍하게 됩니다. 경험이 아무리 많아도 새로운 지식이 없으면 결국 아는 한도 내에서 똑같은 틀의 코드만 계속 만들 뿐, 나아지는 건 없습니다.&lt;/p&gt;
&lt;p&gt;참고로, 저는 이런 관점에서 오픈소스 프로젝트를 지지하는 편입니다. 프로그래머를 성장시키는 가장 빠른 방법 중 하나는 오픈소스 프로젝트에 참여시키는 것이라는 말도 공감합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;좋은 코드를 작성하려면 많이 쓰고 자주 고쳐야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;하나의 기능을 구현하기 위해 수없이 많은 시행착오를 겪어야 결국 좋은 코드가 나옵니다. 글 쓰는 사람 예를 다시 들어보면, 한 번 쓴 글을 바로 내보내는 경우는 없습니다. 수없이 다시 쓰고 퇴고의 과정을 거쳐, 심지어 쉼표 하나 마침표 하나까지 고치고 또 고칩니다. 프로그램은 더 고약한 놈이라, 릴리스 이후에도 언제든 다시 손을 대야 합니다.&lt;/p&gt;
&lt;p&gt;저는 프로그래밍할때 가장 중요한 부분부터 간단하게 코딩하는 습관이 있습니다. 똑똑한 편이 아니라서, 대부분의 개념은 코딩하면서 구체화되는 경우가 대부분입니다. 변수 이름부터 구조체, API 방식, 동작 알고리즘 모두 계속 코딩하고 테스트하면서 계속 바뀝니다. (보통 다른 사람의 다섯 배 정도는 코드를 다시 고쳐 쓴다고 자부합니다. 자랑은 아닌데&amp;hellip;) 그래서 저는 처음에 만든 코드 형태가 그대로 있는 경우가 별로 없습니다.&lt;/p&gt;
&lt;p&gt;프로그래머는 결국 코드로 자신의 생각을 표현해야 하고, 자신의 주장을 뒷받침해야 합니다. 코드의 가독성(readability)을 높이기 위해 노력해야 하는 이유이기도 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;쉽게 레벨업 되려는 욕심은 버려야 하지만, 꾸준이 노력하는 습관은 욕심내야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;프로그래머는 알아야 할 게 너무 많습니다. 새 언어, 라이브러리, 디자인패턴, 기술 , 개발 도구, 플랫폼,  코딩 스타일, 디버깅 기법&amp;hellip; 거기에다 글도 잘써야 하고, 영어도 잘해야 하고, 말도 잘해야 하고&amp;hellip; 알면 알수록 모르는 게 더 많다는 걸 느끼고 기본 개념이 중요하다는 걸 깨닫게 됩니다. 그리고 좌절과 무기력도 동시에 느낍니다. 이럴때 대부분은 머리가 나빠서, 혹은 소질이 없는 것 같다고 핑계를 대는데&amp;hellip; 제 경험엔 모두 핑계일 뿐, 노력하지 않고 게으르거나 또는 투자를 하지 않고 바라기만 하기 때문입니다.&lt;/p&gt;
&lt;p&gt;제가 자주 인용하는 표현이지만, 강물에 아무리 돌을 던져도 티가 나지 않습니다. 하지만, 좌절하지 않고 계속 던지다 보면 물 밑에서 돌무더기는 계속 쌓이게 되고, 어느 순간 수면위로 올라오게 되면, 그때부터는 한 개만 던져도 바로 쌓이는 게 티가 납니다. 프로그래밍도 마찬가지라, 어느 순간 흩어져있던 여러 가지가 한 가지로 연결되면서 깨닫게 되는 순간이 있습니다. 이미 알고 있던 지식의 다른 관점, 다른 개념도 조금씩 보이기 시작합니다. 그리고 그 후부터는 조금만 노력해도 다른 사람에 비해 쉽게 이해할 수 있게 됩니다.하지만, 대부분 이 단계까지 오기 전에 포기하거나, 자기합리화를 선택합니다.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;여기까지 적다보니, 역시나 대가들이 했던 말을 앵무새처럼 되풀이하고 있군요. 아, 몇 시간 동안 적은 글 버리기는 아까워 그냥 내버려 두니, 저보다 나중에 시작하시는 분들에게 조금이라도 도움이 되길 바랍니다. 그리고, 지극히 개인적인 생각이라 나중엔 바뀔 수도 있고 논리적 오류도 많을 테지만, 개인 블로그에 돈 받지 않고 적는 글이니, 이렇게 생각하는 사람도 있구나 하고 넘어가 주시길~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Review Board 소개</title>
      <link>/2009/02/03/review-board/</link>
      <pubDate>Tue, 03 Feb 2009 00:00:00 +0000</pubDate>
      <guid>/2009/02/03/review-board/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://www.review-board.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Review Board&lt;/a&gt;
는 코드 리뷰(Code Reviews)를 도와주는 웹 기반 소프트웨어입니다. 
&lt;a href=&#34;http://www.vmware.com/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;VMware&lt;/a&gt;
 개발팀에서 사용하는 걸 외부로 공개한 것 같은데, 파이썬으로 작성되었고, MIT 라이센스를 따릅니다.&lt;/p&gt;
&lt;p&gt;리뷰 보드는 커밋전(pre-commit) / 커밋후(post-commit) 리뷰를 지원합니다. 커밋전 리뷰란 공용 저장소나 안정 브랜치(master / trunk) 같은 주 저장소에 체크인 되기 전에 검토(review)하는 것을 말합니다. 검토자가 사인하기 전까지 코드는 커밋되지 않게 때문에 제품 안정성을 얻는데 도움을 줍니다. 커밋후 리뷰는 일단 저장소에 커밋된 이후 검토하는 방식입니다. 구조가 많이 변경되거나 여러 사람이 함께 코드를 검토하면서 작업을 해야하는 개발 브랜치에 적합한 방법입니다.&lt;/p&gt;
&lt;p&gt;리뷰 과정에서는 단순히 검토만 받는게 아니라 서로 의견을 주고 받고, 이를 근거로 커밋할 코드를 다시 업데이트하는 작업이 반복됩니다. 마지막에 코드가 검토 과정을 통과하면 코드는 자동으로 저장소에 커밋됩니다. 기본 개념은 이러하더라도 기존 이메일과 버그트랙킹 소프트웨어만으로는 무언가 부족한 부분을 채워주어야 하는데, 실제로 데모 사이트에 접속해서 사용해 보면 코드 변경 사항(diff) 라인 단위로 쉽게 의견(comment)을 달 수 있고, 이 모든 과정이 기록으로 남는 점이 매우 실용적임을 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;아직 알파 1 버전이고 서브버전과 Perforce 등만 지원하지만, 조만간 정식 버전이 나오면 개발팀 프로세스에 한 번 적용해 보고 싶은 생각이 들게 합니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Presenter First 개발</title>
      <link>/2008/12/17/presenter-first-development/</link>
      <pubDate>Wed, 17 Dec 2008 00:00:00 +0000</pubDate>
      <guid>/2008/12/17/presenter-first-development/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://en.wikipedia.org/wiki/Presenter_First&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;프리젠터 먼저하기(Presenter First)&lt;/a&gt;
는
&lt;a href=&#34;http://en.wikipedia.org/wiki/Model_View_Presenter&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;모델-뷰-프리젠터(MVP)&lt;/a&gt;
 디자인 패턴과 테스트 주도 개발(TDD) 등의 아이디어를 버무린  소프트웨어 개발 방법론입니다. 이에 대해 설명하기에 앞서 먼저 모델-뷰-컨트롤러(MVC) 패턴과 비교하여 모델-뷰-프리젠터(MVP) 개념을 정리하면 대략 다음과 같습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;모델(Model)&lt;/strong&gt; : 실제 다루고자 하는 데이터 읽기 / 쓰기. 관찰자(Observer) 패턴처럼 이벤트를 제공하면 더 좋습니다. MVC 패턴에서는 모델이 실제 데이터 뿐 아니라 사용자 인터페이스(View)와 연관된 데이터까지 처리하지만, MVP 패턴에서 모델은 순수하게 데이터만 처리합니다. 즉, 모델은 뷰나 프리젠터(사용자 인터페이스)에 대해서는 알 필요도 없고 알아서도 안됩니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;뷰(View)&lt;/strong&gt; : 사용자 인터페이스. 데이터 표시 뿐 아니라 사용자 입력까지 모두 처리합니다. MVC 패턴에서는 사용자 입력을 컨트롤러(Controller)에서 처리하지만 MVP 패턴에서는 뷰가 모두 처리합니다. 사용자 이벤트는 프리젠터에게 전달합니다. (관찰자 패턴을 사용합니다) 모델의 데이터가 변경되었다는 이벤트가 발생하면 데이터를 표시합니다. 하지만 초기 MVP 패턴과 달리 요즘에는 뷰와 모델간의 의존성까지 아예 없애버리고, 프리젠터가 디스플레이까지 제어합니다. 프리젠터 먼저하기 방법론에서 특히 이 방식을 이용합니다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;프리젠터(Presenter)&lt;/strong&gt; : 뷰가 전달한 사용자 이벤트에 기반하여 시나리오에 따라 모델 데이터를 조작합니다. MVC 패턴에서 어플리케이션 역할을 하는 부분이며, 사용자 요구사항이 변경되거나 로직이 변경되면 수정이 되어야 하는 부분이기도 합니다. 결과적으로, 모델과 뷰에 대해 알고있는 건 오직 프리젠터 뿐이고, 모델과 뷰는 프리젠터를 모릅니다. 뷰는 모델에 대해 알 수도 있지만, 프리젠터 먼저하기 방법론에서는 이 의존성도 없애버립니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;뷰를 오버로딩 가능한 추상 인터페이스로 만들고 프리젠터가 이 인터페이스를 사용하도록 하면, 뷰를 구현한(implementation) 객체는 플러그인처럼 교체 가능합니다. 즉, 뷰는 어쩔 수 없이 플랫폼이나 GUI 라이브러리에 의존하게 구현해야 하지만 모델과 프리젠터, 추상 뷰는 이와 상관없이 구현할 수 있습니다. 따라서 쉽게 이식 가능할 뿐 이나라, 하나의 데이터에 대해 여러가지 모양의 사용자 인터페이스를 지원하는 소프트웨어 개발이 쉬워집니다. 물론 모델 역시 추상 인터페이스로 만들고 같은 방식으로 프리젠터가 이 인터페이스를 사용하도록 하면 모델 구현 역시 쉽게 교체 가능한 구조가 됩니다. 그리고, 이러한 추상화는 테스트 주도 개발에도 응용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;결과적으로, 프리젠터 먼저하기 방법론에서 모델-뷰-프리젠터의 관계는 다음 그림과 같습니다.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; [M]  -----&amp;gt;    [P]    &amp;lt;----- [V]
Model &amp;lt;===== Presenter =====&amp;gt; View

  (---&amp;gt; : Events, ===&amp;gt; : Messages)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;모델과 뷰는 프리젠터에게 이벤트를 전달하고, 프리젠터는 모델과 객체를 제어하기 위한 메시지를 전달합니다. 즉, 프리젠터만 모델과 뷰에 대해 알고 있을 뿐, 모델과 뷰는 다른 구성 요소를 알지 못합니다. 뷰는 비즈니스 로직에서 완전히 분리하고 모든 로직은 프리젠터에서 처리합니다.  뷰 인터페이스는 가능한 얇고 단순해야 하고, 이상적인 경우 사용자 이벤트를 그대로 프리젠터에게 전달하고, 표시할 내용을 읽고 쓰는 동작만 해야 합니다.&lt;/p&gt;
&lt;p&gt;프리젠터에게 전달하는 이벤트는 비즈니스 로직에서 사용하는 용어를 사용하여 전달되어야 합니다. 엔지니어 관점의 이벤트가 아닌 사용자 관점의 이벤트를 사용해야 한다는 점입니다. 예를 들어, 비즈니스 로직이 &amp;ldquo;추가 버튼을 누르면 텍스트 입력 내용이 할일목록에 추가되어야 함&amp;quot;이라면, 뷰는 &amp;ldquo;save-button-clicked&amp;rdquo; 이벤트가 정의되어야 하고, 프리젠터는 이 이벤트가 발생했을때 호출할 핸들러를 연결합니다. 핸들러에서는 뷰의 &amp;ldquo;get_text()&amp;rdquo; 함수를 호출하여 텍스트 내용을 얻은 뒤 모델의 &amp;ldquo;add_to_list()&amp;rdquo; 함수를 이용해 모델에 추가합니다. 여기서 만일 버튼 대신 예쁜 아이콘으로 뷰가 달라졌다고 이벤트 이름을 &amp;ldquo;save-image-clicked&amp;quot;로 변경하거나 새로운 이벤트를 추가하면 안됩니다. 사용자가 팝업 메뉴를 원해 메뉴 선택을 이용해 동일한 처리를 하게 되더라도 &amp;ldquo;save-menu-activated&amp;quot;로 변경하거나 새로 추가할 필요도 없습니다.  또는 실제로 버튼의 &amp;ldquo;clicked&amp;rdquo; 이벤트가 아닌 &amp;ldquo;button-pressed&amp;rdquo; 이벤트를 사용하더라도 프리젠터에게 전달하는 이벤트 이름은 변경하면 안된다는 점이 중요합니다.&lt;/p&gt;
&lt;p&gt;위 예를 조금 더 이어보면, 모델의 &amp;ldquo;add_to_list()&amp;rdquo; 함수 내에서는 데이터에 새로운 텍스트 내용을 추가한 뒤 내용이 변경되었음을 알리는 &amp;ldquo;list-changed&amp;rdquo; 이벤트를 발생하고, 프리젠터에서 미리 이 이벤트에 연결한 핸들러는 모델의 &amp;ldquo;get_list()&amp;rdquo; 함수를 호출해 목록을 얻은 뒤, 뷰의 &amp;ldquo;set_list()&amp;rdquo; 함수를 이용해 변경된 데이터를 화면에 표시합니다. 여기까지 설명에서 중요한 점은, 모든 변경사항은 관찰자 패턴처럼 이벤트를 이용해 전달한다는 점이고, 프리젠터가 모델과 뷰 간의 중재 작업을 통해 비즈니스 로직을 완성한다는 점입니다. 만일 할일 목록과 할 일 목록 편집 화면이 분리되어 구현되어 있을 경우 서로 의존성을 가지고 싶지 않을 수도 있습니다. 이런 경우 두 모델을 중재(coordinator)해서 연결하는 새로운 프리젠터, 혹은 어플리케이션 객체를 새로 만들어 이벤트 처리를 하면 두 모델간의 의존성도 사라질 수 있습니다.&lt;/p&gt;
&lt;p&gt;프리젠터 먼저하기 방법론은 지금까지 설명한 MVP 패턴으로 프로그램을 할때 프리젠터 객체를 가장 먼저 코딩합니다. 어차피 모델과 뷰 객체의 인터페이스(API)와 이벤트는 프리젠터 객체 구현이 마무리 될때까지 계속 수정되므로, 모델과 뷰는 가짜 객체(Mock Object)로 구현합니다. 가짜 객체라고 해도 프리젠터가 원하는 작업은 실제로 수행하는 것처럼 동작해야 하므로 가능한 단순한 자료구조를 이용해야 합니다.  이렇게 해서 비즈니스 로직을 모두 프리젠터에 구현한 뒤에, 모델과 뷰를 실제로 데이터 베이스에 접근하거나 파일에 읽고 쓰든, GTK+ 위젯 라이브러리를 이용하거나 콘솔 GUI를 이용하든 해서 구현하면 됩니다.&lt;/p&gt;
&lt;p&gt;하지만 유닛 테스트 도구를 사용하지 않는다면 뷰 없이 프리젠터 동작을 확인하는 코드를 만들기는 조금 불편합니다. 이런 경우 뷰를 가짜 객체 방식으로 만들더라도 어느 정도 기본적인 사용자 입출력이 가능하도록 만들면서 해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;참고한 자료&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.wildcrest.com/Potel/Portfolio/mvp.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;MVP: Model-View-Presenter, The Taligent Programming Model for C++ and Java&amp;rdquo;&lt;/a&gt;
, Mike Potel, 1996&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://www.object-arts.com/papers/TwistingTheTriad.PDF&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;TWISTING THE TRIAD, The evolution of the Dolphin Smalltalk MVP application framework&amp;rdquo;&lt;/a&gt;
, Andy Bower, Blair McGlashan, Tutorial Paper for ESUG 2000&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://atomicobject.com/files/PresenterFirstAgile2006.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;Presenter First: Organizing Complex GUI Applications for Test-Drivn Development&amp;rdquo;&lt;/a&gt;
, agile, pp. 276-288, AGILE 2006 (AGILE&amp;rsquo;06), 2006.&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;http://atomicobject.com/files/BigComplexTested_Feb07.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&amp;ldquo;Big, Complex, and Tested? Just Say &amp;lsquo;When&amp;rsquo;&amp;quot;&lt;/a&gt;
, Better Software Magazine February, 2007&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>10 Minute Guide to Project Management</title>
      <link>/2006/04/11/10-minute-guide-to-project-management/</link>
      <pubDate>Tue, 11 Apr 2006 00:00:00 +0000</pubDate>
      <guid>/2006/04/11/10-minute-guide-to-project-management/</guid>
      <description>&lt;p&gt;
&lt;a href=&#34;http://www.amazon.com/gp/product/0028639669/104-9221248-6347126&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;프로젝트 관리 10분 가이드&lt;/a&gt;
라는 책을 읽고 느낀 점은 대학교때 소프트웨어 공학 개론 수업 내용과 거의 흡사하다는 점 뿐일까. 책에서 말하는 내용 중 몇 가지만 정리해 둔다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;프로젝트 계획의 기본은 정확한 목표, 데드라인, 자원 산출이다.&lt;/li&gt;
&lt;li&gt;정확한 목표를 설정한다. 세부적인 결과물과 성과를 정의한다.&lt;/li&gt;
&lt;li&gt;가능한 자세한 작업 명세 구조를 추출한다. 하지만, 너무 자세하면 안되고, 담당자에게 어느 정도 위임이 가능하면서 관리자가 반드시 확인해야 하는 수준의 작업으로 분류한다.&lt;/li&gt;
&lt;li&gt;프로젝트 중간 중간 이정표(milestone)를 두고, 각 단계별 산출 결과물을 명확하게 명시한다. (코드, 문서, 장비 구성 등)&lt;/li&gt;
&lt;li&gt;계획 수립 단계에 팀원을 참여시킨다.&lt;/li&gt;
&lt;li&gt;프로젝트 스케쥴은 여러가지 변수에 의해 수시로 변동된다. 관리자는 이러한 변화를 항상 감지하고, 대처하고 계획을 수정한다.&lt;/li&gt;
&lt;li&gt;프로젝트 회의록 / 일지를 작성하여 유지한다.&lt;/li&gt;
&lt;li&gt;GANTT 챠트에서는 작업의 계획된 시작/끝 정보와 실제로 실행된 시작/끝 정보가 함께 유지되어야 한다.&lt;/li&gt;
&lt;li&gt;PERT/CPM 챠트를 이용하여 중대경로(critical path)를 추출하면, 예외처리나 우선순위 변경 작업이 용이해진다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>중국집 주방장과 소설가, 프로그래머</title>
      <link>/2006/01/20/cookers-writers-and-programmers/</link>
      <pubDate>Fri, 20 Jan 2006 00:00:00 +0000</pubDate>
      <guid>/2006/01/20/cookers-writers-and-programmers/</guid>
      <description>&lt;p&gt;언젠가 &amp;lsquo;유림&#39;이라는 책을 소개하는 TV 프로그램에 나온 작가 최인호 왈:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;우리 나라 교육은 나은 사람 하나를 만들기 위해 아흔 아홉을 희생한다. 백 명 모두를 나은 사람으로 만드는 것은 불가능하다. 하지만 모두를 된 사람을 만드는 교육은 가능하다. &amp;lsquo;나은 사람&#39;보다 &amp;lsquo;된 사람&#39;이 더 행복하다는 사실은 진실이다.&lt;/li&gt;
&lt;li&gt;원래 중국집 주방장과 소설가는 이런 자리에 나오면 안된다. 짜장면을 맛있게 먹었으면 그만이지 주방장을 불러 이러쿵 저러쿵 설명하게 하는 것은 별로 좋은 일이 아니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;프로그래머도 마찬가지가 아닐까? 프로그래머는 자신이 설계하고 구현한 프로그램을 사용자가 편하고 유용하게 사용하면 그만이다. 원칙적으로 프로그래머가 다른 프로그래머와 프로그램에 대해 얘기해야 하는 방법은 자신의 코드를 통해서다.&lt;/p&gt;
&lt;p&gt;하지만 우리는 이미 프로그래머가 아티스트보다는 엔지니어로서, 때로는 웅변가나 저술가로서 역할을 더 많이 해야 인정을 받는 세상에 살고 있다. 프로그램도 잘 짜야 하고, 말도 잘해야 되고, 글도 잘 써야 되고, 영어도 잘 해야 되고, 사람들도 잘 이끌어야 하고&amp;hellip;&lt;/p&gt;
&lt;p&gt;카스탈리엔은 점점 멀어져가고 있다.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
