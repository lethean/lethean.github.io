[{"authors":null,"categories":null,"content":"2001년부터 지금 회사에서 직장 생활을 시작해서 회사의 흥망성쇠를 함께 한 지 벌써 20년이 되었다는 사실에 놀란 이유는, 여전히 하루하루가, 일주일이, 일 년이 금방 지나가기 때문인 것 같습니다.\n스스로가 처세에 영민하지 못해 어떤 식으로든 끝을 보자는 각오로 힘든 시기를 견뎌왔지만, 함께한 분들이 있어서 그리 어렵지는 않았습니다. 다행히도 최근 더 많은 좋은 분들과 함께 일하게 되면서 격세지감을 느낄 정도로 회사가 다시 좋아지는 분위기라서 기분이 좋은 것도 숨길 수 없습니다.\n하지만 아직 부족함이 많고 앞으로도 할 일이 많다는 사실을 잘 알고 있기 때문에 앞으로도 계속 겸손해야 합니다. 거창한 큰 그림과 원대한 계획도 중요하지만, 그때그때 하나하나 문제를 해결하고, 조금씩 개선하고 부족함을 채워 나가는 노력이 지금까지 이어질 수 있는 원동력 중에 하나라고 생각하기 때문입니다.\n마지막으로, 제가 가끔 술자리에서 얘기하는, 직장 생활의 좌우명 중 하나를 말씀드리고 인사말을 마무리합니다.\n일로만 스트레스받고, 사람에게 스트레스받지 말자!\n감사합니다.\n","date":1623715200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1623715200,"objectID":"da7a006ccdb9a144cfd248c6bd3f638a","permalink":"https://lethean.github.io/2021/06/15/20-years-in-emstone/","publishdate":"2021-06-15T00:00:00Z","relpermalink":"/2021/06/15/20-years-in-emstone/","section":"post","summary":"2001년부터 지금 회사에서 직장 생활을 시작해서 회사의 흥망성쇠를 함께 한 지 벌써 20년이 되었다는 사실에 놀란 이유는, 여전히 하루하루가, 일주일이, 일 년이","tags":null,"title":"20년 근속 기념 인사","type":"post"},{"authors":null,"categories":null,"content":"   Flutter: 모바일, 웹, 임베디드 및 데스크톱을 위한 Portable UI 프레임워크 구글이 Flutter 프레임워크를 iOS / 안드로이드뿐 아니라 데스크탑 / 웹까지 지원하는 도구로 발전시켰다. 구글이 차세대 운영체제로 개발 중인 Fuchsia OS의 공식 UI 도구 로 사용하기 전에 충분한 개발자와 사용자를 확보하기 위한 행보로도 보이지만, 어찌 되었든 성능 좋고 사용하기 편한 개발 도구가 오픈소스로 제공된다는 점은 분명히 개발자에게는 좋은 일이다.\n   Clear Linux Is Beginning To Make Strides In The Industry From Alibaba To MontaVista  인텔 CPU에서 클리어 리눅스가 최고의 성능 을 낸다는 건 이미 기정사실화된 것 같은데 마이크로소프트, 알리바바, 몬타비스타 등과 같은 IT 대기업에서 채용하기 시작했다는 점은 시사하는 바가 크다.\n   Rufus 윈도우 운영체제에서 부팅 가능한 USB를 만드는 데 사용하는 프로그램. 오픈소스이면서 속도가 빠르고 호환성이 좋아서 요즘 대세로 사용하는 프로그램인 것 같다.\n   개방형 사무실의 비밀 외국의 유행이 처음에는 근사해 보이지만 그들에게도 시행착오의 한 단면일 뿐이다. 참고는 하더라도, 우리 역시 시행착오를 거치면서 우리에게 맞는 걸 조금씩 찾아가야 한다.\n   납치 사건부터 축구까지, 하이네켄 이야기 어쩐지 맛있더라. 하지만 요즘은 국내 맥주도 맛있다.\n  ","date":1559001600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1559001600,"objectID":"f136106e1edf8b456f43138c6241eb68","permalink":"https://lethean.github.io/2019/05/28/reading-2019-05-28/","publishdate":"2019-05-28T00:00:00Z","relpermalink":"/2019/05/28/reading-2019-05-28/","section":"post","summary":"Flutter: 모바일, 웹, 임베디드 및 데스크톱을 위한 Portable UI 프레임워크 구글이 Flutter 프레임워크를 iOS / 안드로이드뿐 아니라 데스크탑 / 웹까지 지원하는 도구로 발전시켰다. 구글","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2019-05-28)","type":"post"},{"authors":null,"categories":null,"content":"   프로그래밍의 황금률은? 행동하지 않는 양심은 악의 편이라는 말도 있지만, 이런 좋은 내용은 알아도 사실 따라 하기 어렵다. 다만 하나만 덧붙이자면, 시작할 때는 최대한 단순하게 만들어야 한다. 나중에 어떻게 변할지 모르는데 미리 알고 확장성 있게 설계한다는 건 모순이다.\n   Rust is not a good C replacement  월등한 성능과 언어적 안정성, C로 작성된 모듈과 쉽게 합칠 수 있다는 장점 때문에 Rust를 실무에 도입하고 싶지만 가장 큰 난관은 배우기 쉽지 않다는 점이다. 게다가 언어 자체가 아직도 계속 변하고 있다. 이 글의 통계에 따르면 해마다 15개의 새 기능이 Rust에 추가된다. (참고로 C++ 11.3개, Go 2개, C 0.73개) 언어 설계자들의 패러다임의 차이일 수도 있지만, 문제를 해결하기 위해 언어에 기능을 추가하는 C++, Rust와 달리 C, Go는 라이브러리나 모듈을 추가한다. 그래서 이 글의 결론처럼, 나처럼 C++을 안 좋아하는 사람에게 배우기 쉬운 Go 언어는 매력적이다. 마찬가지로 \u0026ldquo;Rust vs. Go\u0026rdquo; 글을 쓴 유명한 프로그래머가 Rust에서 Go로 넘어간 이유에도 격하게 공감한다. 그런데도 Rust에 대한 미련을 버리지 못하는 이유는 해커 뉴스 댓글 에도 언급되어 있지만, Rust의 장점이자 Go의 단점으로 지적한 멀티쓰레드 디버깅 이 얼마나 골치 아픈지 알기 때문이다. 게다가 Go의 가비지 컬렉션은 C에서 Go 함수를 호출하기 어렵게 만들어 당장 기존 프로젝트에 적용해볼 수도 없다. 흠\u0026hellip;\n   Remix Icon  Font Awesome 같은 무료 아이콘 덕분에 그래픽 디자이너의 지원을 받을 수 없는 영세 개발자도 깔끔한 제품을 만들 수 있게 되었다. 하지만 Font Awesome 5.0 버전부터 Free / Pro 버전이 분리되고 월 사용료를 지불해야 5000개 이상의 Pro 아이콘을 사용할 수 있다. 덕분에 계속 대안을 찾는 중에 발견한 중국산(?) 고품질 무료 아이콘이다. 전반적으로 요즘에 유행하는 간결하고 미니멀한 스타일의 아이콘 1400개를 무료로 사용할 수 있다. 다른 이야기지만, 여유가 있는 우리 IT 기업들도 무료 한글 글꼴만 배포하지 말고 국내 사정에 맞는 아이콘 폰트도 무료로 공유해 주면 좋겠다.\n   업무 메일, 잘하고 있나요 첨부 파일을 보낼 때 PDF 파일을 함께 보내고 반드시 메일을 다 쓰고 마지막에 수신인 적기\n  ","date":1555977600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1555977600,"objectID":"a4560708ae0e37d2846c7a50ab3d3f04","permalink":"https://lethean.github.io/2019/04/23/reading-2019-04-23/","publishdate":"2019-04-23T00:00:00Z","relpermalink":"/2019/04/23/reading-2019-04-23/","section":"post","summary":"프로그래밍의 황금률은? 행동하지 않는 양심은 악의 편이라는 말도 있지만, 이런 좋은 내용은 알아도 사실 따라 하기 어렵다. 다만 하나만 덧붙이자면, 시작할 때는 최대","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2019-04-23)","type":"post"},{"authors":null,"categories":null,"content":"   소프트웨어를 모르는 대한민국 기업의 위기 마이크로소프트가 깃헙(github)을 인수했다는 뉴스의 이면을 들여다보면서 우리나라 기업들이 소프트웨어 개발을 어떤 관점으로 바라보는지 자세히 설명하고 있다.\n개발 방법론과 소프트웨어 공학이라는 미명 아래 앞으로도 얼마나 더 많은 헛돈이 쓰일지 모르겠다. 하지만 집을 짓는 건축 분야와 기계를 다루는 전자 통신 분야에서 넘어온 수많은 방법론을 배웠지만, 지금은 마치 오래된 유물처럼 느껴진다.\n   종단 간 암호화 파일 공유 서비스 ‘파이어폭스 센드’ 출시   파이어폭스 센드 를 이용하면, 프로그램을 따로 설치하지 않아도 웹 브라우저에서 대용량 파일을 쉽게 공유할 수 있다.\n사용 방법은 간단하다. 파일을 보내는 사람이 파이어폭스 센드 웹사이트에 들어가 파일을 올리면 다운로드 링크가 생성된다. 이 과정에서 링크 유효 기간을 설정하거나 총 다운로드 횟수를 설정할 수 있다. 비밀번호를 설정할 수도 있다. 기간은 5분부터 최대 7일까지, 다운로드 횟수는 1회부터 최대 100회까지 제한할 수 있다.\n이후 생성된 링크를 파일을 받는 사람에게 보내주면 된다. 해당 링크를 클릭하면 파일 다운로드가 시작된다. 파일을 받는 사람은 파이어폭스 계정이 필요 없으며, 별도 로그인 과정을 거치지 않는다.\n사용자는 최대 1GB까지 웹브라우저로 파일을 전송할 수 있다. 파이어폭스 계정이 있으면, 최대 2.5GB까지 전송할 수 있다. 설정한 기간이 만료되면 자동으로 파일 공유 링크가 소멸한다.\n 앞으로 대용량 파일을 메일에 첨부하기 위한 고생이 많이 줄어들 것 같다.\n   7 Firefox Add-Ons Every English Learner Should Make Use Of 회사에서 사용하는 리눅스 데스크톱 장비에서 오랫동안 기본 브라우저로 파이어폭스를 사용했다. 적은 메모리 사용량과 사용자 편의성은 가장 내게 맞는 것 같고, 요즘은 성능도 조금씩 다른 브라우저만큼 좋아지고 있어서 불만이 없었는데, 구글 문서 같은 사이트에서 한글 입력이 밀리거나 느려지는 문제 때문에 용도에 따라 가끔 구글 크롬을 사용하기도 한다.\n이 사이트에서 소개하는 영어 공부 관련 확장 기능 중에서는 Textly.AI , Google Translate 등을 사용한다. 그 외에도 Copy as Markdown , Naver English Dictionary , Vue.js devtools 등을 사용하고 있다.\n   Automatic Calling System using Raspberry Pi 이 글의 출처 블로그는 라즈베리 파이를 이용해 만든 여러 장비와 아이디어를 소개하는데, 이 글처럼 \u0026lsquo;나도 한 번 만들어볼까?\u0026rsquo; 하는 생각이 들게 하는 아이템을 가끔 발견한다.\n   일상 속의 3D 프린팅 나도 한 번 갖고 놀고 싶다. 하지만 언제나 그렇듯이…\n  ","date":1553212800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1553212800,"objectID":"506b70161a617d2d4eefdb7400ed4c19","permalink":"https://lethean.github.io/2019/03/22/reading-2019-03-22/","publishdate":"2019-03-22T00:00:00Z","relpermalink":"/2019/03/22/reading-2019-03-22/","section":"post","summary":"소프트웨어를 모르는 대한민국 기업의 위기 마이크로소프트가 깃헙(github)을 인수했다는 뉴스의 이면을 들여다보면서 우리나라 기업들이 소프트웨어 개발을","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2019-03-22)","type":"post"},{"authors":null,"categories":null,"content":"   My personal favorite Visual Studio Code extensions 아주 오랫동안 VI, Emacs 등을 사용했는데, 그래서 지금도 급할 때는 습관적으로 사용하지만, Sublime Text를 알게 되어 잠깐 사용하다가 몇 년 전부터 VSCode를 사용한다. 여기 소개된 것처럼 확장 기능은 많지만, 기본 기능이 너무 좋아서 언어별 확장 기능만 추가해서 사용하는 것 같다.\n   타다 시스템 아키텍처 요즘은 우리나라 개발자들도 현재 서비스 중이거나 개발 중인 시스템의 아키텍처를 공개하는 경우가 많다. 흐뭇하기도 하고 부럽기도 하고\u0026hellip;\n   윈도우 오픈 소스 한글 입력기를 만들었습니다 생각해보면 이런 분들의 노고 때문에 요즘은 리눅스 한글 관련 불편함이 거의 없어진 셈이다. 여전히 오픈 소스와 코딩에 대한 열정이 넘치는 글쓴이의 모습도 부럽다.\n   한글 인코딩과 자바스크립트 이런 문제에 부딪혔을 때 과연 나라면 어떻게 했을까? 아마도 쉽게 구현할 수 있는 다른 기능으로 대체하고 그냥 넘어가지 않았을까.\n   Learning Rust in 2019 언젠가는 실무에 Rust 언어를 도입해야지 생각만 하면서 벌써 몇 년이 지나갔다. 뭐, 언젠가는 함께할 수 있겠지.\n  ","date":1551052800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1551052800,"objectID":"9c0eacc1626aa307f318aec1ea2bb543","permalink":"https://lethean.github.io/2019/02/25/reading-2019-02-25/","publishdate":"2019-02-25T00:00:00Z","relpermalink":"/2019/02/25/reading-2019-02-25/","section":"post","summary":"My personal favorite Visual Studio Code extensions 아주 오랫동안 VI, Emacs 등을 사용했는데, 그래서 지금도 급할 때는 습관적으로 사용하지만, Sublime Text를 알게 되어 잠깐 사용하다가 몇 년 전부터 VSCo","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2019-02-25)","type":"post"},{"authors":null,"categories":null,"content":"   Electron으로 데스크톱 앱을 개발한 경험 조만간 익숙해질 것 같은 Electron 관련 시행착오를 조금은 덜어줄 것 같다.\n   동작하게 만들고, 제대로 만들고, 빠르게 만든다 소프트웨어 개발의 기본 원칙이라는 걸 잘 알면서도 잘 안되는, 욕심 때문에 때로는 무지 때문에\u0026hellip;\n   소프트웨어 엔지니어들이 읽기 어려운 코드를 만드는 이유는? 과연 카스탈리엔은 존재하는가?\n   나이 든 개발자는 무엇으로 살아야 할까? 회사 생활에만 매몰되지 말고, 내 서비스를 만들어서 노년의 자산을 조금씩 늘리라는데\u0026hellip; 우리 회사 개발자는 읽지 못하게 해야겠다.\n   효과적인 소프트웨어 문서를 적는 방법 틀린 말은 없지만, 코딩과 마찬가지로 좋은 습관이 들 때까지 계속 많이 적는 노력이 제일 중요하지 않을까.\n   주택 임차보증금 제때 돌려주지 않을 때 이런 일이 발생하지 않기를 바라지만 요즘 부동산 시장의 흐름을 보면 미리 알아두어야 할 것 같다.\n   압생트, 예술적인 너무나 예술적인  언제나 취해 있어야 한다. 모든 것이 거기에 있다. 그것이 유일한 문제다.\n   ","date":1550448000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1550448000,"objectID":"173750fbee17120768a9bb1bfe97a6f3","permalink":"https://lethean.github.io/2019/02/18/reading-2019-02-18/","publishdate":"2019-02-18T00:00:00Z","relpermalink":"/2019/02/18/reading-2019-02-18/","section":"post","summary":"Electron으로 데스크톱 앱을 개발한 경험 조만간 익숙해질 것 같은 Electron 관련 시행착오를 조금은 덜어줄 것 같다. 동작하게 만들고, 제대로 만들고, 빠르게 만든다","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2019-02-18)","type":"post"},{"authors":null,"categories":null,"content":"   손짓으로 기기 제어… 구글 ‘프로젝트 솔리’ FCC 승인 소개 동영상을 보면 터치 이후의 사용자 인터페이스 후보 중에서 상용화가 가장 빠를 것 같다.\n   UI디자인에서 컬러를 사용하는 방법 먼저 요소의 간격과 레이아웃을 잡는 데에 집중해야 한다는 문장에 뜨끔했다.\n   미국인이 많이 쓰는 영어 문장 500개 예전에도 몇 번 읽었지만, 끝까지 본 적은 한 번도 없는 문서.\n   너의 회사는? 여러 회사의 업무 강도와 복지 수준이 대략 어느 정도인지 궁금한 사람에게 권하는 기사. 물론 IT 관련 회사가 대부분이지만, 업무 시스템 정착, 조직원 간의 커뮤니케이션과 공유 문화 등은 모든 회사에 중요하지 않을까.\n  ","date":1546560000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1546560000,"objectID":"a2aab76e5eb406ab6dc54631d659290e","permalink":"https://lethean.github.io/2019/01/04/reading-2019-01-04/","publishdate":"2019-01-04T00:00:00Z","relpermalink":"/2019/01/04/reading-2019-01-04/","section":"post","summary":"손짓으로 기기 제어… 구글 ‘프로젝트 솔리’ FCC 승인 소개 동영상을 보면 터치 이후의 사용자 인터페이스 후보 중에서 상용화가 가장 빠를 것 같다. UI디자인에서 컬러를","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2019-01-04)","type":"post"},{"authors":null,"categories":null,"content":"   Flutter는 왜 혁명적인가? Flutter 장점을 다른 기술과 비교해서 잘 설명한 번역 문서. 당연하지만 Dart 언어와 새 프레임워크 학습에 드는 비용 같은 단점은 생략되어 있다.\n   5 Tips To Speed Up Linux Software Raid Rebuilding And Re-syncing CPU 점유율과 I/O 사용량을 고려해서 커널 설정을 튜닝하면 리눅스 소프트웨어 RAID 리빌딩 속도를 크게 개선할 수 있다.\n   꼰대가 되는 법 성공했다고 생각하지 않으니까 나는 아직 꼰대가 아닌 건가.\n  ","date":1545868800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1545868800,"objectID":"e80cd6f485a93940bc9c8136a74ab421","permalink":"https://lethean.github.io/2018/12/27/reading-2018-12-27/","publishdate":"2018-12-27T00:00:00Z","relpermalink":"/2018/12/27/reading-2018-12-27/","section":"post","summary":"Flutter는 왜 혁명적인가? Flutter 장점을 다른 기술과 비교해서 잘 설명한 번역 문서. 당연하지만 Dart 언어와 새 프레임워크 학습에 드는 비용 같은 단점은 생략되어 있다","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2018-12-27)","type":"post"},{"authors":null,"categories":null,"content":"   개발자를 위한 인프라 기초 총정리 클라우드 기반 기술을 간략하게 설명하지만 일반적인 리눅스 플랫폼을 이해하는데도 도움이 된다.\n   Flutter 1.0: Google의 휴대용 UI 도구 키트 Flutter 1.0 버전이 정식으로 출시되었다. 기능 추가와 더불어 성능도 더 개선되었는데, 많은 써드 파티 업체의 부가적인 서비스가 눈에 띈다. 게다가 iOS / 안드로이드 뿐 아니라 웹과 데스크톱 앱까지 대상을 확대하고 있다.\n   Linux 4.19.7 Getting Revised STIBP Code, Important PCIe Fix For Radeon GPUs 성능 저하 문제를 일으켰던 STIBP 코드가 다시 안정 버전에 반영되었는데, 다행히도 prctl을 이용하거나 SECCOMP 옵션을 켰을 때만 동작하도록 바뀌었다.\n  ","date":1544832000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1544832000,"objectID":"9317450b353cab493f44e5032f36f3dc","permalink":"https://lethean.github.io/2018/12/15/reading-2018-12-15/","publishdate":"2018-12-15T00:00:00Z","relpermalink":"/2018/12/15/reading-2018-12-15/","section":"post","summary":"개발자를 위한 인프라 기초 총정리 클라우드 기반 기술을 간략하게 설명하지만 일반적인 리눅스 플랫폼을 이해하는데도 도움이 된다. Flutter 1.0: Google의 휴대용 UI 도구","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2018-12-15)","type":"post"},{"authors":null,"categories":null,"content":"   Some Linux Users Are Reporting Software RAID Issues With ASRock Motherboards ASRock 메인보드나 Z97 칩셋 기반 메인보드의 UEFI 펌웨어가 부팅할 때 리눅스 소프트웨어 RAID 파티션 정보를 건드려서 문제가 발생한다고 한다.\n   Bash scripting cheatsheet 셸 스크립트 작성할 때 이 문서 하나만 참고해도 될 정도로 간략하게 정리가 잘 되어 있다.\n   Beyond console.log() 솔직히 console.dir()은 알고 있었지만 이렇게 많은 기능이 있는지 몰랐다.\n   실용주의 프로그래머 / Clean Code 유명한 두 권의 책을 보고 정리한 글이다. 하지만 책 자체를 읽어보는 걸 권한다. 더불어 책의 모든 내용이 맞는 것도 아니라는 사실도\u0026hellip;\n   효율적인 회의의 5원칙 결국 회의라는 건 정보 공유가 아닌 의사 결정을 위해 필요한 걸까?\n   케이블 꼬이지 않게 감는 방법 랜선 정리할 때 한 번 써봐야겠다.\n  ","date":1543536000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1543536000,"objectID":"da55d4bf6183b46476dbf73cbaf0f821","permalink":"https://lethean.github.io/2018/11/30/reading-2018-11-30/","publishdate":"2018-11-30T00:00:00Z","relpermalink":"/2018/11/30/reading-2018-11-30/","section":"post","summary":"Some Linux Users Are Reporting Software RAID Issues With ASRock Motherboards ASRock 메인보드나 Z97 칩셋 기반 메인보드의 UEFI 펌웨어가 부팅할 때 리눅스 소프트웨어 RAID 파티션 정보를 건드려서 문제가 발생한다고 한다. Bash scripting cheatsheet 셸","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2018-11-30)","type":"post"},{"authors":null,"categories":null,"content":"   Linux Stable Updates Are Dropping The Performance-Pounding STIBP 리눅스 커널 4.20 버전에 포함될 예정이고 4.19.2 안정 버전에 이미 반영된 STIBP 보안 패치가 최대 50%까지 성능 저하를 일으킬 수 있어서 논란이 있었는데, 최근 다시 일선에 복귀한 리누스 토발스가 이 패치를 되돌렸다. 4.19.4 / 4.14.83 안정 버전에도 반영되었다.\n   Desktop icons RC release GNOME 데스크톱 바탕 화면 기능이 최근에 사라졌다가 GNOME 셸 확장 기능으로 다시 돌아왔다. 생각해보니 다른 확장 기능 때문에 불편한 점이 별로 없었는데, 아무튼 그래도 반갑다. 참고로, 지금 사용하는 GNOME 셸 확장 기능은 Desktop Icons , Hide Top Bar , Places Status Indicator , TopIcons Redux 등이다.\n   Async JavaScript: From Callbacks to Promises to Async/Await 이제는 대부분 자바스크립트 라이브러리가 비동기 작업을 위해 콜백함수 대신 Promise 방식을 사용한다. 그리고 앞으로는 async / await 방식으로 또 바뀔 거라는데\u0026hellip;\n   토큰(Token) 기반 인증에 대한 소개 / JSON Web Token 소개 및 구조 / Express.js 서버에서 JWT 기반 회원인증 시스템 구현하기 웹 토큰과 JWT를 쉽게 설명한 연재글. 언제나 그렇듯이 기술은 계속 진화하면서 단점을 보완한다. 앞서가진 못하더라도 따라가기라도 해야 도태되지 않는다.\n   요즘 개발자들은 다들 이렇게 책임감이 없나요?  자기가 진행하는 프로젝트에 애정을 가지지 않는 개발자는 없다. 오랜 시간 끌어안아야 하는 만큼 개발자에게 자신의 프로젝트는 자기 자식과 다름없다. 오류가 발생한다면 대부분 개발자는 어떤 일이 있어도 고쳐낸다. 하지만 그런 애정이 생길 만큼의 커뮤니케이션도 안 되는 곳이라면 개발자는 그곳을 떠날 수밖에 없다.\n    모든 웹사이트 홈페이지가 갖춰야 할 12가지 핵심 요소 이런 종류의 글은 계속 재생산되지만 정작 필요할 때 찾기 힘들다.\n  ","date":1542931200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1542931200,"objectID":"eb714ba64e2342712c4db1ede5f492ac","permalink":"https://lethean.github.io/2018/11/23/reading-2018-11-23/","publishdate":"2018-11-23T00:00:00Z","relpermalink":"/2018/11/23/reading-2018-11-23/","section":"post","summary":"Linux Stable Updates Are Dropping The Performance-Pounding STIBP 리눅스 커널 4.20 버전에 포함될 예정이고 4.19.2 안정 버전에 이미 반영된 STIBP 보안 패치가 최대 50%까지 성능 저하를 일으킬 수 있어서 논란이 있었는데, 최근","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2018-11-23)","type":"post"},{"authors":null,"categories":null,"content":"   Epilogue: Create flexible REST endpoints and controllers from Sequelize models in your Express app Node.js + Sequelize + Epilogue 조합을 사용하면 데이터베이스와 연동되는 REST 서버를 정말 쉽게 만들 수 있다. 이렇게 만든 백엔드에 Vuetify.js 같은 프레임워크를 이용해 웹 프론트엔드를 올리기만 하면 된다. 새삼 깨닫지만, 무슨 일이든 전에 했던 일이라도 반드시 최신 기술과 트렌드를 한 번 확인하고 시작해야 몸이 고생하는 걸 피한다.\n   Flutter - Beautiful native apps in record time 구글에서 밀고 있는 모바일 개발 플랫폼. Dart 언어와 자체 UI 라이브러리를 이용해 하나의 코드로 iOS / Android 네이티브 앱을 동시에 빌드한다. 물론 React / React Native , Vue.js / NativeScript 등을 사용하면 한 번 학습해서 웹과 모바일 앱 양쪽에 사용할 수 있지만, 모바일 앱 자체만 고려한다면 Flutter의 성능과 편의성을 무시할 수 없다. 다만 새 언어와 새 플랫폼을 배워야하는 부담이 있지만, 이 직업이 원래 그런 걸 어찌할까.\n   왜 45세 정년이 될 수 밖에 없는가 2014년에 작성된 글인데 아직도 링크가 공유되는 걸 보면 여전히 공감을 일으키는 부분이 많은 것 같다. 다만 어디까지 직접 만들어야 원천기술인지 모르겠고, 주변에 45세 넘은 개발자가 생각보다 많다는 사실은 조금씩 나아지고 있다는 반증일 수도 있다.\n   How To Write A Dissertation 그래, 이제 나도\u0026hellip;\n  ","date":1542326400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1542326400,"objectID":"bef5ce4c1fe2954ec097d43a4f428dd7","permalink":"https://lethean.github.io/2018/11/16/reading-2018-11-16/","publishdate":"2018-11-16T00:00:00Z","relpermalink":"/2018/11/16/reading-2018-11-16/","section":"post","summary":"Epilogue: Create flexible REST endpoints and controllers from Sequelize models in your Express app Node.js + Sequelize + Epilogue 조합을 사용하면 데이터베이스와 연동되는 REST 서버를 정말 쉽게 만들 수 있다. 이렇게 만든 백엔드에 Vuetify.js 같은 프레임워크를 이","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2018-11-16)","type":"post"},{"authors":null,"categories":null,"content":"   고퀄리티 개발 컨텐츠 모음 내용이 아직 많지 않지만(?), 우리말로 정리된 이런 사이트는 언제나 반갑고 고맙다.\n   Best practices for building secure API Keys 요즘 많이 사용하는 API 키를 안전하게 생성하고 관리하는 방법을 간략하고 명료하게 설명한다.\n   스타트업에서 쓰기 좋은 도구들 우리 회사에서 사용하는 도구도 보이는 걸 보니 우리 회사는 아직도 스타트업인가 보다.\n   식당에서 아이에게 스마트폰 보여줘도 괜찮아 이 글에 공감하지만, 현실에서는 워낙 강경한 분들이 많아서 반박하지 않는 경우가 대부분이다.\n   영화 \u0026lsquo;루시\u0026rsquo;가 퍼뜨리는 뇌에 대한 잘못된 신화 우리가 잘못 알고 있거나 최신 정보로 갱신되지 않은 과학 상식이 많은데, 일반 사람이 뇌의 10% 정도만 사용한다는 사실도 그중 하나라고 한다.\n   40세 이상의 나이에 주 25시간 일하면 인식 능력이 떨어진다 같은 일을 하는데 이전보다 더 많은 시간이 소요되는 원인일까?\n   낮잠 권하는 회사들 그래서 회사에서 낮잠을 자주 잔다!\n  ","date":1541030400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1541030400,"objectID":"c3e936ccf7466c61c92dbc394d60f40e","permalink":"https://lethean.github.io/2018/11/01/reading-2018-11-01/","publishdate":"2018-11-01T00:00:00Z","relpermalink":"/2018/11/01/reading-2018-11-01/","section":"post","summary":"고퀄리티 개발 컨텐츠 모음 내용이 아직 많지 않지만(?), 우리말로 정리된 이런 사이트는 언제나 반갑고 고맙다. Best practices for building secure API Keys 요즘 많이 사용하는 API 키를 안전하게","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2018-11-01)","type":"post"},{"authors":null,"categories":null,"content":"   카카오헤어샵 개발 후기를 시작하며 클린코드, 개발문화, 프레임워크. 이런 글은 항상 지금의 나를 되짚어보게 한다.\n   코드 수정 없이 리눅스 게임 서버 성능 평가 리눅스 성능 프로파일 기법을 하나씩 적용하다가 최신 eBPF가 등장한다. 우리글로 작성된 고품질의 읽을거리를 만나면 항상 반가우면서 부럽다.\n   초당 천만 개의 패킷을 버리는 방법 리눅스 네트워크 패킷 필터링 기술의 역사와 최신 흐름을 한눈에 확인할 수 있다. iptables, nftables, tc, XDP 처럼 처음 보는 것도 있음을 솔직히 인정한다.\n   1.1.1.1 — the Internet’s Fastest, Privacy-First DNS Resolver Google DNS 서버(8.8.8.8)보다 빠르다. 물론 다른 이유로 사용하는 이도 많지만\u0026hellip;\n   IP Accounting and Access Lists with systemd systemd 235 버전부터 unit 파일 속성을 이용해 쉽게 IP 주소를 필터링할 수 있다. 다만, 외부에서 접속하는 IP 주소뿐 아니라 외부로 접속하는 IP 주소도 필터링한다.\n   The Longest Debugging—The journey towards a reliable Linux workstation 불안정한 시스템의 원인을 찾기 위해 10개월에 걸쳐 소프트웨어와 하드웨어를 디버깅한 결과는 과연 무엇일까? 솔직히 다 읽지 못하고 중간에 포기하고 마지막 결론만 확인했다.\n   Building Better Interfaces with SVG SVG 능력을 잘 보여주는 슬라이드. 비트맵 아이콘 대신 폰트 아이콘을 사용하면 해상도가 높아져도 그래픽 품질이 저하되지 않는 장점을 알게 된다. 언젠가는 SVG를 웹이 아닌 일반 앱 UI에도 적용해 볼 기회도 오겠지.\n   SVG can do THAT?! SVG 능력을 잘 보여주는 슬라이드 2.\n   아이폰 10년, 우리는 바스 오딩을 기억해야 한다 살아있는 UI의 신.\n   DP 케이블 쓰시는 분들 혹시 20핀 유무 확인하시나요? 부팅 후 모니터 반응 시간이 1초 이상 걸리거나 반응이 없다면 DP 케이블 20핀 유무를 확인하자.\n   우리는 어쩌다 희석식 소주를 먹게 되었을까 좋아하는 사람이라면 어느 정도 알고 있는 소주의 역사. 어쩌면 취하기 위한 목적에만 충실한 술이라서 더 좋을 수도 있다.\n  ","date":1540771200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1540771200,"objectID":"1a9b7dddd789a4e1846039879537201f","permalink":"https://lethean.github.io/2018/10/29/reading-2018-10-29/","publishdate":"2018-10-29T00:00:00Z","relpermalink":"/2018/10/29/reading-2018-10-29/","section":"post","summary":"카카오헤어샵 개발 후기를 시작하며 클린코드, 개발문화, 프레임워크. 이런 글은 항상 지금의 나를 되짚어보게 한다. 코드 수정 없이 리눅스 게임 서버 성능 평가 리눅스","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2018-10-29)","type":"post"},{"authors":null,"categories":null,"content":"   버튼 디자인 12가지 팁 요즘 웹은 개발자와 디자이너의 경계가 점점 흐려지는 것 같다.\n   SVG, JS, CSS로 만드는 라이언 로그인 폼 멋지다!\n   Tabler - Admin panel made simple Bootstrap 기반 오픈 소스 대시 보드 템플릿. 무료!\n   더 이상 초보 개발자가 아니라는 사실을 언제 알게 되나요? 성실성, 참을성, 겸손함이 아주 중요하다.\n   Light Phone 2 우리나라에 발매되면 제일 먼저 사고 싶은 휴대폰\n   ‘한글2018’에서 뒤늦게 맞춤법을 배우다 이 글을 읽고 iOS용 한컴오피스를 구매했지만, 실제로는 한국어 맞춤법/문법 검사기 를 더 자주 사용한다. 심지어 지금 쓰는 이 글까지도.\n   How To Enable New \u0026amp; Built-In Windows 10 OpenSSH Client? 윈도우 10 1709 버전에 포함된 OpenSSH 클라이언트 사용 방법. 심지어 SSH 공개키를 이용한 접속도 된다.\n  ","date":1537056000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1537056000,"objectID":"4b56e42b6db728ad674e71bacaa7e804","permalink":"https://lethean.github.io/2018/09/16/reading-2018-09-16/","publishdate":"2018-09-16T00:00:00Z","relpermalink":"/2018/09/16/reading-2018-09-16/","section":"post","summary":"버튼 디자인 12가지 팁 요즘 웹은 개발자와 디자이너의 경계가 점점 흐려지는 것 같다. SVG, JS, CSS로 만드는 라이언 로그인 폼 멋지다! Tabler - Admin panel made simple Bootstrap 기반 오픈 소스 대","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2018-09-16)","type":"post"},{"authors":null,"categories":null,"content":"   구글 인기 메일 클라이언트 Inbox, 역사 속으로 사라진다 잘 쓰고 있었는데 내년 3월에 없어진다고 하니 아쉽다.\n   효과적인 대시보드를 만들기 위해 고려해야 할 6가지 결국 계속 만들고 테스트하고 고치기\n   A Global Switch To Kill Linux\u0026rsquo;s CPU Spectre/Meltdown Workarounds?  Spectre / Meltdown 같은 CPU 보안 버그에 대한 패치가 리눅스 커널에 반영되면서 전체적인 성능이 저하 되는데, 커널 컴파일 옵션을 조정해 다시 빌드하지 않고 리눅스 커널 커맨드 라인 옵션만 추가해도 보안 패치를 비활성화할 수 있다. 내장형 시스템이나 검증되지 않은 외부 프로그램이 설치될 수 없는 환경에서 유용하다.\n   A Rolling Battle: Antergos vs. Clear Linux vs. openSUSE On Four Systems 인텔이 만든 Clear 리눅스 배포판이 인텔 CPU에서 성능이 좋다는 건 어찌 보면 당연하다. 그런데 AMD CPU에서도 문제없이 동작할까? 조만간에 제품에 적용할 수 있는지 테스트가 필요하다.\n   Using the Chrome OS- graphics stack on Intel-based Linux- desktops 리눅스의 그래픽 스택이 많이 좋아졌지만 다른 운영체제에 비해 성능 개선이 필요한 부분도 여전히 많다. 이 글에서 소개한 크롬 OS의 그래픽 스택이 리눅스 데스크톱 / 내장형 시스템에 공식적으로 반영되는 날이 하루라도 빨리 오기를 기대한다. 참고로, 만화로 나누는 자유/오픈소스 소프트웨어 이야기 로 유명한 허준회 님이 아마도(?) 업무적으로 작성한 글이 아닐까 생각한다.\n   팀장은 팀원보다 일을 더 잘하면 안 된다(?) 그래서 요즘 많이 배를 째고 있다. 하지만 모든 팀원은 언젠가 팀장이 된다는\u0026hellip;\n   백종원 라면 레시피! 면발이 탱탱한 라면 끓이기! 조금 귀찮지만 확실히 더 맛있다.\n  ","date":1536883200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1536883200,"objectID":"dd217724160ea128d3fe1e0343fd9422","permalink":"https://lethean.github.io/2018/09/14/reading-2018-09-14/","publishdate":"2018-09-14T00:00:00Z","relpermalink":"/2018/09/14/reading-2018-09-14/","section":"post","summary":"구글 인기 메일 클라이언트 Inbox, 역사 속으로 사라진다 잘 쓰고 있었는데 내년 3월에 없어진다고 하니 아쉽다. 효과적인 대시보드를 만들기 위해 고려해야 할 6가지 결국 계속","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2018-09-14)","type":"post"},{"authors":null,"categories":null,"content":"   더 나은 폼 디자인하기 전부 동의하지 않지만, 알아 두면 좋은 내용\n   좋은 UI 애니메이션에서 더 좋은 UI 애니메이션으로 만드는 팁 우리가 흔히 접하는 UI 애니메이션 효과도 그냥 막 만든 게 아니라는 사실을 새삼 깨닫는다.\n   키오스크 UI 설계 시 고려할 것들 사용자의 시야각과 입력 방식, 사용 환경을 고려해야 한다.\n   모바일 동영상 플레이어 내 Gesture UI 살펴보기 유튜브, 페리스코프, TVING, 옥수수, 비디오포털 등의 모바일 앱의 제스쳐 UI를 비교 분석\n   How to Read an RFC 알고 있으면 좋은 RFC 문서 상식\n   나는 대기업에서 ㅍㅍㅅㅅ로 이직했다: 효율 편 초기 잔디 앱을 사용해 보다가 말았는데, 다시 한번 써볼까 하는 생각을 들게 하는 광고(?) 기사\n   일을 하는 시스템 만들기 일당백을 할 수 있는 좋은 인력이 열심히 일하는 것도 중요하지만, 이보다 더 중요한 건 사람의 개입을 최소화 할 수 있는 시스템을 개발하는데 회사의 많은 자원을 집중해야 한다.\n   참고와 참조의 차이 더 자세한 내용을 가리킬 때는 참고, 비교하거나 대조할 내용은 참조.\n   삼겹살은 직접 구워야 하는 음식인가? 이 글에 나오는 요리법을 따라 하다가 집안 곳곳에 파 향기 듬뿍 삼겹살 냄새가 가득 차서 고생했다. 하지만 맛있다.\n   등산화, 운동화 끈 안 풀리게 묶는 방법 쉬운데, 예쁜 모양이 잘 안 나온다.\n   Reference counting in modern GLib GLib 2.58 버전에 참조 카운터 API가 새로 추가되었다. 기존 구조체를 수정하지 않고 참조 카운터만 추가하는 방법이 눈여겨볼 만하다.\n   JavaScript ES6 — write less, do more 자바스크립트 ES6 버전이 나온 지 오래되었으나, 자주 사용하지 않기 때문인지 관심이 별로 없었는데, 웹이나 Node.js 관련 최근 예제를 보면 ES6 문법이 많이 눈에 띈다. 이젠 더 피할 수 없다.\n   Here are examples of everything new in ECMAScript 2016, 2017, and 2018 더 최신 자바스크립트 기능을 더 확인할 수 있다. 그런데 이 모든 기능을 내가 얼마나 사용하게 될까 궁금하다.\n   AMD Finally Rolls Out New Linux Patches For Adaptive-Sync / VRR (FreeSync) AMD GPU 리눅스 드라이버 커널 모듈이 FreeSync 기능을 지원하기 시작했다. 커널 모듈뿐 아니라 X.Org 드라이버, Mesa 3D 라이브러리도 지원해야 하므로 바로 동작하는 건 아니다. 물론 FreeSync 기능은 이를 지원하는 모니터에서만 동작한다.\n  ","date":1536710400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1536710400,"objectID":"c86dbc8670d72ddc1d0b08e3735af6c8","permalink":"https://lethean.github.io/2018/09/12/reading-2018-09-12/","publishdate":"2018-09-12T00:00:00Z","relpermalink":"/2018/09/12/reading-2018-09-12/","section":"post","summary":"더 나은 폼 디자인하기 전부 동의하지 않지만, 알아 두면 좋은 내용 좋은 UI 애니메이션에서 더 좋은 UI 애니메이션으로 만드는 팁 우리가 흔히 접하는 UI 애니메이션 효과도 그","tags":["Reading"],"title":"대체로 무해한 읽을거리 (2018-09-12)","type":"post"},{"authors":null,"categories":null,"content":"\u0026lsquo; 2015년 주목받은 신인 오픈소스 SW 11선 \u0026rsquo; 기사와 Dropbox 클라이언트의 다음 버전을 Rust 언어와 Bazel 로 만든다는 글 을 보고 궁금증이 생겨 잠시 Bazel 빌드 도구를 살펴보았다. 하지만 아직 윈도 플랫폼을 지원하지 않고 Java 언어로 구현되어 있어서 당분간 사용을 보류.\n그러다가 문득 요즘에는 어떤 빌드 시스템이 인기 있는지 궁금해서 조사해 보니, 지난 몇 년 사이에 Ninja 라는 빌드 도구가 계속 언급되는 걸 발견했다. CMake , GYP 같은 전통의 빌드 시스템이 Make 빌드 파일뿐 아니라 Ninja 빌드 파일도 생성한다. 심지어 Chromium 브라우저 빌드 도 Ninja를 사용하는 방식으로 변경되었다.\n반나절 정도 걸려 Ninja 빌드 파일을 만들고 실행해 본 소감은 만족 반 실망 반인 것 같다. 항상 ccache 를 사용하기 때문에 이와 맞물려 더한 감도 있지만, 체감 빌드 속도는 대만족이다. 하지만 단순한 기능을 보완하기 위해 별도의 도구가 더 필요한 점은 아쉽다.\nNinja의 장점은 빠른 빌드 속도와 리눅스 / 윈도 / 맥 운영체제를 포함하는 멀티 플랫폼 지원이다. 빠른 속도를 얻기 위해 시스템에 장착된 모든 CPU를 모두 사용해서 병렬로 작업을 처리한다. make -jN 명령에서 N에 시스템 CPU 갯수를 지정한 것과 같은 셈이다. 하지만 조금 다뤄보니 병렬 작업에 대한 고려를 많이 했다는 느낌을 받는다. 병렬 처리되는 작업의 결과 내용을 섞어서 표시하지 않고 버퍼링 했다가 따로따로 출력한다거나 Make처럼 세심하게 신경 쓰지 않아도 대부분 작업을 병렬로 잘 처리한다.\n쉬운 문법과 사용법도 장점이다. 1~2시간 정도면 매뉴얼을 다 읽을 수 있을 정도로 문법이 단순하고 양도 적다. Make의 암묵적인 규칙 같은 게 전혀 없어서 외우거나 혼란스러운 것도 없다. 하지만 이 단순함은 반대로 치명적인 단점이기도 하다.\n예를 들어 Make에서는 A = $(shell pkg-config --cflags libuv)처럼 명령어 실행 결과를 변수에 담거나, A += $(B), A ?= src 같이 다양한 조건을 이용해 변수를 조작할 수 있는데 Ninja에서는 a = $b 단순 대입 문법이 전부다. 심지어 환경 변수도 사용할 수 없다. 조건문 같은 건 상상도 할 수 없다. 다양한 운영체제를 지원하기 위해 유닉스 셸 실행 기능이 빠진 건 이해할 수 있지만, 환경 변수나 조건문이 없다는 건 Make처럼 혼자서 모든 다양한 경우에 대한 작업을 다 할 수 없다는 뜻이기도 하다. 그래서 홈페이지에도 Ninja를 직접 사용하지 말고 Ninja 빌드 파일을 자동으로 만드는 다른 도구 를 추천하는 것 같다.\n참고로 Sublime Text 같은 텍스트 에디터에서 Ninja 문법을 지원하거나 빌드 명령어 실행 을 위한 설정 방법은 대부분 구글에서 검색하면 쉽게 발견된다. 다음은 리눅스에서 Sublime Text를 사용할 때 필요한 Ninja 빌드 시스템 내용인데, 따로 적어두는 이유는 Chromium 사이트의 내용과 조금 다르기 때문이다.\n{ \u0026quot;shell_cmd\u0026quot;: \u0026quot;ninja\u0026quot;, // ${folder} or ${file_path} \u0026quot;working_dir\u0026quot;: \u0026quot;${folder}\u0026quot;, // (file_path):(line_number):(column):(error_message) \u0026quot;file_regex\u0026quot;: \u0026quot;^([^:\\n]*):([0-9]+):?([0-9]+)?:? (.*)$\u0026quot; }  ","date":1458172800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1458172800,"objectID":"f207d07c674eca7f1075639cf7cb857b","permalink":"https://lethean.github.io/2016/03/17/about-ninja-build/","publishdate":"2016-03-17T00:00:00Z","relpermalink":"/2016/03/17/about-ninja-build/","section":"post","summary":"\u0026lsquo; 2015년 주목받은 신인 오픈소스 SW 11선 \u0026rsquo; 기사와 Dropbox 클라이언트의 다음 버전을 Rust 언어와 Bazel 로 만든다는 글 을 보고 궁금증이 생겨 잠시 Bazel 빌드 도구를 살펴보았다.","tags":["Ninja","Build"],"title":"Ninja 빌드 도구 소개","type":"post"},{"authors":null,"categories":null,"content":"리눅스 커널 4.3 버전으로 업그레이드하면서부터 RocketRAID RAID 장치가 동작하지 않았다. 컴파일 오류도 없고 로딩에도 문제가 없는데, 응답이 너무 느려서 거의 동작하지 않는 거나 마찬가지다. 구글링을 해도 해결 방법을 찾을 수 없었는데, 아마도 업체에서 제공하는 커널 드라이버라서 사용자가 적어서일 수도 있다. 이렇게 심각한 문제라면 4.3.x 안정 버전이나 4.4 버전에서 해결될 것이라 생각하고 기다렸다. 하지만 4.4 버전이 출시되어도 증상은 동일했다. 결국 직접 원인을 찾기로 했다. 분명한 건 리눅스 커널 4.2 버전까지 정상적으로 동작했는데 4.3 버전부터 동작하지 않는다는 사실이다.\n정상적으로 동작하는 리눅스 커널 4.2.5 버전에서는 rr272x_1x 모듈이 인터럽트 16을 할당받아 동작하는데,\n$ cat /proc/interrupts ... 16: 13629 3699 2326 1683 IR-IO-APIC 16-fasteoi ehci_hcd:usb1, rr272x_1x ... $ dmesg | grep rr272x ... [ 1.619829] rr272x_1x:adapter at PCI 1:0:0, IRQ 16 ...  오동작하는 리눅스 커널 4.4.1 버전에서는 인터럽트 11을 할당받지만 실제 인터럽트xi는 발생하지 않고,\n$ cat /proc/interrupts ... 11: 0 0 0 0 IR-IO-APIC 11-edge rr272x_1x 16: 199999 0 1 1 IR-IO-APIC 16-fasteoi ehci_hcd:usb1 ... $ dmesg | grep rr272x ... [ 1.639672] rr272x_1x:adapter at PCI 1:0:0, IRQ 11 ...  인터럽트 16을 아무도 처리하지 않아서 커널이 경고 메시지를 출력한다.\n[ 5.750969] irq 16: nobody cared (try booting with the \u0026quot;irqpoll\u0026quot; option) [ 5.750973] CPU: 0 PID: 0 Comm: swapper/0 Tainted: G U O 4.4.1-1-ARCH #1 [ 5.750974] Hardware name: Supermicro C7Z97-OCE/C7Z97-OCE, BIOS 2.0 06/22/2015 [ 5.750975] 0000000000000000 bf85cf29362dfeed ffff880856c03e68 ffffffff812c7f39 [ 5.750977] ffff88082e06ae00 ffff880856c03e90 ffffffff810d1053 ffff88082e06ae00 [ 5.750978] 0000000000000000 0000000000000010 ffff880856c03ec8 ffffffff810d13de [ 5.750980] Call Trace: [ 5.750981] \u0026lt;IRQ\u0026gt; [\u0026lt;ffffffff812c7f39\u0026gt;] dump_stack+0x4b/0x72 [ 5.750988] [\u0026lt;ffffffff810d1053\u0026gt;] __report_bad_irq+0x33/0xc0 [ 5.750990] [\u0026lt;ffffffff810d13de\u0026gt;] note_interrupt+0x23e/0x280 [ 5.750992] [\u0026lt;ffffffff810ce6d7\u0026gt;] handle_irq_event_percpu+0xa7/0x1b0 [ 5.750994] [\u0026lt;ffffffff810ce819\u0026gt;] handle_irq_event+0x39/0x60 [ 5.750995] [\u0026lt;ffffffff810d1be9\u0026gt;] handle_fasteoi_irq+0x89/0x150 [ 5.750997] [\u0026lt;ffffffff81018c7a\u0026gt;] handle_irq+0x1a/0x30 [ 5.751000] [\u0026lt;ffffffff815944db\u0026gt;] do_IRQ+0x4b/0xd0 [ 5.751002] [\u0026lt;ffffffff815925c2\u0026gt;] common_interrupt+0x82/0x82 [ 5.751002] \u0026lt;EOI\u0026gt; [\u0026lt;ffffffff81447c14\u0026gt;] ? cpuidle_enter_state+0x124/0x290 [ 5.751006] [\u0026lt;ffffffff81447db7\u0026gt;] cpuidle_enter+0x17/0x20 [ 5.751008] [\u0026lt;ffffffff810b79b2\u0026gt;] call_cpuidle+0x32/0x60 [ 5.751010] [\u0026lt;ffffffff81447d93\u0026gt;] ? cpuidle_select+0x13/0x20 [ 5.751012] [\u0026lt;ffffffff810b7c72\u0026gt;] cpu_startup_entry+0x292/0x370 [ 5.751014] [\u0026lt;ffffffff815858c9\u0026gt;] rest_init+0x89/0x90 [ 5.751015] [\u0026lt;ffffffff81906013\u0026gt;] start_kernel+0x483/0x4a4 [ 5.751017] [\u0026lt;ffffffff81905120\u0026gt;] ? early_idt_handler_array+0x120/0x120 [ 5.751019] [\u0026lt;ffffffff81905339\u0026gt;] x86_64_start_reservations+0x2a/0x2c [ 5.751020] [\u0026lt;ffffffff81905485\u0026gt;] x86_64_start_kernel+0x14a/0x16d [ 5.751021] handlers: [ 5.751025] [\u0026lt;ffffffffa0093410\u0026gt;] usb_hcd_irq [usbcore] [ 5.751026] Disabling IRQ #16  인터럽트 번호가 잘못 할당된 것 같은데 원인을 찾아야 했다. 결국 무식하지만 가장 확실한 방법을 사용하기로 결심하고, git bisect 명령을 이용해 리눅스 커널 4.2 버전과 4.3 버전 사이에서 문제를 일으키는 커밋을 찾아야 했다. 물론 매번 커널을 다시 컴파일하고 테스트하는 작업은 오래 걸리지만 다행히 성능 좋은 개발 서버에서 돌려서 시간을 많이 단축할 수 있었고 약 하루 정도 만에 문제의 커밋을 찾았다.\n$ git bisect start 6a13feb9c82803e2b815eca72fa7a9f5561d7861 64291f7db5bd8150a74ad2036f1037e6a0428df2 $ git bisect log # bad: [6a13feb9c82803e2b815eca72fa7a9f5561d7861] Linux 4.3 # good: [64291f7db5bd8150a74ad2036f1037e6a0428df2] Linux 4.2 git bisect start '6a13feb9c82803e2b815eca72fa7a9f5561d7861' '64291f7db5bd8150a74ad2036f1037e6a0428df2' # bad: [807249d3ada1ff28a47c4054ca4edd479421b671] Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus git bisect bad 807249d3ada1ff28a47c4054ca4edd479421b671 # bad: [102178108e2246cb4b329d3fb7872cd3d7120205] Merge tag 'armsoc-drivers' of git://git.kernel.org/pub/scm/linux/kernel/git/arm/arm-soc git bisect bad 102178108e2246cb4b329d3fb7872cd3d7120205 # good: [c8192ba416397ad6ce493f186da40767ce086c3b] Merge tag 'for-v4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/sre/linux-power-supply git bisect good c8192ba416397ad6ce493f186da40767ce086c3b # bad: [7073bc66126e3ab742cce9416ad6b4be8b03c4f7] Merge branch 'core-rcu-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip git bisect bad 7073bc66126e3ab742cce9416ad6b4be8b03c4f7 # bad: [26f8b7edc9eab56638274f5db90848a6df602081] Merge tag 'pci-v4.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci git bisect bad 26f8b7edc9eab56638274f5db90848a6df602081 # good: [cf9d615f7f5842ca1ef0f28ed9f67a97d20cf6fc] Merge tag 'regulator-v4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator git bisect good cf9d615f7f5842ca1ef0f28ed9f67a97d20cf6fc # good: [edc837da4b54a01ba6fa3c29b411e35d1a8430ca] Merge tag 'leds_for_4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/j.anaszewski/linux-leds git bisect good edc837da4b54a01ba6fa3c29b411e35d1a8430ca # bad: [5a4f3cf0d1f02884c0a64488d22b3bb4bce31b44] Merge branches 'pci/irq', 'pci/misc', 'pci/resource' and 'pci/virtualization' into next git bisect bad 5a4f3cf0d1f02884c0a64488d22b3bb4bce31b44 # good: [932c435caba8a2ce473a91753bad0173269ef334] PCI: Add dev_flags bit to access VPD through function 0 git bisect good 932c435caba8a2ce473a91753bad0173269ef334 # good: [cd66d5c3df7c96cbf75010b964b94032ceca8889] Merge branches 'pci/host-designware', 'pci/host-xgene' and 'pci/host-xilinx' into next git bisect good cd66d5c3df7c96cbf75010b964b94032ceca8889 # bad: [5f2269916b0e509f2926346b58209abfa8316143] PCI/MSI: Free legacy IRQ when enabling MSI/MSI-X git bisect bad 5f2269916b0e509f2926346b58209abfa8316143 # bad: [991de2e59090e55c65a7f59a049142e3c480f7bd] PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq() git bisect bad 991de2e59090e55c65a7f59a049142e3c480f7bd # good: [890e4847587fcff5eb0438e90992ad7d2a261f33] PCI: Add pcibios_alloc_irq() and pcibios_free_irq() git bisect good 890e4847587fcff5eb0438e90992ad7d2a261f33 # first bad commit: [991de2e59090e55c65a7f59a049142e3c480f7bd] PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq()  바로 이 커밋이 원인이었다.\ncommit 991de2e59090e55c65a7f59a049142e3c480f7bd Author: Jiang Liu \u0026lt;jiang.liu@linux.intel.com\u0026gt; Date: Wed Jun 10 16:54:59 2015 +0800 PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq() To support IOAPIC hotplug, we need to allocate PCI IRQ resources on demand and free them when not used anymore. Implement pcibios_alloc_irq() and pcibios_free_irq() to dynamically allocate and free PCI IRQs. Remove mp_should_keep_irq(), which is no longer used. [bhelgaas: changelog] Signed-off-by: Jiang Liu \u0026lt;jiang.liu@linux.intel.com\u0026gt; Signed-off-by: Bjorn Helgaas \u0026lt;bhelgaas@google.com\u0026gt; Acked-by: Thomas Gleixner \u0026lt;tglx@linutronix.de\u0026gt; :040000 040000 765e2d5232d53247ec260b34b51589c3bccb36ae f680234a27685e94b1a35ae2a7218f8eafa9071a M\tarch :040000 040000 d55a682bcde72682e883365e88ad1df6186fd54d f82c470a04a6845fcf5e0aa934512c75628f798d M\tdrivers  이 커밋에 대한 자세한 정보를 얻기 위해 인터넷을 검색하니, 약간 허무하지만, 동일한 문제가 이미 보고되어 있었다.\n  PCI device driver broken between 4.2 and 4.3   TA1-PCI card worked in v4.2, fails in v4.3   해당 버그질라 에 간단한 댓글을 달면서 공식 해결 방법을 기다렸지만, 공식 커널에 적용되려면 너무 시간이 오래 걸릴 것 같아서 직접 드라이버 패치 를 만들어 적용했더니 문제없이 동작했다. 일종의 편법이긴 하지만, pci_register_driver() 함수를 미리 호출한 다음에 pci_get_device() 함수를 이용하는 원래 초기화 함수를 호출하도록 변경했다.\n그런데 조금 성급했는지, 아니면 심각한 버그라고 판단했는지 리눅스 4.5 RC 버전에 바로 반영 되었다.\ncommit 6c777e8799a93e3bdb67bec622429e1b48dc90fb Author: Bjorn Helgaas \u0026lt;bhelgaas@google.com\u0026gt; Date: Wed Feb 17 12:26:42 2016 -0600 Revert \u0026quot;PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq()\u0026quot; 991de2e59090 (\u0026quot;PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq()\u0026quot;) appeared in v4.3 and helps support IOAPIC hotplug. Олег reported that the Elcus-1553 TA1-PCI driver worked in v4.2 but not v4.3 and bisected it to 991de2e59090. Sunjin reported that the RocketRAID 272x driver worked in v4.2 but not v4.3. In both cases booting with \u0026quot;pci=routirq\u0026quot; is a workaround. I think the problem is that after 991de2e59090, we no longer call pcibios_enable_irq() for upstream bridges. Prior to 991de2e59090, when a driver called pci_enable_device(), we recursively called pcibios_enable_irq() for upstream bridges via pci_enable_bridge(). After 991de2e59090, we call pcibios_enable_irq() from pci_device_probe() instead of the pci_enable_device() path, which does *not* call pcibios_enable_irq() for upstream bridges. Revert 991de2e59090 to fix these driver regressions. Link: https://bugzilla.kernel.org/show_bug.cgi?id=111211 Fixes: 991de2e59090 (\u0026quot;PCI, x86: Implement pcibios_alloc_irq() and pcibios_free_irq()\u0026quot;) Reported-and-tested-by: Олег Мороз \u0026lt;oleg.moroz@mcc.vniiem.ru\u0026gt; Reported-by: Sunjin Yang \u0026lt;fan4326@gmail.com\u0026gt; Signed-off-by: Bjorn Helgaas \u0026lt;bhelgaas@google.com\u0026gt; Acked-by: Rafael J. Wysocki \u0026lt;rafael@kernel.org\u0026gt; CC: Jiang Liu \u0026lt;jiang.liu@linux.intel.com\u0026gt; arch/x86/include/asm/pci_x86.h | 2 ++ arch/x86/pci/common.c | 20 +++++++++++--------- arch/x86/pci/intel_mid_pci.c | 7 ++----- arch/x86/pci/irq.c | 15 ++++++++++++++- drivers/acpi/pci_irq.c | 9 ++++++++- 5 files changed, 37 insertions(+), 16 deletions(-)  참 좋은 세상이다 ;)\n","date":1457481600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1457481600,"objectID":"30b36ef21aadacb3378bdcaa12609bb7","permalink":"https://lethean.github.io/2016/03/09/git-bisect-linux-pci-driver-debugging/","publishdate":"2016-03-09T00:00:00Z","relpermalink":"/2016/03/09/git-bisect-linux-pci-driver-debugging/","section":"post","summary":"리눅스 커널 4.3 버전으로 업그레이드하면서부터 RocketRAID RAID 장치가 동작하지 않았다. 컴파일 오류도 없고 로딩에도 문제가 없는데, 응답이 너무 느려서 거의 동작하지 않는 거나","tags":["Git","Linux"],"title":"git bisect 이용한 리눅스 PCI 드라이버 디버깅","type":"post"},{"authors":null,"categories":null,"content":"요즘은 비동기 이벤트 루프가 필요하면 GLib 라이브러리 대신 libuv 라이브러리를 주로 사용한다.\nGLib 라이브러리의 기능은 거의 완벽하다. 하지만 아주 가끔 멀티 스레드 환경에서 idle 함수가 이유 없이 실행되지 않는다. 또한 여러 기능이 점점 추가되고 통합되면서 점점 무거워지고 있다. 게다가 이제는 단순히 리눅스 / 윈도 플랫폼뿐 아니라 Mac OS / iOS / Android 등과 같은 모바일 플랫폼까지 고려해야 하는데 GLib 라이브러리는 이 부분에서 매우 취약하다. 이로 인해 네트워킹에 특화되어 있으면서 상대적으로 더 가볍고 멀티 플랫폼에서 성능과 안정성이 더 많이 검증된 libuv 라이브러리를 사용하게 된다.\nlibuv 라이브러리는, 이미 대세를 지나 조금씩 거품이 빠지고 있는지도 모르는, Node.js 의 핵심 엔진이다. 처음 관심을 가졌던 때 와 달리 지금은 공식 사이트 와 API 문서 도 매우 잘 정리되어 있다.\n하지만 지난 몇 년간 libuv 라이브러리를 여기저기 사용해보니, 역시나 완벽한 소프트웨어는 없다고, 처음에는 좋은 점만 보이더니 이제는 아쉬움이 더해간다. 물론 그래도 당분간은 다른 대안이 없어서 계속 사용할 예정이기 때문에 그동안 틈틈이 적었던 기록(이라 적어 놓고 불만이라고 읽는 기록)을 정리해 본다.\n 비동기 이벤트 핸들에 우선순위 개념이 없어서 조금 아쉽다. 물론 GLib 메인 루프에만 있는 개념이고 대부분 비동기 이벤트 라이브러리에도 없기 때문에 필요하면 직접 구현해야 한다.\nuv_idle_t와 uv_prepare_t / uv_check_t 핸들의 차이는 무엇일까? uv_idle_t는 I/O 또는 uv_timer_t가 없어도 실행되도록 하기 위해 I/O 대기 시간(polling time)이 항상 0이 되어 CPU 사용률이 100%가 된다. 하지만, uv_prepare_t / uv_check_t 핸들은 I/O가 있을 때만 I/O 앞과 뒤에서 실행된다. 즉, I/O 작업이 없으면 아예 호출되지 않는다.\nuv_fs_*() 함수를 실행한 다음에 uv_fs_req_cleanup() 함수를 호출하지 않으면 메모리 누수 귀신을 만나게 된다. 파일 입출력을 TCP / UDP처럼 스트림 기반 비동기 방식으로 만들지 않은 이유를 모르겠다. 윈도 플랫폼에서 소켓과 파일이 전혀 다르기 때문에 그럴 수도 있지만 유닉스 기반에서는 오히려 더 좋은 성능을 보여줄 텐데 말이다.\nuv_timer_t에 반복(repeat)을 지정하면 정확한 주기에 동작한다. 예를 들어 5초 반복인데 콜백 함수가 2초간 실행되면 3초 후에 다시 실행된다. GLib의 g_timeout_*() 함수는 5초 간격(interval)이라면 콜백 함수가 2초간 실행되어도 5초 이후에 다시 실행된다.\n리눅스에서 시리얼 장치처럼 libuv가 직접 지원하지 않는 파일 디스크립터를 연결하려면 uv_poll_t를 사용하면 된다. uv_tty_t는 터미널이나 콘솔에만 사용해야 한다.\n다른 스레드가 특정 지점에 도달할 때까지 기다려야 한다면 uv_barrier_t를 사용하면 편리하다. 예를 들어 새 스레드를 생성하고 그 스레드가 특정 위치까지 실행될 때까지 대기하는 목적으로 사용하면 된다.\n하나의 uv_loop_t 개체와 연결된 모든 libuv 함수는 uv_run() 함수가 실행된 스레드에서만 호출되어야 한다. 심지어 uv_*_init() 함수도 같은 스레드에서 호출해야 한다. uv_async_send() 함수가 유일한 예외인데, 이것만 사용해서 스레드 간에 통신하기에는 조금 부족하다. 스레드 간 통신에 TCP / UDP / 파이프 등을 이용해도 되지만 오버헤드가 발생할 수밖에 없다. 예를 들어 GLib 같은 경우 특정 스레드에서 어떤 함수를 호출하고 싶으면 해당 스레드에서 실행 중인 루프의 콘텍스트에 g_idle_add() / g_timeout_add() 종류의 함수를 이용해서 쉽게 추가할 수 있다. 하지만 libuv에서는 메시지 큐 또는 채널 같은 자료구조를 구현해서 메시지를 전달하면 그 메시지를 해독해서 특정 함수를 실행하거나 작업을 진행해야 한다. 어쩌면 libuv / Node.js 개발자가 멀티 스레드를 지양하고 멀티 프로세스를 지향하는 구조를 선호하기 때문일 수도 있다. C 언어의 특성상 다양한 방식이 존재하기 때문에 필요에 따라 직접 구현해서 사용하기를 권장하는 건지도 모르겠다. 하지만 적어도 Go 언어의 채널 이나 Rust 언어의 채널 처럼 널리 사용되는 스레드 간 통신 방법을 libuv 라이브러리가 제공해주면 더 좋을 것 같다.\nuv_close() 함수를 호출해도 핸들의 리소스가 실제로 해제되는 시점이 uv_run() 루프 내부라는 점도 불편하다. 이 때문에 핸들과 연관된 리소스를 해제하기 위해 콜백 함수라는 한 단계를 더 거쳐야 한다. 이는 매우 귀찮은 작업인데, 수많은 libuv 예제 소스에는 리소스 해제를 고려하지 않고 대부분 static 변수를 사용하지만, 실전에서는 메모리 누수와 개체의 라이프 사이클을 신경 써야 하기 때문이다. 예를 들어 현재 TCP 연결을 끊고 나서 다른 정보로 다시 TCP 연결을 생성해야 할 때, 콜백 함수가 호출되기 전까지의 그 위험한 순간에 TCP 연결에 대한 핸들을 가리키는 변수에 접근하게 되면 재앙이 발생한다.\n 안전한 C 프로그래밍 을 하고 싶어도 동적인 메모리 할당 / 해제 작업을 피할 수가 없다. 물론 uv_read_start() 함수는 읽기 작업 전에 버퍼를 할당해야 하는 것처럼 보이지만 큰 버퍼를 미리 할당하고 포인터와 크기만 잘 조작해도 된다. 하지만 핸들 자체가 실행 중에 다른 인수로 다시 시작해야 하는 경우처럼 복잡한 단계를 거쳐야 하는 건 어쩔 수 없다.\nuv_read_start() 함수는 매우 편리하다. 그런데 연결이 끊기거가 에러가 발생했을때 문서 와 다른 패턴을 종종 경험한다.\n","date":1457395200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1457395200,"objectID":"7b78fecb32d30d43cd75ab172df0cf5d","permalink":"https://lethean.github.io/2016/03/08/note-about-libuv/","publishdate":"2016-03-08T00:00:00Z","relpermalink":"/2016/03/08/note-about-libuv/","section":"post","summary":"요즘은 비동기 이벤트 루프가 필요하면 GLib 라이브러리 대신 libuv 라이브러리를 주로 사용한다. GLib 라이브러리의 기능은 거의 완벽하다. 하지만 아주 가끔 멀티 스레드 환경에","tags":["libuv","GLib"],"title":"libuv 사용기","type":"post"},{"authors":null,"categories":null,"content":"git diff, git log 같은 명령어는 내부적으로 다시 less 프로그램을 사용합니다. 그런데 언젠가부터 갑자기 명령어가 끝나면 내용이 지워지면서 원래 화면이 표시되어 여간 불편했는데, 그 이유를 조사해 보니 Zsh 셸을 사용하면서 설치한 Oh My Zsh 때문이었습니다.\n~/.oh-my-zsh/lib/misc.zsh 파일에 다음과 같이 되어 있는데,\nexport PAGER=\u0026quot;less\u0026quot; export LESS=\u0026quot;-R\u0026quot;  아래와 같이 수정하면 됩니다.\nexport PAGER=\u0026quot;less\u0026quot; export LESS=\u0026quot;-R -F -X\u0026quot;  구글링으로 참조한 링크는 아래와 같습니다.\n  \u0026lsquo;less\u0026rsquo; command clearing screen upon exit - how to switch it off?   Is there any way to exit “less” without clearing the screen?   :)\n","date":1457308800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1457308800,"objectID":"7b5b48e8080315644d6b27b09671221d","permalink":"https://lethean.github.io/2016/03/07/exit-less-without-clearing-the-screen/","publishdate":"2016-03-07T00:00:00Z","relpermalink":"/2016/03/07/exit-less-without-clearing-the-screen/","section":"post","summary":"git diff, git log 같은 명령어는 내부적으로 다시 less 프로그램을 사용합니다. 그런데 언젠가부터 갑자기 명령어가 끝나면 내용이 지워지면서 원래 화면이 표시되어 여간 불편했는","tags":["Git","Less","Zsh"],"title":"less 명령어가 끝나도 내용을 지우지 않게 하기","type":"post"},{"authors":null,"categories":null,"content":"요즘 웹에는 글꼴 아이콘(font icon)을 많이 사용합니다. 벡터 그래픽 방식이라 확대해도 좋은 품질을 보여주고, 자주 사용되는 다양한 모양도 많이 제공됩니다. 덕분에 작은 규모의 팀에서 간단한 웹 사이트나 웹앱을 개발할 때, 디자이너의 도움(?)이 없어도 되기 때문에, 시간과 노력을 많이 절약하게 됩니다. 특히 라이센스도 자유로우면서 다양한 아이콘을 제공하는 글꼴 아이콘도 많은데, 대표적으로 Font Awesome , WebHostingHub Glyphs 등이 있습니다. 물론 구글 검색을 해보면 유료제품도 있고, 직접 만들어주는 도구까지 있습니다.\n그런데 글꼴 아이콘은 HTML과 CSS를 이용하는 웹 페이지에서는 쉽게 이용할 수 있지만, 데스크톱 / 임베디드 프로그램에서 사용하려면 약간 다른 방법을 사용해야 합니다. 이 글은 여러 방법 중에서 GTK+, Clutter 라이브러리에서 이용하는 Cairo 라이브러리를 이용해 Font Awesome 아이콘을 그리는 방법을 설명합니다.\n생각해 보면 간단할 것 같은데, 막상 Cairo API를 뒤져보면 글꼴 파일을 직접 지정하는 방법이 없습니다. 막강한 기능을 제공하는 Pango 라이브러리 역시 글꼴 파일을 지정하는 함수는 없습니다. 모두 Fontconfig 를 이용해 아이콘 글꼴 파일을 지정해야 합니다. 하지만 프로그램과 함께 배포해야 하는 아이콘 글꼴 파일을 시스템 글꼴 디렉터리나 사용자 글꼴 디렉터리에 복사하는 방식은 번거롭기도 하고 불가능한 경우도 있어서 가능하다면 글꼴 파일을 직접 사용하는 방법을 찾아보았습니다.\n(2015-05-06 업데이트: Pango 개발자가 더 자세히 설명한 Pango를 이용한 사용자 폰트 사용하기 문서를 참고해도 됩니다)\n그래서 찾은 방법은 다음과 같습니다.\n먼저 FreeType 라이브러리를 이용해 글꼴 파일을 읽은 후 cairo_ft_font_face_create_for_ft_face() 함수를 이용해 Cairo 글꼴을 만듭니다.\nstatic cairo_font_face_t * get_font_face (void) { static cairo_font_face_t *font_face = NULL; if (!font_face) { FT_Library ft_library; FT_Face ft_face; FT_Error ft_error; ft_error = FT_Init_FreeType (\u0026amp;ft_library); if (ft_error) { g_warning (\u0026quot;FT_Init_FreeType() failure: %d\u0026quot;, ft_error); return NULL; } ft_error = FT_New_Face (ft_library, \u0026quot;FontAwesome.otf\u0026quot;, 0, \u0026amp;ft_face); if (ft_error) { g_warning (\u0026quot;FT_New_Face() failure: %d\u0026quot;, ft_error); FT_Done_FreeType (ft_library); return NULL; } font_face = cairo_ft_font_face_create_for_ft_face (ft_face, 0); } return font_face; }  이제 Cairo 글꼴 함수를 이용해 아이콘을 그리면 됩니다. 참고로, 아래 코드에서는 ClutterColor 구조체를 이용해 아이콘 색상과 그림자 색상을 지정합니다.\nstatic void draw_font_icon (cairo_t *cr, double x, double y, int centering, const char *code, double size, const ClutterColor *color, const ClutterColor *shadow_color, double shadow_offset) { cairo_font_options_t *options; cairo_save (cr); options = cairo_font_options_create (); cairo_font_options_set_antialias (options, CAIRO_ANTIALIAS_GRAY); cairo_font_options_set_hint_style (options, CAIRO_HINT_STYLE_FULL); cairo_set_font_options (cr, options); cairo_font_options_destroy (options); cairo_set_font_face (cr, get_font_face ()); cairo_set_font_size (cr, size); { cairo_text_extents_t extents; cairo_text_extents (cr, code, \u0026amp;extents); if (!centering) { x -= extents.x_bearing; y -= extents.y_bearing; } else { x += (extents.x_bearing -extents.width * 0.5); y += (-extents.y_bearing -extents.height * 0.5); } } if (shadow_color \u0026amp;\u0026amp; shadow_color-\u0026gt;alpha \u0026gt; 0 \u0026amp;\u0026amp; shadow_offset != 0.0) { cairo_save (cr); cairo_move_to (cr, x + shadow_offset, y + shadow_offset); clutter_cairo_set_source_color (cr, shadow_color); cairo_show_text (cr, code); cairo_restore (cr); } clutter_cairo_set_source_color (cr, color); cairo_move_to (cr, x, y); cairo_show_text (cr, code); cairo_restore (cr); }  아이콘을 회전하려면 다음과 같이 미리 캔버스를 돌린 후에 아이콘을 그리면 됩니다. 예를 들어, ClutterCanvas::draw 시그널 핸들러는 다음과 같이 작성합니다.\nstatic gboolean draw_icon_content (ClutterCanvas *canvas, cairo_t *cr, gint width, gint height, gpointer user_data) { const double rotate_degree = 180.0; /* Clear the contents of the canvas. */ cairo_save (cr); cairo_set_operator (cr, CAIRO_OPERATOR_CLEAR); cairo_paint (cr); cairo_restore (cr); if (rotate_degree \u0026gt; 0.0) { cairo_translate (cr, width / 2, height / 2); cairo_rotate (cr, rotate_degree * (G_PI / 180.0)); cairo_translate (cr, - width / 2, - height / 2); } draw_font_icon (cr, ...); return TRUE; }  그런데 Font Awesome 아이콘 목록 에서 원하는 아이콘은 찾았는데, 아이콘 이름에 해당하는 실제 글꼴의 문자 코드(code)는 어떻게 알 수 있을까요? 웹 페이지를 무식하게 파싱해서 C 언어 헤더 파일을 자동으로 생성하는 Node.js 스크립트 를 이용하면 다음과 같은 결과를 얻을 수 있습니다.\n#define FA_ICON_ADJUST \u0026quot;\\xef\\x81\\x82\u0026quot; /* \u0026amp;#xf042; */ #define FA_ICON_ADN \u0026quot;\\xef\\x85\\xb0\u0026quot; /* \u0026amp;#xf170; */ #define FA_ICON_ALIGN_CENTER \u0026quot;\\xef\\x80\\xb7\u0026quot; /* \u0026amp;#xf037; */ #define FA_ICON_ALIGN_JUSTIFY \u0026quot;\\xef\\x80\\xb9\u0026quot; /* \u0026amp;#xf039; */ #define FA_ICON_ALIGN_LEFT \u0026quot;\\xef\\x80\\xb6\u0026quot; /* \u0026amp;#xf036; */ #define FA_ICON_ALIGN_RIGHT \u0026quot;\\xef\\x80\\xb8\u0026quot; /* \u0026amp;#xf038; */ #define FA_ICON_AMBULANCE \u0026quot;\\xef\\x83\\xb9\u0026quot; /* \u0026amp;#xf0f9; */ #define FA_ICON_ANCHOR \u0026quot;\\xef\\x84\\xbd\u0026quot; /* \u0026amp;#xf13d; */ #define FA_ICON_ANDROID \u0026quot;\\xef\\x85\\xbb\u0026quot; /* \u0026amp;#xf17b; */ #define FA_ICON_ANGELLIST \u0026quot;\\xef\\x88\\x89\u0026quot; /* \u0026amp;#xf209; */  :)\n","date":1425600000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1425600000,"objectID":"49352068a1976d0efd2914ba872b8d29","permalink":"https://lethean.github.io/2015/03/06/draw-font-awesome-icons-with-cairo/","publishdate":"2015-03-06T00:00:00Z","relpermalink":"/2015/03/06/draw-font-awesome-icons-with-cairo/","section":"post","summary":"요즘 웹에는 글꼴 아이콘(font icon)을 많이 사용합니다. 벡터 그래픽 방식이라 확대해도 좋은 품질을 보여주고, 자주 사용되는 다양한 모양도 많이 제공됩니","tags":["Cairo","Clutter","FontAwesome"],"title":"Cairo 라이브러리를 이용해 Font Awesome 아이콘 그리기","type":"post"},{"authors":null,"categories":null,"content":"systemd 데몬은 가끔 \u0026ldquo;Time has been changed\u0026quot;라는 로그 메시지를 출력합니다. 그래서 과연 어떤 방식으로 시간이 변경되는 이벤트를 감지하는지 궁금해서 소스 코드 를 한 번 들여다보았습니다.\n일반적으로 timerfd_create() 함수는 지연되어 실행하거나 주기적으로 처리해야 작업을 실행할 때 사용합니다. 맨 페이지의 예제 소스는 이러한 용도로 완벽합니다. 그런데 systemd에서는 timerfd_settime() 함수를 호출할 때 두 번째 인수에 TFD_TIMER_CANCEL_ON_SET 값을 전달합니다. 이 값은 맨 페이지에도 없어서 구글 검색을 해보니 glibc API 변경 문서 에서 다음과 같이 설명된 부분을 찾을 수 있었습니다.\n The timerfd_settime() system call adds a TFD_TIMER_CANCEL_ON_SET flag. If this flag is set for a CLOCK_REALTIME absolute (TFD_TIMER_ABSTIME) timer, then the timer is expired if the clock is reset.\n 즉, 커널 내부 시계(clock)가 초기화(reset)되면 타이머가 만기되어(expired) 이벤트가 발생한다는 내용입니다. 그리고 눈으로 읽는 것만으로는 역시 잊어버릴 것 같아서, 예제 프로그램을 간단하게 수정 해서 시간이 변경되는 여러 경우를 실험해보니, 직접 시간을 변경하거나 NTP 시간 동기화로 인한 시간 변경은 감지하는데, 시간대(time zone) 변경은 감지하지 못하는군요. 게다가 사람이 보기에는 같지만 아주 조금만 달라져도, 추측하기에는 시간 변경 함수가 호출만 되어도, 이벤트가 발생합니다. 게다가 시간이 앞으로 이동했는지 뒤로 이동했는지도 알 방법이 없고\u0026hellip;\n아무튼, 오늘도 역시 여전히 아는 것보다 모르는 게 더 많다는 사실을 새삼 깨닫게 된 하루입니다.\n","date":1424131200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1424131200,"objectID":"3508a0f36bdd2e14876d407055d70205","permalink":"https://lethean.github.io/2015/02/17/detect-time-change-with-timerfd-in-linux/","publishdate":"2015-02-17T00:00:00Z","relpermalink":"/2015/02/17/detect-time-change-with-timerfd-in-linux/","section":"post","summary":"systemd 데몬은 가끔 \u0026ldquo;Time has been changed\u0026quot;라는 로그 메시지를 출력합니다. 그래서 과연 어떤 방식으로 시간이 변경되는 이벤트를 감지하는지 궁금해서 소스 코","tags":["Linux","glibc"],"title":"리눅스에서 시간 변경 감지하기","type":"post"},{"authors":null,"categories":null,"content":"결론부터 말하자면 실패한 해킹에 대한 기록입니다.\nRaspberry Pi 2 장비를 하나 얻게 되어, 이삼일 정도 클러터(Clutter) 라이브러리가 제대로 동작하도록 삽질을 했습니다.\n구글에는 X 서버, 즉 X 윈도 없이 리눅스 프레임 버퍼 위에서 EGL + GLES2 API를 이용하는 방법은 많이 나와 있는데, X11 + EGL + GLES2 조합은 없어서 여기저기 구글링을 통해 얻은 정보를 이용해 Cogl 예제 디렉터리에 있는 프로그램들이, 비록 전체화면 방식이기는 하지만, 문제없이 실행되게 하는 데까지는 성공했습니다. ( 패치 파일 과 빌드 스크립트 )\n하지만 Clutter 예제 프로그램을 돌리면 여러 가지 경고를 내고 멈추거나 아무 메시지도 출력하지 않고 CPU 점유율만 차지하는 경우가 발생합니다. EGL + Raspberry Pi API가 전혀 생소한 것은 물론 Cogl + Clutter 연결 고리도 잘 모르지만, 다른 할 일도 많고, 내일모레부터는 설 연휴이기도 하고, 당장 급한 일도 아니라 일단 이 상태에서 작업을 멈추었습니다.\n혹시 Clutter / Cogl 라이브러리를 Raspberry Pi 상에서 깔끔하게 돌아가게 하는 패치나 소스를 알고 계신 분 있나요? 아마도 회사에서 업무로 Raspberry Pi를 건드리는 분 중에는 분명 이미 작업한 분이 있을 것 같은데\u0026hellip;\n시간이 지날수록 구글링 실력도 점점 줄어드는 것 같고\u0026hellip; :)\n","date":1424044800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1424044800,"objectID":"3a9bf1379548f4eddd19b719b18b2ebd","permalink":"https://lethean.github.io/2015/02/16/try-cogl-with-x11-on-raspberry-pi/","publishdate":"2015-02-16T00:00:00Z","relpermalink":"/2015/02/16/try-cogl-with-x11-on-raspberry-pi/","section":"post","summary":"결론부터 말하자면 실패한 해킹에 대한 기록입니다. Raspberry Pi 2 장비를 하나 얻게 되어, 이삼일 정도 클러터(Clutter) 라이브러리가 제대로 동작하도록 삽질을 했","tags":["Linux","RaspberryPi","Clutter"],"title":"Raspberry Pi + X11 + Clutter(+ Cogl)","type":"post"},{"authors":null,"categories":null,"content":"다음에 진행할 프로젝트를 위해 이더넷 프레임 패킷을 리눅스에서 소켓 API를 이용해 직접 읽고 쓰는 방법이 필요해서 조사한 결과를 남겨봅니다.\n언제나처럼 구글의 도움을 받아 발견한 \u0026ldquo; Receiving raw packets in Linux without pcap \u0026rdquo; 글의 코드를 참고해서 샘플로 구현한 소스는 여기 에서 확인할 수 있습니다.\n윈본 소스와 다른 점은, 알려져 있는 이더넷 타입 대신 자신만의 고유 타입을 사용하고, 브로드캐스트 주소도 인식하면서 간단한 메시지를 전송하거나 수신합니다.\n컴파일 방법은 다음과 같습니다.\n$ gcc -Wall -o ethcom ethcom.c  사용법은 -l 옵션을 주면 수신 모드로 동작하고, -i 옵션으로 네트워크 인터페이스 이름(기본 eth0)을 지정할 수 있고, -d 옵션으로 전송할 대상 주소(기본 ff:ff:ff:ff:ff:ff)를 지정할 수 있습니다. 예를 들어 다음과 같이 입력하면 \u0026lsquo;Hello, World\u0026rsquo; 문자열을 이더넷 네트워크에 브로드캐스트합니다.\n$ sudo ./ethcom \u0026quot;Hello, World\u0026quot;  다른 장비에서 수신 모드로 실행하면 다음과 같이 문자열을 수신합니다.\n$ sudo ./ethcom -l 60:a4:4c:xx:xx:xx -\u0026gt; ff:ff:ff:ff:ff:ff Hello, World  참고로, 실행할 때 반드시 루트(root) 권한이어야 합니다.\n","date":1423526400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1423526400,"objectID":"9a0db6417c10a471f371e3d4a8645caa","permalink":"https://lethean.github.io/2015/02/10/send-receive-raw-ethernet-frames-with-custom-ether-type-in-linux/","publishdate":"2015-02-10T00:00:00Z","relpermalink":"/2015/02/10/send-receive-raw-ethernet-frames-with-custom-ether-type-in-linux/","section":"post","summary":"다음에 진행할 프로젝트를 위해 이더넷 프레임 패킷을 리눅스에서 소켓 API를 이용해 직접 읽고 쓰는 방법이 필요해서 조사한 결과를 남겨봅니다. 언제나처럼 구글의 도","tags":["Linux","Network"],"title":"리눅스에서 이더넷 프레임 보내고 받기","type":"post"},{"authors":null,"categories":null,"content":"아무것도 하지 않고 기존 내용을 유지하는 목적으로 사용하던 sunjinyang.wordpress.com 사이트에서 최신 유행(?)이라고 할 수 있는 GitHub Pages 사이트로 블로그를 이전했습니다.\n다행히 기존 내용을 이전하는 작업은 별로 어렵지 않았습니다. 하지만 테마, 태그, 댓글 이전, 페이지 이동 등과 같은 기능을 추가하는 작업을 조금씩 더 해야할 것 같네요\u0026hellip;\n아무튼, 앞으로의 행보를 지켜봐 주시기 바라지 않습니다. ;)\n[Update: 2015-02-02] 태그(tags)를 비롯한 여러가지 부족한 기능을 채우는데 Nolboo\u0026rsquo;s Blog 사이트를 많이 참고했습니다.\n","date":1422403200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1422403200,"objectID":"327b43ad16c0ae4c2da06384016f5dd6","permalink":"https://lethean.github.io/2015/01/28/migration-to-github-page/","publishdate":"2015-01-28T00:00:00Z","relpermalink":"/2015/01/28/migration-to-github-page/","section":"post","summary":"아무것도 하지 않고 기존 내용을 유지하는 목적으로 사용하던 sunjinyang.wordpress.com 사이트에서 최신 유행(?)이라고 할 수 있는 GitHub Pages 사이트로 블로그를 이전했습니다. 다행히 기존 내용을","tags":null,"title":"깃허브 페이지로 블로그 다시 이전","type":"post"},{"authors":null,"categories":null,"content":"지금까지 회사 서버에 몰래 기생해서 운영하던 lethean.pe.kr 블로그를 워드프레스닷컴 서비스로 이전했습니다. 새 블로그 사이트 이름은 sunjinyang.wordpress.com 입니다. 그리고 당분간 블로그는 더 이상 작성하지 않을 생각입니다. 사실 이제는, 직접 사이트를 구축하고 관리하는 작업이 부담스럽기도 하고 귀찮기도 한 게 사실이지만, 무엇보다도 시간이 모자라네요\u0026hellip; 대신 이제부터는 요즘(?) 사람들처럼 이미 잘 구축된 다른 서비스를 이용해 볼 예정입니다.\n lethean.pe.kr 사이트는 아마 수일 내에 사라지거나 도메인이 유효하다면 자동으로 sunjinyang.wordpress.com 사이트로 포워딩됩니다. 워드프레스닷컴으로 옮기면서 기존 글 모두 그대로 이전하는 작업은 쉬었지만, 글 내부에 존재하는 기존 사이트에 대한 링크는 유효하지 않게 되었습니다. 이 경우 아마도 맨 앞의 사이트 이름만 바꿔주면 정상적으로 접속이 가능하리라 생각합니다.\n","date":1351728000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1351728000,"objectID":"8feba8365ef94ac83373079635573be0","permalink":"https://lethean.github.io/2012/11/01/blog-is-moved-here/","publishdate":"2012-11-01T00:00:00Z","relpermalink":"/2012/11/01/blog-is-moved-here/","section":"post","summary":"지금까지 회사 서버에 몰래 기생해서 운영하던 lethean.pe.kr 블로그를 워드프레스닷컴 서비스로 이전했습니다. 새 블로그 사이트 이름은 sunjinyang.wordpress.com 입니다. 그리고 당분간 블로그는 더 이상","tags":[],"title":"블로그 사이트 옮김","type":"post"},{"authors":null,"categories":null,"content":"GUI 설계 단계에서 사용하는 프로토타이핑(prototyping) 도구는 매우 많습니다. 그냥 김프(Gimp)나 포토샵, 잉크스케이프(Inkscape) 등과 같은 일반적인 그래픽 도구에 익숙한 사람에게는 더 이상의 도구가 필요없겠지만, 저처럼 디자인에 문외한인 프로그래머에게는 더 쉽고 자동화된 도구가 필요할 수 밖에 없습니다. 그래서, 그냥 오픈오피스나 파워포인트, 워드 등과 같은 오피스 슈트를 이용해서 그린 적도 있었고, 조금 더 특화된 비지오(Visio), 다이아(Dia) 등을 이용하기도 하다가 최근까지는 발사믹 목업(Balsamiq Mockups) 등과 같은 도구를 이용했습니다.\n리눅스를 기본 데스크탑으로 사용하면서 업무상 어쩔 수 없이 가끔 맥 / 윈도우를 사용하다보니 유료 소프트웨어를 사용하면 웬지 돈이 아깝다는 생각이 들 때가 있습니다. 리눅스에서는 필요한 소프트웨어를 대부분 그때 그때 패키지를 검색해서 설치하고, 배포판 패키지가 없으면 소스 가져다 컴파일 해서 사용하는 습관이 오랫동안 길들여져 있기도 하지만, 리눅스용 소프트웨어는 대부분 오픈 소스일 거라는 편견(!) 때문에, 가능하면 기능이 조금 부족하더라도, 어차피 제가 전문적으로 사용하지 않는다면, 유료 소프트웨어에 대한 오픈 소스 / 무료 소프트웨어 대안이 있으면 이를 사용하는 편입니다. (소프트웨어 개발로 밥먹는 프로그래머의 마인드가 이러면 안된다는 걸 알기에, 적어도 최소한의 양심으로, 불법복제 만큼은 피하고 있습니다)\n 에볼루스 펜슬(Evolus Pencil) 은 이러한 개인적인 취향에 딱 맞는 도구입니다. 한 블로그 글 에서 처음 접하게 되었는데, 알고 보니 꽤 유명한 도구입니다. 오픈 소스이면서 무료인 것은 물론, 리눅스 / 윈도우 / 맥 플랫폼을 모두 지원합니다. 또한 독립 어플리케이션처럼 실행할 수도 있고 파이어폭스 확장 기능으로 사용할 수도 있습니다. 작업한 내용을 HTML, PNG, PDF, ODT, SVG 형식으로 저장할 수도 있습니다. 그리고, 유료 도구인 발사믹 목업(Balsamiq Mockups) 만큼 다양하지는 않지만 다운로드해서 쉽게 추가할 수 있는 스텐실(stencil) 과 템플릿(template) 도 몇몇 제공합니다. 참고로, 공식 스텐실 다운로드 페이지에는 없는 다른 스텐실, 예를 들어 이전 버전 안드로이드나 iOS 스텐실은 다운로드 목록 을 잘 찾아보면 발견할 수 있습니다. 아마도 버전이 올라가면서 이전 버전용 스텐실이 잘 호환되지 않아서 링크가 사라진 것 같습니다.\n우리말로 이미 잘 소개된 동영상 튜토리얼 이 있기 때문에 더 자세한 설명은 생략합니다. 도움 되시길~\n참고로, 위의 폭포 사진은 엊그제 다녀온 강원도 철원 삼부연 폭포 전경입니다.\n","date":1341187200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1341187200,"objectID":"11a6967e51e25d3fa355853ab8bd5ca4","permalink":"https://lethean.github.io/2012/07/02/evolus-pencil-gui-prototyping-tool/","publishdate":"2012-07-02T00:00:00Z","relpermalink":"/2012/07/02/evolus-pencil-gui-prototyping-tool/","section":"post","summary":"GUI 설계 단계에서 사용하는 프로토타이핑(prototyping) 도구는 매우 많습니다. 그냥 김프(Gimp)나 포토샵, 잉크스케이프(Inkscape","tags":["GUI"],"title":"Evolus Pencil 프로토타이핑 도구","type":"post"},{"authors":null,"categories":null,"content":"그놈3 데스크탑 환경을 사용할때 불편했던 점 중 하나는, 프로그램을 실행하는 등의 창 작업을 위해 화면 상단 왼쪽 구석으로 마우스를 이동했을때 듀얼 모니터에서 마우스가 미끌어져 버리는 현상이었습니다. 그런데, 어느 날부터인가 이 현상, 즉 마우스를 화면 구석으로 이동해도 마우스가 다음 모니터로 미끌어져 넘어가는 현상이 발생하지 않았습니다. 제가 \u0026lsquo;어느 날\u0026rsquo;이라는 표현을 사용한 이유는, 아치 리눅스로 이전 한 이후로 아직까지 한 번도 시스템을 재설치하지 않고, 생각날 때마다 최소 2~3일에 한 번씩 패키지를 업그레이드하는 습관 때문입니다.\n그러다가 최근 LWN.net의 X11R7.7 릴리스 기사 에서 이런 내용을 읽게 되었습니다.\n Pointer barriers were added by X Fixes extension Version 5.0. Compositing managers and desktop environments may have UI elements in particular screen locations such that for a single-headed display they correspond to easy targets, for example, the top left corner. For a multi-headed environment these corners should still be semi-impermeable. Pointer barriers allow the application to define additional constraint on cursor motion so that these areas behave as expected even in the face of multiple displays.\n 즉, X Fixes 확장 기능 5.0 버전에 포인터 장벽(?)이라는게 추가되었는데, 어플리케이션이 커서 움직임에 제한을 더할 수 있도록 했다는 겁니다. 그리고 이를 이용하면 바로 정확하게 제가 경험한 것과 같은 멀티 모니터에서의 구석 마우스 미끄러짐 현상을 없앨 수 있다는 점도 부연하고 있습니다.\n사실 비슷한 문제가 제가 회사에서 개발 중인 프로그램에서도 발생하고 있었기 때문에 이 기능에 관심이 안 갈 수가 없었습니다. 그래서 조금 더 정확하게 확인하기 위해 그놈 셸 소스 코드를 조사했더니 아니나 다를까, 패널 박스 크기가 변경될때마다(\u0026ldquo;allocation-changed\u0026rdquo;) 호출되는 _updatePanelBarriers() 함수가 그 역할을 하고 있습니다. ( 2011년 7월 25일에 작성된 코드 군요\u0026hellip;)\n_updatePanelBarriers: function() { if (this._leftPanelBarrier) global.destroy_pointer_barrier(this._leftPanelBarrier); if (this._rightPanelBarrier) global.destroy_pointer_barrier(this._rightPanelBarrier); if (this.panelBox.height) { let primary = this.primaryMonitor; this._leftPanelBarrier = global.create_pointer_barrier(primary.x, primary.y, primary.x, primary.y + this.panelBox.height, 1 /* BarrierPositiveX */); this._rightPanelBarrier = global.create_pointer_barrier(primary.x + primary.width, primary.y, primary.x + primary.width, primary.y + this.panelBox.height, 4 /* BarrierNegativeX */); } else { this._leftPanelBarrier = 0; this._rightPanelBarrier = 0; } }  위 자바스크립트 코드가 호출하는 실제 C 함수 코드 는 다음과 같습니다.\n/** * shell_global_create_pointer_barrier: * @global: a #ShellGlobal * @x1: left X coordinate * @y1: top Y coordinate * @x2: right X coordinate * @y2: bottom Y coordinate * @directions: The directions we're allowed to pass through * * If supported by X creates a pointer barrier. * * Return value: value you can pass to shell_global_destroy_pointer_barrier() */ guint32 shell_global_create_pointer_barrier (ShellGlobal *global, int x1, int y1, int x2, int y2, int directions) { #if HAVE_XFIXESCREATEPOINTERBARRIER return (guint32) XFixesCreatePointerBarrier (global-\u0026gt;xdisplay, DefaultRootWindow (global-\u0026gt;xdisplay), x1, y1, x2, y2, directions, 0, NULL); #else return 0; #endif } /** * shell_global_destroy_pointer_barrier: * @global: a #ShellGlobal * @barrier: a pointer barrier * * Destroys the @barrier created by shell_global_create_pointer_barrier(). */ void shell_global_destroy_pointer_barrier (ShellGlobal *global, guint32 barrier) { #if HAVE_XFIXESCREATEPOINTERBARRIER g_return_if_fail (barrier \u0026gt; 0); XFixesDestroyPointerBarrier (global-\u0026gt;xdisplay, (PointerBarrier)barrier); #endif }  XFixesCreatePointerBarrier() / XFixesDestroyPointerBarrier() 함수에 대한 더 자세한 사용법을 확인하기 위해 XFIXES 공식 프로토콜 문서 를 확인해 보니 마지막에 다음과 같은 API 설명이 있습니다.\n12. Pointer Barriers ... 12.1 Types BARRIER: XID BarrierDirections BarrierPositiveX: 1 \u0026lt;\u0026lt; 0 BarrierPositiveY: 1 \u0026lt;\u0026lt; 1 BarrierNegativeX: 1 \u0026lt;\u0026lt; 2 BarrierNegativeY: 1 \u0026lt;\u0026lt; 3 12.3 Requests CreatePointerBarrier barrier: BARRIER drawable: DRAWABLE x1, y2, x2, y2: INT16 directions: CARD32 devices: LISTofDEVICEID Creates a pointer barrier along the line specified by the given coordinates on the screen associated with the given drawable. The barrier has no spatial extent; it is simply a line along the left or top edge of the specified pixels. Barrier coordinates are in screen space. The coordinates must be axis aligned, either x1 == x2, or y1 == y2, but not both. The varying coordinates may be specified in any order. For x1 == x2, either y1 \u0026gt; y2 or y1 \u0026lt; y2 is valid. If the coordinates are not valid BadValue is generated. Motion is allowed through the barrier in the directions specified: setting the BarrierPositiveX bit allows travel through the barrier in the positive X direction, etc. Nonsensical values (forbidding Y axis travel through a vertical barrier, for example) and excess set bits are ignored. If the server supports the X Input Extension version 2 or higher, the devices element names a set of master device to apply the barrier to. If XIAllDevices or XIAllMasterDevices are given, the barrier applies to all master devices. If a slave device is named, BadDevice is generated; this does not apply to slave devices named implicitly by XIAllDevices. Naming a device multiple times is legal, and is treated as though it were named only once. If a device is removed, the barrier continues to apply to the remaining devices, but will not apply to any future device with the same ID as the removed device. Nothing special happens when all matching devices are removed; barriers must be explicitly destroyed. Errors: IDChoice, Window, Value, Device DestroyPointerBarrier barrier: BARRIER Destroys the named barrier.  포인터 장벽은 반드시 화면 구석에서만 사용할 수 있는 게 아니라 화면 어느 곳에나 생성할 수 있으며, 장벽 생성시 지정한 방향(direction)으로만 마우스 커서가 이동할 수 있도록 허용합니다. 다시 말해 마우스 커서가 반대 방향으로는 장벽을 넘어갈 수 없게 합니다.방향과 함께 장벽의 영역 좌표를 지정해야 하는데, 예를 들어 왼쪽에서 오른쪽이라면 Y 좌표값만 다르고 X 좌표값을 동일하게 지정해야 합니다. 즉, 세로로 장벽 선을 그리면 됩니다. 그런데, 사실 화면 구석에서는 원하는 대로 동작하는데, 화면 임의의 위치에 포인터 장벽을 생성해 보면 마우스 커서의 대각선 움직임 등은 허용하기 때문에 아주 정확하게 원하는 대로 동작하지 않을 수도 있습니다.\n참고로 상위 툴킷에서 X 윈도우 API 호출에 사용하는 Display, Window 핸들을 얻으려면, Clutter의 경우 clutter_x11_get_default_display() / clutter_x11_get_stage_window() 또는 clutter_x11_get_root_window() 함수를 이용하면 됩니다. GTK+ 역시 GDK 관련 API를 뒤져 보시면 됩니다. ;)\n","date":1341187200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1341187200,"objectID":"b20a30d9027541b642f624afc19d86b5","permalink":"https://lethean.github.io/2012/07/02/mouse-pointer-barriers-in-x-window/","publishdate":"2012-07-02T00:00:00Z","relpermalink":"/2012/07/02/mouse-pointer-barriers-in-x-window/","section":"post","summary":"그놈3 데스크탑 환경을 사용할때 불편했던 점 중 하나는, 프로그램을 실행하는 등의 창 작업을 위해 화면 상단 왼쪽 구석으로 마우스를 이동했을때 듀얼 모니터에서 마우스","tags":["GTK+","Xorg"],"title":"X 윈도우 마우스 포인터 장벽(barrier)","type":"post"},{"authors":null,"categories":null,"content":"리눅스에서 IP 주소가 변경되었거나 링크 상태 변경 여부(예를 들어 랜선이 꽂히거나 빠졌을때)를 자동으로 감지하는 C 코드입니다. ifconfig 명령등의 결과를 파싱하는 방법이 아닌 리눅스 커널 rtnetlink(7) 프로토콜과 getifaddrs() 함수를 이용해 직접 처리합니다. 참조한 소스는 여러군데가 있는데 모두 구글링이 가능하므로 결과물만 기록으로 남겨둡니다.\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;errno.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; #include \u0026lt;ifaddrs.h\u0026gt; #include \u0026lt;net/if.h\u0026gt; #include \u0026lt;netdb.h\u0026gt; #include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;linux/netlink.h\u0026gt; #include \u0026lt;linux/rtnetlink.h\u0026gt; static int create_sock (const char *nic) { struct sockaddr_nl addr; int sock; memset (\u0026amp;addr, 0, sizeof (addr)); addr.nl_family = AF_NETLINK; addr.nl_groups = RTMGRP_LINK | RTMGRP_IPV4_IFADDR | RTMGRP_IPV6_IFADDR; sock = socket (PF_NETLINK, SOCK_RAW, NETLINK_ROUTE); if (sock \u0026lt; 0) { fprintf (stderr, \u0026quot;failed to open NETLINK_ROUTE socket for %s - %s(%d)\u0026quot;, nic, strerror (errno), errno); return -1; } if (bind (sock, (struct sockaddr *)\u0026amp;addr, sizeof(addr)) \u0026lt; 0) { fprintf (stderr, \u0026quot;failed to bind NETLINK_ROUTE socket for %s - %s(%d)\u0026quot;, nic, strerror (errno), errno); close (sock); return -1; } return sock; } static int ip_changed (int sock, const char *nic) { struct nlmsghdr *nlh; char buffer[4096]; int len; int idx; int found; len = recv (sock, buffer, sizeof (buffer), 0); if (len \u0026lt;= 0) { fprintf (stderr, \u0026quot;NETLINK_ROUTE socket recv() failedn\u0026quot;); return -1; } found = 0; idx = if_nametoindex (nic); for (nlh = (struct nlmsghdr *)buffer; NLMSG_OK (nlh, len); nlh = NLMSG_NEXT (nlh, len)) { if (nlh-\u0026gt;nlmsg_type == NLMSG_DONE) break; if (nlh-\u0026gt;nlmsg_type == NLMSG_ERROR) continue; if (!(NLMSG_OK (nlh, len))) continue; switch (nlh-\u0026gt;nlmsg_type) { case RTM_NEWADDR: { struct ifaddrmsg *ifa = (struct ifaddrmsg *)NLMSG_DATA (nlh); if (ifa-\u0026gt;ifa_index == idx) found = 1; } break; case RTM_NEWLINK: { struct ifinfomsg *ifi = (struct ifinfomsg *)NLMSG_DATA (nlh); if (ifi-\u0026gt;ifi_index == idx) found = 1; } break; default: break; } } return found; } static int get_nic_addr (const char *nic, struct ifaddrs *ifaddr, int wanted_family, char *host, int host_len, int *active) { struct ifaddrs *ifa; for (ifa = ifaddr; ifa != NULL; ifa = ifa-\u0026gt;ifa_next) { int family; int s; if (ifa-\u0026gt;ifa_addr == NULL) continue; if (strcmp (ifa-\u0026gt;ifa_name, nic)) continue; /* Skip unwanted families. */ family = ifa-\u0026gt;ifa_addr-\u0026gt;sa_family; if (family != wanted_family) continue; *active = (ifa-\u0026gt;ifa_flags \u0026amp; IFF_RUNNING) ? 1 : 0; s = getnameinfo (ifa-\u0026gt;ifa_addr, family == AF_INET ? sizeof (struct sockaddr_in) : sizeof (struct sockaddr_in6), host, host_len, NULL, 0, NI_NUMERICHOST); if (s != 0) { fprintf (stderr, \u0026quot;failed to getnameinfo() for '%s - %s(%d)\u0026quot;, ifa-\u0026gt;ifa_name, strerror (errno), errno); continue; } /* Get the address of only the first network interface card. */ return 1; } return 0; } static void print_ip (const char *nic) { struct ifaddrs *ifaddr; char addr[NI_MAXHOST]; int active; if (getifaddrs (\u0026amp;ifaddr) == -1) { fprintf (stderr, \u0026quot;failed to getifaddrs() - %s(%d)\u0026quot;, strerror (errno), errno); return; } if (!get_nic_addr (nic, ifaddr, AF_INET, addr, sizeof (addr), \u0026amp;active)) if (!get_nic_addr (nic, ifaddr, AF_INET6, addr, sizeof (addr), \u0026amp;active)) { strcpy (addr, \u0026quot;127.0.0.1\u0026quot;); active = 0; } freeifaddrs (ifaddr); fprintf (stdout, \u0026quot;%s is %s (link %s)n\u0026quot;, nic, addr, active ? \u0026quot;active\u0026quot; : \u0026quot;inactive\u0026quot;); } int main (void) { char *nic = \u0026quot;eth0\u0026quot;; int sock; print_ip (nic); sock = create_sock (nic); if (sock \u0026lt; 0) return -1; while (1) { int ret; ret = ip_changed (sock, nic); if (ret \u0026lt; 0) return -1; if (ret) print_ip (nic); } close (sock); return 0; } /* Local Variables: mode:c c-file-style:\u0026quot;gnu\u0026quot; indent-tabs-mode:nil End: vim:autoindent:filetype=c:expandtab:shiftwidth=2:softtabstop=2:tabstop=8 */  참고로 위 소스에서 네트웍 인터페이스 설정 변경을 감지하기 위해 사용한 소켓 파일 디스크립터(socket file descriptor)는 select() / poll() 등을 이용해 비동기적으로 감시하는 것도 가능합니다. 당연하지만, GLib 메인루프 의 g_io_add_watch() 등을 이용해도 됩니다.\n[UPDATE 2012-03-21] rtnetlink(7) 프로토콜의 기반이 되는 netlink(7) 프로토콜에 대해 더 자세히 알고 싶다면 Netlink 라이브러리의 Netlink 프로토콜 기초 문서 를 참고하기 바랍니다.\n","date":1332115200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1332115200,"objectID":"80b3578a80937ae63223364ef7e9b951","permalink":"https://lethean.github.io/2012/03/19/detect-change-of-ip-address-and-link-status-in-linux/","publishdate":"2012-03-19T00:00:00Z","relpermalink":"/2012/03/19/detect-change-of-ip-address-and-link-status-in-linux/","section":"post","summary":"리눅스에서 IP 주소가 변경되었거나 링크 상태 변경 여부(예를 들어 랜선이 꽂히거나 빠졌을때)를 자동으로 감지하는 C 코드입니다. ifconfig 명령등의 결과를 파싱하는 방법","tags":["GLib","glibc","Linux","Network"],"title":"리눅스 IP 주소 / 링크 상태 변경 여부 감지하기","type":"post"},{"authors":null,"categories":null,"content":"거의 2년만에 GObject 객체 지향 프로그래밍 연재 글을 포스팅합니다. 사실 이 글의 일부는 예전에 작성해 둔 것인데, 이번 GNOME Tech Talks 에서 발표 하나를 맡게 되면서, 슬라이드 자료를 따로 만들 시간은 없고 그렇다고 오래된 자료를 재탕하는 건 실례인 것 같아 조금 보완해서 작성했습니다. 참고로, GObject 개념을 잘 모르는 분이라면 이전 연재 글을 먼저 읽어 보시면 도움이 될 수 있습니다. :)\n  GObject 객체 지향 프로그래밍 (1)   GObject 객체 지향 프로그래밍 (2)   GObject 객체 지향 프로그래밍 (3)   GObject 객체 지향 프로그래밍 (4)   싱글턴(Singleton) GObject 객체 만들기   GObject 속성 직렬화(Serialization)하기   GObject 객체 지향 시스템을 구성하는 여러가지 개념 중 상속(inheritance), 참고 카운터(reference counting), 속성(properties) 등에 대해서는 지난 글에서 이미 소개했습니다. 아직 GObject 라이브러리에서 소개하지 않은 개념이 아직 많이 남아 있지만, 그 중에서 가장 중요한 것 중 하나는 바로 시그널(signals)이 아닐까 생각합니다. 속성이 변경되었을때 자동으로 호출되는 콜백 함수를 등록해서 사용하는 방법을 설명할 때 약간 소개했지만, 아무래도 그걸로는 부족하기 때문에 이번 글은 시그널의 개념과 사용 방법, 그리고 속성 바인딩을 정리해 보았습니다.\n간단한 클러터 기반 시계\n언제나 그렇듯이 재미없는 예제 소스를 먼저 보여드립니다. 이 소스를 컴파일해서 실행하면 위 그림과 같은 시계가 동작합니다.\n/* myclock1.c */ /*****************************************************************************/ #include \u0026lt;glib-object.h\u0026gt; #define MY_TYPE_CLOCK (my_clock_get_type ()) #define MY_CLOCK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), MY_TYPE_CLOCK, MyClock)) #define MY_CLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), MY_TYPE_CLOCK, MyClockClass)) #define MY_IS_CLOCK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MY_TYPE_CLOCK)) #define MY_IS_CLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MY_TYPE_CLOCK)) #define MY_CLOCK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), MY_TYPE_CLOCK, MyClockClass)) typedef struct _MyClock MyClock; typedef struct _MyClockClass MyClockClass; typedef struct _MyClockPrivate MyClockPrivate; struct _MyClock { GObject parent; MyClockPrivate *priv; }; struct _MyClockClass { GObjectClass parent_class; }; enum { PROP_0, PROP_DATE_TIME, PROP_LAST }; struct _MyClockPrivate { GDateTime *datetime; guint timeout; }; G_DEFINE_TYPE (MyClock, my_clock, G_TYPE_OBJECT); static GParamSpec *props[PROP_LAST]; GDateTime * my_clock_get_date_time (MyClock *clock_) { g_return_val_if_fail (MY_IS_CLOCK (clock_), NULL); return g_date_time_ref (clock_-\u0026gt;priv-\u0026gt;datetime); } static void my_clock_set_date_time (MyClock *clock_, GDateTime *datetime) { g_date_time_unref (clock_-\u0026gt;priv-\u0026gt;datetime); clock_-\u0026gt;priv-\u0026gt;datetime = g_date_time_ref (datetime); g_object_notify_by_pspec (G_OBJECT (clock_), props[PROP_DATE_TIME]); } static gboolean my_clock_update (gpointer data) { MyClock *clock_ = data; GTimeVal now; GDateTime *datetime; guint interval; g_get_current_time (\u0026amp;now); datetime = g_date_time_new_from_timeval_local (\u0026amp;now); my_clock_set_date_time (clock_, datetime); g_date_time_unref (datetime); interval = (1000000L - now.tv_usec) / 1000L; clock_-\u0026gt;priv-\u0026gt;timeout = g_timeout_add_full (G_PRIORITY_HIGH_IDLE, interval, my_clock_update, g_object_ref (clock_), g_object_unref); return FALSE; } static void my_clock_set_property (GObject *object, guint param_id, const GValue *value, GParamSpec *pspec) { switch (param_id) { default: G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec); break; } } static void my_clock_get_property (GObject *object, guint param_id, GValue *value, GParamSpec *pspec) { MyClock *clock_ = MY_CLOCK (object); switch (param_id) { case PROP_DATE_TIME: g_value_set_boxed (value, clock_-\u0026gt;priv-\u0026gt;datetime); break; default: G_OBJECT_WARN_INVALID_PROPERTY_ID (object, param_id, pspec); break; } } static void my_clock_finalize (GObject *gobject) { MyClockPrivate *priv = MY_CLOCK (gobject)-\u0026gt;priv; g_date_time_unref (priv-\u0026gt;datetime); g_source_remove (priv-\u0026gt;timeout); G_OBJECT_CLASS (my_clock_parent_class)-\u0026gt;finalize (gobject); } static void my_clock_class_init (MyClockClass *klass) { GObjectClass *obj_class = G_OBJECT_CLASS (klass); GParamSpec *pspec; obj_class-\u0026gt;set_property = my_clock_set_property; obj_class-\u0026gt;get_property = my_clock_get_property; obj_class-\u0026gt;finalize = my_clock_finalize; g_type_class_add_private (klass, sizeof (MyClockPrivate)); pspec = g_param_spec_boxed (\u0026quot;datetime\u0026quot;, \u0026quot;Date and Time\u0026quot;, \u0026quot;The date and time to show in the clock\u0026quot;, G_TYPE_DATE_TIME, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS); props[PROP_DATE_TIME] = pspec; g_object_class_install_property (obj_class, PROP_DATE_TIME, pspec); } static void my_clock_init (MyClock *clock_) { MyClockPrivate *priv; priv = clock_-\u0026gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (clock_, MY_TYPE_CLOCK, MyClockPrivate); priv-\u0026gt;datetime = g_date_time_new_now_local (); priv-\u0026gt;timeout = 0; my_clock_update (clock_); } MyClock * my_clock_new (void) { return g_object_new (MY_TYPE_CLOCK, NULL); } /*****************************************************************************/ #include \u0026lt;clutter/clutter.h\u0026gt; static void clock_datetime_changed (GObject *object, GParamSpec *pspec, gpointer data) { MyClock *clock_ = MY_CLOCK (object); ClutterActor *text = data; GDateTime *datetime; gchar *str; datetime = my_clock_get_date_time (clock_); str = g_date_time_format (datetime, \u0026quot;%xn%H:%M:%S\u0026quot;); clutter_text_set_text (CLUTTER_TEXT (text), str); g_free (str); g_date_time_unref (datetime); } int main (int argc, char **argv) { ClutterActor *stage; ClutterActor *text; ClutterConstraint *constraint; MyClock *clock_; if (clutter_init (\u0026amp;argc, \u0026amp;argv) != CLUTTER_INIT_SUCCESS) return -1; /* stage */ stage = clutter_stage_get_default (); clutter_actor_set_size (stage, 320, 240); clutter_stage_set_color (CLUTTER_STAGE (stage), CLUTTER_COLOR_Black); clutter_stage_set_user_resizable (CLUTTER_STAGE (stage), TRUE); /* text */ text = clutter_text_new_full (\u0026quot;Sans Bold 20\u0026quot;, \u0026quot;NOW\u0026quot;, CLUTTER_COLOR_LightButter); clutter_container_add_actor (CLUTTER_CONTAINER (stage), text); clutter_text_set_line_alignment (CLUTTER_TEXT (text), PANGO_ALIGN_CENTER); /* align text in center of stage */ constraint = clutter_align_constraint_new (stage, CLUTTER_ALIGN_X_AXIS, 0.5); clutter_actor_add_constraint (text, constraint); constraint = clutter_align_constraint_new (stage, CLUTTER_ALIGN_Y_AXIS, 0.5); clutter_actor_add_constraint (text, constraint); /* clock */ clock_ = my_clock_new (); g_signal_connect (clock_, \u0026quot;notify::datetime\u0026quot;, G_CALLBACK (clock_datetime_changed), text); clutter_actor_show (stage); clutter_main (); return 0; }  소스 코드를 간단하게 설명하면, MyClock 객체가 1초 간격으로 현재 시간을 얻어와 자신의 datetime 속성을 갱신하면[my_clock_update()], 속성이 변경되었을때(notify::datetime) 자동으로 호출되는 콜백 함수를[clock_datetime_changed()] 등록해 자동으로 클러터 텍스트(ClutterText)를 이용해 화면에 표시합니다.\n이제 이 소스 코드를 두 가지 방법으로 확장하려고 합니다. 첫번째 방법은 속성 바인딩(property binding)을 이용해 시그널을 사용하지 않는 방법이고, 두번째 방법은 시간이 변경되었을때 호출되는 진짜(!) 시그널을 추가하는 것입니다.\n속성 바인딩 (Property Binding)\n속성 바인딩(property binding)이란 두 GObject 객체간의 두 속성을 묶는 걸 말합니다. 여기서 묶는다는 의미는, 한 객체의 속성 값이 변하면 다른 객체의 속성 값도 자동으로 변한다는 의미입니다. 물론 묶으려는 두 속성은 같은 형(type)이어야 합니다. 그런데, 위 예제의 경우 MyClock:``datetime 속성과 ClutterText:``text 속성은 형(type)이 다릅니다. 그래서, 위 소스를 다음과 같이 수정합니다. (변경된 부분만 보여 드립니다)\n/* myclock2.c */ /* ... */ enum { PROP_0, PROP_DATE_TIME, PROP_TEXT, PROP_LAST }; struct _MyClockPrivate { GDateTime *datetime; guint timeout; gchar *text; }; /* ... */ const gchar * my_clock_get_text (MyClock *clock_) { g_return_val_if_fail (MY_IS_CLOCK (clock_), NULL); return clock_-\u0026gt;priv-\u0026gt;text; } static void my_clock_set_date_time (MyClock *clock_, GDateTime *datetime) { g_date_time_unref (clock_-\u0026gt;priv-\u0026gt;datetime); clock_-\u0026gt;priv-\u0026gt;datetime = g_date_time_ref (datetime); g_object_notify_by_pspec (G_OBJECT (clock_), props[PROP_DATE_TIME]); g_free (clock_-\u0026gt;priv-\u0026gt;text); clock_-\u0026gt;priv-\u0026gt;text = g_date_time_format (datetime, \u0026quot;%xn%H:%M:%S\u0026quot;); g_object_notify_by_pspec (G_OBJECT (clock_), props[PROP_TEXT]); } /* ... */ static void my_clock_finalize (GObject *gobject) { /* ... */ g_free (priv-\u0026gt;text); /* ... */ } static void my_clock_class_init (MyClockClass *klass) { /* ... */ pspec = g_param_spec_string (\u0026quot;text\u0026quot;, \u0026quot;Text\u0026quot;, \u0026quot;The text of the date and time\u0026quot;, NULL, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS); props[PROP_TEXT] = pspec; g_object_class_install_property (obj_class, PROP_TEXT, pspec); } static void my_clock_init (MyClock *clock_) { /* ... */ priv-\u0026gt;text = NULL; /* ... */ } /* ... */ int main (int argc, char **argv) { /* ... */ /* clock */ clock_ = my_clock_new (); g_object_bind_property (clock_, \u0026quot;text\u0026quot;, text, \u0026quot;text\u0026quot;, G_BINDING_SYNC_CREATE); /* ... */ }  위 코드에서 변경된 내용은, MyClock에 문자열 형식의 text 속성을 추가하고[my_clock_class_init()], datetime 속성을 갱신할때 text 속성도 함께 갱신하도록 한 다음[my_clock_set_date_time()], 기존 속성 변경(notify::datetime)에 대한 g_signal_connect() 함수 호출 대신 g_object_bind_property() 함수를 이용해 두 객체의 속성을 묶었다는 점입니다. 여기서 핵심은 물론 g_object_bind_property() 함수인데, 이 함수는 GLib 2.26 버전에 추가 되었으며 예전에 소개한 ExoBinding 과 사용법이 거의 유사합니다. 물론, 옵션을 통해 바인딩하는 시점부터 값을 동기화할 지(G_BINDING_SYNC_CREATE), 단방향이 아닌 양방향으로 동기화할 지(G_BINDING_BIDIRECTIONAL) 등을 지정할 수도 있습니다. 이처럼, 위의 코드에서 볼 수 있듯이, 속성 바인딩을 이용하면 매번 콜백함수를 만들지 않고도 간단하게 코드 몇 줄로 원하는 객체 속성간의 동기화(synchronization)를 처리할 수 있습니다.\n여담이지만, 처음 이 기능을 접했을때 맥, 아이폰 응용 프로그램을 개발하기 위해 XCode에서 마우스 드래그 만으로 객체 속성간 바인딩이 지원되는 것처럼, 코딩이 아닌, Glade 같은 GUI 도구에서 위젯 속성간 바인딩이 지원되면 참 편하지 않을까 하는 생각이 들었던 적도 있습니다.\n시그널 (Signals)\n GObject 공식 매뉴얼 에 의하면 시그널(signals)은 메시지 전달 시스템을 구성하는 두가지 기술 중 하나입니다. 하나는 클로저(closures)이고 다른 하나가 시그널(signals)인데, 클로저가 콜백(callback) 함수를 자료구조로 정의한 거라면, 시그널은 이 콜백함수를 등록하고 호출하는 알고리즘을 정의한 것이라고 이해해도 무방합니다.\n클로저를 다시 정의하지 않고 함수 포인터를 직접 사용해도 될 것 같은데 이를 객체로 정의한 이유는 여러가지가 있지만, 무엇보다도 콜백함수에 전달되는 인자(parameters) 목록과 인자 형(type)에 대한 처리(marshalling) 때문입니다. C/C++ 언어에서 함수 호출시 스택에 쌓이는 인자를 가공하는 것 뿐 아니라, GObject가 지원하는 여러 언어에 대한 바인딩을 위해 더 일반화된 클로저(closure) 객체가 필요합니다.\n아무튼, 이론적인 설명은 그만하고 다시 본론으로 돌아와서, 위 예제에서 구현한 MyClock 객체가 생각보다 잘 설계되고 동작하는 바람에(\u0026hellip;) 프로그램 전체에서 이 객체를 사용하기로 결정했다고 가정해 봅시다. 수많은 모듈과 수많은 객체에서 전역 시계 객체에 속성 알림(notify) 시그널을 연결합니다. 그리고 그때마다 my_clock_get_date_time()을 호출해 현재 시간을 가져와서 처리합니다. 물론 이 예제에서 전달되는 GDateTime 구조체는 참조 카운터 방식으로 관리되기 때문에 구조체 전달시 많은 오버헤드가 없지만, 문자열을 복사하거나 많은 데이터가 전달되는 경우라면 무시할 수 없는 상황이 발생합니다. 그래서, 위 첫번째 소스를 다음과 같이 조금 수정합니다.\n/* myclock3.c */ /* ... */ struct _MyClockClass { GObjectClass parent_class; /* signals */ void (*changed) (MyClock *clock_, GDateTime *datetime); }; enum { SIGNAL_CHANGED, SIGNAL_LAST }; /* ... */ static guint signals[SIGNAL_LAST]; /* ... */ static void my_clock_set_date_time (MyClock *clock_, GDateTime *datetime) { /* ... */ } static void my_clock_real_changed (MyClock *clock_, GDateTime *datetime) { my_clock_set_date_time (clock_, datetime); } static gboolean my_clock_update (gpointer data) { /* ... */ datetime = g_date_time_new_from_timeval_local (\u0026amp;now); g_signal_emit (clock_, signals[SIGNAL_CHANGED], 0, datetime); g_date_time_unref (datetime); /* ... */ } static void my_clock_class_init (MyClockClass *klass) { /* ... */ klass-\u0026gt;changed = my_clock_real_changed; signals[SIGNAL_CHANGED] = g_signal_new (\u0026quot;changed\u0026quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (MyClockClass, changed), NULL, NULL, g_cclosure_marshal_VOID__POINTER, G_TYPE_NONE, 1, G_TYPE_POINTER); } /* ... */ static void clock_changed (MyClock *clock_, GDateTime *datetime, gpointer user_data) { ClutterActor *text = user_data; gchar *str; str = g_date_time_format (datetime, \u0026quot;%xn%H:%M:%S\u0026quot;); clutter_text_set_text (CLUTTER_TEXT (text), str); g_free (str); } int main (int argc, char **argv) { /* ... */ /* clock */ clock_ = my_clock_new (); g_signal_connect (clock_, \u0026quot;changed\u0026quot;, G_CALLBACK (clock_changed), text); /* ... */ }  바로 위 코드에 보이는 것처럼 g_signal_connect() 호출시 연결하는 시그널 이름과 콜백 함수[clock_changed()]가 더 단순하고 효율적으로 변경된 걸 확인할 수 있습니다. 콜백 함수 호출시 전달되는 인수를 그냥 사용하면 되니까 오버헤드가 매우 많이 줄어들 수 밖에 없습니다. 하지만 시그널을 정의해서 사용하는게 단순히 성능과 효율 때문만은 아닙니다. 위 예제에서는 속성이 변경되었을 때 발생하는 시그널을 정의했지만, 일반적으로 시그널은 속성 만으로 표현할 수 없는 객체의 상태 변화를 알리기 위해서 많이 사용합니다.(예: ClutterActor::enter-event 시그널) 또한 속성의 변화를 통해 알 수 있더라도 더 쉽고 명확하게 이를 전파하기 위해서도 사용합니다.(예: ClutterActor::hide 시그널과 ClutterActor:visible 속성)\n더 나아가, 시그널은 상태 변화 뿐 아니라 객체의 동작 방식을 외부에서 제어할 수 있도록 유연성을 제공하는데도 사용합니다. 더 자세한 이해를 위해 시그널 함수 포인터부터 설명하자면, 클래스 구조체 안에 선언된 시그널 함수 포인터[MyClockClass::changed()]는 일종의 가상 함수(virtual function) 역할을 하면서, 시그널이 발생하면(emit) g_signal_connect()를 이용해 등록된 사용자 콜백함수가 모두 실행된 뒤 맨 나중에 실행되거나 혹은 사용자 콜백 함수보다 먼저 실행됩니다. 따라서 필요 없을 경우 그냥 NULL로 내버려두어도 상관없지만, 위 예제에서는 클래스 생성시 my_clock_real_changed() 함수를 등록시켰습니다. my_clock_real_changed()는 다시 실제로 datetime 속성을 갱신하는 작업을 처리하는 my_clock_set_date_time()을 호출합니다. 그리고, 기존 시간 갱신 함수[my_clock_update()]에서는 직접 my_clock_set_date_time()을 호출하지 않고, 시그널을 발생시켜[g_signal_emit()] 작업을 처리합니다.\n왜 이렇게 복잡하게 일을 나누어 처리할까요? 이렇게 구현하면 몇 가지 장점이 있기 때문입니다. 예를 들어 위 예제에서는 datetime 속성이 읽기 전용으로 선언되어 있기 때문에 외부에서 그 값을 변경할 수 없습니다. 하지만, 외부에서 직접 g_signal_emit_by_name() 등을 이용해 시그널을 발생시키면 시그널에 연결된 모든 콜백 함수 뿐 아니라 my_clock_real_changed() 함수까지도 간접적으로 호출되어 작업을 처리하도록 할 수 있습니다. 게다가 만일 시그널에 연결된 콜백 함수 중 하나가 어떤 이유로 g_signal_stop_emission_by_name() 등을 호출하면 이후 실행될 콜백 함수나 my_clock_real_changed() 함수가 호출되지 않게 할 수도 있고, 심지어 객체의 클래스에 등록된 함수 포인터에 직접 자신만의 콜백 함수를 등록해서 원래 작업이 아예 수행되지 않게 할 수도 있습니다.\n참고로, GTK+ / Clutter 등과 같은 GObject 기반 그래픽 툴킷 시스템은 대부분 이 시그널 콜백 함수 메커니즘을 이용해 커스텀 위젯을 만들거나 기존 액터를 상속받아 사용자가 마음껏 기능을 확장할 수 있는 길을 열어 두었습니다.(예: clutter_actor.c:clutter_actor_real_paint() 소스 참고)\n시그널 객체는 g_signal_new() 함수를 이용해 생성한 뒤 전역 signals[] 배열에 ID를 저장해 둡니다. 이렇게 저장한 시그널 ID는 g_signal_emit() 함수 호출시 사용합니다. 물론 이렇게 ID를 따로 저장하지 않고 g_signal_emit_by_name()을 사용해 시그널 이름으로 직접 시그널을 발생시켜도 되지만, 어차피 내부적으로 시그널 이름을 ID로 변환하는 과정을 거치기 때문에 효율을 위해 객체 구현시 관례적으로 이런식으로 작성합니다. 물론 객체 외부에서는 시그널 ID를 모르기 때문에 어쩔 수 없이 g_signal_emit_by_name()을 사용해야 합니다.\n g_signal_new() 함수의 인자 중에서 중요한 항목만 설명하면, 첫번째 항목은 시그널 이름을 정의하고, 세번째 항목은 시그널 함수 포인터가 맨 나중에 실행될 지(G_SIGNAL_RUN_LAST), 또는 가장 먼저 실행될 지(G_SIGNAL_RUN_FIRST) 등을 지정합니다. 네번째 항목은 클래스 구조체에 정의된 시그널 함수 포인터 위치를 지정하고, 여덟번째는 시그널 콜백 함수의 리턴 형(type), 아홉번째는 콜백 함수에게 전달할 인자의 갯수, 열번째부터는 전달될 인자의 형(types)을 차례대로 정의합니다.\n g_signal_new() 함수의 일곱번째 인자는 함수 호출시 인자를 처리하는 마샬링(marshalling) 함수를 지정하는데, 함수의 리턴 형(type)과 인자 목록, 인자의 각 형(type)이 정확히 일치되는 함수를 지정해야 합니다. 그런데 원하는 형태의 마샬링 함수를 GLib에서 기본으로 제공하지 않을 경우 glib-genmarshal 프로그램을 이용해 직접 C 소스 코드를 생성해서 사용해야 했는데, GLib 2.30 버전부터는 그냥 NULL을 지정하면 libffi 라이브러리를 이용해 구현한 g_cclosure_marshal_generic() 함수가 기본으로 호출되어, 알아서 자동으로 마샬링을 처리합니다.\n정리하자면, GObject 시그널은 모델-뷰(model-view) 구조나 관찰자 패턴(observer pattern)을 구현하는데 사용하기도 하지만, 더 복잡한 객체 지향 시스템을 설계할 때도 유용합니다. 하지만, 여기서는 시그널의 특징과 개념만 설명하느라 전체 기능의 반의 반도 소개되지 않은 셈입니다. 따라서 더 깊은 이해와 활용을 원하시면 반드시 참고 매뉴얼을 한 번 정독하시길 권합니다.\n그리고\u0026hellip;\n다른 프로그래머가 왜 C++, Java, Python 처럼 좋은 언어 놔두고 C 언어 기반에서 복잡한 GObject 같은 걸 가지고 객체 지향 프로그래밍을 할려고 애쓰냐고 물어본다면, 리눅스 커널 메일링 리스트 FAQ 에 있는 유명한 다음 구절을 해석해서 미소지으며 알려주시기 바랍니다.\n What\u0026rsquo;s important about object-oriented programming is the techniques, not the languages used.\n 뭐, 모든 도구는 필요한 곳이 반드시 있으니까 계속 존재합니다. 다만 내가 아직 그 쓰임새를 알지 못할 뿐이죠\u0026hellip; :)\n","date":1330041600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1330041600,"objectID":"7051feb34280fdc29a2bcd40672ed7be","permalink":"https://lethean.github.io/2012/02/24/oop-with-gobject-5/","publishdate":"2012-02-24T00:00:00Z","relpermalink":"/2012/02/24/oop-with-gobject-5/","section":"post","summary":"거의 2년만에 GObject 객체 지향 프로그래밍 연재 글을 포스팅합니다. 사실 이 글의 일부는 예전에 작성해 둔 것인데, 이번 GNOME Tech Talks 에서 발표 하나를 맡게 되면서, 슬라이드 자료","tags":["Agile","Clutter","Coding","GLib"],"title":"GObject 객체 지향 프로그래밍 (5)","type":"post"},{"authors":null,"categories":null,"content":"대부분의 작업을 리눅스 환경에서 진행하지만 가끔은 어쩔 수 없이 윈도우 프로그램을 디버깅합니다. 그런데 메모리 오류를 디버깅할 때 리눅스에서 애용하는 Valgrind 같은 괜찮은 무료(!) 도구가 없어서 아쉬었는데, 오늘 발견한 Dr. Memory 덕분에 매우 수월하게 메모리 오류 디버깅을 진행할 수 있었습니다. 또한, 리눅스에서도 사용할 수 있다고 하니 계속 디버깅에 사용해 볼 생각입니다.\n사실, 이 포스팅은, 사용하기 쉬우면서도 Valgrind 만큼 강력한 Dr. Memory 덕분에 해묵은 버그와 오류까지 모조리 잡을 수 있게 되어, 그 고마움을 표시하고 싶어서 남기는 글입니다. 따라서, 사용법 같은 자세한 내용이 궁금하신 분은 홈페이지를 방문해 보시길\u0026hellip; :)\n","date":1328659200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1328659200,"objectID":"1d9edef4c9d9540dafc9a2ce09eb1390","permalink":"https://lethean.github.io/2012/02/08/detect-memory-leaks-and-corruption-with-dr-memory/","publishdate":"2012-02-08T00:00:00Z","relpermalink":"/2012/02/08/detect-memory-leaks-and-corruption-with-dr-memory/","section":"post","summary":"대부분의 작업을 리눅스 환경에서 진행하지만 가끔은 어쩔 수 없이 윈도우 프로그램을 디버깅합니다. 그런데 메모리 오류를 디버깅할 때 리눅스에서 애용하는 Valgrind 같은 괜찮","tags":["Coding","Windows"],"title":"Dr. Memory 메모리 오류 / 누수 감지 도구","type":"post"},{"authors":null,"categories":null,"content":"제목이 조금 길지만, 이 글의 내용은 제목 그대로입니다. (참고로, 이 글은 최근 인텔 그래픽 칩셋을 대상으로 작성되었습니다. 즉, 다른 그래픽 칩셋 드라이버는 어떻게 동작하는지 확인을 안 해 보았다는 의미입니다)\n요즘 X 서버는 연결된 모니터가 없고, /etc/X11/xorg.conf 파일에 수직/수평 주파수가 정의되어 있지 않다고 하더라도 일단 정상적으로 실행됩니다. 다만, 초기 해상도가 320x200 처럼 매우 작을 수 있습니다. 그런데 나중에 필요에 의해 모니터를 연결했는데 화면이 보이지 않는 경우가 발생합니다. 이 경우, 네트웍으로 접속해서 다음 명령어를 실행합니다.\n$ export DISPLAY=:0.0 $ xrandr --auto  그러면 X 서버가 알아서 연결되어 있는 모니터를 출력으로 재설정하고 가장 선호하는(preferred) 해상도와 주파수를 선택합니다. 그런데 이를 자동으로 동작하게 하려면 udev 데몬의 도움을 받아야 합니다. 그래서 /etc/udev/rules.d 디렉토리에 확장자가 '.rules'인 파일을 생성하고 다음과 같이 내용을 채웁니다.\nACTION==\u0026quot;change\u0026quot;, SUBSYSTEM==\u0026quot;drm\u0026quot;, KERNEL==\u0026quot;card*\u0026quot;, RUN+=\u0026quot;/usr/bin/auto-xrandr.sh\u0026quot;  그리고 /usr/bin/auto-xrandr.sh 파일을 아래와 같이 작성한뒤 실행권한을 줍니다.\n#!/bin/sh [ \u0026quot;$DISPLAY\u0026quot; = \u0026quot;\u0026quot; ] \u0026amp;\u0026amp; export DISPLAY=:0.0 xrandr --auto xrandr --dpi 96  그러면 이제부터 모니터 연결시 자동으로 연결을 재설정하게 됩니다.\n그런데, 만일 네트웍으로 접속했거나, udev 데몬에 의해 실행되는 경우 X 서버 인증이 안된 계정이라며 xrandr 명령이 실행이 거부됩니다. 이를 제대로 처리하려면 복잡한 인증 과정이 필요한데, 이를 쉽게 처리하려면 그냥 X 서버 시작할때 자동으로 실행되는 초기화 스크립트에 'xhost +' 명령어를 주면 인증을 무시하게 됩니다. 물론 보안상 좋은 방법은 아니지만, 폐쇠된 환경이라면 별로 문제가 없을 겁니다.\n각각의 명령어에 대해 더 궁금하신 분은 관련 명령어 매뉴얼 페이지를 확인해 보시기 바랍니다.\n참고로 조금만 더 설명하면, 노트북 외부 모니터 단자에 빔 프로젝트나 외부 모니터를 연결했을 경우도 xrandr 명령을 직접 사용하거나 지금까지 설명한 방법을 조금 다르게 응용할 수 있습니다.\n","date":1327795200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1327795200,"objectID":"76becac0e7efa562eefa61f6f4d0b835","permalink":"https://lethean.github.io/2012/01/29/setup-new-connected-monitors-automatically-after-starting-x-server-without-connected-monitors/","publishdate":"2012-01-29T00:00:00Z","relpermalink":"/2012/01/29/setup-new-connected-monitors-automatically-after-starting-x-server-without-connected-monitors/","section":"post","summary":"제목이 조금 길지만, 이 글의 내용은 제목 그대로입니다. (참고로, 이 글은 최근 인텔 그래픽 칩셋을 대상으로 작성되었습니다. 즉, 다른 그래픽 칩셋 드라이버는 어떻","tags":["Linux","Udev","Xorg"],"title":"모니터 없이 X 서버 실행 후 나중에 모니터 연결해도 화면이 안보인다면","type":"post"},{"authors":null,"categories":null,"content":"최근 클러터를 이용한 프로그램을 개발 하면서 메모리 누수 현상을 발견했습니다. 코드를 하나 하나 막아가면서 테스트를 한 결과 ClutterGstVideoSink 객체를 사용하지 않으면 메모리 누수가 발생하지 않았습니다. 하지만, 아무리 소스를 분석해도 원인을 찾아낼 수 없었고, 잘못된 부분도 없는 것 같았습니다. 물론 구글링을 해도, 검색 실력이 미천한지, 답을 찾을 수 없었습니다.\n그래서 결국 예전에 소개한 적 있는 구글 성능 도구(google-perftools)를 이용해 디버깅 을 했습니다. 그런데 문제는, 아치 리눅스(Arch Linux) x86_64 환경으로 개발 환경을 바꾸면서 메모리 프로파일 기능이 제대로 동작하지 않는다는 사실인데, 특히 메모리 누수 발생 지점을 정확하게 알기 위해서 필요한 함수 호출 백트레이스(backtrace) 정보가 추출되지 않는 게 가장 큰 문제였습니다. 이 문제를 해결하기 위한 과정을 기록으로 남겨봅니다.\n구글 성능 도구 설치\n아치 리눅스(Arch Linux) x86_64 환경에서 구글 성능 도구(google-perftools)가 정확한 메모리 프로파일 결과를 얻으려면 libunwind 라이브러리를 설치해야 하는데, 아치리눅스 AUR 패키지를 yaourt 를 이용해 다음과 같이 쉽게 설치했습니다.\n$ yaourt -S libunwind  그리고 다음과 같이 구글 성능 도구를 빌드하고 설치합니다.\n$ cd google-perftools $ ./configure --prefix=/usr --enable-frame-pointers $ make $ sudo make install  라이브러리 패키지 재생성 및 재설치\n정확한 함수 호출 백트레이스(backtrace) 정보를 얻기 위해 프로그램에 사용되는 모든 라이브러리를 다시 컴파일해 패키지를 다시 설치해야 하는데, 그 과정은 다음과 같습니다. ( 관련 위키 페이지 참고)\n먼저 아치 리눅스 빌드 시스템(ABS) 정보를 동기화합니다.\n$ sudo abs  그러면 /var/abs 디렉토리 밑에 모든 공식 패키지의 빌드 정보가 다운로드됩니다.\n라이브러리의 패키지 빌드 옵션을 수정하기 위해, /etc/makepkg.conf 파일에서 아래 부분을 찾아 디버그 심볼(-g)과 프레임 포인터 포함(-fno-omit-frame-pointer) 컴파일 옵션을 추가하고 빌드 옵션에서 strip을 제외합니다.\nCFLAGS=\u0026quot;-g -fno-omit-frame-pointer -march=x86-64 -mtune=generic -O2 -pipe\u0026quot; CXXFLAGS=\u0026quot;-g -fno-omit-frame-pointer -march=x86-64 -mtune=generic -O2 -pipe\u0026quot; OPTIONS=(!strip docs libtool emptydirs zipman purge)  /var/abs/local 디렉토리로 이동해서(없으면 새로 생성) 다음과 같이 사용되는 프로그램에 사용되는 모든 라이브러리 패키지를 다시 생성하고 설치합니다. 예를 들어 클러터 라이브러리는 다음과 같습니다.\n$ src=$(find /var/abs -name clutter | grep -v /var/abs/local) $ cp -r $src /var/abs/local $ cd /var/abs/local/clutter $ makepkg -f $ sudo pacman -U *.pkg.tar.xz  위와 같은 방식으로 clutter, cogl, glib2, glibc 패키지를 다시 만들고 설치합니다.\n메모리 프로파일링\n이제 다음 명령으로 디버깅할 프로그램(eview-demo)을 실행합니다.\n$ G_SLICE=always-malloc HEAPPROFILE=/tmp/profile HEAP_PROFILE_ALLOCATION_INTERVAL=10737418240 LD_PRELOAD=/usr/lib/libtcmalloc.so ./eview-demo Starting tracking the heap Dumping heap profile to /tmp/profile.0001.heap (...) Dumping heap profile to /tmp/profile.0002.heap (...) Dumping heap profile to /tmp/profile.0003.heap (...) Dumping heap profile to /tmp/profile.0004.heap (...)  정상적으로 구글 성능 도구의 메모리 프로파일러가 동작하면 위와 같은 메시지가 출력됩니다. 이제 적당한 시점에서 프로그램을 멈추고, 다음과 같이 프로파일링 데이터를 분석합니다.\n$ pprof --pdf --lines --base /tmp/profile.0001.heap ./eview-demo /tmp/profile.0004.heap \u0026gt; profile-1.pdf  이렇게 생성된 그래프는 다음과 같습니다.\n이 그래프를 분석해서 관련 코드를 분석해 보니, 결정적으로 두 군데에 문제가 있습니다. 첫번째는 cogl_pipeline_fragend_arbfp_start() 함수 내부에서 생성한 arbfp_program_state 객체를 해제하는 곳이 없다는 점이고, 두번째는 cogl_pipeline_get_layers() 함수에서 생성한 deprecated_get_layers_list 리스트를 해제하는 곳이 없다는 점입니다. 그런데 최근 클러터 1.8 버전 소스를 보면 두번째 문제는 해결이 된 것 같은데, 첫번째 문제가 있는 곳은 코드 수정이 많이 되어 해결 여부를 알 수가 없습니다.\n그래서 결론은, 며칠 전에 릴리스된 클러터 1.8 안정 버전이 아치 리눅스 패키지로 올라오면 다시 메모리 누수 여부를 확인해볼 예정입니다. (GNOME 3 핵심 라이브러리를 직접 컴파일해서 사용하는게 귀찮기도 하고 두렵기도 해서입니다\u0026hellip; :)\n[UPDATE 2011-10-04] 클러터 1.8 버전에서 확인해 보니 메모리 누수 문제가 해결된 것 같습니다. 역시, 미루기를 잘 했습니다. ;)\n[UPDATE 2011-10-05] 다시 확인해 보니, 이제는 다른 부분에서 메모리 누수가 발생합니다. 그래서 이번에는 당당히(?) 버그 리포팅( Bug 660985 , Bug 660986 ) 했습니다.\n[UPDATE 2011-10-10] CPU 사용량이 가장 많은 함수를 프로파일링하려면 다음과 같이 실행하면 됩니다.\n$ CPUPROFILE=./cpu.prof LD_PRELOAD=/usr/lib/libtcmalloc_and_profiler.so ./eview-demo  정상적으로 종료한뒤 다음과 같이 CPU 사용량을 함수별로 프로파일한 그래프를 얻을 수 있습니다.\n$ pprof --pdf --lines ./eview-demo ./cpu.prof \u0026gt; profile-1.pdf  [UPDATE 2012-02-04] 최신 아치 리눅스에 포함되어 있는 glibc 2.15 버전의 버그 때문에 프로파일링이 제대로 동작하지 않을 경우  sscanf 관련 패치 를 적용해 glibc 패키지를 다시 빌드하고 설치해야 합니다. glibc 2.15-5 버전으로 업그레이드하면 됩니다. 버그 리포팅 이 바로 반영되어 버렸습니다. :)\n","date":1317168000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1317168000,"objectID":"d0afbe0e871b13a71278115a3deda722","permalink":"https://lethean.github.io/2011/09/28/clutter-memory-leak-debugging/","publishdate":"2011-09-28T00:00:00Z","relpermalink":"/2011/09/28/clutter-memory-leak-debugging/","section":"post","summary":"최근 클러터를 이용한 프로그램을 개발 하면서 메모리 누수 현상을 발견했습니다. 코드를 하나 하나 막아가면서 테스트를 한 결과 ClutterGstVideoSink 객체를 사용하지 않으면 메모리 누수가","tags":["Clutter","Coding"],"title":"Clutter 메모리 누수 디버깅","type":"post"},{"authors":null,"categories":null,"content":" 클러터(Clutter) 라이브러리를 이용하면서 부딪친 대부분의 문제는 성능과 관련된 것입니다. 클러터 라이브러리 자체가 느리다는 얘기가 아니라, 주로 개발하는 분야에서 요구되는 16채널 이상 다채널 라이브 / 녹화 동영상 재생을 구현할 때, 고사양 장비는 문제가 되지 않지만 저사양 임베디드 보드에서는 성능 저하가 발생하기 때문입니다. 하지만, 효율적인 2D 그래픽을 위한 3D 그래픽 라이브러리로서 클러터는 아직까지 만족스럽습니다. OpenGL 기반 라이브러리는 기존 2D 그래픽 라이브러리와 여러가지 기본 개념이 달라서, 저처럼 이쪽 세상에 입문한지 얼마 안되는 개발자는 많은 시행 착오를 겪을 수 밖에 없는데, 이미 사용해 본 GTK+ / GObject 방식에 익숙한 점도 유리하게 작용했지만, 2D 그래픽 + 효과를 위한 약간의 3차원 API 조합은 복잡하고 어려운(\u0026hellip;) 3D 라이브러리를 직접 사용하는 것보다 훨씬 수월했습니다.\n아무튼 그래서, 지금까지 겪은 경험 중 몇 가지를 정리해 보았습니다. 당연하지만, 아직 OpenGL에 대한 이해가 부족해 틀린 내용이 있을 수도 있으니, 감안해 주시기 바랍니다.\n   클러터 라이브러리는 계속 버전업 되는데 예전에 작성된 튜토리얼이나 예제는 갱신되지 않아 잘못되거나 사용을 권장하지 않는(deprecated) API를 사용하는 경우가 많이 있습니다. 가능한 클러터 개발자들이 라이브러리와 함께 직접 업데이트하는 클러터 해설서(The Clutter Cookbook) 를 참고하는게 가장 정확했습니다.\n  OpenGL 기반 클러터 라이브러리 동작 방식은 일반적인 2D GUI 프로그래밍과 달리 화면, 즉 스테이지(stage)에 조그만 변화라도 있으면 그때마다 스테이지를 다시 그립니다. 즉, 클러터의 기본 단위인 액터(actor) 하나가 다시 그려져야 하면 액터가 속한 스테이지의 모든 액터를 다시 그립니다. 그리고 이로 인해 스테이지에 보이는 모든 액터의 paint() 함수가 매번 호출되기 때문에 이 함수를 최적화하는 게 매우 중요합니다.\n  내부적으로 캐싱(caching)이 이용되긴 하지만, 한 액터의 좌표(크기 + 위치)가 변경되면 스테이지의 모든 액터의 크기를 다시 계산하기 위해 모든 액터의 allocate() 함수가 호출됩니다. 예를 들어 텍스트(text) 액터 구현을 보면, 문자열이나 폰트, 크기 등이 변경되었을때 텍스트 액터를 포함하는 부모 컨테이너 액터가 변경된 크기를 감지하고 자신의 크기를 조정할 수 있도록 clutter_actor_queue_relayout() 함수가 호출됩니다. 그리고, 이 함수가 호출되면 결국 스테이지 단계까지 호출이 계속된 다음, 다시 스테이지에 속한 액터의 allocate() 함수가 재귀적으로 호출됩니다. 따라서 액터의 allocate() 함수 역시 내부적으로 최적화되는 것이 좋습니다. 참고로 clutter_actor_queue_relayout() 함수가 호출되면 자동으로 clutter_actor_queue_redraw() 함수가 호출되어 스테이지의 모든 객체를 다시 그립니다.\n  클러터에서 기본으로 제공하는 박스(ClutterBox) , 그룹(CutterGroup) 등과 같은 컨테이너 액터를 사용하지 않고 직접 컨테이너 액터를 구현해 자식 액터를 배치하고 싶거나 혹은 기존 컨테이너 액터를 상속받아 새 컨테이너 액터를 구현할 때가 있습니다. 그런데, 컨테이너 액터 좌표(크기 + 위치) 변경에 따라 자식 액터의 좌표를 자동으로 변경할 필요가 있으면 대개 \u0026quot;allocation-changed\u0026quot; 시그널을 이용해 감지한 뒤 clutter_actor_set_size() , clutter_actor_set_position() 함수 등을 이용해 자식 액터의 좌표를 조정하거나, 제약(ClutterConstraints) 기능을 이용하는데, 위에서 설명한 것처럼 좌표가 변환되면 자동으로 clutter_actor_queue_relayout() 함수가 호출되면서 \u0026ldquo;The actor \u0026lsquo;xxx\u0026rsquo; is currenty inside an allocation cycle; calling clutter_actor_queue_relayout() is not recommended\u0026rdquo; 디버그 경고 메시지가 계속 출력됩니다. 메시지니를 무시할 수도 있지만, 문제는 한 액터의 좌표 변경으로 인해 매번 화면 전체가 다시 좌표를 다시 계산하기 때문에 결국 모든 액터의 allocate() 함수가 계속 호출되면서 CPU 점유율이 매우 높아진다는 점입니다. 여기에 좌표를 이용한 애니메이션까지 사용하면 CPU 점유율은 상상을 초월할 정도로 올라갑니다. 이 문제를 해결하려면 반드시 allocate() 함수에서 자식 액터의 좌표를 지정할때 clutter_actor_allocate*() 종류의 함수만 이용해야 하고, 어쩔 수 없을 경우 g_idle_add_full() 함수를 이용해 자식 액터 좌표 지정 루틴의 실행을 뒤로 조금 미룬 뒤에 좌표 중복 검사 등을 통해 가능한 화면 재구성(relayout) 작업이 덜 일어나게 해야 합니다. 메인루프 우선 순위는 CLUTTER_PRIORITY_EVENTS 값을 사용하는 게 좋습니다.\n   클러터 실행에 영향을 주는 환경 변수 를 이용하면 성능 조율 및 디버깅에 상당한 도움을 받을 수 있습니다. 예를 들어 COGL_DEBUG=rectangles 이나 CLUTTER_DEBUG=\u0026quot;paint layout\u0026quot; 등은 도움이 많이 됩니다.\n   텍스트(ClutterText) 액터의 위치가 정수가 아니라면, 즉 소수점 이하 값이 존재하는 실수일 경우 글꼴 선이 흐려지거나 뭉개지는 현상이 발생합니다. 텍스트 액터 뿐 아니라 사각형(ClutterRectangle) 액터처럼 그림이 아니라 직접 그려지는 액터들도 비슷한 현상이 발생합니다. 비단 액터의 위치가 정수일 지라도 이를 포함하는 상위 컨테이너 액터의 위치가 소수점 이하를 포함하는 실수일 경우, 즉 화면(stage)상 절대 좌표가 정수가 아닐 경우 이 현상이 발생합니다. 따라서 액터의 좌표를 계산해서 지정할 경우 반드시 floor() / ceil() 등의 함수를 이용해 소수점 아래 값을 없애주는 것이 좋습니다.\n  액터에 배경 또는 테두리를 장식하고 싶을때 보통 떠오르는 구현 방법은 두 가지가 있습니다. 첫번째는 컨테이너 액터를 이용해 사각형 액터를 맨 아래 두고 대상 액터를 위에 두는 방법을 이용한 것이고, 두 번째는 이런 작업을 하는 커스텀 액터를 직접 구현하는 것입니다. 그런데 이보다 더 좋은 방법은, 효과(ClutterEffect) 객체를 구현해서 사용하는 것입니다. 효과 객체가 액터 객체에 추가되면 효과의 pre_paint() / post_paint() 함수가 액터의 paint() 함수 호출 전후에 자동으로 호출되므로, 동일한 디스플레이 루틴을 여러 객체에 쉽게 적용할 수 있습니다. 클러터에서 이미 기본으로 제공하는 고급 효과 를 사용해도 되지만, 예를 들어 텍스트에 그림자를 넣어주는 예제 를 그대로 이용해 테두리 효과 처럼 구현할 수도 있는 셈입니다.\n  클러터에서 직접 그리기 위해 사용하는 OpenGL 랩퍼 API Cogl 함수를 사용할때 경로(Path) 등을 사용하지 않고 가능하다면 기본(Primitives) 함수 만 사용해서 구현하는게 성능이 좋습니다.\n   Cogl 함수를 이용해 직접 그리는 방식과 모든 것을 그림 이미지로 처리하는 텍스쳐(ClutterTexture) 를 이용하는 방식의 장단점을 아직 잘 모르겠습니다. 다만, 텍스쳐는 내부적으로 사용하는 메모리량이 더 많은 것이 분명하고, 현재 개발 중인 시스템에서는 수많은 채널의 비디오 동시 재생을 위해 어차피 많은 텍스쳐가 사용되기 때문에 가능한 텍스쳐 사용을 자제했습니다. 하지만 영역 크기에 따라 크기가 달라지는 GUI 부분을 구현할때는 이미지 기반 텍스쳐보다 일종의 벡터 그래픽이라고 할 수 있는 Cogl 함수를 이용해 직접 그리면 훨씬 깔끔한 GUI를 얻을 수 있는 것도 사실인 것 같습니다.\n  비디오 재생을 위해 비디오싱크(ClutterGstVideoSink) 객체를 사용할 때 갱신 우선순위 (update-priority) 속성을 CLUTTER_PRIORITY_REDRAW 값으로 낮추면 마우스 이벤트 반응 속도를 개선할 수 있습니다.\n  정말로 빈번한 애니메이션을 구현할때는, 사용하기 쉽지만, 내부적으로 수많은 객체가 생성되고 소멸되는 clutter_actor_animate() 대신, 번거롭지만, 타임라인(ClutterTimeline) 등을 이용해 구현하는게 CPU / 메모리 사용량을 줄이는데 도움이 됩니다.\n  AMD(ATI) 그래픽 카드를 장착한 리눅스 상에서 클러터를 실행할때 Catalyst 상용 X 드라이버와 최신 오픈소스 X 드라이버와 성능 차이가 거의 없어진 것 같습니다. 물론 NVidia는 상용 드라이버 성능이 월등이 더 좋고, 인텔 칩셋은 오픈 소스 드라이버만 있고 성능도 좋습니다.\n이해에 도움이 될까 싶어, 아직 프로토타입이고 많은 기능이 빠져있지만, 현재 개발 중인 시스템의 동작 화면을 녹화한 영상을 보여드립니다. 녹화에 사용한 프로그램은 gtk-recordMyDesktop 입니다.\n GUI 프로그래밍을 할 때마다 느끼는 점은 구현하기 위한 기술도 중요하지만, 결국 사용자를 배려하면서도 아름다움을 잃지 않는 참신한 아이디어 기반의 디자인이 더 중요하다는 점입니다. 물론 그렇기 때문에 디자이너라는 직업이 따로 있는 것이겠지만, 좋은 프로그램과 삶의 다양한 모습을 많이 보고, 많이 경험하고, 많이 참고해야 하는 지적 즐거움을 언제부터인가 프로그래머들은 남의 영역이라 멀리한 채 무미건조한 기술에만 전념하고 있는 건 아닌지 모르겠습니다.\n","date":1316044800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1316044800,"objectID":"fc8b46ca118919e3a4814a242c01ad62","permalink":"https://lethean.github.io/2011/09/15/note-about-using-clutter/","publishdate":"2011-09-15T00:00:00Z","relpermalink":"/2011/09/15/note-about-using-clutter/","section":"post","summary":"클러터(Clutter) 라이브러리를 이용하면서 부딪친 대부분의 문제는 성능과 관련된 것입니다. 클러터 라이브러리 자체가 느리다는 얘기가 아니라, 주로 개발","tags":["Clutter"],"title":"클러터(Clutter) 사용기","type":"post"},{"authors":null,"categories":null,"content":"오랜만에 GNOME 개발자 센터 를 들어갔더니, 모양 뿐 아니라 내용도 확 바뀌어 있습니다. 예전에도 있었는데 제가 몰랐던 건지도 모르지만, 10분짜리 설명서(10-minute tutorials) 가 가장 먼저 눈에 띄었습니다. (접속한 페이지의 실제 이름은 GNOME 개발자 플랫폼 데모입니다) 이미지 보기, 기타 튜너, 메시지 보드 등과 같은 여러 예제를 통해 단순한 GTK+ 위젯 라이브러리 사용법만 보여주는것 뿐 아니라, 말 그대로 GNOME 플랫폼의 중심이 되는 GTK+ / Clutter / GStreamer / WebKitGtk 라이브러리 등을 이용하여 유용하게 참고할 수 있는 간단한 응용 프로그램을 Anjuta 통합 개발 도구, Glade UI 편집기를 이용하여 개발하는 방법을 설명합니다. 또한 C / C++ / JavaScript / Python / Vala 등과 같은 언어별 예제도 각각 제공하고 있습니다.\n최근 계속 연재되는 파이썬(Python) 언어와 GTK+ / Clutter / GStreamer 라이브러리를 이용한 GNOME 개발 동영상(screencast)도 볼만합니다. 몇몇 예제는 그놈 개발자 사이트 데모 프로그램과 겹치는 것도 있습니다.\n  GNOME 스크린캐스트 - 01. 첫번째 GTK+ 어플리케이션 (2011-06-16): 파이썬을 이용해 기본 기능을 가진 GTK+ 프로그램 만들기  GNOME 스크린캐스트 - 02. 화려한 사진 어플리케이션 만들기 (2011-06-22): 파이썬과 GTK+를 이용해 간단한 사진 프로그램 만들기  GNOME 스크린캐스트 - 03. 멋진 계산기 만들기 (2011-06-29): 파이썬과 GTK+를 이용해 간단한 계산기 프로그램 만들기  GNOME 스크린캐스트 - 04. 우아한 기타 튜너 만들기 (2011-07-07): 파이썬과 GTK+, GStreamer를 이용해 기타 튜너 프로그램 만들기  GNOME 스크린캐스트 - 05. 매력적인 동영상 재생기 만들기 (2011-07-15): 파이썬과 GTK+, GStreamer, Clutter를 이용해 동영상 재생기 만들기   gedit 텍스트 편집기와 Glade UI 편집기만을 이용해 파이썬 언어의 간결함과 GNOME 플랫폼 라이브러리의 강력함을 잘 보여주고 있습니다. 여담이지만, 영어가 짧아 단어만 알아듣는 본인도 코드만 보고 이해할 수 있었습니다. :)\n물론 이 글에서 소개한 설명서는 대부분 아마도 많은 개발자에게 GNOME 플랫폼의 우수성을 전파하고 사용을 독려하기 위해 매우 기본적인 내용만 맛보기로 소개하기 때문에 더 심각하고(?) 자세한 내용을 알고 싶다면 각 기술에 대한 심층적인 공부가 필요합니다.\n또한 GNOME 플랫폼 라이브러리라는 제목을 달고 있지만 대부분의 기술이 반드시 GNOME 환경에서만 동작하는 게 아니므로 리눅스 관련 개발자라면 한 번 들여다보는 것도 좋을 것 같습니다.\n","date":1310688000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1310688000,"objectID":"1e1135811fd36073d2ab16a58922148d","permalink":"https://lethean.github.io/2011/07/15/gnome-development-screencasts-and-tutorials/","publishdate":"2011-07-15T00:00:00Z","relpermalink":"/2011/07/15/gnome-development-screencasts-and-tutorials/","section":"post","summary":"오랜만에 GNOME 개발자 센터 를 들어갔더니, 모양 뿐 아니라 내용도 확 바뀌어 있습니다. 예전에도 있었는데 제가 몰랐던 건지도 모르지만, 10분짜리 설명서(10-mi","tags":["Clutter","GNOME","GStreamer","GTK+"],"title":"GNOME 개발 설명서 / 동영상","type":"post"},{"authors":null,"categories":null,"content":"리눅스에서 비단 부모 자식 프로세스간 통신 뿐 아니라, 쓰레드간 메시지 전달에도 pipe() 를 자주 이용합니다. 읽거나 쓸때 별도로 뮤텍스로 보호해줄 필요가 없기 때문이기도 하지만, 무엇보다도 poll(), select(), epoll() 등과 함께 사용할 수 있기 때문입니다. 예를 들어 예전에 적었던 GLib 쓰레드 프로그래밍 에서 쓰레드간 통신에 g_async_queue()를 이용하는데, 이 방법의 단점은 쓰레드가 오직 이 메시지가 도착했을때만 깨어난다는 점입니다. 만일 이 쓰레드가 네트웍 소켓 작업이나 파일 읽기 쓰기 작업을 비동기적으로 계속 처리해야 한다면 타임아웃을 주어 처리하거나 반대로 다시 주기적으로 메시지큐를 검사하는 방법밖에 없습니다. 하지만, 리눅스에서 모든 소켓 작업, 파일 작업은 디스크립터(descriptor)로 단일화되어 있기 때문에 pipe()로 생성된 디스크립터와 실제 작업 디스크립터를 한꺼번에 epoll() 등을 이용해 처리하면 불필요한 오버헤드 없이 정확하게 작업을 처리해야할 시점에 깨어나 필요한 작업을 처리하게 됩니다. 즉, 메시지큐에 실제 메시지를 넣고 파이프의 쓰기 디스크립터에 더미 데이터를 쓰면, 작업 쓰레드에서는 파이프 읽기 디스크립터에 내용이 있을 경우 poll() 등이 감지하기 때문에 자동으로 깨어나 처리하는 방식입니다. 심지어, 파이프 전송시 더미 데이터가 아닌 메시지 내용 혹은 주소(pointer)를 쓰고, 읽는 쓰레드에서 이를 읽어 처리하면 별도의 메시지큐도 불필요하게 됩니다.\n이 글에서 소개하려는 eventfd() 는 파이프 역할을 어느 정도 대체하기 위해 최근(?) 리눅스 커널에 추가된 API입니다. 읽고 쓰기에 각각 다른 두 개의 파일 디스크립터를 사용하는 파이프와 달리 eventfd는 한 개의 파일 디스크립터를 가지고 동시에 읽고 쓰기 작업을 처리합니다. 또한 별도 커널 버퍼와 복사 과정이 필요한 파이프와 달리 정수 값을 더하고(쓰고) 읽는 작업만 처리하기 때문에 성능도 훨씬 좋다고 합니다. 물론 파일 디스크립터이기 때문에 poll() 등과 함께 사용할 수 있습니다.\n동작 방식을 간단하게 설명하면, write() 호출시 64비트 정수값을 쓰면 내부 버퍼 값에 더하면서, read() 호출시 내부 버퍼 값이 0일 경우 기다리다가, 값이 바뀌면 그 값을 읽어오고 0으로 초기화합니다.(세마포어 방식일 경우 1을 읽어오고 그 값에서 1을 감소합니다) 즉, 읽기 작업에 대한 poll() 호출은 내부 버퍼 값이 0일 경우 입력이 없는 것으로, 1 이상의 값일 경우 입력이 있는 것으로 간주하고 디스크립터를 감지하게 됩니다. (예제 코드는 매뉴얼 페이지에 포함된 코드를 확인하시길\u0026hellip; 물론 예제 코드는 쓰레드간 통신에도 잘 동작합니다)\n매뉴얼에 의하면 리눅스 커널 2.6.22, glibc 2.8 버전부터 eventfd() 함수를 지원합니다. 대부분의 요즘 리눅스 데스크탑 / 서버 배포판에서는 당연히 사용할 수 있지만 임베디드 시스템에서는 버전을 확인해야할 필요가 있습니다. 물론, eventfd가 메시지 내용 자체를 전송할 수 없다는 단점도 있지만, 이와 함께 리눅스 커널이 제공하는 signalfd() , timerfd() , epoll() 등을 함께 사용하면 고전 유닉스 프로그래밍의 한계에서 벗어나 마음껏 이벤트 기반 코드를 만들 수 있습니다.\n물론 이미 잘 만들어진 GLib 메인루프 나 libevent 등과 같은 라이브러리를 사용하는 것도 좋지만\u0026hellip; :)\n","date":1309996800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1309996800,"objectID":"ca898345c2070481a80a3336d7343b0f","permalink":"https://lethean.github.io/2011/07/07/eventfd/","publishdate":"2011-07-07T00:00:00Z","relpermalink":"/2011/07/07/eventfd/","section":"post","summary":"리눅스에서 비단 부모 자식 프로세스간 통신 뿐 아니라, 쓰레드간 메시지 전달에도 pipe() 를 자주 이용합니다. 읽거나 쓸때 별도로 뮤텍스로 보호해줄 필요가 없기 때문이기도","tags":["glibc","Linux"],"title":"eventfd 소개","type":"post"},{"authors":null,"categories":null,"content":" Vala 언어는 C# 언어와 문법이 비슷한 객체 지향 언어입니다. Vala 언어로 작성한 소스를 이용해 실행 파일을 직접 만들 수도 있지만 C 소스 코드로 변환할 수도 있는데, 더 정확히 말하면, GObject 프레임워크를 이용하는 순수 GLib 기반 C 언어 코드를 생성한 뒤 이를 다시 C 컴파일를 이용해 실행 파일을 생성합니다. 따라서 이렇게 생성된 C 소스 코드는 이론적으로 GLib 라이브러리가 포팅된 어떤 플랫폼에서든 동작할 수 있고, 실행 속도 역시 C 언어로 작성된 코드와 거의 동일한 성능을 보여 줍니다. 생성된 소스 코드나 라이브러리는 GLib 외의 다른 라이브러리 의존성이 없기 때문에(posix 프로파일을 사용하면 GLib 의존성도 없어짐) 당연히 다른 C 언어에서도 이용할 수 있고, 반대로 C 언어로 개발된 라이브러리를 별다른 바인딩 코드 없이 VAPI 기법을 통해 사용할 수도 있습니다.\n요즘 GNOME 프로젝트 개발 흐름을 보면 크게 두 가지 언어, JavaScript와 Vala가 대두되고 있는데, GUI 같은 상위 제어 모듈은 JavaScript로 구현하고, 성능이 중요한 하위 모듈은 C + Vala로 구현한 뒤 이를 하나의 프로그램에서 합쳐서 성능과 개발 효율을 동시에 얻고자 하는 것 같습니다.\n사실, GObject 프레임워크가 좋긴 하지만, 여러 고수준 언어에서 사용할 때와는 달리 C 언어에서 사용하려면 어려움이 많아서 비판을 많이 받습니다. Vala 언어는, 말하자면, 이러한 반복되는 코드 재작성(boilerplate code)과 자잘한 코딩을 획기적으로 줄여주면서 C 언어로 GObject 객체 지향 프로그램을 할 수 있도록 도와주는 역할을 하는 겁니다. C++의 복잡함은 싫고, 인터프리터 언어의 느림은 견디기 힘들고\u0026hellip; 결국 목마른 사람들이 직접 우물을 판 셈입니다.\n그렇다고 Vala 언어는 비단 GTK+ / Clutter 기반 GUI 프로그램을 개발하는데만 사용되지 않고, 서버 데몬[ systemd ] 같은 콘솔 프로그램 개발에도 사용합니다. 이미 수많은 프로그램이 Vala를 이용해 개발 되었는데, C 언어로 개발되었던 기존 프로그램을 Vala 언어로 다시 작성한 것[ Cheese ]도 눈에 띕니다.\n그러나, Vala 언어의 단점이라면, C 언어 부류인 C#과 문법이 비슷하긴 하지만, 무엇보다도 새 언어를 익혀야 한다는 점, 그리고 GLib / GObject 개념에 익숙하지 않을 경우 익히는데 조금 더 시간과 노력이 필요하다는 점입니다. 물론, 오픈 소스 리눅스 개발자 커뮤니티에서 개발되어, 아직은, 그 안에서만 사용하는 마이너 언어라는 한계 때문에, 즉 상용 벤더의 지원이나 Visual Studio, XCode 등과 같은 완벽한 통합 개발 환경도 없기 때문에, 많은 개발자를 끌어당길 매력이 부족한 것도 사실입니다. 하지만 한편으로는, 오픈 소스이기 때문에 오히려 미래가 더 투명한게 아닐까 하는 생각도 듭니다.\n아무튼, Vala 언어에 대해 더 관심이 생기는 분은 소개, FAQ, 튜토리얼 문서 등을 한 번 훑어보시길 바랍니다. 샘플 코드도 많고, 튜토리얼도 참 많습니다. 아마 C++ / C# / Java / Python 등과 같은 객체 지향 언어에 익숙한 개발자라면 생각보다 어렵지 않다는 사실을 알게 될 겁니다. 더불어, Vala 컴파일러가 생성한 C 소스 코드를 한 번 확인해 보시면, 객체 지향 개념을 이런 식으로 코딩하고 구현할 수도 있구나 하는, 결국 중요한 건 개발자의 능력이지, 사용하는 언어나 개발도구가 전부가 아니란 것도 느끼게 됩니다.\n","date":1308096000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1308096000,"objectID":"c677c58878be76804bb87b6031bc6585","permalink":"https://lethean.github.io/2011/06/15/vala-language-introduction/","publishdate":"2011-06-15T00:00:00Z","relpermalink":"/2011/06/15/vala-language-introduction/","section":"post","summary":"Vala 언어는 C# 언어와 문법이 비슷한 객체 지향 언어입니다. Vala 언어로 작성한 소스를 이용해 실행 파일을 직접 만들 수도 있지만 C 소스 코드로 변환할 수도 있는데, 더 정확히","tags":["GLib","Vala"],"title":"Vala 언어 소개","type":"post"},{"authors":null,"categories":null,"content":"요즘은 예전에 작성한 라자냐 코드(Lasagna Code) 의 굴레에서 벗어나기 위해 노력하고 있습니다. 스파게티 코드(Spaghetti Code)가 아닌 라자냐 코드라고? 처음 들어보시는 분을 위해 위키피디어 설명을 날림으로 번역해 보면 다음과 같습니다.\n 라자냐 코드는 일종의 프로그램 구조인데, 잘 정의되어 분리된 여러 계층(layer)을 가지는 것이 특징입니다. 각각의 코드 계층은 잘 정의된 인터페이스를 통해 아래 계층의 서비스에 접근합니다. 이 용어는 프로그램 구조를 파스타에 비유하는 스파케티 코드와 비교되곤 하는데, 다른 재료(고기, 소스, 채소, 치즈 등)가 각각 파스타 조각으로 분리되어 하나의 접시에 담긴 라자냐의 계층 구조에 기인합니다.\n라자냐 코드의 흔한 예 중 하나는 다른 하부 시스템 , 가령 웹 어플리케이션과 비즈니스 로직, 관계형 데이터베이스 사이에 존재하는 인터페이스입니다. 또한 프로그래밍 기법 중에, 프로그램 전체 구조에서 레벨마다 다른 프로그래밍 언어를 사용하는 경우에도 이를 연결하는 계층이 존재하는데 이 역시 라자냐 코드의 일종입니다. 일반적인 클라이언트-서버 응용 프로그램 역시 대부분 잘 정의된 인터페이스를 통해 통신하므로 라자냐 코드라고 할 수 있습니다.\n대개 라자냐 코드는 다른 계층간에 인캡슐레이션(encapsulation)을 강요하기 때문에, 문제의 하부 시스템은 잘 정의된 메카니즘(SQL, RPC, FFI 등)을 제외한 다른 통신 수단이 없습니다. 물론, 시스템의 개별적인 레이어는 덜 구조화되어 있거나 엉망으로 조직화되어 있을 수도 있습니다.\n 위 설명을 보면 라자냐 코드는 전혀 나쁜 것 같지 않은데 도대체 무슨 굴레를 벗어난다고 하는 걸까, 모든 진리가 말하듯이, 과하면 부족함만 못한 법입니다. 너무 많은 계층화는 성능 개선 / 기능 확장 / 유지 보수 디버깅에 오히려 방해가 되어 버리고 맙니다. 예를 들어 GNOME 2 플랫폼에서는 용도별로 개발된 수많은 libgnome* 라이브러리가 존재했지만 GNOME 3 개발 과정에서 대부분 기능을 GLib / GTK+ 라이브러리에 통합한 이유 중 하나도 마찬가지일 겁니다. 여담이지만, 사실 그래서 GTK+는 모든 기능이 종합 선물 셋트처럼 제공되는 QT 애호가들에게 많은 비난을 받아왔었던 것도 사실입니다. 무슨 라이브러리 의존성이 이렇게 많고 복잡한지\u0026hellip; 물론 아직도 GTK+ 툴킷 자체는 여전히 기능별 라이브러리에 의존하고 있지만 예전에 비해 정말 많이 정리된 셈입니다.\n아무튼, 스스로 만든 라자냐 코드의 굴레 중에서 가장 문제가 되는 부분은, 멀티 플랫폼을 고려하는 것과 더불어 향후 라이브러리 교체시 수고를 덜기 위해 어떤 라이브러리 API를 그대로 사용하지 않고 일종의 확장성있는 랩퍼(wrapper) API를 따로 만들어 사용한 점입니다. 결과적으로, 라이브러리 자체도 계속 업그레이드 되기 때문에 이를 반영해야 하고, 다른 라이브러리로 교체하는 경우도 별로 없고, 성능 개선이나 기능 추가를 위해 끊임없이 랩퍼 API를 추가하면서, 디버깅할 때는 한 동작을 위해 두 세 단계 이상의 계층을 따라 가야하고\u0026hellip; 배보다 배꼽이 더 커지는 경우가 발생해 버리는 상황에 이르게 됩니다.\n두번째로 문제가 되는 부분은, 기능 하나를 구현할때 구성 모듈을 너무 세분하게 나눈 점입니다. 특히, 수평적이 아닌 수직적으로 기능을 나눌때 적절한 범위를 넘어가버리면, 새 기능 추가시 매우 많은 모듈에 대한 의존성 검사, 부작용 검사 등의 작업이 몇 배나 어렵습니다. 예를 들어 상위 계층에 있는 기능을 하위 계층에서 사용해야 하는 경우가 발생하면 이를 위한 인터페이스를 설계하는데 시간이 더 걸리는 경우도 많습니다. 그냥 간단하게 하나의 모듈로 작성하면 되었을 걸\u0026hellip;\n과하면 부족함만 못하다\u0026hellip; 언제 어떻게 무엇이 될 지 모르는 미래를 위해 미리 고민해서 확장성 있는 구조를 설계하는데 노력하는 것보다, 지금 당장의 요구 사항 수준에서 아무 문제없이 잘 돌아가는, 향후 쉽게 이해하고 확장할 수 있는 간단한 구조의 코드를 작성하는게 맞는 것 같습니다. 게다가 향후 발생할 요구사항을 미리 알 지 못하는데 미리 확장성있게 설계한다는 것 자체가 모순이 아닌가 하는 생각도 들고\u0026hellip;\n","date":1307664000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1307664000,"objectID":"219cc940338a6afe3e2f4b602e40af85","permalink":"https://lethean.github.io/2011/06/10/lasagna-code/","publishdate":"2011-06-10T00:00:00Z","relpermalink":"/2011/06/10/lasagna-code/","section":"post","summary":"요즘은 예전에 작성한 라자냐 코드(Lasagna Code) 의 굴레에서 벗어나기 위해 노력하고 있습니다. 스파게티 코드(Spaghetti Code)가 아닌 라자냐","tags":["Agile"],"title":"라자냐 코드 (Lasagna Code)","type":"post"},{"authors":null,"categories":null,"content":"아치리눅스를 비롯한 몇몇 리눅스 배포판은 여전히 시스템 부팅 초기화에 필요한 작업, 예를 들어 로컬 파일 시스템을 마운트하거나 웹서버, X서버 같은 시스템 프로그램을 자동으로 실행하기 위해 전통적인 유닉스의 SysV 시스템 구동 스크립트 방식(런레벨, rc.d 스크립트 등) 혹은 비슷한 방식을 이용하고 있습니다. 하지만 오래된 이 방식은 셸 스크립트 기반이라 전반적인 실행 속도가 느릴 뿐 아니라 프로세스간 의존성, 프로세스 종료시 예외처리(예: 자동 재실행) 등과 같은 기능을 지원하지 않아 많은 시스템 관리자 및 개발자의 불만을 산 것도 사실입니다. 특히 최근 몇 년동안 이슈가 되었던 리눅스 부팅 속도 단축을 위해 제일 먼저 처리되어야 하는 걸림돌로 여겨지기도 했습니다. 이런 이유로, 우분투(Ubuntu)는 오래전부터 자체적으로 개발한 Upstart 프로그램으로 이를 교체했고, 페도라(Fedora) 역시 Fedora 15부터 Systemd 프로그램을 이용해 구동 과정을 관리합니다. 즉, 요즘 리눅스 서버 / 데스크탑 시스템에서 시스템 초기 부팅 작업을 위한 솔루션은, 가히 춘추전국시대라고 할 수 있을만큼, 각각을 리눅스 표준으로 정착하려고 노력하는 이들이 있는가 하면, 그냥 옛것이 좋은 것이라고 고수하는 이도 있고, 더 단순하고 본인 입맛에 맞는 시스템을 직접 개발해서 사용하는 이도 있을만큼 다양합니다.\n그런데 여담이지만, 아치리눅스 부팅 과정 커스터마이징과 속도를 경험해봐서 그런 건지, 범용 배포판은 어쩔 수 없이 모든 사용자가 만족할 수 있도록 가능한 많은 서비스 프로그램을 기본적으로 설치하고 이를 모두 시작하기 때문에 느려질 수 밖에 없는 건데, 부팅 속도 향상을 위해 시작 프로세스 관리 데몬의 성능과 기능을 개선하는 방향으로만 접근하고 있는 게 아닌가 하는 생각도 듭니다. 물론 다른 고급 기능을 제공한다고 하지만, 어차피 대부분의 기능은 배포판 개발자들만 사용하는 거고\u0026hellip; :) 참고로, 이 발표자료 만 봐도 부팅 속도와 초기화 프로그램의 능력은 무관한 것 같습니다.\n아무튼, 지금까지 설명한 배경이 최근 임베디드 리눅스 컨퍼런스 2011 발표 슬라이드 를 읽다가 PCD(Process Control Daemon)라는 프로세스 관리 데몬을 소개하는 내용 을 보고 흥미를 가질 수 밖에 없었던 이유입니다. 위에 소개한 최신 프로그램들이 제공하는 기본 기능을 충실히 구현한 것은 물론, 임베디드 시스템을 우선 대상으로 개발했기 때문에 실행파일 크기가 매우 작고 빠르다는 점이 가장 매력적인 장점인 것 같습니다. (자세한 기능은 직접 확인해 보시길\u0026hellip; :)\nSystemd / Upstart 프로그램은 기능은 강력하지만 임베디드 시스템에 적용하기에는 너무 덩치가 크고 라이브러리 의존성도 무시하지 못할만큼 무겁습니다. 또한 임베디드 시스템은 개발자가 시스템의 모든 프로세스를 통제하고 완벽하게 관리해야 하기 때문에, 시스템에 대해 배포판 개발자와 동등하거나 더 많은 이해를 필요로 하므로 이러한 도구를 이용하면 작업이 수월해질 수 있습니다. 더 나아가, 이 프로그램을 조금 더 응용하면 데스크탑 / 서버용 시스템에서 여러 프로세스로 동작하는 시스템을 개발할 때도 유용하지 않을까 하는 생각도 듭니다.\n물론 임베디드 리눅스 개발시 하나의 셸 스크립트 안에서 부팅 과정에 필요한 모든 작업을 처리하는 방식이 무조건 나쁜 건 아닙니다. 다만 복잡도가 더 높은 시스템을 설계할 때는 반드시 이런 프로세스 / 세션 관리 / 예외 처리 프로그램을 사용하거나 알아두면 나중에 참고하는 데 도움이 되지 않을까 생각해 봅니다.\n","date":1306713600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1306713600,"objectID":"e618acc84df154f5b633c0752003d599","permalink":"https://lethean.github.io/2011/05/30/pcd-process-control-daemon/","publishdate":"2011-05-30T00:00:00Z","relpermalink":"/2011/05/30/pcd-process-control-daemon/","section":"post","summary":"아치리눅스를 비롯한 몇몇 리눅스 배포판은 여전히 시스템 부팅 초기화에 필요한 작업, 예를 들어 로컬 파일 시스템을 마운트하거나 웹서버, X서버 같은 시스템 프로그램","tags":["Embedded","Linux"],"title":"PCD - Process Control Daemon","type":"post"},{"authors":null,"categories":null,"content":"최근 프로젝트에서 내장 웹서버를 운영하기 위해 libmicrohttpd 라이브러리를 적용해 보았습니다. 물론, 임베디드 시스템에서 많이 사용하는 GoAhead 등과 같은 상용 라이브러리를 사용하거나, BusyBox 내장 웹서버, 또는 다른 많은 오픈소스 라이브러리를 사용할 수도 있지만, 라이센스도(LGPL 또는 eCos) 괜찮고, 성능과 API 구성이 단순하고 명쾌한 것 같아서 시도해 보았습니다. (물론 아직도 주변에는 라이센스 무시하고 상용 라이브러리 몰래 사용하는 곳이 많긴 하지만\u0026hellip; :-) 참고로, 이 라이브러리는 XBMC 프로젝트를 들여다보다가 내부에서 사용하는 걸 우연하게 발견했습니다.\n내장 웹서버 라이브러리를 사용하면 얻을 수 있는 가장 좋은 장점은 MJPEG, RTSP-over-HTTP 등과 같은 웹기반 스트리밍 서버를 만들때 매우 편리하다는 점입니다. 한 프로세스 안에서 웹서버 + 스트리밍 생성 루틴이 함께 동작하므로 메모리 복사 오버헤드가 줄어들고 프로그래밍 복잡도 역시 감소합니다. 또한 CGI 프로세스가 따로 동작할 필요가 없으므로 웹을 통해 설정을 변경해도 별도의 프로세스간 통신이 불필요합니다.\n물론, 내장 웹서버 방식이 장점만 있는 건 아닙니다. 기존 스탠드얼론 웹서버가 알아서 자동으로 해주던 부분, 예를 들어 디렉토리 인덱스 파일 생성, 동시 접속 클라이언트 수 관리, 클라이언트 캐시를 위한 수정 시각 고려 등을 프로그래머가 직접 작성해야 합니다. 특히 libmicrohttpd 라이브리는 GoAhead 등과 같은 상용 라이브러리에 비하면 자동화 부분이 조금 부족합니다. 예를 들어 파일 시스템의 일반 파일에 대한 웹서비스 처리도 직접 만들어야 합니다. 물론, 대부분 필요한 기능은 예제 소스를 참고하면 어렵지 않게 구현할 수 있습니다. 하지만 제 생각에는, 웹서버 라이브러리가 너무 많은 기능을 자동화하지 않는게 오히려 더 맞다고 생각하는데, 왜냐하면 대부분 응용 프로그램에서 웹서버를 내장하는 경우는 특수한 용도(RESTful / SOAP)이거나 필요한 기능만 구현하기 위해서이기 때문에 나머지는 모두 개발자가 제어하는게 라이브러리의 제 역할이 아닌가 생각합니다.\n","date":1304294400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1304294400,"objectID":"c0ea804f3145cad9adc663c268b85901","permalink":"https://lethean.github.io/2011/05/02/libmicrohttpd-embedded-web-server-library/","publishdate":"2011-05-02T00:00:00Z","relpermalink":"/2011/05/02/libmicrohttpd-embedded-web-server-library/","section":"post","summary":"최근 프로젝트에서 내장 웹서버를 운영하기 위해 libmicrohttpd 라이브러리를 적용해 보았습니다. 물론, 임베디드 시스템에서 많이 사용하는 GoAhead 등과 같은 상용 라이브러리를 사용하","tags":["Embedded","Linux","Web"],"title":"libmicrohttpd 내장 웹서버 라이브러리","type":"post"},{"authors":null,"categories":null,"content":" GStreamer 2011 컨퍼런스 발표 자료 를 보다가 Ice 미들웨어 라는 걸 알게 되었습니다. 참고로 제가 본 발표 자료에서는 원격 임베디드 장치와 PC 사이의 비디오 스트리밍 및 장치 제어에 사용하고 있습니다.\nIce(The Internet Communication Engine) 미들웨어는 쉽게 말해 간편하게 사용할 수 있는 통신 라이브러리인데, 윈도우, 리눅스, 솔라리스, 맥OS, iOS 등의 운영체제를 지원하면서 C++, Java, C#, Python, Ruby, PHP, Objective C 등의 언어에서 사용할 수 있습니다. 라이센스는 GPL과 더불어 상용 제품에 사용할 수 있는 라이센스를 동시에 적용합니다. 즉, 다양한 이기종간의 네트웍 통신을 가능하게 합니다.\n지원하는 기능을 보면, 우선 가장 눈에 띄는 점이 방화벽(firewall) 넘어 자유롭게 피어(peer)간 TCP / UDP 통신을 지원한다는 점입니다. 요즘은 방화벽 대신 NAT, IP 공유기 등이 더 일반적이겠지만, UDP 홀 펀칭(hole punching)이나 인증, 필터링 등과 같은 복잡한 작업을 모두 대신해 준다는 점입니다. 더불어 동기 / 비동기 방식 RPC(Remote Procedure Call) 지원, SSL을 통한 암호화 지원, 다중 서버 인스턴스 지원을 통한 결함 허용(fault tolerance)과 로드 밸런싱(load balancing) 지원, 마지막으로 (제가 직접 사용해보진 않아서 잘 모르지만) 성능과 확장성도 매우 뛰어나다고 합니다.\n라이브러리를 개발한 ZeroC라는 회사는 이 라이브러리를 기반으로 다양한 상용 제품을 제공하는 것은 물론, 용역(?) 개발을 하면서 라이브러리가 실무 분야에서 검증된 것임을 강조하고 있습니다.(당연히 저는 이 회사와 아무 관계가 없습니다)\n언제나 느끼는 거지만, 세상에는 내가 아는 것보다 모르는게 훨씬 더 많고, 뭐가 어디에 있는지 알고 있는게 점점 더 중요해지고 있는 것 같습니다.\n","date":1301961600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1301961600,"objectID":"36ae2c9eed4511abba4721a4d6675995","permalink":"https://lethean.github.io/2011/04/05/ice-internet-communication-engine/","publishdate":"2011-04-05T00:00:00Z","relpermalink":"/2011/04/05/ice-internet-communication-engine/","section":"post","summary":"GStreamer 2011 컨퍼런스 발표 자료 를 보다가 Ice 미들웨어 라는 걸 알게 되었습니다. 참고로 제가 본 발표 자료에서는 원격 임베디드 장치와 PC 사이의 비디오 스트리밍 및 장치 제어에 사","tags":["GStreamer","Ice"],"title":"Ice 인터넷 통신 엔진","type":"post"},{"authors":null,"categories":null,"content":"예를 들어 nobody@hades.net이라는 메일 주소의 서버는 hades.net인 것 같지만 실제로 메일을 호스팅하는 서버는 해당 도메인 서버에 질의해서 MX 레코드에 기록된 호스트를 찾아야 합니다. 그리고 이 작업을 위해 DNS 관련 프로토콜을 직접 구현하거나. djbdns 등과 같은 라이브러리를 이용합니다.\n그런데, 요즘 기존 코드를 리팩토링하면서 가능한 오래된(?) 라이브러리에 대한 의존성을 없애고 있는데 위에서 설명한 작업을 하는 함수가 리눅스 기본 glibc 라이브러리가 당연히 제공하는 걸 알게 되어 잠시 허탈했습니다.\n다음은 도메인 이름을 인수로 주면 해당 도메인의 MX 레코드, 즉 메일서버 호스트를 glibc API를 이용해 작성한 코드입니다.\n#include \u0026lt;netinet/in.h\u0026gt; #include \u0026lt;arpa/nameser.h\u0026gt; #include \u0026lt;resolv.h\u0026gt; static char * lookup_mx (const char *name) { unsigned char response[NS_PACKETSZ]; /* big enough, right? */ ns_msg handle; int ns_index; int len; len = res_search (name, C_IN, T_MX, response, sizeof (response)); if (len \u0026lt; 0) { /* failed to search MX records */ return strdup (name); } if (ns_initparse (response, len, \u0026amp;handle) \u0026lt; 0) { /* failed to parse MX records for '%s'\u0026quot;, name); */ return strdup (name); } len = ns_msg_count (handle, ns_s_an); if (len \u0026lt;= 0) { /* no mx records */ return strdup (name); } for (ns_index = 0; ns_index \u0026lt; len; ns_index++) { ns_rr rr; char dispbuf[4096]; if (ns_parserr (\u0026amp;handle, ns_s_an, ns_index, \u0026amp;rr)) { /* WARN: ns_parserr failed */ continue; } ns_sprintrr (\u0026amp;handle, \u0026amp;rr, NULL, NULL, dispbuf, sizeof (dispbuf)); if (ns_rr_class (rr) == ns_c_in \u0026amp;\u0026amp; ns_rr_type (rr) == ns_t_mx) { char mxname[MAXDNAME]; dn_expand (ns_msg_base (handle), ns_msg_base (handle) + ns_msg_size (handle), ns_rr_rdata(rr) + NS_INT16SZ, mxname, sizeof (mxname)); return strdup (mxname); } } return strdup (name); }  관련 자료는 Stack Overflow 에서 본 것 같기도 하고\u0026hellip; 아무튼, 명색이 전문 리눅스 C 프로그래머로서 15년 넘게 버티고 있으면서도 아직까지도 기본 C 라이브러리가 제공하는 함수도 제대로 알지 못하는 스스로를 돌아보게 됩니다. :(\n","date":1301961600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1301961600,"objectID":"e6e6f0ada0b54229c937f9b977e671b6","permalink":"https://lethean.github.io/2011/04/05/get-domain-mx-host-name/","publishdate":"2011-04-05T00:00:00Z","relpermalink":"/2011/04/05/get-domain-mx-host-name/","section":"post","summary":"예를 들어 nobody@hades.net이라는 메일 주소의 서버는 hades.net인 것 같지만 실제로 메일을 호스팅하는 서버는 해당 도메인 서버에 질의해","tags":["glibc","Linux"],"title":"도메인 메일 호스트(MX) 주소 얻기","type":"post"},{"authors":null,"categories":null,"content":"이제는 리눅스 데스크탑 뿐 아니라 임베디드 시스템에서도 당연하게 사용하는 udev 시스템은 단순히 장치 파일을 자동으로 생성해 주는 역할 뿐 아니라 여러 핫플러그(hot-plug) 방식 장치를 감지하는데도 유용하게 사용됩니다. 비단 키보드, 마우스 같은 입력 장치 뿐 아니라 USB 플래시, SATA / IDE / SCSI 하드디스크, CD-RW 등과 같은 저장장치가 삽입되었거나 제거되었을 경우 쉽게 감지할 수 있게 도와줍니다.\n이러한 udev 서브 시스템의 혜택을 개발자가 얻기 위해 많은 방법이 존재하지만, 이 글에서는 GLib 메인루프 기반으로 동작하는 GUDev 라이브러리를 이용하는 법을 설명합니다. GLib 라이브러리를 사용하지 않을 경우 직접 libudev 라이브러리를 사용해도 되지만, 기본 개념만 파악하면 쉽게 어떤 라이브러리를 사용해도 상관없기 때문에 인터페이스가 더 편하고 직관적인 GUDev 라이브러리를 사용합니다. 참고로, 이 글은 \u0026ldquo; libudev and Sysfs Tutorial ﻿\u0026rdquo; 글과 \u0026ldquo; gudev Vala bindings \u0026rdquo; 글을 참고했습니다.\n먼저 라이브러리를 설치하려면 우분투에서는 libgudev-1.0-dev 패키지, 아치리눅스에서는 udev 패키지를 설치하면 됩니다. (여담이지만, 아치리눅스는 개발에 필요한 헤더파일과 라이브러리가 별도 패키지로 분리되어 있는 경우가 별로 없는 것 같습니다)\n다음 소스 코드는 현재 시스템에 장착된 모든 블럭 장치(block)를 보여주고, 이후 USB 플래시가 삽입되거나 제거되었을때 이를 감지하여 표시하도록 한 소스 코드입니다.(gudev.c)\n#include \u0026lt;gudev/gudev.h\u0026gt; static void print_device (GUdevDevice *device) { const gchar * const *symlinks; g_print (\u0026quot; subsystem : %sn\u0026quot; \u0026quot; devtype : %sn\u0026quot; \u0026quot; name : %sn\u0026quot; \u0026quot; number : %sn\u0026quot; \u0026quot; sysfs_path : %sn\u0026quot; \u0026quot; driver : %sn\u0026quot; \u0026quot; action : %sn\u0026quot; \u0026quot; seqnum : %lldn\u0026quot; \u0026quot; device_type : %dn\u0026quot; \u0026quot; device_number : %dn\u0026quot; \u0026quot; device_file : %sn\u0026quot; \u0026quot;n\u0026quot;, g_udev_device_get_subsystem (device), g_udev_device_get_devtype (device), g_udev_device_get_name (device), g_udev_device_get_number (device), g_udev_device_get_sysfs_path (device), g_udev_device_get_driver (device), g_udev_device_get_action (device), g_udev_device_get_seqnum (device), g_udev_device_get_device_type (device), g_udev_device_get_device_number (device), g_udev_device_get_device_file (device)); } static void uevented (GUdevClient *client, gchar *action, GUdevDevice *device, gpointer user_data) { g_print (\u0026quot;[action:%s]n\u0026quot;, action); print_device (device); } static void print_block_device (gpointer data, gpointer user_data) { GUdevDevice *device = data; print_device (device); g_object_unref (device); } static void print_block_devices (GUdevClient *client) { GList *devices; devices = g_udev_client_query_by_subsystem (client, \u0026quot;block\u0026quot;); if (devices) { g_print (\u0026quot;[block devices]n\u0026quot;); g_list_foreach (devices, print_block_device, NULL); g_list_free (devices); } } int main (int argc, char **argv) { const gchar *subsystems[4] = { \u0026quot;usb/usb_interface\u0026quot;, \u0026quot;scsi/scsi_device\u0026quot;, \u0026quot;block\u0026quot;, NULL }; GUdevClient *client; GMainLoop *main_loop; g_type_init (); main_loop = g_main_loop_new (NULL, FALSE); client = g_udev_client_new (subsystems); g_signal_connect (client, \u0026quot;uevent\u0026quot;, G_CALLBACK (uevented), NULL); print_block_devices (client); g_main_loop_run (main_loop); g_object_unref (client); return 0; }  컴파일 하려면 다음과 같이 실행하면 됩니다.\n$ gcc -o gudev gudev.c `pkg-config --cflags --libs gudev-1.0`  소스 코드를 간단하게 설명하면, 제일 먼저 g_udev_client_new() 함수를 이용해 GUdevClient 객체를 생성합니다. 이때 넘겨주는 인수는 변화를 감지하고 싶은 서브 시스템 목록인데, 여기서는 모든 블럭 장치와 USB, SCSI 서브 시스템을 지정했습니다.(SCSI는 실제로 모든 종류의 하드디스크를 의미하기도 합니다) 만일 NULL을 지정하면 변화 감지 기능을 사용하지 않고 그냥 질의(query) 계열 API만 사용할 수 있으며, 비어있는 목록을 넘겨주면 시스템의 모든 서브시스템의 장치 변화를 감지해서 시그널로 알려줍니다. 참고로 매뉴얼에는 클라이언트를 생성한 쓰레드의 메인루프를 사용하여 감지 루틴이 실행된다고 하니, 만일 별도 쓰레드에서 이 감지 작업을 수행하려면 쓰레드를 먼저 만들고 그 쓰레드 안에서 생성해야 합니다. 이 예제에서는 테스트를 위해 기본 메인 루프를 사용하고 있습니다.\n직접 장치 목록을 질의(query)하거나 시그널이 발생했을 경우 넘겨받는 GUdevDevice 객체와 g_udev_device_get_*() 계열 API를 이용하면 장치의 세부 정보를 얻을 수 있습니다. 위 예제에서는 udev / sysfs 관련 속성 등은 출력하지 않고 있지만, 필요하다면 더 자세한 정보를 얻을 수 있습니다.\n실행하면 대략 다음과 같이 출력됩니다. (당연히 실행 환경에 따라 결과가 다릅니다)\n$ ./gudev [block devices] subsystem : block devtype : disk name : sda number : (null) sysfs_path : /sys/devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda driver : (null) action : (null) seqnum : 0 device_type : 98 device_number : 2048 device_file : /dev/sda subsystem : block devtype : partition name : sda1 number : 1 sysfs_path : /sys/devices/pci0000:00/0000:00:1f.2/host0/target0:0:0/0:0:0:0/block/sda/sda1 driver : (null) action : (null) seqnum : 0 device_type : 98 device_number : 2049 device_file : /dev/sda1 subsystem : block devtype : disk name : sr0 number : 0 sysfs_path : /sys/devices/pci0000:00/0000:00:1f.2/host5/target5:0:0/5:0:0:0/block/sr0 driver : (null) action : (null) seqnum : 0 device_type : 98 device_number : 2816 device_file : /dev/sr0 위 출력에서는 일반 디스크 장치(`/dev/sda`)와 디스크 파티션(`/dev/sda1`), DVD-RW 장치(`/dev/sr0`)가 있음을 보여줍니다. 여기서 만일 일반 USB 플래시 메모리를 삽입하면 다음과 같은 결과가 출력됩니다. [action:add] subsystem : usb devtype : usb_interface name : 2-3:1.0 number : 0 sysfs_path : /sys/devices/pci0000:00/0000:00:1d.7/usb2/2-3/2-3:1.0 driver : usb-storage action : add seqnum : 1934 device_type : 0 device_number : 0 device_file : (null) [action:add] subsystem : scsi devtype : scsi_device name : 17:0:0:0 number : 0 sysfs_path : /sys/devices/pci0000:00/0000:00:1d.7/usb2/2-3/2-3:1.0/host17/target17:0:0/17:0:0:0 driver : sd action : add seqnum : 1938 device_type : 0 device_number : 0 device_file : (null) [action:change] subsystem : scsi devtype : scsi_device name : 17:0:0:0 number : 0 sysfs_path : /sys/devices/pci0000:00/0000:00:1d.7/usb2/2-3/2-3:1.0/host17/target17:0:0/17:0:0:0 driver : sd action : change seqnum : 1944 device_type : 0 device_number : 0 device_file : (null) [action:add] subsystem : block devtype : disk name : sdc number : (null) sysfs_path : /sys/devices/pci0000:00/0000:00:1d.7/usb2/2-3/2-3:1.0/host17/target17:0:0/17:0:0:0/block/sdc driver : (null) action : add seqnum : 1945 device_type : 98 device_number : 2080 device_file : /dev/sdc [action:add] subsystem : block devtype : partition name : sdc1 number : 1 sysfs_path : /sys/devices/pci0000:00/0000:00:1d.7/usb2/2-3/2-3:1.0/host17/target17:0:0/17:0:0:0/block/sdc/sdc1 driver : (null) action : add seqnum : 1946 device_type : 98 device_number : 2081 device_file : /dev/sdc1  위 예제 소스 코드에서 감시하기 위해 지정한 서브 시스템 모두의 변화를 보여주다보니 복잡해 보이지만, 결국 USB 플래시 메모리가 USB / SCSI / BLOCK 서브시스템에 모두 정상적으로 감지되는 걸 확인할 수 있습니다. 다시 장치를 제거하면 다음과 같이 출력됩니다.\n[action:remove] subsystem : block devtype : disk name : sdc number : (null) sysfs_path : /sys/devices/pci0000:00/0000:00:1d.7/usb2/2-3/2-3:1.0/host16/target16:0:0/16:0:0:0/block/sdc driver : (null) action : remove seqnum : 1926 device_type : 0 device_number : 2080 device_file : /dev/sdc [action:remove] subsystem : scsi devtype : scsi_device name : 16:0:0:0 number : 0 sysfs_path : /sys/devices/pci0000:00/0000:00:1d.7/usb2/2-3/2-3:1.0/host16/target16:0:0/16:0:0:0 driver : (null) action : remove seqnum : 1927 device_type : 0 device_number : 0 device_file : (null) [action:remove] subsystem : usb devtype : usb_interface name : 2-3:1.0 number : 0 sysfs_path : /sys/devices/pci0000:00/0000:00:1d.7/usb2/2-3/2-3:1.0 driver : (null) action : remove seqnum : 1931 device_type : 0 device_number : 0 device_file : (null)  이 정보를 실제로 어떻게 활용할지는 이제 어플리케이션에게 달린 몫입니다.\n","date":1299456000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1299456000,"objectID":"d5ef3e0d156948cc39011751bb7fd1a3","permalink":"https://lethean.github.io/2011/03/07/using-gudev/","publishdate":"2011-03-07T00:00:00Z","relpermalink":"/2011/03/07/using-gudev/","section":"post","summary":"이제는 리눅스 데스크탑 뿐 아니라 임베디드 시스템에서도 당연하게 사용하는 udev 시스템은 단순히 장치 파일을 자동으로 생성해 주는 역할 뿐 아니라 여러 핫플러그(hot","tags":["GLib","Linux","Udev"],"title":"GUDev 사용하기","type":"post"},{"authors":null,"categories":null,"content":"요즘 디지털 카메라나 휴대폰으로 촬영한 JPEG 파일에는 EXIF 정보가 삽입되어 있어서 나름 유용할 때가 많습니다. 카메라에 대한 자세한 사양(?) 정보에는 관심이 없지만, 촬영한 시각이라든지 카메라를 세워서 촬영했는지 여부는 물론, 카메라 GPS 옵션을 켜면 기록되는 촬영 장소의 정확한 좌표는 가끔 두려울 때도 있습니다.\n아무튼 요즘은 윈도우나 맥 부럽지 않은 리눅스 사진 관리 프로그램들이 많이 있어서 편하긴 한데, 이런 프로그램들이 존재하기 전부터, EXIF 정보가 포함되지도 않았던 시절부터 디렉토리별로 관리해오던 습관을 버리지 못하는 게 문제입니다. 예를 들어 폴더는 알아보기 쉽게 YYYYMMDD-장소또는이벤트이름 식으로 이름짓고, 안에 들어있는 JPEG 파일은 YYYYMMDD-hhmmss-photo.jpg, 동영상 파일은 YYYYMMDD-hhmmss-movie.mp4 식으로 이름을 지어 줍니다.\n물론, 이런 작업을 모두 수작업으로 하지는 않습니다. EXIF 정보에 문외한이던 시절에는 gthumb 같은 프로그램의 이름일괄변경(Rename...) 기능을 이용해 자동으로 날짜 뒤에 일련번호를 붙이기도 했습니다.\n하지만 요즘은 그것도 귀찮아서 exiv2 / rename 명령어를 이용해 한꺼번에 변경해 버립니다. exiv2 프로그램을 이용해 EXIF 정보에 들어있는 촬영 시각을 기준으로 사진 파일 이름을 변경하고, rename 명령어를 이용해 대문자로 된 .JPG 확장자를 소문자 .jpg 확장자로 한번에 변경합니다. 예를 들어 위에서 설명한 예처럼 파일 이름을 변경하려면 사진 파일이 들어 있는 디렉토리에서 다음과 같이 실행하면 됩니다.\n$ rename .JPG .jpg *.JPG $ exiv2 -r '%Y%m%d-%H%M%S-photo' -k rename *.jpg  rename 명령어는 대부분 배포판에 기본으로 설치되어 있으나 exiv2 프로그램은 수동으로 패키지를 설치해야 할 수도 있습니다. 게다가, 우분투의 rename 명령어는 perl 패키지에 포함되어 있는 버전인데 아치 리눅스는 util-linux 패키지에 포함되어 있는 거라 사용법이 조금 다릅니다. 참고로 위 예제는 아치 리눅스 버전입니다. 하지만 exiv2, rename 명령어 모두 매뉴얼 페이지를 보면 자세한 사용 예제가 있으므로 쉽게 사용할 수 있습니다.\n그리고 이 글은 사실, 나이가 들수록 자꾸만 옵션을 잊어버려 다시 찾기 귀찮아서 기록하고 있습니다\u0026hellip; :)\n","date":1298332800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1298332800,"objectID":"1d3accc15af72ea999e29bbf6d278425","permalink":"https://lethean.github.io/2011/02/22/renaming-photo-files/","publishdate":"2011-02-22T00:00:00Z","relpermalink":"/2011/02/22/renaming-photo-files/","section":"post","summary":"요즘 디지털 카메라나 휴대폰으로 촬영한 JPEG 파일에는 EXIF 정보가 삽입되어 있어서 나름 유용할 때가 많습니다. 카메라에 대한 자세한 사양(?) 정보에는 관심이 없지만,","tags":["ArchLinux","Linux","Ubuntu"],"title":"사진 파일 이름 변경하기","type":"post"},{"authors":null,"categories":null,"content":"1996년부터 리눅스를 사용하면서 슬랙웨어 , 레드햇 , 데비안 을 거쳐 우분투 배포판을 사용해 오다가 최근 아치 리눅스 로 갈아 탔습니다. 우분투가 여러 이유로 편하긴 하지만, 어느 순간부터 점점 무거워지다가(mono, python 기반 기본 프로그램 때문?), 별로 사용하지 않고 원하지도 않는 기능들이 추가되는가 싶더니만(Ubuntu One 등) 급기야 2011.4 버전부터 그놈 3(GNOME 3) 프로젝트의 공식 셸(GNOME Shell) 대신 자체 유나이티(Unity) 셸을 채택한다고 하는 순간, 아 이제 우분투와 이별의 순간이 다가왔구나 깨달았습니다. 그놈 셸이 유나이티보다 UX 측면에서 완성도가 더 높다고 생각하고 있었고, 개인적으로 더 선호하는 스타일이었기 때문이기도 하지만, 역시 상업 회사가 이끄는 배포판은 장점도 많지만 이런 단점도 있을 수 있다는 걸 다시 한 번 깨달았기 때문이기도 합니다. 물론 지금까지 우분투에 불만이 없었던 건 아니지만, 대부분 다른 장점에 의해 묻혀버렸는데, 이번 일을 계기로 쌓였던 불만이 한꺼번에 노출된 것 같기도 합니다.\n그렇다고 데비안이나 페도라, 젠투 배포판으로 가기에는 별로 재미가 없을 것 같아서 여기 저기 확인해보다가 아치 리눅스를 선택하게 되었습니다. 여러가지 이유가 있지만, 32비트 버전의 경우 패키지 바이너리가 i686에 최적화되어 있고, 패키지 시스템이 의외로 빠르고 단순명료하게 동작하면서, 6개월마다 시스템을 갈아 엎을 일 없이 계속 조금씩 업그레이드 되어(rolling release) 최신 소프트웨어를 항상 바로 사용할 수 있다는 점이 맘에 들었습니다. 더 이상 우분투 개발 버전을 사용하면서 X가 실행되지 않는다든지, 부팅이 안된다든지, 잘 돌던 소프트웨어가 동작하지 않는다든지 걱정할 필요가 없어진 셈입니다. 게다가 아치 사용자 저장소(Arch User Repository; AUR)와 yaourt 프로그램을 사용하니 기존에 별도로 설치했던 dropbox, android-sdk, eclipse, openproj 등도 쉽게 패키지로 설치할 수 있어 더 편했습니다. 물론 GUI 방식 패키지 관리자가 없고 패키지 설치만으로 모든 설정이 자동으로 되는게 아니라 어느 정도 리눅스 경험자가 아니면 불편한 점도 많지만, 오히려 중급 사용자 이상일 경우 원리를 하나씩 알아가면서 설치하는 재미도 쏠쏠합니다. 게다가 별도 문서가 불필요할 정도로 아치리눅스 위키 페이지 정리가 잘 되어 있어 굳이 다른 구글링도 필요없는 것 같습니다. 물론, 한글 글꼴 패키지의 부족이나 부족한 그놈 테마 패키지 등 못마땅한 점이 없는 건 아니지만, 어차피 단점 없는 배포판은 없는 법, 나름 오랜만에 커스터마이징에 즐거운 시간을 보낸 것 같습니다.\n인증 스크린샷이라도 하나 올리려다가, 별로 다른게 없어서 그만 두었습니다. 사용하는 배포판이 무엇이든, 어차피 설치 이후에는 결국 동일한 리눅스일 뿐이기 때문입니다. 여담이지만, 오래된 저사양 노트북에서도 동일한 그놈 환경인데 우분투보다 더 빨리 실행되는 듯한 느낌을 받고 있습니다. 물론 정신적인 영향이 더 큰 것 같기도 하지만\u0026hellip; :)\n","date":1298246400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1298246400,"objectID":"ac7c3ffc6c48477458cf5e7dad993e5d","permalink":"https://lethean.github.io/2011/02/21/migrated-to-arch-linux/","publishdate":"2011-02-21T00:00:00Z","relpermalink":"/2011/02/21/migrated-to-arch-linux/","section":"post","summary":"1996년부터 리눅스를 사용하면서 슬랙웨어 , 레드햇 , 데비안 을 거쳐 우분투 배포판을 사용해 오다가 최근 아치 리눅스 로 갈아 탔습니다. 우분투가 여러 이유로 편하","tags":["ArchLinux","Linux"],"title":"아치 리눅스(Arch Linux)로 갈아타다","type":"post"},{"authors":null,"categories":null,"content":"리눅스에서 병목 현상 디버깅이나 현재 실행중인 프로세스 중에서 가장 CPU 리소스를 많이 소모하는 녀석을 찾아야 할 경우가 있습니다. 이런 경우 가장 전통적이고 간단한 방법은 top 명령어를 실행해서 키보드 단축키 \u0026lsquo;1\u0026rsquo; / \u0026lsquo;H\u0026rsquo;를 눌러 CPU / 쓰레드별 사용량을 확인하는 것입니다. 또한 이와 관련된 전통적인 유닉스 명령어도 많지만, 리눅스에서 실행 루틴 수준에서 더 정밀하게 분석하고 싶다면 OProfile , Valgrind , Google Performance Tools 등과 같은 도구를 사용해도 됩니다.\n그런데, 최근 리눅스 커널과 배포판에는 perf 추적(trace) 도구가 포함되어 있습니다. 그리고 이를 기반으로 한 여러 명령어 중에서, 이 글에서 소개하는 perf top 명령어를 사용하면 쉽게 현재 실행중인 커널 / 사용자 프로세스의 CPU 사용 내역을 확인할 수 있습니다. 이 명령어는 기본적으로 top 명령어와 비슷하게 동작하지만, OProfile 같은 도구처럼 별도의 복잡한 설정 과정이 필요없다는 장점이 있습니다. 게다가 그 원리를 조금만 이해하면 다양한 응용이 가능하고, 최근 리눅스 커널에 추가된 많은 추적 도구 중에서 가장 활발하게 개발되고 있는 프레임워크이기 때문에 익숙해지는 것도 나쁘지 않을 것 같습니다.\n우분투 리눅스에서 perf 도구를 사용하려면 제일 먼저 다음과 같이 해당 패키지를 설치해야 합니다.\n$ sudo apt-get install linux-tools  실행하기 위해서 반드시 perf 이벤트 접근 권한이 있어야 하므로 루트 계정 또는 sudo 명령을 이용해 다음과 같이 무작정 실행하면 됩니다.\n$ sudo perf top  위 출력 화면을 간단하게 설명하면, 마지막 갱신 주기 동안 AES_encrypt 함수가 가장 많이 실행되었습니다. 목록은 위에서 아래로 더 많이 실행된 순서로 정렬되어 있는데, 각 열(column)을 설명하면, 맨 앞의 샘플(samples)과 퍼센트(pcnt)는 총 성능 카운터 샘플링 중에서 차지한 회수와 비율을 나타내고 함수(function)과 동적 공유 객체(DSO)는 샘플링된 위치를 보여줍니다. 따라서 가장 많이 샘플링된 함수가 갱신 주기 동안 가장 많이 실행된 부분이라고 해석하면 됩니다.\n예를 들어 위 실행 결과는, git pull 명령으로 ssh 방식 네트웍 서버로부터 데이터를 받아오는 작업을 처리하는 과정을 분석한 것입니다. ssh 연결이므로 암호화 관련 라이브러리 호출이 가장 많이 보이고, 커널에서 사용자 공간으로 복사하는 함수, e1000 이더넷 드라이버 인터럽트 핸들러 등이 눈에 띕니다.\nman perf top 또는 perf top help 명령으로 더 자세한 사용법을 얻을 수 있습니다. 많은 옵션이 있지만 그 중에서 자주 사용하는 옵션 몇 가지만 설명하면, -v 옵션은 함수 내에서 더 장확한 샘플링 위치를 보여주면서 상세한 메시지를 출력합니다. 그리고, -s 옵션은 지정한 함수만 어셈블리 단계에서 샘플링한 결과를 자세히 보여줍니다.\n참고로, 데비안 / 우부툰에서 개발하는 분이라면 패키지로 설치한 라이브러리의 디버깅 심볼 포함 패키지를 함께 설치해 두면, 예를 들어 libc6 라이브러리는 libc6-dbg 패키지(끝에 \u0026lsquo;-dbg\u0026rsquo;가 더 붙음), 많은 개발 / 분석 도구에서 더 자세한 정보를 얻을 수 있습니다.\n","date":1295136000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1295136000,"objectID":"0eaf2ad9c8e0be0c49ad8da161d8565a","permalink":"https://lethean.github.io/2011/01/16/using-perf-top/","publishdate":"2011-01-16T00:00:00Z","relpermalink":"/2011/01/16/using-perf-top/","section":"post","summary":"리눅스에서 병목 현상 디버깅이나 현재 실행중인 프로세스 중에서 가장 CPU 리소스를 많이 소모하는 녀석을 찾아야 할 경우가 있습니다. 이런 경우 가장 전통적이고 간단한 방","tags":["Kernel","Linux","Perf"],"title":"perf top 사용하기","type":"post"},{"authors":null,"categories":null,"content":"비단 비트토런트(BitTorrent)나 어뮬(aMule) 같은 P2P 응용 프로그램이 아니라도 파일 크기를 (대략이라도) 미리 알고 있을 경우, 디스크 공간을 미리 할당해서 단편화(fragmentation)를 줄이는 것은 물론 용량 부족으로 인한 쓰기 오류를 미리 막는 기법은 종종 필요합니다.\n예전에는 이를 위해 파일을 생성한뒤 원하는 크기의 0으로 채워진 파일을 미리 만들어 두는 무식한 방법을 사용하거나, lseek() 함수를 이용해 원하는 크기만큼 뒤로 이동한 뒤 더미 1바이트르 쓰는 기법 등을 사용했습니다. 물론 이 기법은 지금도 유용합니다.\n그런데 요즘 리눅스 커널에서 주로 사용하는 파일시스템이 이런 기능을 근본적으로 지원하게 되면서 쉽게 사용할 수 있는 API가 추가되었는데, 다름아닌 fallocate() / posix_fallocate() 함수입니다. 매뉴얼에 의하면 리눅스 커널 2.6.23 버전, glibc 2.10 버전 이후부터 btrfs, ext4, ocfs2, xfs 파일시스템에서 지원한다고 하는데, 해당 파일시스템이 직접 지원하지 않을 경우 커널이 알아서 비효율적인 방법으로 처리해 주는 것 같습니다.\n터미널이나 콘솔에서 직접 지정한 크기의 파일을 만들 수 있는 fallocate 명령어도 요즘 리눅스 배포판에는 기본적으로 포함되어 있습니다. 사용해 보면 알겠지만, 아무리 큰 파일도 매우 빨리 만들어 줍니다. 그리고, 매뉴얼에는 명시되어 있지 않지만, 큰 파일을 지원하기 위한 fallocate64() / posix_fallocate64() 함수도 사용할 수 있습니다. 자세한 함수와 명령어 사용법은 매뉴얼(man) 페이지를 참고하면 쉽게 알 수 있기 때문에 자세한 사용법은 생략합니다.\n참고로, 멀티플랫폼 비트토런트 클라이언트인 Transmission 소스 를 보면 다양한 플랫폼에서 동일한 기능을 어떻게 사용하는지 알 수 있습니다.\n","date":1294790400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1294790400,"objectID":"5193a0005a6d37573a4f0b7d8636ef0b","permalink":"https://lethean.github.io/2011/01/12/allocate-file-space-in-advance/","publishdate":"2011-01-12T00:00:00Z","relpermalink":"/2011/01/12/allocate-file-space-in-advance/","section":"post","summary":"비단 비트토런트(BitTorrent)나 어뮬(aMule) 같은 P2P 응용 프로그램이 아니라도 파일 크기를 (대략이라도) 미리 알고 있을 경우, 디스크 공간을","tags":["glibc","Linux"],"title":"파일 공간 미리 할당하기","type":"post"},{"authors":null,"categories":null,"content":"힘겹게 겨우 다시 한 학기를 마무리했지만, 할 일은 여전히 밀려 있습니다. 그래서 잠시 머리도 식힐겸 요즘 관심있게 지켜보고 있는 GNOME 프로젝트 중 하나인 The Board 프로젝트에 대해 간략하게 소개해볼까 합니다.\n일단, 백마디 말보다 스크린샷 하나가 더 좋을 것 같군요.\n이 프로그램은 쉽게 말해 다음과 같은 오프라인 보드를 컴퓨터에서 흉내내는 것입니다. 다만 아직은 개인 자료 수집용입니다.\n 그놈 셸(GNOME Shell) 과 마찬가지로, 클러터(Clutter) 라이브러리 를 이용해 자바스크립트(JavaScript) 언어 로 작성되었다는 점이 흥미롭습니다. 다음은 실제 동작 화면을 캡쳐한 동영상 모음입니다.\n[vimeo 13601332 w=400 h=250]\n Introducing The Board from Lucas Rocha on Vimeo .\n[vimeo 13869009 w=400 h=250]\n Videos in The Board from Lucas Rocha on Vimeo .\n[vimeo 15969297 w=400 h=250]\n Toolbar in The Board from Lucas Rocha on Vimeo .\n[vimeo 16908549 w=400 h=250]\n Context Toolbars in The Board from Lucas Rocha on Vimeo .\n[vimeo 17506246 w=400 h=250]\n Adding to The Board from Lucas Rocha on Vimeo .\n개발 로그를 들여다보면 로컬 웹서버를 구동시켜 웹브라우저에서도 접근할 수 있는 인터페이스가 추가되고 있는 것도 같은데, 언젠가는 현재 인터넷의 글목록 방식 게시판이 아닌 이와 같이 실생활을 모방한 방식의 인터넷 게시판도 등장하지 않을까\u0026hellip; 상상해봅니다.\n","date":1293062400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1293062400,"objectID":"13b12d66cbab29d99ca0c5e93080642a","permalink":"https://lethean.github.io/2010/12/23/the-board-project-introduction/","publishdate":"2010-12-23T00:00:00Z","relpermalink":"/2010/12/23/the-board-project-introduction/","section":"post","summary":"힘겹게 겨우 다시 한 학기를 마무리했지만, 할 일은 여전히 밀려 있습니다. 그래서 잠시 머리도 식힐겸 요즘 관심있게 지켜보고 있는 GNOME 프로젝트 중 하나인 The Board 프로젝트에","tags":["Clutter","GNOME"],"title":"The Board 소개","type":"post"},{"authors":null,"categories":null,"content":"며칠전부터 리눅스 커뮤니티와 관련 뉴스 사이트에서 리눅스 데스크탑 반응속도(reponsiveness)를 획기적으로 향상시킨다는 233라인짜리 패치 에 대한 소식 이 끊임없이 흘러다니고 있습니다. 리누스 토발즈가 극찬을 해서 더 유명해진 것 같기도 한데, 아마도 원래 아이디어를 본인이 제안해서 그런게 아닌가 싶기도 하고, 커널 컴파일과 동시에 웹브라우징, 동영상 재생을 하는 것처럼 극단적인 환경과 멀티코어 시스템에만 적용될 뿐이라고 그리 대단하게 않게 보는 사람 들도 있는 것 같습니다. 게다가 한 터미널(tty)에서 파생한 프로세스를 모두 하나의 태스크 그룹으로 묶어 다른 태스크 그룹과 공평한 스케줄링이 되도록 한다는 아이디어가 근본적으로 cgroup 파일시스템을 이용하기 때문에 특별한 커널 패치 없이 cgroup 데몬과 스크립트를 이용해 동일한 효과를 얻는 기법 도 등장했습니다.\n직접 느껴보려고 일단 회사 개발 장비에 적용해 보았는데, 사양이 너무 좋아서인지 별로 차이점을 느끼지 못했습니다. 그래서 오래된 노트북 PC와 상대적으로 낮은 사양의 데스크탑 장비에도 적용해봤습니다. 하지만, 아이디어 자체가 터미널 작업과 다른 작업을 다른 그룹으로 나누는 것 뿐이라서 그런지, 터미널을 열어 다른 작업을 안했더니 별로 반응속도가 달라지는 건 느끼지 못하고 있습니다.\n그럼에도 불구하고, 스케줄링 정책만으로 데스크탑 반응성을 향상할 수 있다는 아이디어를 조금만 더 확장하면 더 좋은 아이디어만 알고리즘이 나오지 않을까 기대해 봅니다. 아니나 다를까, 페도라 15에서 시작 데몬으로 탑재할 SystemD 데몬에서 이미 사용자 세션, 서비스별로 각각의 태스크 그룹을 분리하도록 적용 하는 것 같습니다.\n[업데이트-2010.11.22] 예를 들어 제 경우, 구형 노트북에서 조금이라도 그래픽 성능 향상을 얻을 수 있을까 해서 ﻿/etc/gdm/Init/Default 파일 마지막 라인 \u0026lsquo;exit 0\u0026rsquo; 전에 다음과 같은 항목을 추가해서 체감 속도 변화를 느껴보려고 노력 중입니다.\n#chrt -rr -p 10 $(pidof X) mkdir -m 0700 -p /mnt/cgroups/cpu/Xorg echo $(pidof X) \u0026gt; /mnt/cgroups/cpu/Xorg/tasks  ","date":1290211200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1290211200,"objectID":"0a8c28d3e37365f464d56215ec5962cf","permalink":"https://lethean.github.io/2010/11/20/test-a-patch-to-improve-responsiveness-in-linux-desktop/","publishdate":"2010-11-20T00:00:00Z","relpermalink":"/2010/11/20/test-a-patch-to-improve-responsiveness-in-linux-desktop/","section":"post","summary":"며칠전부터 리눅스 커뮤니티와 관련 뉴스 사이트에서 리눅스 데스크탑 반응속도(reponsiveness)를 획기적으로 향상시킨다는 233라인짜리 패치 에","tags":["Kernel","Linux","Schedule"],"title":"리눅스 데스크탑 반응속도 향상 패치 테스트","type":"post"},{"authors":null,"categories":null,"content":"실시간 시스템의 핵심 요구사항 중 하나는 빠른 대기시간(latency)이 아니라 가장 느린 대기시간을 미리 가늠할 수 있어야(predictability) 한다는 점입니다. 즉, 아무리 짧은 응답시간을 제공하더라도 시스템 부하(load)나 입출력(I/O), 태스크 동기화(synchronization) 등에 의해 느려지거나 최대 응답시간을 예측할 수 없다면 실시간 운영체제가 아닙니다. 물론 응답시간이 가능한 짧으면서 편차가 크지 않으면 더 바랄게 없겠지만, 그렇지 못할 경우라도 운영체제가 대기시간을 어느 정도까지 보장할 수 있느냐가 더 중요합니다. 참고로 여기서 언급하는 대기시간(latency)은 인터럽트, 태스크 스케줄링, I/O 스케줄링 등 여러 문맥에서 다른 의미를 가집니다.\n실시간 시스템의 또 하나의 중요한 특징은 실시간 태스크의 스케줄링을 보장하는 일입니다. 즉, 시스템에 어떤 상황이 발생하더라도 미리 지정한 실시간 태스크가 마감시간(deadline)을 지킬 수 있어야 합니다. 이를 위해 전통적인 실시간 운영체제들은 마감시간 스케줄러(deadline scheduler), 스포래딕 서버(sporadic server) 등을 이용해 이를 보장합니다.\n최근 리눅스 커널과 관련된 이슈를 살펴보면 위에서 설명한 두 가지 조건을 만족하기 위한 작업이 한창이지만, 이 글에서는 안드로이드(Android) 운영체제가 스마트폰 뿐 아니라 여러 내장 시스템(embedded system)에 도입되기 위한 필수조건을 일단 정리했습니다.\n일반적으로 기능적 오류가 아닌 시간적 오류, 즉 안드로이드가 실시간 시스템 설계 명세에서 제한한 마감시간(deadline)을 얼마나 잘 지원하는지를 실험한 결과를 보면[1], 측정을 크게 둘로 나뉘어, 첫번째는 하드웨어 인터럽트 이벤트가 커널 내부의 이벤트 처리 모듈에게 전달되는데까지 소요되는 대기시간(latency)을 측정한 것이고, 두번째는 커널 이벤트 처리 모듈이 이벤트를 안드로이드 달빅(Dalvik) 가상머신 위에서 동작하는 어플리케이션에게 전달하기까지 걸리는 시간을 측정합니다. 더불어 대기시간의 변동량(variation)을 관찰해 실시간 시스템에 적합한 지 여부도 확인해 봅니다. 안드로이드 하부는 리눅스 커널이므로, 이 실험은 결국 안드로이드 플랫폼에 사용되는 리눅스 커널에 대한 실험이기도 합니다.\n실험 결과는 흥미로운데, 정상적인 부하가 걸릴때보다(under normal load) 아무 부하도 없을때(under no load) 대기시간이 더 들쑥날쑥 합니다. 그 원인은 아무 작업도 없을 경우 저전력모드(low power mode)로 있다가 인터럽트가 발생하면 그때서야 정상적인 상태로 돌아와 이벤트를 처리하기 때문입니다. 하지만 타이머 인터럽트 주기를 100밀리초에서 1밀리초로 변경하면, 거의 제 시간에 처리하지 못하는 결과가 발생하는 모습을 보여줍니다.\n안드로이드 자바 어플리케이션의 각 쓰레드는 리눅스 pthread에 일대일로 대응합니다. 안드로이드에서 자바 쓰레드 우선순위는 10단계로 조정할 수 있는데, 이 값은 리눅스 쓰레드의 nice값으로 변환됩니다. 즉, 리눅스 커널 스케줄링 클래스 중에서 SCHED_OTHER 클래스만 사용하고 실시간 우선순위를 사용하는 SCHED_FIFO, SCHED_RR 클래스는 사용하지 않습니다.[2] 달빅(Dalvik) 가상머신은 고전적인 자바 가상머신이 실시간 시스템에서 고생하는 원인 중 하나로 지목되는 가비지 컬렉션(garbage collection)으로 인한 예측불가능한 프로세스 멈춤(freeze) 현상을 여전히 가지고 있습니다. 자체적으로 구현한 C 라이브러리(bionic)는 SystemV IPC 등과 같은 기존 프로세스간 동기화 메카니즘을 없애고 Binder라는 고유 IPC 메카니즘을 제공하는데, 태스크간 우선순위 역전(priority inversion)을 막기 위한 우선순위 상속(priority inheritance), 우선순위 한계(priority ceiling) 같은 프로토콜을 아직 제공하지 않습니다.\n안드로이드는 인터럽트 핸들러가 우선순위가 더 높은 실시간 태스크를 선점하거나 지연하지 않기 위해 반드시 해결되어야 하는 리눅스 커널 인터럽트 처리 방식의 구조적 한계도 그대로 가지고 있습니다. 이를 해결하려면, 사용하는 모든 드라이버의 인터럽트 핸들러를 리눅스 2.6.30 버전부터 추가된 쓰레드 방식으로 바꾸거나 PREEMPT_RT 패치를 적용해야 합니다.\n그래서 결론은, 역시 아직 안드로이드 운영체제는 실시간 시스템에 적합하지 않지만, 이를 보완하기 위한 많은 작업과 연구가 더 필요합니다.\n[1]﻿ Bhupinder S. Mongia, Vijay K. Madisetti, ﻿Reliable Real-Time Applications on Android OS [2] Claudio Mia, Luis Nogueira, Evaluating Android OS for Embedded Real-Time Systems ","date":1290124800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1290124800,"objectID":"57652bc6d4bd849e71fb91755d7fdb5b","permalink":"https://lethean.github.io/2010/11/19/real-time-on-android-os/","publishdate":"2010-11-19T00:00:00Z","relpermalink":"/2010/11/19/real-time-on-android-os/","section":"post","summary":"실시간 시스템의 핵심 요구사항 중 하나는 빠른 대기시간(latency)이 아니라 가장 느린 대기시간을 미리 가늠할 수 있어야(predictability)","tags":["Android","Kernel","Linux"],"title":"안드로이드 운영체제에서 실시간 시스템","type":"post"},{"authors":null,"categories":null,"content":"스케줄링 영역 (Scheduling Domain)\n멀티 프로세서 시스템에서 스케줄러의 중요한 역할 중 하나는 모든 CPU의 부하를 균등하게 맞추는 일입니다. 이를 위해 스케줄러는 한 CPU에서 동작하던 태스크를 다른 CPU로 이동해야 하는 경우, 각 아키텍쳐의 특성을 고려해야 합니다. 왜냐하면, 한 CPU에서 동작하던 태스크를 다른 CPU로 옮기면(migration) 캐시 불일치 등으로 인한 오버헤드가 발생하는 것은 물론 아키텍쳐에 따라 심각한 성능 저하를 일으킬 수도 있기 때문입니다.[1]\n예를 들어, 하이퍼 쓰레드 프로세서는 하나의 프로세서 안에 논리적인 CPU가 여러 개 포함된 구조이기 때문에 여러 논리 CPU는 모두 캐시와 메모리를 모두 공유합니다. 따라서 이 논리 CPU간에는 태스크를 이동하는데 오버헤드가 없습니다. SMP(Symmectric Multi Processor) 시스템이나 멀티 코어(Multi Core) 프로세서에는 하나의 물리 CPU 안에 한 개 이상의 CPU 코어가 장착되어 있습니다. 이 CPU 코어는 각각 캐시(cache)를 가지고 있지만, 메모리는 모두 공유합니다. 따라서 프로세서간 태스크 이동(migration)이 가능한 적을수록 좋은 성능을 얻을 수 있습니다. NUMA 아키텍쳐는 여러 노드로 구성되는데, 한 노드는 하나의 CPU와 메모리, 캐시로 구성됩니다. 그리고 한 CPU가 같은 노드의 메모리를 접근할 때는 속도가 다른 노드의 메모리를 접근할 때보다 훨씬 빠릅니다. 그러므로 CPU간 태스크 이동은 정책적으로 반드시 필요한 경우에만 일어나야 합니다. 최근 출시되는 프로세서는 대부분 멀티 코어이면서 각 프로세서 코어가 다시 하이퍼 쓰레드를 통해 논리 CPU를 지원하고, NUMA 아키텍쳐에서 한 노드의 프로세서가 하이퍼 쓰레드를 지원하기도 합니다.\n이처럼 다양한 구조의 시스템을 효율적으로 지원하기 위해 리눅스 커널 2.6 버전부터 스케줄링 영역(scheduling domains) 기능이 추가되었습니다. 스케줄링 영역은 스케줄링 그룹 자료구조와 함께 구성되며 계층적인 방식으로 전체 시스템의 영역을 구성합니다. 스케줄링 영역(struct sched_domain)은 속성(properties)과 정책(policies)을 공유하는 CPU 집합이기 때문에, 해당 CPU 간에 부하가 균등하게 조절됩니다. 스케줄링 그룹(struct sched_group)은 CPU별로 할당되면서 동시에 영역의 여러 CPU를 묶어서 구성되기도 합니다. 스케줄링 영역은 스케줄링 그룹을 한 개 이상 포함하기 때문에 스케줄러가 한 영역 내에서 균형을 유지하려할 때 그룹 안에서 발생하는 상황을 걱정하지 않고 그룹의 부하(load)를 다른 그룹으로 이동합니다.\n스케줄링 클래스 (Scheduling Class)\n리눅스 커널 2.6.23 버전에서 기존 O(1) 스케줄러를 대체한 CFS(Completely Fair Scheduler) 스케줄러를 구현하면서 함께 도입된 스케줄링 클래스(Scheduling Class)는 리눅스 커널의 다양한 스케줄링 정책을 캡슐화해서 기본 스케줄러를 확장하기 쉽도록 도와줍니다. 하지만 스케줄러 메인 코드가 모듈 방식으로 구현된 건 아니기 때문에 새 스케줄러를 일반 커널 모듈처럼 쉽게 넣거나 뺄 수 있는 건 아닙니다. 다만 POSIX 표준에서 요구하는 SCHED_RR, SCHED_FIFO, SCHED_NORMAL, SCHED_BATCH, SCHED_IDLE 등과 같은 정책을 분리해서 구현하기 위해 도입된 구조입니다.[2] 하지만, 새 스케줄러 모듈을 추가하는 작업이 예전에 비해 쉬어진 것은 사실입니다.\n스케줄링 클래스는 코어 스케줄러를 돕는 여러 모듈을 연결해 놓은 고리처럼 볼 수 있습니다. 가장 앞에 있는 스케줄러 모듈이 먼저 실행되고, 실행할 태스크가 없으면 다음 스케줄러 모듈을 실행하는 방식으로 동작합니다. 실제로, 스케줄링 클래스에는 실시간 스케줄러(sched_rt.c), CFS 스케줄러(sched_fair.c), 유휴 스케줄러(sched_idletask.c) 순으로 단일 연결 목록에 등록되어 있어 순서대로 스케줄러 모듈을 실행합니다.\n각 스케줄러 모듈은 스케줄링 클래스 구조체(struct sched_class)가 제안하는 기능을 콜백 함수처럼 구현합니다. 다음은 리눅스 커널 2.6.23 버전에서 정의된 스케줄링 클래스 구조입니다.\nstruct sched_class { /* Defined in 2.6.23:/usr/include/linux/sched.h */ struct sched_class *next; void (*enqueue_task) (struct rq *rq, struct task_struct *p, int wakeup); void (*dequeue_task) (struct rq *rq, struct task_struct *p, int sleep); void (*yield_task) (struct rq *rq, struct task_struct *p); void (*check_preempt_curr) (struct rq *rq, struct task_struct *p); struct task_struct * (*pick_next_task) (struct rq *rq); void (*put_prev_task) (struct rq *rq, struct task_struct *p); unsigned long (*load_balance) (struct rq *this_rq, int this_cpu, struct rq *busiest, unsigned long max_nr_move, unsigned long max_load_move, struct sched_domain *sd, enum cpu_idle_type idle, int *all_pinned, int *this_best_prio); void (*set_curr_task) (struct rq *rq); void (*task_tick) (struct rq *rq, struct task_struct *p); void (*task_new) (struct rq *rq, struct task_struct *p); };  위 구조체에서 중요한 함수를 살펴보면 다음과 같습니다.\n enqueue_task() : 태스크가 실행 가능한 상태로 진입할 때 호출됩니다. dequeue_task() : 태스크가 더 이상 실행 가능한 상태가 아닐때 호출됩니다. yield_task() : 태스크가 스스로 yield() 시스템콜을 실행했을 때 호출됩니다. check_preempt_curr() : 현재 실행 중인 태스크를 선점(preempt)할 수 있는지 검사합니다. pick_next_task() : 실행할 다음 태스크를 선택합니다. put_prev_task() : 실행중인 태스크를 다시 내부 자료구조에 넣을때 호출됩니다. load_balance() : 코어 스케줄러가 태스크 부하를 분산하고자 할때 호출됩니다. set_curr_task() : 태스크의 스케줄링 클래스나 태스크 그룹을 바꿀때 호출됩니다. task_tick() : 타이머 틱 함수가 호출합니다. task_new() : 새 태스크가 생성되었을때 그룹 스케줄링을 위해 호출됩니다.  스케줄링 클래스 구조는 기본 CFS 스케줄러에서 사용하는 내부 자료구조와 밀접하게 연관되어 있습니다. 예를 들어 각 CPU별로 유지하면서 콜백 함수의 인수로 넘겨지는 실행 큐(struct rq)는 CFS 스케줄러를 위해 채택한 레드-블랙 트리(red-black tree) 자료구조를 사용하기 때문에 새 스케줄러 모듈을 구현하려면 반드시 기존 CFS 스케줄러 동작 방식과 구조를 어느정도 자세히 알고 있어야 합니다.[3]\n[1] Jonathan Corbet, \u0026ldquo;Scheduling domains\u0026rdquo;, LWN.net, 2004  [2] Avinesh Kumar, Multiprocessing with the Completely Fair Scheduler, IBM developerWorks, 2008  [3] M. Tim Jones, Inside the Linux 2.6 Completely Fair Scheduler, IBM developerWorks, 2009 ","date":1286323200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1286323200,"objectID":"09b285efdc8baae2c7bff553da84476b","permalink":"https://lethean.github.io/2010/10/06/linux-kernel-scheduling-domains-and-classes/","publishdate":"2010-10-06T00:00:00Z","relpermalink":"/2010/10/06/linux-kernel-scheduling-domains-and-classes/","section":"post","summary":"스케줄링 영역 (Scheduling Domain) 멀티 프로세서 시스템에서 스케줄러의 중요한 역할 중 하나는 모든 CPU의 부하를 균등하게 맞추는 일입니다. 이를 위해 스케줄러는 한 CPU에서 동","tags":["Kernel","Linux","Schedule"],"title":"리눅스 커널 스케줄링 영역과 클래스","type":"post"},{"authors":null,"categories":null,"content":"리눅스 커널 CPU 스케줄링과 마찬가지로 I/O 스케줄링에 적용되는 스케줄링 클래스와 우선순위도 ioprio_set() 시스템콜을 이용해 사용자가 제어할 수 있습니다. 하지만 리눅스 커널이 제공하는 여러가지 I/O 스케줄러 중에서 CFQ(Completely Fair Queuing) 스케줄러에서만 사용할 수 있습니다. 물론 리눅스 커널은 블럭 장치마다 다른 I/O 스케줄러를 사용할 수 있도록 허용하므로 필요한 경우 적절하게 시스템을 구성하는 것도 가능합니다.[1]\nI/O 스케줄링 클래스는 CPU 스케줄링과 비슷하게 나누어집니다. 첫번재 IOPRIO_CLASS_RT(1) 클래스는 실시간(real-time) I/O 클래스로서, 이 클래스에 속한 태스크는 다른 클래스에 속한 태스크보다 항상 디스크에 먼저 접근합니다. 클래스 내부 우선순위는 가장 높은 0부터 가장 낮은 7까지 지정할 수 있습니다. 두번째 IOPRIO_CLASS_BE(2) 클래스는 최선노력(best-effort) I/O 클래스로서, 특별히 I/O 우선순위를 지정하지 않은 대부분의 태스크가 이 클래스에 속합니다. 첫번째 클래스와 마찬가지로 0부터 7까지 내부 우선순위를 지정할 수 있으며, 이 우선순위에 따라 얼마나 많은 I/O 대역폭을 할당할지 결정합니다. 마지막 IOPRIO_CLASS_IDLE(3) 클래스에 속한 태스크는 위의 두 클래스에 속한 어떤 태스크도 해야할 I/O 작업이 없을때만 I/O 작업을 수행하고, 내부 우선순위는 무시됩니다.\nI/O 스케줄링 클래스와 우선순위는 읽기 작업과 동기화 쓰기 작업(O_DIRECT, O_SYNC)에만 반영됩니다. 즉, 일반적인 비동기 쓰기 작업에는 적용되지 않습니다.\nioprio_set(), ioprio_get() 시스템콜은 리눅스 표준 C 라이브러리에 대응하는 함수가 없기 때문에 다음과 같이 직접 syscall() 함수를 이용해 호출해야 합니다.[2]\n#define _GNU_SOURCE /* or _BSD_SOURCE or _SVID_SOURCE */ #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; /* For SYS_xxx definitions */ static inline int ioprio_set (int which, int who, int ioprio) { return syscall (__NR_ioprio_set, which, who, ioprio); } static inline int ioprio_get (int which, int who) { return syscall (__NR_ioprio_get, which, who); }  위와 같이 프로그램 소스 코드를 수정하지 않아도 ionice 프로그램을 이용하면 셸(shell)이나 스크립트에서 직접 다른 태스크의 I/O 스케줄링 클래스와 우선순위를 변경할 수도 있습니다.\n이와 더불어 리눅스 커널 cgroups 시스템의 blkio 서브시스템을 이용하면 태스크 / 디스크별 대역폭(bandwidth)을 할당하거나 그룹별로 더 다양한 I/O 정책을 세밀하게 적용할 수 있습니다.[3]\n[1] ioprio_set(), Linux Programmer\u0026rsquo;s Manual [2] Block IO Priorities, Linux Kernel Source Documentation [3] Block IO Controller, Linux Kernel Source Documentation ","date":1286236800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1286236800,"objectID":"a9b4f4694694ec35bbfae5d368d09fc3","permalink":"https://lethean.github.io/2010/10/05/linux-kernel-io-scheduler-priority/","publishdate":"2010-10-05T00:00:00Z","relpermalink":"/2010/10/05/linux-kernel-io-scheduler-priority/","section":"post","summary":"리눅스 커널 CPU 스케줄링과 마찬가지로 I/O 스케줄링에 적용되는 스케줄링 클래스와 우선순위도 ioprio_set() 시스템콜을 이용해 사용자가 제어할 수 있습니다. 하지만 리눅스 커널이","tags":["Kernel","Linux","Schedule"],"title":"리눅스 커널 I/O 스케줄링 우선순위","type":"post"},{"authors":null,"categories":null,"content":" GLib 2.26.0 안정버전 이 출시되었습니다. 한동안 개인적으로 관심있는 업데이트가 없어서 정리를 안 했는데, 이번 업데이트는 흥미로운 기능이 매우 많이 추가되어 있어 관심을 가질 수 밖에 없을 것 같습니다.\n전반적으로 2011년 4월 예정인 GNOME 3 환경을 목표로 계속 개발중인 GTK+ 3.0 에 초점이 맞추어 있는 듯 싶더니, 굵직한 기능들을 이번 GTK+, GLib 안정버전에 미리 많이 포함했다는 느낌을 받습니다. 다른 말로 표현하면, 기존에 여러 라이브러리를 사용해야 했던 데스크탑 어플리케이션 기본(?) 기능들을, 마치 QT 라이브러리처럼, GLib 라이브러리 하나에 통합하고 있는 듯한 느낌입니다. 물론 이로 인해 멀티플랫폼 라이브러리 색깔은 조금 옅어질 것 같지만, 어차피 리눅스 / 유닉스 특화적인 기능은 GIO 모듈로 분리되어 있기 때문에 GIO 라이브러리 사용만 조심한다면, C++ 언어에서 STL, Boost 라이브러리 등과 같이 C 프로그래머를 편하게 해 주는 멀티 플랫폼 \u0026ldquo;기본\u0026rdquo; C 라이브러리 역할을 하는데는 여전히 문제가 없을 것으로 생각됩니다.\nglib 모듈에서 가장 눈에 띄는 기능은 단연 GDateTime API입니다. 지금까지 GLib 라이브러리를 사용하면서 제일 아쉬웠던 부분 중 하나인데, 날짜와 매우 기초적인 초(seconds) 정보만 다루는 GDate API만 있어서 매번 시 / 분 / 초를 표현하는 자료구조와 API를 만들어 사용했던 번거로움이 사라질 것 같습니다.\ngobject 모듈에는 제가 무척이나 아쉬워했던 객체 속성 바인딩 GBinding 기능이 추가되었습니다. 사용법은 이전에 제가 소개했던 ExoBinding 과 거의 비슷하고, 내부 구현도 거의 유사합니다. 더불어 트리모델이나 객체 속성으로 기존 구조체를 사용하기 위해 매번 GBoxed 타입을 구현했는데, 이를 쉽게 해주는 G_DEFINE_BOXED_TYPE() , G_DEFINE_POINTER_TYPE() 등과 같은 매크로도 추가되었습니다.\ngio 모듈에는 이번 릴리스의 핵심 기능들이 추가되었습니다. 첫번째는 더 이상 리눅스 기본시스템 버스인 DBus 에 접근하기 위해 별도의 라이브러리가 필요없도록 GDBus API가 추가되었습니다.(간단한 튜토리얼 가이드 도 있습니다) 두번째 기능은 GSettings API인데, GNOME 3부터 현재 GConf 설정 기능을 대체할 dconf 기능과 연동되어 사용될 것으로 보입니다.( \u0026ldquo;GConf에서 GSettings로 이전하기\u0026rdquo; 가이드도 참고하시면 좋을 것 같습니다)\n이외에도 물론 많은 API가 추가되었으므로, 관련 있으신 분들은 반드시 각 모듈 참고 매뉴얼 마지막의 2.26 버전에서 새로 추가된 API 목록을 확인해 보시기 바랍니다. 참고로, 지금까지 설명한 GLib 변경사항은 GNOME 2.32 버전에 이미 포함되어 있기 때문에 앞으로 출시되는 대부분의 배포판(Ubuntu 10.10 포함)에 기본적으로 탑재됩니다.\n","date":1285977600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1285977600,"objectID":"619bbcdafaff81da7aa48cf3ceee4791","permalink":"https://lethean.github.io/2010/10/02/glib-2-26-0-release/","publishdate":"2010-10-02T00:00:00Z","relpermalink":"/2010/10/02/glib-2-26-0-release/","section":"post","summary":"GLib 2.26.0 안정버전 이 출시되었습니다. 한동안 개인적으로 관심있는 업데이트가 없어서 정리를 안 했는데, 이번 업데이트는 흥미로운 기능이 매우 많이 추가되어 있어 관심을","tags":["GLib"],"title":"GLib 2.26.0 출시","type":"post"},{"authors":null,"categories":null,"content":"SCHED_OTHER, SCHED_IDLE, SCHED_BATCH 스케줄링 정책(policy)에 속하는 일반 태스크는 스케줄링 우선순위(priority)는 항상 0입니다. 하지만 SCHED_FIFO, SCHED_RR 등과 같은 실시간 스케줄링 정책에 속하는 태스크는 가장 낮은 1부터 가장 높은 99까지의 우선순위가 부여됩니다.\n리눅스 커널 스케줄러는 태스크 우선순위별로 실행 가능한 태스크 목록을 유지하고, 가장 높은 우선순위부터 차례대로 각 우선순위별 태스크 목록이 비어있는지 검사해서 태스크가 있을 경우 목록의 첫번째 태스크를 다음에 실행할 태스크로 선택합니다. 따라서, 항상 가장 높은 우선순위가 부여된 실시간 태스크가 실행되고, 결과적으로 일반 태스크는 항상 실시간 태스크보다 나중에 스케줄링됩니다.\nSCHED_FIFO, SCHED_RR 정책은 우선순위가 같을 경우 태스크를 목록 어디에 삽입할 지를 결정하는데 사용합니다. SCHED_FIFO 정책에 속하는 태스크는 실행 가능 상태가 되면 우선순위 태스크 목록의 마지막에 삽입됩니다. 이 태스크는 I/O 요청을 기다리거나, 우선순위가 더 높은 태스크에 의해 선점(preempted)되는 경우, 직접 sched_yield(2) 시스템콜을 호출하는 경우가 아니면 계속 실행됩니다. 반면에 SCHED_RR 정책은 SCHED_FIFO 정책과 비슷하지만 각 태스크에게 할당된 최대 실행 시간(maximum time quantum)이 지나면 자동으로 우선순위 태스크 목록 마지막으로 이동됩니다.[1]\n만일 프로세스(process)가 아닌 쓰레드(thread)의 스케줄링 속성을 변경하려면, gettid() 시스템콜을 호출해서 얻은 tid 값을 프로세스 pid 대신 넘겨주면 됩니다. 하지만 gettid() 시스템콜은 C 라이브러리에 대응하는 함수가 없기 때문에 다음과 같이 직접 syscall() 함수를 이용해 호출해야 합니다.[2]\n#define _GNU_SOURCE /* or _BSD_SOURCE or _SVID_SOURCE */ #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/syscall.h\u0026gt; /* For SYS_xxx definitions */ #include \u0026lt;sys/types.h\u0026gt; /* For pid_t */ static inline pid_t gettid (void) { return (pid_t) syscall (SYS_gettid); /* or __NR_gettid */ }  위와 같이 직접 프로그래밍하지 않아도 chrt 유틸리티를 사용하면 셸(shell)이나 스크립트에서 직접 다른 태스크의 실시간 스케줄링 속성을 변경할 수도 있습니다.\n하지만 리눅스 커널은 실시간 태스크 스케줄링에 필수적인 스케쥴링 지연시간(scheduling latency), 인터럽트 지연시간(interrupt latency)을 보장하지(guarantee) 않기 때문에 이를 개선하기 위해서는 별도의 패치를 적용한 커널을 사용해야 합니다.[3][4]\n[1] sched_setscheduler(), Linux Programmer\u0026rsquo;s Manual [2] gettid(), Linux man-pages [3] Real-time Linux Wiki [4] OSADL Project: Real-time Linux ","date":1285804800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1285804800,"objectID":"da5a3de45bc4f4d80b1d316c0a851480","permalink":"https://lethean.github.io/2010/09/30/linux-kernel-realtime-scheduling-priority/","publishdate":"2010-09-30T00:00:00Z","relpermalink":"/2010/09/30/linux-kernel-realtime-scheduling-priority/","section":"post","summary":"SCHED_OTHER, SCHED_IDLE, SCHED_BATCH 스케줄링 정책(policy)에 속하는 일반 태스크는 스케줄링 우선순위(priority)는 항상 0입니다. 하지만 SCHED_FIFO, SCHED_RR 등과 같은 실시간 스케줄링 정","tags":["Kernel","Linux","Schedule"],"title":"리눅스 커널 실시간 스케줄링 우선순위","type":"post"},{"authors":null,"categories":null,"content":"뭐, 전혀 관심 없는 분이 대부분이겠지만, 제 하드 디스크에서 묵히는 것보다 누군가에게 도움이 되는 편이 좋을 것 같아, 별로 품질이 좋은 소스는 아니지만, 오픈 소스만 사용해도 무난하게 과제 수행에 문제가 없음을 보여주기 위해, 지난 학기 수업 과제물로 제출했던 과제물의 문서와 프로그램 소스를 공개합니다.\n참고로, 앞의 두 프로그램은 GTK+ 라이브러리를 이용해서 리눅스에서 개발했지만, 과제 시연을 위해 윈도우에서도 문제없이 컴파일되고 실행되도록 만들었습니다. 그리고, 안드로이드 뷰어는 라이브 보기만 구현된 소스입니다.\n1. Image Histogram Viewer\n﻿﻿이 프로그램은 JPEG 이미지 파일을 읽어들여 화면에 표시하고 파일의 이름, 생성일시, 수정일시 등과 같은 속성을 보여주고, 이미지의 히스토그램을 분석하여 그래프로 표시합니다.\n2. Photo Mosaic Builder\n이 프로그램은 원본 사진을 동일한 크기의 작은 영역으로 쪼갠뒤 복수의 다른 사진으로 다시 구성하여 최종 모자이크 사진을 생성합니다. 복수의 사진은 작은 썸네일(thumbnail) 사진으로 변환되며 각 영역의 색 속성과 가장 유사한 썸네일 사진으로 채워집니다. 이 과정에 복수의 사진을 한번만 사용할 지 여부를 선택할 수 있으 며, 최종 사진을 파일로 다시 저장할 수도 있습니다. 이 모든 과정을 처리하는데 걸리는 시간을 측정하여, OpenMP 라이브러리를 이용한 성능 최적화 정도를 확인할 수 있습니다.\n3. 안드로이드 IP 카메라 뷰어 설계 및 구현\n안드로이드 IP 카메라 뷰어는 휴대폰 같은 안드로이드(Android) 장비에서 네트워크에 연결된 IP 카메라에 접속하여 라이브 영상과 음성을 재생하고 카메라 동작을 제어합니다. 또한 사용자에게 친숙한 안드로이드폰의 다른 기능과 유기적으로 연동하여 언제 어디서나 쉽고 빠르게 긴급상황에 대처할 수 있도록 도와줍니다. 이를 위해 원격에서 비디오 스트리밍 데이터를 수신하여 디코딩한 후 색상 공간(color space) 변환까지 마친 후 화면에 표시하는 작업에 안드로이드 NDK(Native Development Kit) 방식 C/C++ 코드를 활용합니다. 또한 네이티브 C 모듈과 자바 언어와의 통신 오버헤드를 줄이기 위해 메모리 공유 기법을 이용하여 제한된 하드웨어의 성능을 최대화합니다.\nP.S. 새 학기가 시작되었는데, 오히려 지난 첫 학기보다 더 험난한 시절을 보내고 있습니다. 요즘은 술 사준다고 연락하는 사람도 점점 뜸해지고\u0026hellip;\n","date":1285632000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1285632000,"objectID":"c09e17b1129a12519456a04e6053c9c2","permalink":"https://lethean.github.io/2010/09/28/programs-written-in-2010-spring-semester/","publishdate":"2010-09-28T00:00:00Z","relpermalink":"/2010/09/28/programs-written-in-2010-spring-semester/","section":"post","summary":"뭐, 전혀 관심 없는 분이 대부분이겠지만, 제 하드 디스크에서 묵히는 것보다 누군가에게 도움이 되는 편이 좋을 것 같아, 별로 품질이 좋은 소스는 아니지만, 오픈 소스만","tags":["Android","GTK+","GUI","Linux","Windows"],"title":"2010년 1학기에 작성한 프로그램","type":"post"},{"authors":null,"categories":null,"content":"오랫동안 묵혀두었던 LG XNOTE C1 노트북에 우분투를 설치했는데, 사운드 카드를 통해 오디오가 재생되지 않았습니다. 한동안 오디오를 재생할 일이 없어서 그냥 사용하다가, 오늘 갑자기 필요해져서 급하게 문제를 해결했는데, 그 과정을 기록해 둡니다.\n일단 확인 결과 사운드 카드 관련 드라이버는 모두 정상적으로 동작합니다. 하지만, 역시나 가장 문제 많은 snd-hda-intel 드라이버를 사용하고 있었습니다. 그래서 더 정확히 사용하는 모델을 확인하기 위해 /proc/asound/pcm 파일을 열어보니 다음과 같이 ALC883 모델을 사용하고 있습니다.\n00-00: ALC883 Analog : ALC883 Analog : playback 1 : capture 1 00-01: ALC883 Digital : ALC883 Digital : playback 1 : capture 1 00-02: ALC883 Analog : ALC883 Analog : capture 1  이제 이 칩셋을 사용하는 모델 목록을 얻기 위해 리눅스 커널 소스 문서 디렉토리에서 해당 파일을 검색합니다.(Documentation/sound/alsa/HD-Audio-Models.txt) 그러면 ALC883 칩은 다음과 같은 목록이 있습니다.\nALC882/883/885/888/889 ====================== 3stack-dig 3-jack with SPDIF I/O 6stack-dig 6-jack digital with SPDIF I/O arima Arima W820Di1 targa Targa T8, MSI-1049 T8 asus-a7j ASUS A7J asus-a7m ASUS A7M macpro MacPro support mb5 Macbook 5,1 macmini3 Macmini 3,1 mba21 Macbook Air 2,1 mbp3 Macbook Pro rev3 imac24 iMac 24'' with jack detection imac91 iMac 9,1 w2jc ASUS W2JC 3stack-2ch-dig 3-jack with SPDIF I/O (ALC883) alc883-6stack-dig 6-jack digital with SPDIF I/O (ALC883) 3stack-6ch 3-jack 6-channel 3stack-6ch-dig 3-jack 6-channel with SPDIF I/O ... auto auto-config reading BIOS (default)  이제 남은 일은 /etc/modprobe.d/alsa-base.conf 파일 마지막 부분에 다음과 같은 내용을 추가하고, 위 문서에 있는 각 모델 이름을 지정하고 재부팅한 뒤 사운드 재생 테스트 과정을 모든 모델에 대해 반복합니다.\noptions snd-hda-intel model=3stack-dig  다행히 제 경우 첫번째 모델이었습니다. 빙고!\n[추가 - 2010.08.19] 우분투 10.10 알파 버전에서는 터치패드 버튼도 이상 동작합니다. 여러 사이트를 참고 했지만, 일단 다음 내용을 위와 동일한 방법으로 추가해서 일반 마우스처럼 사용하고 있습니다.\noptions psmouse proto=imps  ","date":1281312000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1281312000,"objectID":"4255978a290717ca80204b4b764cefb5","permalink":"https://lethean.github.io/2010/08/09/sound-problem-on-lg-xnote-c1-notebook-in-ubuntu/","publishdate":"2010-08-09T00:00:00Z","relpermalink":"/2010/08/09/sound-problem-on-lg-xnote-c1-notebook-in-ubuntu/","section":"post","summary":"오랫동안 묵혀두었던 LG XNOTE C1 노트북에 우분투를 설치했는데, 사운드 카드를 통해 오디오가 재생되지 않았습니다. 한동안 오디오를 재생할 일이 없어서 그냥 사용하다가","tags":["Sound","Ubuntu"],"title":"LG XNOTE C1 노트북 우분투 사용시 사운드 재생 문제","type":"post"},{"authors":null,"categories":null,"content":"Btrfs 파일 시스템을 사용해 보려고 새로 나온 우분투 10.10 버전을 설치했습니다. 그런데, 아니나 다를까 한글 글꼴 설정은 여전히 맘에 들지 않는군요. 예전에는 이것 저것 쉽게 찾아 고쳤는데, 시간이 점점 흘러서 그 과정을 자꾸 잊어버리게 되다 보니 오늘은 조금 더 많이 헤매게 되어 기록해 두려고 합니다.\n먼저 메인 글꼴로 사용하는 나눔글꼴은 우분투 저장소에 패키지(ttf-nanum, ttf-nanum-coding)가 이미 올라와 있어서 그대로 설치해서 사용했습니다. 더불어 기본적인 MS 글꼴 패키지(ttf-mscorefonts-installer)를 설치하고, 터미널 글꼴로 사용하는 드로이드 글꼴(ttf-droid)을 설치하고 cairo 라이브러리 패치 작업을 한 뒤 \u0026lsquo;시스템-기본 설정-모양\u0026lsquo;은 다음 그림과 같이 설정했습니다.\n이제 글꼴 설정 파일을 건드려야 하는데, 제일 먼저 /etc/fonts/conf.d/ 디렉토리에서 10-hinting-slight.conf 파일과 29-language-selector-ko-kr.conf 파일을 삭제합니다. 그래야 일반적인 영문 / 한글 글꼴에 대한 힌팅이 예쁘게 동작합니다. 그 다음에 같은 디렉토리의 69-language-selector-ko-kr.conf 파일을 다음과 같이 수정합니다.\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE fontconfig SYSTEM \u0026quot;fonts.dtd\u0026quot;\u0026gt; \u0026lt;fontconfig\u0026gt; \u0026lt;!-- Set preferred Korean fonts --\u0026gt; \u0026lt;match target=\u0026quot;pattern\u0026quot;\u0026gt; \u0026lt;test qual=\u0026quot;any\u0026quot; name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;family\u0026quot; mode=\u0026quot;prepend\u0026quot; binding=\u0026quot;strong\u0026quot;\u0026gt; \u0026lt;string\u0026gt;DejaVu Sans\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;나눔고딕\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;UnDotum\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026quot;pattern\u0026quot;\u0026gt; \u0026lt;test qual=\u0026quot;any\u0026quot; name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;family\u0026quot; mode=\u0026quot;prepend\u0026quot; binding=\u0026quot;strong\u0026quot;\u0026gt; \u0026lt;string\u0026gt;DejaVu Serif\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;나눔명조\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;UnBatang\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026quot;pattern\u0026quot;\u0026gt; \u0026lt;test qual=\u0026quot;any\u0026quot; name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;monospace\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;family\u0026quot; mode=\u0026quot;prepend\u0026quot; binding=\u0026quot;strong\u0026quot;\u0026gt; \u0026lt;string\u0026gt;Droid Sans Mono\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;DejaVu Sans Mono\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;나눔고딕코딩\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Guseul\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;UnDotum\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026quot;font\u0026quot;\u0026gt; \u0026lt;test name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;나눔고딕\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;NanumGothic\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;나눔고딕코딩\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;NanumGothicCoding\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;맑은 고딕\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Malgun Gothic\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;UnDotum\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;UnBatang\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;hintstyle\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;const\u0026gt;hintmedium\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026quot;font\u0026quot;\u0026gt; \u0026lt;test name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;나눔명조\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;NanumMyeongjo\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;hintstyle\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;const\u0026gt;hintslight\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026quot;font\u0026quot;\u0026gt; \u0026lt;test name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;DejaVu Sans Mono\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Droid Sans Mono\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;hintstyle\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;const\u0026gt;hintslight\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026quot;font\u0026quot;\u0026gt; \u0026lt;test name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;Andale Mono\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Arial Black\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Arial\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Comic Sans MS\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Courier New\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Georgia\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Impact\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Tahoma\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Times New Roman\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Trebuchet MS\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Verdana\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Webdings\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;hintstyle\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;const\u0026gt;hintmedium\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;/fontconfig\u0026gt;  뭐, ﻿대충 이 정도만 설정해도 깔끔한 모양의 글꼴을 볼 수 있습니다.\n사족) Btrfs 파일 시스템은 많은 디스크 I/O가 동시에 걸리면 시스템 전체가 느려지는 듯한 느낌이 여전히 듭니다. 뭐, 앞으로 조금씩 더 좋아지겠지요.\n[UPDATE-2010.12.23] 이 포스트를 작성하는 시점에서는 아직 Ubuntu 글꼴이 패포판에 포함되지 않았던 시점이라서 이를 사용한 fontconfig 설정으로 업데이트 했습니다.\n[UPDATE-2011.01.04] 한동안 크로미엄 브라우저만 사용하다가 최근 다시 파이어폭스를 사용하다보니 MS 글꼴이 이쁘게 나오지 않는 걸 확인하고 이를 반영했습니다.\n","date":1281052800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1281052800,"objectID":"0e4372043d2000dbdfaec818ae7b543a","permalink":"https://lethean.github.io/2010/08/06/ubuntu-10-10-korean-font-configuration/","publishdate":"2010-08-06T00:00:00Z","relpermalink":"/2010/08/06/ubuntu-10-10-korean-font-configuration/","section":"post","summary":"Btrfs 파일 시스템을 사용해 보려고 새로 나온 우분투 10.10 버전을 설치했습니다. 그런데, 아니나 다를까 한글 글꼴 설정은 여전히 맘에 들지 않는군요. 예전에는 이것 저것 쉽게","tags":["FontConfig","Hangul","Ubuntu"],"title":"우분투 10.10 한글 글꼴 설정","type":"post"},{"authors":null,"categories":null,"content":"우분투 최신 버전을 설치하면 kerneloops-daemon 패키지가 자동으로 설치됩니다. 이 프로그램은 커널 로그 메시지를 주기적으로(10초 간격으로) 가져와서 파싱(parsing)한 뒤 커널 패닉(OOPS) 메시지를 추출해 이를 D-Bus 를 통해 전달하는 역할을 하는데. kerneloops-applet 패키지를 설치하면 로그인시 자동으로 애플릿 하나가 실행되면서 D-Bus에서 메시지를 받아 사용자 확인을 거쳐 kerneloops.org 사이트 등으로 보고서를 자동으로 전송합니다. 참고로, 우분투에서 데몬을 동작하게 하려면 /etc/default/kerneloops 파일 안에서 enabled 항목을 1로 변경해야 하고, 세부 동작 옵션은 /etc/kerneloops.conf 설정 파일을 수정하면 됩니다.\n그런데 이 kernelooops 소스를 검토하던 중 커널 로그 버퍼(보통 dmesg 명령 결과)를 가져오기 위해 다음과 같은 시스템콜을 직접 호출하는 것을 발견했습니다. (kerneloops 패키지 소스 안에 dmesg.c:423)\nsyscall(__NR_syslog, 3, buffer, getpagesize());  이 시스템 콜 사용법이 궁금해서 dmesg 소스를 확인해 보니 여기서는 다음과 같은 C 라이브러리 함수를 사용합니다. (util-linux 패키지 소스 안에 sys-utils/dmesg.c:120)\nn = klogctl(3, buf, sz); /* read only */  그래서 매뉴얼을 찾아보니(man klogctl) 둘 모두 같은 동작을 하는 것은 물론, 지금껏 모르고 있었던 몇가지 기능도 알 수 있었습니다.\n예를 들어, 매뉴얼에도 나와 있듯이, 지금까지는 syslogd 데몬과 통신하는 syslog(3) 함수만 알고 있었는데, 이 함수는 커널 syslog 시스템콜과 아무 관계가 없다는 점 등입니다. 참고로, 리눅스 커널 소스는 kernel/printk.c 파일에 있는 do_syslog() 함수가 실제로 syslog 시스템콜을 처리하고 있습니다.\n","date":1280275200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1280275200,"objectID":"076e220791bd536d746c831975c0da89","permalink":"https://lethean.github.io/2010/07/28/reading-linux-kernel-log-buffer/","publishdate":"2010-07-28T00:00:00Z","relpermalink":"/2010/07/28/reading-linux-kernel-log-buffer/","section":"post","summary":"우분투 최신 버전을 설치하면 kerneloops-daemon 패키지가 자동으로 설치됩니다. 이 프로그램은 커널 로그 메시지를 주기적으로(10초 간격으로) 가져와서 파싱(parsing)","tags":["Kernel","Linux"],"title":"리눅스 커널 로그 버퍼 읽기","type":"post"},{"authors":null,"categories":null,"content":"구글 리더를 읽다가 어떤 분이 터미널 글꼴로 \u0026lsquo;Droid Sans Mono\u0026rsquo; 사용한 포스트 를 보고 따라해 보았습니다. 그런데, 이상하게도 글꼴이 예쁘지 않아서 확인해 보니 폰트 설정에서 힌팅(hinting)을 살짝(slight)만 사용하도록 설정해야 했습니다. 사실, 대부분의 영문 폰트는 힌팅을 살짝 주어야 원래 의도대로 멋지게 표시되는 경우가 많습니다. (아래 그림에서 폰트 설정 화면 참조)\n그런데 문제는, 이 설정을 이용하면 나눔글꼴과 같은 일부 한글 글꼴이 오히려 안 이쁘게 표시됩니다. 특히 나눔고딕은 힌팅을 중간(hintmedium)이나 충분히(hintfull) 사용해야 합니다. 그런데 위 그림을 보면 나눔고딕 역시 정상적으로 표시되고 있습니다. 이 포스트는 그 과정을 정리한 것입니다. 사용환경은 우분투 10.04 배포판이고, 나눔글꼴 과 나눔고딕코딩 글꼴은 데비안 패키지를 직접 내려받아 설치했습니다. 우분투 저장소에도 조만간 반영되겠지요.\n먼저 폰트별로 다른 힌팅 스타일을 사용하기 위해 폰트 설정에서, 나눔글꼴 계열 힌팅 스타일을 충분히(hintfull)로 변경합니다. ~/.fonts.conf 파일을 편집해도 되지만, 제 경우 그냥 ﻿﻿﻿/etc/fonts/conf.avail/69-language-selector-ko-kr.conf 파일에 다음 내용을 추가했습니다. 그래야 루트 사용자를 포함한 모든 사용자가 사용할 수 있고, 다른 설정 항목도 모두 거기 있어서 나중에 다시 설치할때 파일 하나만 복사해서 사용하기 때문입니다.\n\u0026lt;match target=\u0026quot;font\u0026quot;\u0026gt; \u0026lt;test name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;나눔고딕\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;NanumGothic\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;나눔명조\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;NanumMyeongjo\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;나눔고딕코딩\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;NanumGothicCoding\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;hintstyle\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;const\u0026gt;hintfull\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt;  그런데 문제는, 이 설정이 먹혀들지 않는다는 점입니다. 이상하게도 파이어폭스나 크롬브라우저, KDE 등에서는 잘 적용되는데, 정작 그놈 터미널이나 모든 그놈 프로그램에서는 적용이 되지 않았습니다. 검색해보니, GTK+ 툴킷을 포함한 대부분 그놈 프로그램이 사용하는 카이로(cairo) 라이브러리에 관련 버그 가 이미 보고되어 있는데 아직 패키가 반영되지 않은 상태였습니다. 카이로 라이브러리가 힌팅의 경우 FontConfig 설정을 따르지 않고 무조건 그놈 글꼴 설정, 더 정확히 말하면 X 리소스의 Xft.hintstyle 값만 사용하기 때문이었습니다.\n그래서 다음과 같은 과정을 거쳐 직접 빌드한 패키지를 설치해서 사용하고 있습니다.\n$ apt-get source libcairo2 # 패키지 소스 내려받기 $ sudo apt-get build-dep libcairo2 # 빌드를 위한 패키지 내려받기 $ cd cairo-* $ vi src/cairo-ft-font.c # 위 버그질라에 등록된 패치 적용 $ vi debian/changelog # 패키지 버전 올림 $ dpkg-buildpackage -rfakeroot # 패키지 생성 $ cd ..; sudo dpkg -i libcairo*.deb # 패키지 설치  패키지 생성 방법을 익힌게 거의 10년 전 쯤 데비안 사용 시절이라 요즘은 어떻게 만드는지 잘 모르겠지만, 다행히도 위 방식도 제대로 동작하는 것 같아 그냥 사용하고 있습니다. 요즘은 우분투 PPA도 활성화되었고, 빌드 방식도 더 간단해진 것 같긴 한데, 게을러서\u0026hellip; :)\n결론은, Droid Sans Mono 글꼴을 터미널 글꼴로 잘 사용하고 있습니다. 참, 이 글꼴 역시 다음과 같이 쉽게 설치할 수 있습니다.\n$ sudo apt-get install ttf-droid  그런데, 위 패치가 아직까지도 최근 cairo 소스에는 반영되지 않은 것 같아 약간 아쉽군요.\n","date":1279497600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1279497600,"objectID":"1f5173593b84e661f3b954abdb0f8f0b","permalink":"https://lethean.github.io/2010/07/19/hinting-for-different-fonts/","publishdate":"2010-07-19T00:00:00Z","relpermalink":"/2010/07/19/hinting-for-different-fonts/","section":"post","summary":"구글 리더를 읽다가 어떤 분이 터미널 글꼴로 \u0026lsquo;Droid Sans Mono\u0026rsquo; 사용한 포스트 를 보고 따라해 보았습니다. 그런데, 이상하게도 글꼴이 예쁘지 않아서 확인해 보니 폰트 설정에서 힌팅","tags":["Cairo","FontConfig","Ubuntu"],"title":"글꼴마다 다른 힌팅 사용하기","type":"post"},{"authors":null,"categories":null,"content":"한 10년만에 가져보는 방학(?)을 만끽하느라, 오랜만에 올리는 글입니다.\n다른게 아니라, Xper 메일링 리스트에 어느 분이 재미있는 글 을 올리셨는데, 글에도 언급된 것처럼 예전에 비슷한 내용이 있었지만, 개인적으로는, 이 버전이 더 나은 것 같습니다.\n특히 구로 디지털단지 역 앞 건물들 이름이 너무 친숙해서, 더 실감이 나기도 하고\u0026hellip;\nP.S. 워드프레스 3.0 버전으로 업그레이드하면서 기본 테마를 사용하게 되었는데, 집에서 보이는 관악산 전경을 휴대폰 카메라로 촬영한 뒤 약간의 조작을 거쳐 상단 이미지로 사용했습니다. (어디냐고 물어보는 분이 계셔서\u0026hellip; :)\n","date":1278720000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1278720000,"objectID":"4b3e0e834d1ee08092f60878391b0573","permalink":"https://lethean.github.io/2010/07/10/old-man-who-was-coding/","publishdate":"2010-07-10T00:00:00Z","relpermalink":"/2010/07/10/old-man-who-was-coding/","section":"post","summary":"한 10년만에 가져보는 방학(?)을 만끽하느라, 오랜만에 올리는 글입니다. 다른게 아니라, Xper 메일링 리스트에 어느 분이 재미있는 글 을 올리셨는데, 글에도 언급","tags":["Coding"],"title":"코딩하던 노인","type":"post"},{"authors":null,"categories":null,"content":" Btrfs 사용기 를 포스팅한 지 얼마 되지도 않았는데, 우분투 배포판 10.10 버전 기본 파일시스템으로 Btrfs를 사용할지도 모른다는 소식 이 들려옵니다. 인텔(Intel) 모블린(Moblin)과 노키아(Nokia) 마에모(Maemo) 플랫폼이 통합된 미고(MeeGo) 플랫폼에서도 Btrfs 파일시스템을 채택 하더니 바로 우분투 다음 버전도 채택할 지 모른다는 얘기입니다.\n세부 일정은, Btrfs 파일시스템 안정성과 성능은 일단 2010년 10월 릴리스에 사용하는 리눅스 커널 2.6.35 버전에서 어느 정도 완성된다는 가정하에, GRUB2 부트로더를 지원하고 알파(alpha) 릴리스부터 사용자 피드백을 받아 파일시스템 개발자와 충분한 피드백을 주고 받아 안정화 하는 방식으로 진행할 것 같습니다.\n아무튼, 이렇게 되면 Btrfs 파일시스템을 설치 옵션으로 제공함으로써 패키지 업데이트 전후 스냅샷 복구 기능을 Btrfs를 이용해 지원하는 페도라(Fedora) 배포판처럼, 사용자가 직접 느낄 수 있는 기능이 우분투에도 추가되면 재미있고 유용해 질 수 있을 것 같습니다. 게다가, SSD 디스크에 최적화되어 있다는 마운트 옵션도 궁금하고, 요즘 관심을 가지고 있는 Ceph 분산 파일 시스템도 테스트해 볼 수 있을테고\u0026hellip;\n","date":1273968000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1273968000,"objectID":"f3bd199b49b50412cfaeb6903143abd2","permalink":"https://lethean.github.io/2010/05/16/btrfs-as-the-default-filesystem-in-ubuntu-10-10/","publishdate":"2010-05-16T00:00:00Z","relpermalink":"/2010/05/16/btrfs-as-the-default-filesystem-in-ubuntu-10-10/","section":"post","summary":"Btrfs 사용기 를 포스팅한 지 얼마 되지도 않았는데, 우분투 배포판 10.10 버전 기본 파일시스템으로 Btrfs를 사용할지도 모른다는 소식 이 들려옵니다. 인텔(Intel","tags":["Kernel","Linux","Ubuntu"],"title":"우분투 10.10 기본 파일시스템 - Btrfs","type":"post"},{"authors":null,"categories":null,"content":"LWN.net 기사 중에서 소스 코드 작업 시각화 관련 기사 를 보고 재미있을 것 같아 Gource 프로그램을 이용해 회사에서 진행중인 프로젝트에 적용해 보았습니다.\n 만드는 방법은 우선 필요한 패키지를 설치하고(Ubuntu 기준)\n$ sudo apt-get install gource ffmpeg  Git 저장소가 있는 디렉토리로 이동해서 다음과 같이 실행합니다.\n$ gource -s 0.01 --auto-skip-seconds 0.1 --file-idle-time 500 --disable-progress --output-framerate 25 --highlight-all-users -800x600 --stop-at-end --output-ppm-stream - | ffmpeg -y -b 1000K -r 17 -f image2pipe -vcodec ppm -i - -vcodec mpeg4 gource-edc-20100423.avi  프로젝트에 참여했던 사람들 이름이 나타났다 사라지는 걸 보면 기분이 약간 묘해지는 것 같습니다 ;)\n","date":1271980800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1271980800,"objectID":"0638166100a76e8b0c5f3b900074c523","permalink":"https://lethean.github.io/2010/04/23/gource-source-visualization/","publishdate":"2010-04-23T00:00:00Z","relpermalink":"/2010/04/23/gource-source-visualization/","section":"post","summary":"LWN.net 기사 중에서 소스 코드 작업 시각화 관련 기사 를 보고 재미있을 것 같아 Gource 프로그램을 이용해 회사에서 진행중인 프로젝트에 적용해 보았습니다. 만드는 방법은 우선 필요","tags":["Agile","Git","Ubuntu"],"title":"Gource 소스 저장소 시각화 프로그램","type":"post"},{"authors":null,"categories":null,"content":"GObject 객체의 속성(properties)을 자동으로 저장하고 다시 자동으로 불러들이는 일련의 작업을 자동화할 수 있다면 편하지 않을까 생각해 본 적이 있을겁니다. 이러한 과정을 직렬화(serialization) 라고 부른다면, 오브젝티브-C, 자바 등과 같은 많은 언어가 이미 기본적으로 직렬화를 지원하거나 관련 라이브러리를 제공하고 있는만큼, GObject 객체 직렬화 라이브러리가 없을리가 없습니다. 예를 들어, JSON-GLib , Catalina 등과 같은 라이브러리를 사용하면 됩니다.\n그런데, 여기서 드는 의문은, 왜 GObject 라이브러리 자체에는 정작 이 기능이 없을까입니다. 그리고, 잠깐 생각해보고 내린 결론은, 특정한 형식을 제한하기보다는, 직렬화를 위한 기본 기능만 지원하고, 어플리케이션 특성에 맞게 직렬화는 프로그래머의 자유에 맡긴게 아닌가 합니다. 위에서 언급한 라이브러리도 기능은 강력하지만, 특정 용도에서 사용하기 위해 만들어지다 보니 불필요하거나 어려운 부분이 조금 있습니다.\n그래서 이 글에서는 이전 글 에서 잠깐 언급한 객체 속성 정보 얻는 방법을 이용하여 간단한 GObject 속성 직렬화 코드를 구현하는데 필요한 몇 가지 기법을 소개하려고 합니다. 실제 직렬화 기능은 용도와 방식에 맞게 구현하면 되리라 생각합니다.\n직렬화 대상 속성 지정하기\n직렬화하려는 속성을 매번 지정하는 것보다 객체 설계시 아예 지정해버릴 수 있는 방법이 있으면 자동화에 편합니다. 이때 사용할 수 있는 기법이 G_PARAM_USER_SHIFT 매크로입니다. 객체 클래스 초기화 함수에서 속성을 추가(install)할때 보통 G_PARAM_READABLE, G_PARAM_READWRITE 등과 같은 미리 정의되어 있는 특성을 지정하는데, G_PARAM_USER_SHIFT 매크로를 이용해 사용자가 임의의 특성을 더 추가할 수 있습니다. 예를 들어 다음과 같이 정의하면 됩니다.\n#define G_PARAM_SERIALIZABLE (1 \u0026lt;\u0026lt; (G_PARAM_USER_SHIFT + 1))  이제, 속성 스팩을 만들때(g_param_spec_*()) G_PARAM_SERIALIZABLE 플래그를 함께 지정할 수 있습니다. 예를 들면 다음과 같습니다.\npspec = g_param_spec_int (\u0026quot;id\u0026quot;, \u0026quot;ID\u0026quot;, \u0026quot;unique ID of the device\u0026quot;, 0, G_MAXINT32, 0, G_PARAM_READWRITE | G_PARAM_SERIALIZABLE);  주의할 점은, G_PARAM_USER_SHIFT 매크로를 응용하는 다른 라이브러리가 있을 수 있으므로 충돌 여부를 확인해야 합니다. 예를 들어 GStreamer 라이브러리의 GST_PARAM_USER_SHIFT 매크로도 비슷한 역할을 합니다. 따라서 구현하려는 객체가 Gstreamer 객체를 상속받는다면 다른 값을 지정해야 합니다.\n직렬화 대상 속성 목록 얻기\ng_object_class_list_properties() 함수를 이용하면 객체 클래스의 모든 속성 목록을 얻을 수 있습니다. 이 함수 프로토타입을 흉내내어 직렬화 대상 속성만 추출하는 함수를 만들면 다음과 같습니다.\nGParamSpec ** list_serializable_properties (GObject *serializable, guint *n_properties) { GParamSpec **specs; GParamSpec **new_specs; guint n_specs; guint i; guint total; g_return_val_if_fail (G_IS_OBJECT (serializable), NULL); specs = g_object_class_list_properties (G_OBJECT_GET_CLASS (serializable), \u0026amp;n_specs); new_specs = g_new0 (GParamSpec *, n_specs + 1); for (i = 0, total = 0; i \u0026lt; n_specs; i++) { GParamSpec *spec = specs[i]; if (!(spec-\u0026gt;flags \u0026amp; ECC_PARAM_SERIALIZABLE)) continue; new_specs[total] = spec; total++; } g_free (specs); if (n_properties) *n_properties = total; return new_specs; }  이제 이 함수가 돌려주는 속성 스펙 목록을 이용해 텍스트 파일이나 데이터베이스, 또는 GConf 등을 이용하여 속성 값을 불러오거나 저장하면 됩니다.\n속성값 변환하기\n하지만 속성은 정수형, 실수형, 문자열 등 여러가지 타입인데 모든 종류의 타입을 하나씩 문자열로 변환해서 저장하는 건 비효율적 과정입니다. 이때 사용할 수 있는 함수가 g_value_transform()인데, 이 함수는 기본적으로 두 GValue 간 내용을 적절하게(?) 변환해 줍니다. 다음은 이 함수를 이용하여 간단하게 \u0026lsquo;key=value\u0026quot; 형식으로 저장한 문자열을 돌려주는 코드입니다.\ngchar * serialize_properties (GObject *serializable) { GParamSpec **specs; GString *string; gchar *str; guint i; g_return_val_if_fail (G_IS_OBJECT (serializable), NULL); string = g_string_new (NULL); specs = list_properties (serializable, NULL); for (i = 0; specs[i] != NULL; i++) { GParamSpec *spec = specs[i]; GValue value = { 0 }; GValue value_str = { 0 }; g_value_init (\u0026amp;value, spec-\u0026gt;value_type); g_value_init (\u0026amp;value_str, G_TYPE_STRING); g_object_get_property (G_OBJECT (serializable), spec-\u0026gt;name, \u0026amp;value); if (g_value_transform (\u0026amp;value, \u0026amp;value_str)) g_string_append_printf (string, \u0026quot;%s=%sn\u0026quot;, spec-\u0026gt;name, g_value_get_string (\u0026amp;value_str)); else g_warning (\u0026quot;failed to transform property '%s' to string\u0026quot;, spec-\u0026gt;name); g_value_unset (\u0026amp;value); g_value_unset (\u0026amp;value_str); } g_free (specs); str = string-\u0026gt;str; g_string_free (string, FALSE); return str; }  그런데 한 가지 문제가 있습니다. g_value_transform() 함수는 기본적으로 모든 GValue 사이의 변환을 지원하지 않는다는 점입니다. 위에서 예를 든 코드는 C 언어 기본 타입을 문자열로 변환하는데, 다행히도 이 변환은 기본적으로 지원합니다. 하지만, 반대로 문자열에서 다른 타입으로 변환하는 기능은 제한적으로 지원합니다. 그래서 다음과 같이 필요한 변환 함수를 미리 등록해야 합니다.\nstatic void tranform_string_to_int (const GValue *src_value, GValue *dest_value) { gint64 value; value = g_ascii_strtoll (g_value_get_string (src_value), NULL, 10); g_value_set_int (dest_value, value); } static void tranform_string_to_boolean (const GValue *src_value, GValue *dest_value) { gboolean value; value = g_ascii_strncasecmp (g_value_get_string (src_value), \u0026quot;TRUE\u0026quot;, 4) == 0 ? TRUE : FALSE; g_value_set_boolean (dest_value, value); } static void tranform_string_to_double (const GValue *src_value, GValue *dest_value) { gdouble value; value = g_ascii_strtod (g_value_get_string (src_value), NULL); g_value_set_double (dest_value, value); } static void register_transform_funcs (void) { struct { GType src_type; GType dest_type; GValueTransform transform_func; } transformers[] = { { G_TYPE_STRING, G_TYPE_INT, tranform_string_to_int }, { G_TYPE_STRING, G_TYPE_BOOLEAN, tranform_string_to_boolean }, { G_TYPE_STRING, G_TYPE_DOUBLE, tranform_string_to_double } }; gint i; for (i = 0; i \u0026lt; G_N_ELEMENTS (transformers); i++) if (!g_value_type_transformable (transformers[i].src_type, transformers[i].dest_type)) g_value_register_transform_func (transformers[i].src_type, transformers[i].dest_type, transformers[i].transform_func); }  당연히, 속성 타입이 C 언어 기본 타입이 아닐 경우라도 위와 같은 방식으로 변환 함수를 등록해 주면 알아서 동작합니다.\n그외\u0026hellip;\n실제 프로젝트에서는 위와 같은 기능과 몇가지 도우미 API를 지원하는 인터페이스(GInterface) 객체를 정의해서, 각 객체가 그 인터페이스 객체를 구현(implementation)하도록 했습니다. 왜냐하면, 객체의 속성(properties)으로 나타나지 않는 내부 정보도 직렬화할 수 있기 때문입니다. 예를 들어 장치 목록 객체는 여러 장치 객체를 참조합니다. 그래서 장치 목록 객체를 직렬화하는 함수를 호출하면 실제로 장치 목록 객체는 목록에 포함된 장치 객체의 직렬화 함수를 다시 호출해 문자열을 얻어와 조합된 문자열을 돌려줍니다.\n:)\n","date":1270598400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1270598400,"objectID":"350d6d9d86d6cb89a784d05a0dfc05de","permalink":"https://lethean.github.io/2010/04/07/serialize-gobject-properties/","publishdate":"2010-04-07T00:00:00Z","relpermalink":"/2010/04/07/serialize-gobject-properties/","section":"post","summary":"GObject 객체의 속성(properties)을 자동으로 저장하고 다시 자동으로 불러들이는 일련의 작업을 자동화할 수 있다면 편하지 않을까 생각해 본 적이 있을겁니다.","tags":["Agile","GLib"],"title":"GObject 속성 직렬화(Serialization)하기","type":"post"},{"authors":null,"categories":null,"content":"리눅스 커널 2.6.33 버전이 릴리스(2010-02-24)된지도 한참 지났는데, 이제서야 변경사항을 정리하게 되었습니다. 그 사이에 제 개인적으로는 다시 학생이면서 직장인 신분이 되었고, 그로 인해 사는게 두 배는 바빠졌습니다. 다행인지 불행인지, 릴리스 이후 조금 시간이 지나니 커널 뉴비 뿐 아니라 제가 관심 있는 부분만 따로 정리한 기사도 나타나길래, 이 포스트는 아예 그 기사들을 참고했습니다.\nLZO 압축 알고리즘 추가\n커널 이미지와 initramfs 파일시스템 압축에 LZO 알고리즘을 사용할 수 있게 되었습니다. 기존 LZMA, BZIP2 알고리즘과의 차이라면 압축 해제 속도입니다. 비록 압축된 크기는 10~15% 정도 크지만, 압축 해제 속도가 더 빠르기 때문에 임베디드 시스템 뿐 아니라 일반 데스크탑에서도 부팅 속도 향상을 꾀할 수 있게 되었습니다. 참고로, ARM 플랫폼에서는 기본 옵션이 될 것이라고 합니다. (한동안은 줄이는 게 유행이더니, 이제는 부팅 속도 개선을 위한 기능이 유행이군요)\nCompcache 지원\n Compcache 는 메모리를 디스크에 스왑핑(swapping)할때 압축을 해서 넣고 빼는 기능입니다. 메모리 사용이 제한된 임베디드 시스템, 서버 가상화 환경 뿐 아니라 CPU 성능은 좋지만 상대적으로 메모리가 부족할 수 있는 넷북 플랫폼에서도 유용한 기능입니다. 이미 Edubuntu 배포판에서는 채용하고 있을 정도로 유용성이 증명되고 있는 것 같습니다.\nperftool 기능 개선\n커널 2.6.31 버전부터 추가된 perftool 시리즈에 \u0026lsquo;perf probe\u0026rsquo;라는 기능이 새로 추가되었는데, 솔라리스의 DTrace를 모방한 SystemTap과 비슷한 기능을 합니다. 하지만 SystemTap은 사용하기에 조금 불편한데, 매번 새로운 probe를 추가하거나 수정할때마다 커널 모듈을 만들어 넣어야 하고, 이를 위해 커널 빌드 환경이 구축되어 있어야 합니다. 그래서 정작 임베디드 시스템에서는 사용하기 어려웠습니다. 그런데 \u0026lsquo;perf probe\u0026rsquo; 기능은 sysfs 인터페이스를 이용하기 때문에 커맨드라인에서 직접 실행 중에 probe를 추가 / 편집할 수 있습니다. 더 자세한 내용은 ftrace와 kprobe를 설명한 LWN 기사 를 참고하시기 바랍니다.\n그외 펄(perl) 스크립트를 이용해 perf 도구를 프로그래밍할 수 있는 기능도 추가되는 등, 처음에는 성능 카운터(performance counter)로 출발한 이 도구가 향후 리눅스 커널 디버깅 도구의 주연으로 등장할 것 같은 예감이 들기도 합니다.\n**블럭 디바이스 기능 개선 **\n오랫동안 서버용 시스템에서 좋은 성능을 보여왔다고 평가되어 왔던 Anticipatory I/O 스케쥴러가 제거되었습니다. 이제는 CFQ I/O 스케쥴러가 모든 응용에 적합할만큼 충분히 성숙했다고 판단한 모양입니다. 이제 남은 것은 CFQ(Completely Fair Queue) I/O 스케쥴러와 Deadline, Noop 등인데 향후 이들도 하나의 스케쥴러만 남기거나 통합할 예정이라고 합니다.\n이와 더불어 CFQ I/O 스케쥴러에 블럭 I/O 컨트롤러 기능이 추가되었는데, 이를 이용하면 네트워크 대역폭을 QOS를 이용해 제어하듯이 특정 프로세스나 프로세스 그룹에서 디스크 I/O 대역폭을 할당하거나 제한할 수 있습니다.\n기타\n이제는 커널 컴파일 옵션에서 ext4 파일시스템 하나만 설정해도 이를 이용해 ext2 / ext3 파일시스템도 마운트할 수 있게 되었고, 안드로이드 커널이 공식 커널 트리에서 빠지게 되었으며( 참고 ), NVidia 그래픽카드 오픈소스 드라이버인 Nouveau 드라이버가 대폭 성능과 기능이 개선되어 공식적으로 포함되었습니다. 언제나 그렇듯이 많은 디바이스 드라이버가 추가, 변경되었고 API도 몇 개 바뀐게 보이고\u0026hellip; 대략 한 번 커널 뉴비 내용을 훑어보는 것도 나쁘지는 않을 것 같습니다.\n참고한 기사는 다음과 같습니다.\n Kernel Newbies - Linux 2.6.33 : http://kernelnewbies.org/Linux_2_6_33 Linux 2.6.33 features for embedded systems : http://free-electrons.com/blog/linux-2-6-33/ 2.6.33 is Out! Say Good Bye to the Anticipatory Scheduler : http://www.linux-mag.com/id/7724  ","date":1268524800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1268524800,"objectID":"79c55d9de093c670ddcf56725dd74311","permalink":"https://lethean.github.io/2010/03/14/linux-kernel-2-6-33-release/","publishdate":"2010-03-14T00:00:00Z","relpermalink":"/2010/03/14/linux-kernel-2-6-33-release/","section":"post","summary":"리눅스 커널 2.6.33 버전이 릴리스(2010-02-24)된지도 한참 지났는데, 이제서야 변경사항을 정리하게 되었습니다. 그 사이에 제 개인적으로는 다시 학생이면","tags":["Kernel","Linux"],"title":"리눅스 커널 2.6.33 릴리스","type":"post"},{"authors":null,"categories":null,"content":"GLib 라이브러리 2.16 버전부터 지원하는 테스트 프레임워크 는 C 언어용 유닛테스트 도구입니다. 물론 많은 유닛 테스트 도구가 이미 존재하지만, GLib 라이브러리 기반 C 언어 프로그램이라면 굳이 다른 라이브러리를 사용하는 것보다는 이미 지원하는 훌륭한 도구를 사용하는게 더 좋겠지요. 참고로, GTK+ , Clutter 등 같은 프로젝트도 이미 이 기능을 이용해 테스트 코드를 작성하고 있으므로 알아두면 도움이 됩니다. 모든게 그렇지만, 알고나면 별게 아니므로 기본 개념과 API 사용법만 충실히 이해하면 됩니다.\n**기본 개념 및 사용법 **\n유닛테스트 개념은 스몰토크, 자바, C++처럼 언어적으로 객체지향 개념을 지원하는 언어에서 시작했기 때문에 C 언어에 그대로 적용하기에는 조금 까다로운 점이 많습니다. 그래서 GLib 테스트 프레임워크는 유닛테스트에서 기본 개념과 테스트 실행 방식만 빌려옵니다. 우선 알아야하는 기본 개념은 다음과 같습니다.\n 테스트 케이스 (Test Case) : 가장 기본이 되는 하나의 테스트 단위입니다. GLib에서는 하나의 테스트 함수(function)가 이 역할을 합니다. 픽스쳐 (Fixture) : 고정 설치된 물건이라는 뜻처럼, 테스트 케이스 실행 전후에 항상 실행하는 함수를 의미합니다. 실제로는, 테스트 함수를 실행하기 위해 필요한 환경을 미리 구축하거나(setup) 실행 후 리소스를 정리하는(teardown) 함수, 그리고 이와 함께 사용되는 사용자 데이터(data)로 구성됩니다. 참고로, GLib에서는 각 테스트간 의존성을 피하기 위해 모든 테스트 케이스를 실행할때마다 매번 픽스쳐를 새로 구성하는 방식(fresh fixture)을 사용합니다. 테스트 슈트 (Test Suite) : 여러 테스트 케이스를 묶은 그룹입니다. 트리 구조처럼 테스트 슈트 여러개를 묶어 더 큰 테스트 슈트를 구성할 수도 있습니다. GLib에서는 테스트 경로(path)라는 개념으로 사용합니다.  개념은 조금 복잡한 것 같지만, 복잡하고 다양한 테스트 케이스를 그룹화하면 나중에 테스트 슈트별로 테스트를 진행할 수도 있는 등 많은 장점이 있습니다. 그리고 GLib이 제공하는 커맨드라인 도구를 이용하면 테스트 결과를 XML로 출력할 수도 있고, HTML 문서로 자동 변환할 수도 있는데 이 경우에도 테스트 슈트를 구성해 두면 많은 도움이 됩니다.\n물론 GLib은 정교하게 테스트 슈트와 테스트 케이스, 픽스쳐를 구성할 수 있는 많은 API를 제공하지만, 복잡한 과정을 API 호출 하나로 처리할 수 있는 기능도 제공합니다.\ng_test_add_func (\u0026quot;/onvif/nvc-connections\u0026quot;, test_onvif_nvc_connections);  위 예제에서 g_test_add_func() 함수는 \u0026ldquo;onvif\u0026rdquo; 테스트 슈트 밑에 \u0026ldquo;nvc-connections\u0026rdquo; 이름의 테스트 케이스를 추가합니다. 테스트시 실행할 함수는 사용자가 직접 구현한 test_onvif_nvc_connections() 함수입니다. g_test_add_func() 함수가 테스트 슈트를 자동으로 생성해 주기 때문에 별도의 추가 작업이 불필요합니다. 비슷한 기능의 g_test_add_data_func() 함수는 테스트 함수에 데이터를 전달할 수 있어서, 한 함수로 데이터만 바꿔서 테스트하고자 할때 유용합니다. 하지만, 두 API는 픽스쳐를 지정할 수 없으므로, 픽스쳐를 사용하려면 g_test_add() 함수를 이용해야 합니다.일단, 간단한 예제 코드를 보여드리면 다음과 같습니다. (\u0026quot; Writing Unit Tests with GLib \u0026quot; 글에서 발췌했습니다)\n#include \u0026lt;glib.h\u0026gt; static void simple_test_case (void) { /* a suitable test */ g_assert (g_bit_storage (1) == 1); /* a test with verbose error message */ g_assert_cmpint (g_bit_storage (1), ==, 1); } int main (int argc, char **argv) { /* initialize test program */ g_test_init (\u0026amp;argc, \u0026amp;argv, NULL); /* hook up your test functions */ g_test_add_func (\u0026quot;/Simple Test Case\u0026quot;, simple_test_case); /* run tests from the suite */ return g_test_run (); }  이 코드를 g-test-sample1.c 파일로 저장하고 컴파일 후 실행하면 다음과 같은 결과를 볼 수 있습니다.\n$ gcc -o g-test-sample1 g-test-sample1.c `pkg-config --cflags --libs glib-2.0` $ ./g-test-sample1 /Simple Test Case: OK  이 결과를 재활용하기 위해 XML 형식으로 저장하거나, HTML 문서로 만들고 싶다면 gtester / gtester-report 프로그램을 사용하면 됩니다.\n$ gtester -o sample-log.xml g-test-sample1 TEST: g-test-sample1... (pid=2771) PASS: g-test-sample1 $ gtester-report sample-log.xml \u0026gt; sample-log.html  위와 같이 실행하여 생성한 HTML 문서 결과는 다음과 같습니다.\n참고로, gtester 프로그램의 인수로 여러 테스트 실행 파일을 한꺼번에 전달하면 모든 테스트 실행 파일의 테스트 슈트가 하나의 결과로 통합됩니다.\n위 코드에서 사용한 테스트 코드를 보면 제일 먼저 g_test_init() 함수가 나타납니다. 이 함수는 테스트 기능을 초기화하는데, 리퍼런스 매뉴얼을 보시면 프로그램 실행 인수를 통해 사용자가 여러 테스트 옵션을 지정할 수 있는 걸 알 수 있습니다. 물론 특정 테스트 슈트만 실행하게 하는 옵션도 인수로 지정할 수 있습니다.\n테스트 함수를 보면 g_assert_cmpint() 라는 다소 생소한 API가 보이는데, GLib은 테스트 코드를 위해 이와 비슷한 매크로를 더 제공합니다.\n#define g_assert (expr) #define g_assert_not_reached () #define g_assert_cmpstr (s1, cmp, s2) #define g_assert_cmpint (n1, cmp, n2) #define g_assert_cmpuint (n1, cmp, n2) #define g_assert_cmphex (n1, cmp, n2) #define g_assert_cmpfloat (n1,cmp,n2) #define g_assert_no_error (err) #define g_assert_error (err, dom, c)  위 매크로를 사용하여 테스트 코드를 작성하면 더 친절하고 자세한 에러 메시지를 출력합니다. 예를 들어 다음 코드는,\ngchar *string = \u0026quot;foo\u0026quot;; g_assert_cmpstr (string, ==, \u0026quot;bar\u0026quot;);  이런 메시지를 출력합니다.\nERROR: assertion failed (string == \u0026quot;bar\u0026quot;): (\u0026quot;foo\u0026quot; == \u0026quot;bar\u0026quot;)  물론 기본적으로 실패한 경우에만 메시지를 보여줍니다.\n그 외 더 많은\u0026hellip;\n지금까지 설명한 기본 기능 외에도 표준출력 / 표준에러 메시지를 표시하지 않도록 한 뒤 이 메시지에서 특정 문자열을 확인한다든가, 항상 동일한 패턴의 난수를 생성하여 이를 테스트에 이용하거나, 테스트에 시간이 얼마나 더 걸리는지 측정할 수도 있습니다. 프로그램을 종료시키는 치명적인 에러가 발생하는 경우도 테스트할 수 있고, 여러가지 테스트 모드(quick / slow / performace 등)를 두어 프로그램 인자를 이용해 원하는 테스트 코드만 실행할 수도 있습니다.\n더 많은 활용 예제가 GLib 자체 테스트 코드에( glib/tests/testing.c ) 있으므로, 별로 길지 않으니, 직접 확인해 보시기 바랍니다.\n프로젝트에 활용하기\nMVP 개발 모델과 TDD + 유닛테스트 도구를 이용하여 응용 프로그램을 개발하면( Presenter First 개발 ) 더 빠르고 쉽게 튼튼한 코드를 만들 수 있으니, 한 번 검토해 보시기 바랍니다. 개발자가 TDD 방법론을 주저하는 이유 중 하나가 테스트 코드까지 만들다 보니 늘어나는 코드량과 늘어나는 개발 시간 때문인데, 테스트 코드를 그대로 실제 코드로 재활용할 수 있다면 얘기가 달라지겠죠.\n프로젝트 일일빌드시 테스트 루틴도 동작하도록 한뒤 자동으로 테스트 결과를 웹사이트에 게재하는 것도 좋은 개발 습관입니다. 아예 코드 수정 후 저장소에 커밋하면 반드시 모든 테스트 케이스를 통과해야만 커밋되도록 저장소를 설정할 수도 있지만, 엄청난 서버 부하를 야기할 수 있으므로, 테스트 케이스를 통과한 코드만 커밋할 수 있도록 가이드라인을 규정하는 것도 좋습니다.\n유닛테스트는 특정 객체나 모듈의 모든 API가 항상 정상적으로 동작하는지를 검사하기 위해 사용합니다. 그래서 가장 기본적인 사용법은 공개 함수를 다양한 인수로 호출한 뒤 그 결과값을 확인하는 방식입니다. 하지만 실무에서는 그렇게 단순한(?) 버그만 존재하는게 아니라서, 특정 시나리오나 특정 조건을 만족할 경우에만 버그 현상이 재현되는 경우도 많습니다. 이러한 경우, 버그에 대한 테스트 케이스를 추가하고 이 케이스에 대한 테스트가 통과할때까지 디버깅을 합니다. 이렇게 해두면 동일한 버그가 나중에 재발하는 걸 방지할 수 있습니다. 대부분 회사에서는 버그(이슈)관리시스템을 사용하므로 g_test_bug() API를 사용하면 편리합니다.\n참고로, GTK+ 라이브러리는 GLib 테스트 프레임워크를 기반으로 마우스 버튼 동작이나 키보드 입력을 에뮬레이션하는 기능처럼 GUI 프로그램 테스트용 API 를 제공합니다. 더불어 Xvfb 같은 더미 X서버를 이용하면 원격 터미널이나 cron 작업처럼 실제 X서버가 없는 환경에서도 GUI 프로그램 테스트 진행이 가능합니다. 꼭 GTK+ 프로그램이 아니더라도, 폰트 렌더링 루틴이 정확한 그래픽 비트맵을 생성하는지, 특정 항목을 선택하고 특정 행동을 취했을때 정상적으로 문자열이 표시되는지 등도 테스트 케이스로 작성할 수 있습니다.\n테스트 케이스 실행 방식 및 테스트 코드 위치\n위 예제처럼 테스트 케이스를 특정 주제별로 나누어 각각의 실행파일로 만들어도 되지만, 테스트 케이스를 초기화하는 부분을 잘 정리하여 테스트 케이스를 여러 모듈로 분리한 뒤, 모든 테스트 케이스를 통째로 하나의 실행파일로 만들어도 됩니다. 이렇게 하면 추가적인 스크립트나 도구의 도움없이도 명령어 한번 실행으로 모든 테스트 케이스를 실행할 수 있기 때문에 더 편리할 수 있습니다. 또는 Clutter 프로젝트처럼 테스트 모듈을 각각 공유라이브러리로 만들어 플러그인처럼 로드해서 실행하는 방법도 있습니다.\n하지만, 위 방식은 모두 실제 코드와 테스트 코드가 서로 다른 파일에 존재하는 방식입니다. 테스트 코드가 실제 코드와 하나의 파일에 존재한다면 테스트 코드 작성이 더 일상화되고 자연스러워질 수 있습니다. 그러므로, 프로그램 실행 파일 크기가 별로 문제가 되지 않는다면, 또는 릴리스 / 디버그 모드를 분리하여 컴파일하도록 구성된 프로젝트라면, 프로그램에 특정 옵션을 주었을 경우에만 테스트 케이스 실행 모드로 동작하게 하면 됩니다. 물론 특정 테스트 프로그램은 예제로 사용하기 위해 분리할 수도 있겠지만, 모듈이나 객체의 고유 기능만 테스트하는 코드라면 같은 파일에 있는게 더 자연스러울 수 있습니다. 예를 들어 GObject 객체라면, 속성(properties) / 시그널(signal) 이름이 갑자기 변경되었을때 이를 참조하는 모듈이 문제를 일으키지 않도록 하기 위해, \u0026lsquo;validate-properties\u0026rsquo;, \u0026lsquo;validate-signals\u0026rsquo; 등의 테스트 케이스를 추가한뒤 통과하지 못했을 경우 g_test_message() 등을 이용해 이를 참조하는 모듈을 찾아 수정하라는 강조 메시지를 표시하는 것도 가능합니다. 또한 특정 시그널이 정상적으로 발생하는지, 순서대로 발생하는지 확인할 수 있습니다. 그리고 무엇보다도, 같은 파일에 있으면 내부 자료구조에도 접근할 수 있으므로 내부 로직에 대한 테스트 코드를 작성하는 것도 가능해집니다.\n따라서 무조건 한 가지 방식만 고집하기보다, 적절하게 필요에 따라 알맞는 방식을 선택하는 것이 중요합니다.\n결론\n뭐 다른 결론이 있을리 없을만큼 유닛 테스트와 리그레션 테스트(regression test) 등은 이미 소프트웨어 개발 분야 전반에 광범위하게 사용하고 있습니다. 다만, C 언어를 이용해 개발하는 경우 리거시(legacy) 코드가 너무 많거나, 마땅한 테스트 도구를 찾지 못했거나, 여러가지 이유로 도입하지 못하는 경우가 많은데, 함께 잘 극복하고 익숙해져서 더 좋은 방향으로 나아가야 하지 않을까\u0026hellip; 생각해 봅니다.\n","date":1265932800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1265932800,"objectID":"3b8d980c2b9b23fb82c39bbb9faaba16","permalink":"https://lethean.github.io/2010/02/12/using-glib-test-framework/","publishdate":"2010-02-12T00:00:00Z","relpermalink":"/2010/02/12/using-glib-test-framework/","section":"post","summary":"GLib 라이브러리 2.16 버전부터 지원하는 테스트 프레임워크 는 C 언어용 유닛테스트 도구입니다. 물론 많은 유닛 테스트 도구가 이미 존재하지만, GLib 라이브러리 기반 C 언어","tags":["Agile","Clutter","Coding","GLib","GTK+"],"title":"GLib 테스트 프레임워크 사용하기","type":"post"},{"authors":null,"categories":null,"content":"구글 프로토콜 버퍼 라이브러리에 대해서는 몇 번 언급 을 한 적이 있는데, 관심만 있고 아직 프로젝트에 사용은 못해보고 있었습니다. 그 이유는 프로젝트 대부분이 C 언어를 사용하는데, 공식적으로 지원하는 언어에는 없었기 때문입니다.\n그런데 오늘 우분투 패키지를 업데이트하다가 protobuf-c 우분투 패키지 가 있어서 확인해보니, 프로토콜 버퍼 데이터를 읽고 쓸 수 있는 런타임 라이브러리와 *.[hc] 파일을 생성하는 컴파일러가 들어있군요. 그래서 아예 구글 코드 사이트에 있는 protobuf 관련 프로젝트 목록 을 훑어보니, C 언어 뿐 아니라 다양한 언어에 대한 바인딩을 지원할 뿐 아니라 이클립스 플러그인, 와이어샤크(wireshark) 플러그인 등처럼 유용한 도구도 많이 찾을 수 있었습니다.\n이런 경우 언제나 느끼는 거지만, 요즘은 노하우(know-how)보다 노훼어(know-where)가 더 필요한 세상인 것 같습니다.\n","date":1265932800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1265932800,"objectID":"51bf3c325cf6311771ee44b4a8d77873","permalink":"https://lethean.github.io/2010/02/12/google-protocol-buffers/","publishdate":"2010-02-12T00:00:00Z","relpermalink":"/2010/02/12/google-protocol-buffers/","section":"post","summary":"구글 프로토콜 버퍼 라이브러리에 대해서는 몇 번 언급 을 한 적이 있는데, 관심만 있고 아직 프로젝트에 사용은 못해보고 있었습니다. 그 이유는 프로젝트 대부분이 C 언어","tags":["Coding","Eclipse","Network","Wireshark"],"title":"구글 프로토콜 버퍼(Protocol Buffers)","type":"post"},{"authors":null,"categories":null,"content":"좋은 블로그 포스트 가 올라왔길래, 우리말로 정리해 보았습니다.\nGObject 기반 객체 지향 프로그래밍에서 싱글턴 패턴을 사용하려면 대개 다음과 같은 함수를 추가합니다.\nFooBar* foo_bar_get_default (void) { static FooBar *self = NULL; if (self == NULL) self = foo_bar_new (); return self; }  하지만 이렇게 구현할 경우 몇가지 단점이 있는데, 돌려받은 객체를 실수로 해제할 경우 문제를 일으킬 수 있고, 프로그램이 종료할때까지 객체가 소멸되지 않아 메모리 누수가 발생할 수 있습니다. 또한 사용자가 g_object_new(FOO_TYPE_BAR, NULL) 방식으로 객체를 생성하면 결국 새 객체가 만들어지기 때문에 싱글턴 객체로 동작하지 않습니다.\n그래서, Empathy 프로젝트에서는 다음과 같이 싱글턴 객체를 구현하고 있습니다.\nstatic GObject* constructor (GType type, guint n_construct_params, GObjectConstructParam *construct_params) { static GObject *self = NULL; if (self == NULL) { self = G_OBJECT_CLASS (foo_bar_parent_class)-\u0026gt;constructor ( type, n_construct_params, construct_params); g_object_add_weak_pointer (self, (gpointer) \u0026amp;self); return self; } return g_object_ref (self); } static void foo_bar_class_init (FooBarClass *klass) { GObjectClass *object_class = G_OBJECT_CLASS (klass); object_class-\u0026gt;constructor = constructor; }  이 방식을 이용하면 g_object_new()를 이용해 객체를 만들어도 항상 동일한 객체를 돌려줍니다. 더불어 객체의 참조카운터를 증가해서 돌려주기 때문에, 일반 객체처럼, 사용이 끝나면 g_object_unref()를 호출해 객체를 해제하면 됩니다. 물론 마지막 사용이 끝나는 시점에서는 자동으로 객체가 소멸되고 객체 포인터도 NULL값으로 초기화됩니다.( g_object_add_weak_pointer() 함수가 이 역할을 합니다)\n물론 빈번한 객체 생성 / 소멸 호출을 막기 위해 프로그램 전반적으로 객체를 유지하든, 필요한 때만 생성해서 사용하도록 할 지 여부는 이 객체를 사용하는 프로그램이 선택할 수 있습니다. 따라서 라이브러리 코드를 작성할 경우 반드시 이 방식으로 싱글턴 객체를 제공하는게 좋습니다.\n참고로, 위 구현은 멀티쓰레드가 동시에 접근하는 경우 안전하지 않습니다. 그러므로, 필요하다면, 뮤텍스나 g_once() 등을 이용해 객체 포인터를 보호해야 합니다.\n","date":1265846400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1265846400,"objectID":"a0588d7b1c7bffee7f3610c610fadc6c","permalink":"https://lethean.github.io/2010/02/11/how-to-make-a-gobject-singleton/","publishdate":"2010-02-11T00:00:00Z","relpermalink":"/2010/02/11/how-to-make-a-gobject-singleton/","section":"post","summary":"좋은 블로그 포스트 가 올라왔길래, 우리말로 정리해 보았습니다. GObject 기반 객체 지향 프로그래밍에서 싱글턴 패턴을 사용하려면 대개 다음과 같은 함수를 추가합니다. FooBar*","tags":["Agile","GLib"],"title":"싱글턴(Singleton) GObject 객체 만들기","type":"post"},{"authors":null,"categories":null,"content":" ccache 는 워낙 유명하고 오래된 개발 도구라서, 검색해보면 우리말로 된 글도 많이 찾을 수 있으므로 자세한 설명은 생략하고, 최근에 다른 개발 장비를 구축할 일이 있어서 검토해보다가, 페도라는 이미 기본으로 ccache를 사용하도록 되어 있고, 우분투 / 데비안 계열에서도 매우 쉽게 사용할 수 있도록 되어 있는 걸 알게 되었습니다. 그래서 다시 한 번 정리합니다.\n먼저 패키지를 설치합니다.\n$ sudo apt-get install ccache  /etc/environment 파일을 열어 PATH 변수 맨 앞에 '/usr/lib/ccache' 를 추가합니다. 예를 들어 아래와 같다면\nPATH=\u0026quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games\u0026quot;  다음과 같이 변경합니다.\nPATH=\u0026quot;/usr/lib/ccache:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games\u0026quot;  다시 로그인하면 모든 gcc, g++ 명령은 자동으로 ccache를 이용하게 됩니다.\n물론 본인 계정에서만 사용하고 싶다면, 홈디렉토리 밑의 .bashrc 또는 .bash_profile, .profile 파일에 다음과 같은 내용을 추가하면 됩니다.\nexport PATH=\u0026quot;/usr/lib/ccache:$PATH\u0026quot;  GCC가 느리다고 불평하는 일이 조금 줄어들까요?\n","date":1265241600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1265241600,"objectID":"e73e4fadd339a17e73a6e3707bbf33c3","permalink":"https://lethean.github.io/2010/02/04/using-ccache-in-ubuntu/","publishdate":"2010-02-04T00:00:00Z","relpermalink":"/2010/02/04/using-ccache-in-ubuntu/","section":"post","summary":"ccache 는 워낙 유명하고 오래된 개발 도구라서, 검색해보면 우리말로 된 글도 많이 찾을 수 있으므로 자세한 설명은 생략하고, 최근에 다른 개발 장비를 구축할 일이 있어서 검토","tags":["GCC","Ubuntu"],"title":"우분투에서 ccache 사용하기","type":"post"},{"authors":null,"categories":null,"content":" LWN.net 에서 0MQ 라는 매우 흥미로운 라이브러리를 소개하길래 조금 자세히 살펴 보았습니다.\n일단 소개부터 하자면, BSD 소켓 비슷한 API를 지원하는 경량 메시지 시스템입니다. 소켓 비슷한 API라고 하지만, 소켓보다 사용하기 훨씬 편합니다. 실행 중 차지하는 용량이 1~20 KB 정도밖에 안될 뿐 아니라, 처음 개발이 실시간 증권 정보 시스템의 일부였기 때문인지 매우 빠릅니다. 네트워크 프로토콜은 TCP, UDP, PGM(Pragmatic General Multicast) , IPC는 물론 쓰레드간 통신도 지원합니다. 지원하는 메시징 모델은 일대일 통신에 유용한 요청/응답(request/reply), 일대다 통신에 좋은 출판/가입(publish/subscribe), 스트리밍(streaming) 등을 지원합니다.\n대신 이 라이브러리는 메시지 내용 자체에는 관여하지 않습니다. 메시지 내용은 단순한 바이너리 데이터로 취급하기 때문에 개발자가 직접 정의하거나 구글 프로토콜 버퍼 같은 전용 라이브러리를 사용해야 합니다. (참고로 구글 프로토콜 버퍼는 좋은 라이브러리이지만, C++, Java, Python만 지원하고 정작 제가 사용하는 주언어인 C 언어는 지원하지 않아 검토만 하고 실제 프로젝트에서는 사용해 본 적이 없습니다) 즉, 인증 / 암호화 / 압축 / 시리얼라이제이션 등은 개발자가 알아서 하면 됩니다.\n다양한 언어와 플랫폼을 지원하기 때문에 어떤 프로젝트에서도 향후 확장성이나 호환성을 걱정하지 않고 사용할 수 있습니다. 지원하는 운영체제는 Linux, Windows, Mac OS X, Solaris, AIX, FreeBSD, HP-UX, OpenBSD, OpenVMS, QNX Neutrino 등이고, 아키텍쳐는 i386, x86-64, Sparc, Itanium, Alpha, ARM 등입니다. 사용 가능한 언어는 현재 C, C++, Common Lisp, Java, Python, Ruby 등인데 PHP 같은 웹 개발 언어까지 가능하다면 금상첨화일 것 같습니다.\n아직 직접 사용해보진 않았으나 긍정적으로 다음 프로젝트 또는 기능 추가시 사용해볼 예정인데, 몇 가지 이유를 적어보면 다음과 같습니다.\n 멀티플랫폼을 고려해야 하는 프로젝트에서는 모듈간 통신에 어쩔 수 없이 가장 일반적인 TCP/UDP 소켓을 사용합니다. 그런데 아무리 경험많은 개발자라도 매번 통신 모듈을 새로 개발하는 것은 부담스러운데, 이 라이브러리는 이런 고민을 말끔히 해결해주는 동시에 다양한 메시징 모델을 이용하여 응용 프로그램 자체에만 전념할 수 있게 도와줍니다. 네트워크 상의 클라이언트-서버 방식 뿐 아니라, 하나의 시스템이 여러 역할별로 프로세스가 할당되어 구성되는 경우도 많습니다. 이 경우 성능을 위해 IPC나 PGM 등과 같은 프로토콜을 사용하다가, 나중에 분산 시스템으로 구성이 변경되더라도 프로토콜만 다시 TCP로 바꾸어 주면 되기 때문에 확장성이 매우 좋습니다. 또한 LWN.net 기사에서도 언급한 것처럼 게이트웨이나 프록시 역할을 하는 기능을 추가하는 것도 매우 쉬어집니다. 이를 응용할 수 있는 것도 매우 많아지는데, 예를 들어 사용자가 여러번 프로그램을 실행해도 한 개의 인스턴스만 존재하도록 하고 싶을때, 간단하게 IPC나 루프백 통신을 이용해 인스턴스 여부를 검사하면 되고, 더 나아가 기존 인스턴스에게 인자를 넘겨주는 것도 가능합니다. ( Unique 라이브러리 참고) 게다가 이 라이브러리에서 지원하는 쓰레드간 통신을 이용하면, 물론 뮤텍스나 큐를 사용하는게 더 효율이 좋겠지만, 처음에는 쓰레드로 만들었다가 여러가지 이유로 나중에 프로세스로 분리하거나, 아예 다른 호스트에서 네트워크로 통신해야할 경우에도 쉽게 이전이 가능합니다. 또한 큐는 단순한 일대일 통신에만 사용할 수 있지만, 출판/가입 모델 등과 같이 한 쓰레드가 여러 쓰레드에게 메시지를 전송하는 경우(예를 들어 버스 또는 시그널 방송)도 쉽게 구현할 수 있습니다.   LWN.net 페이지를 보시면 각 언어별로 샘플 코드가 나열되어 있으므로 기본적인 사용법이 궁금하신 분은 직접 확인해보시기 바랍니다. 아, 물론 LGPL 오픈소스입니다.\n","date":1264723200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1264723200,"objectID":"7e41b863500fb30aa5d44dc91139dc05","permalink":"https://lethean.github.io/2010/01/29/0mq-a-new-approach-to-messaging/","publishdate":"2010-01-29T00:00:00Z","relpermalink":"/2010/01/29/0mq-a-new-approach-to-messaging/","section":"post","summary":"LWN.net 에서 0MQ 라는 매우 흥미로운 라이브러리를 소개하길래 조금 자세히 살펴 보았습니다. 일단 소개부터 하자면, BSD 소켓 비슷한 API를 지원하는 경량 메시지 시스템입니","tags":["Embedded","Network","OpenSource"],"title":"0MQ: 메시지 시스템 라이브러리","type":"post"},{"authors":null,"categories":null,"content":"` 정적 분석과 코딩 규칙을 이용한 임베디드 소프트웨어 버그 줄이기 \u0026lsquo;라는 제목의 기사를 읽다가 ` Power of 10 \u0026rsquo; 규칙이 언급되었길래 다시 읽어볼 기회가 생겼습니다. 기사 내용은 필자가 개발한 정적 분석 도구 제품을 홍보하는 느낌을 받았지만, 어느 정도의 가이드라인을 지킨 코드는 정적 분석 도구의 도움을 받아 미리 오류를 발견하고 수정하기가 더 쉽기 때문에 상호 보완하는 것이 좋다는 점에는 동의합니다. 아무튼 기사와는 별도로, 십제곱(?) 규칙은 다시 읽어도 나름대로 곱씹을 가치가 있는 것 같아 우리말로 다시 정리해 보았습니다.\n대부분 소프트웨어 프로젝트는 나름의 코딩 가이드라인을 사용합니다. 가이드라인은 프로그래머가 소프트웨어를 만들때 어떻게 구성할지, 언어의 어떤 특징을 사용하고 사용하면 안되는지 등을 규정합니다. 하지만 수많은 코딩 가이드라인이 대부분 비슷하고, 너무 규칙이 많거나 모호한 경우도 많습니다. 때로는 공백문자 사용법 등과 같은 개인적인 취향을 반영하기도 합니다. 결과적으로 이러한 코딩 가이드라인은 개발자가 코드를 작성할때 별로 영향을 끼치지 못하곤 합니다. 더 나아가 도구를 사용하여 검사하는 작업과 병행하기 어렵게 하기도 합니다. 도구를 사용하여 검사하는 과정은 중요한데, 수십만 라인의 코드를 직접 검토하는 작업은 불가능하기 때문입니다.\n따라서 좋은 코딩 가이드라인은 분량이 적고, 사람들이 쉽게 이해하고 기억할 수 있도록 명료해야 합니다. 그래서 저자는 10개의 효율적이고 규칙을 제안합니다. 이 가이드라인은 임베디드 소프트웨어 개발에 오랫동안 널리 사용해 온 C 언어를 대상으로 합니다. (참고로 저자는 NASA의 JPL(Jet Propulsion Lab.)에 근무하면서 고신뢰 소프트웨어 개발을 연구하는 분입니다)\n규칙 1: 단순하게 제어 흐름(control flow)을 구성하고 goto, setjmp(), longjump(), 재귀(recursion) 사용 안하기\n제어 흐름이 단순할수록 더 튼튼하고 분석이 용이하며 코드를 명료하게 합니다. 재귀를 없애면 순환하는 호출 그래프를 없앨 수 있고, 그로 인해 스택 오버플로우 등을 걱정할 필요도 없습니다. 그렇다고 이 규칙이 모든 함수가 단일점에서 복귀(return)해야 한다는 건 아닙니다.\n규칙 2: 루프에서 상한값을 고정하기\n검사 도구가 쉽게 분석할 수 있을 뿐 아니라, 재귀를 피하는 규칙과 더불어 이 규칙을 따르면 무한루프처럼 폭주하는 코드를 걱정할 필요가 없습니다.\n규칙 3: 초기화 이후 동적 메모리 할당 사용 한하기\n많은 가이드라인에 포함되어 있는 규칙인데, 이유는 명료합니다. 동적 메모리 할당 함수는 성능에 심각한 영향을 끼칠 뿐 아니라 실수로 인한 메모리 누수는 시스템을 심각한 상태에 빠뜨릴 수 있기 때문입니다. 필요하다면 alloca() 등과 같은 스택 기반 동적 할당은 사용할 수 있습니다.\n규칙 4: 함수 하나가 출력시 한 페이지를 넘어가지 않도록 제한하기\n함수를 더 쉽게 이해하고 검증할 수 있는 단위로 나누기 위해 필요합니다. 함수가 길어질수록 논리적으로 잘 구조화된 코드를 작성하기 어렵습니다.\n규칙 5: 함수에 최소 2개 이상의 단언문(assert) 사용하기\n최종 빌드시 비활성화될 수 있는 단언문은 개발 도중 많이 사용할 수록 좋습니다.\n규칙 6: 자료 객체는 가능한 가장 작은 범위(scope)에서 선언하기\n정보 은닉(information hiding) 원칙에 따라, 불필요하게 변수의 범위를 확장하지 않으면 잘못 참조해서 발생하는 오류를 줄일 수 있습니다. 또한 변수 재사용을 막아서, 코드를 더 정확하게 분석하고 구조화할 수 있습니다.\n규칙 7: 결과값을 돌려주는 함수의 결과값을 반드시 확인하고, 함수에 전달된 모든 인수가 유효한지 확인하기\n가장 지켜지지 않는 규칙 중 하나입니다. printf(), scanf(), close() 등의 결과값을 검사하지 않는 사람도 대부분이지만, 검사하는 것이 맞습니다. 결과값이 맞던 틀리던 상관없더라도 반드시 각 조건에 해당하는 처리 코드가 있어야 하며, 분명히 인지하고 있다면 명시적으로 함수 결과값을 (void) 문을 이용해 형변환해서 무시해야 합니다. 하지만 에러값을 돌려주는 함수는 반드시 무조건 검사해야 합니다.\n규칙 8: 매크로는 파일을 포함하거나(include) 단순하게 정의할 때만 사용하기\nC 전처리기는 강력하기 때문에, 그만큼 코드를 복잡하게 만듭니다. 그래서 정적 분석 도구는 물론 사람 역시 코드를 분석하고 이해하려면 매우 많은 노력이 필요하고, 이는 결과적으로 불안정하고 불확실한 코드를 생성하는 주범이 될 수 있습니다. 특히 조건 컴파일을 사용하면 코드 복잡도가 사용하는 회수만큼 높아지기 때문에 가능하면 피해야 합니다.\n규칙 9: 포인터 사용 안하기, 필요하더라도 1단계 이상 참조하는 포인터는 절대 사용 안하기\ntypedef 선언을 이용해 2단계 이상 포인터 참조를 숨겨서도 안됩니다. 포인터는 경험많은 프로그래머라도 오용하기 쉽고, 프로그램에서 데이터 흐름을 따라가기 어렵게 합니다. 함수 포인터 역시 가능하면 사용하지 않는 것이 좋은데, 분석 도구를 사용하더라도, 포인터 유효성, 재귀 호출의 위험 등을 미리 알 수 있는 방법이 어렵기 때문입니다.\n규칙 10: 컴파일시 모든 경고 메시지를 켜고, 모든 코드가 경고 없이 컴파일되도록 하기\n컴파일러 역시 하나의 분석 도구라고 간주할 수 있습니다. 컴파일러가 혼란을 일으키는 코드라면 반드시 실행 중에 문제를 일으킬 수 있습니다.\n물론 위 규칙을 모든 소프트웨어 개발에 적용할 수는 없겠지만, 항상 염두에 두고 있다면, 비단 임베디드 시스템 개발 뿐 아니라 모든 소프트웨어 개발 과정에서 오류를 미리 예방하는데 도움될 것이라는 점은 분명한 것 같습니다.\n","date":1264377600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1264377600,"objectID":"c7e5fb354c649edcd0e0080a502bbb0b","permalink":"https://lethean.github.io/2010/01/25/power-of-10-rules-for-developing-safety-critical-code/","publishdate":"2010-01-25T00:00:00Z","relpermalink":"/2010/01/25/power-of-10-rules-for-developing-safety-critical-code/","section":"post","summary":"` 정적 분석과 코딩 규칙을 이용한 임베디드 소프트웨어 버그 줄이기 \u0026lsquo;라는 제목의 기사를 읽다가 ` Power of 10 \u0026rsquo; 규칙이 언급되었길래 다시 읽어볼 기회가 생겼","tags":["Coding","Embedded"],"title":"Power of 10: 안전성이 중요한 코드 개발을 위한 규칙","type":"post"},{"authors":null,"categories":null,"content":"요즘 여기 저기 서 Btrfs 파일시스템 얘기가 많아서, 한번 써봐야겠다 싶어 우분투 개발버전(lucid, linux kernel 2.6.32) 저장소를 확인해보니 패키지 하나만(btrfs-tools) 설치하면 되길래 홈디렉토리를 btrfs 파일시스템으로 교체해 보았습니다. 그리고 스트레스 테스트를 위해 회사에서 유지하는 모든 프로젝트의 Git 저장소를 내려받고(clone) 동시에 컴파일을 해봤습니다.\n그리고 지금, 다시 Ext4 파일시스템으로 되돌린 상태에서 동일하게 Git 저장소를 내려받으며 이 글을 적고 있습니다. 체감 속도가 느린 것은 물론, 오랜만에 마우스 움직임이 끊기는 현상까지 경험했습니다. CPU 리소스 점유율은 또 얼마나 높은지\u0026hellip;(압축 옵션을 사용하지 않았음에도 불구하고) 적어도 읽기 성능은 좋다고 하던데, 여러 프로세스가 동시에 접근할 때는 형편없이 저하되는 걸 목격했습니다.\n뭐, 물론 아직도 활발하게 개발중이고, 좋은 기능도 많이 있는 것 같지만(그래서 그만큼의 리소스가 더 필요한 걸지도\u0026hellip;), 경험적 결론은, 아직 서버나 제품에 사용하기에는 시기상조라는 겁니다.\n기회가 되면 SSD 디스크에서도 테스트해보고 싶은데, 가난한 개발자라서\u0026hellip; (술값만 줄여도 되려나\u0026hellip;?)\n","date":1264377600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1264377600,"objectID":"9d591c1955f77bec322275d24c210b7f","permalink":"https://lethean.github.io/2010/01/25/btrfs-for-a-while/","publishdate":"2010-01-25T00:00:00Z","relpermalink":"/2010/01/25/btrfs-for-a-while/","section":"post","summary":"요즘 여기 저기 서 Btrfs 파일시스템 얘기가 많아서, 한번 써봐야겠다 싶어 우분투 개발버전(lucid, linux kernel 2.6.32) 저장소를 확인해보니 패키지 하나만(btrfs-to","tags":["Kernel","Linux","Ubuntu"],"title":"아주 잠시 Btrfs 파일시스템을 사용해보고","type":"post"},{"authors":null,"categories":null,"content":"구글 리더에서 오늘치 내용을 읽다가 \u0026lsquo;가 난한 사람의 멀티 터치: Xorg에서 여러 개의 마우스 사용하기 \u0026rsquo; 블로그를 보고 따라해 보았더니 바로 되는 걸 확인하고 기록으로 남겨둡니다. (참고로, 제가 사용하는 배포판은 우분투 개발 버전(lucid)입니다)\n두 개의 마우스를 장착했을때 두 개의 포인터가 생성되고, 각각 따로 동작하는 것은 물론 마우스 별로 커서를 지정할 수도 있습니다. 하지만 아직 GTK+를 비롯한 많은 어플리케이션이 멀티 마우스를 고려하지 않아 창 이동이나 포커스 등과 같은 문제가 원하는 대로 동작하지는 않지만, 언제나 그렇듯이 시간이 지나면 조금씩 나아지리라 생각됩니다.\n저자는 자신이 GIMP 작업을 할 때 하나는 도구나 색상을 고르고, 다른 하나는 그리기 작업에 사용함으로 실제 도움이 많이 되고 있다고 하는데, 단순히 하나의 컴퓨터 화면을 여러 사람이 동시에 사용할 수 있다는 점보다, 사용자 인터페이스 관점에서 멀티 터치를 비롯한 많은 아이디어가 X 어플리케이션에 적용할 수 있는 기반이 될 것으로 여겨집니다.\n","date":1263945600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1263945600,"objectID":"fb385f544de4dc98d2152ebf2beb05d1","permalink":"https://lethean.github.io/2010/01/20/using-multiple-mouses-with-xor/","publishdate":"2010-01-20T00:00:00Z","relpermalink":"/2010/01/20/using-multiple-mouses-with-xor/","section":"post","summary":"구글 리더에서 오늘치 내용을 읽다가 \u0026lsquo;가 난한 사람의 멀티 터치: Xorg에서 여러 개의 마우스 사용하기 \u0026rsquo; 블로그를 보고 따라해 보았더니 바로 되는 걸 확","tags":["GUI","Ubuntu","Xorg"],"title":"여러 개의 마우스 동시에 사용하기","type":"post"},{"authors":null,"categories":null,"content":"멀티플랫폼에서 동작하는 C/C++ 코드를 gcc를 이용해 컴파일할때 플랫폼이나 운영체제를 확인하는 방법 중 하나는 gcc 툴체인이 만들어질때 정의되는 매크로를 사용하는 것입니다. 그런데 이번에 MacOS X / iPhone 플랫폼에 기존 코드를 포팅하면서 이 방법을 이용하려 하는데, 너무 오래 전에 했던 작업이라 (역시나) 명령어를 기억할 수 없었습니다. 그래서 겨우 구글링해서 다시 알게된 내용을 기록해 둡니다.\n$ gcc -E -dM -x c /dev/null  그리고 이 방법을 이용해 사용한 최종 코드는 다음과 같습니다.\n#if defined(_WIN32) #include \u0026quot;lib-win32/config.h\u0026quot; #elif defined(_WIN64) #include \u0026quot;lib-win64/config.h\u0026quot; #elif defined(__ENVIRONMENT_IPHONE_OS_VERSION_MIN_REQUIRED__) #include \u0026quot;lib-iphone/config.h\u0026quot; #elif defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) /* or __APPLE__ */ #include \u0026quot;lib-macosx/config.h\u0026quot; #else /* linux */ #include \u0026quot;config.h\u0026quot; #endif  사실은, 더 깔끔한 다른 방법이 있을지 궁금하기도 합니다.\n","date":1262995200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1262995200,"objectID":"13a78ad8b26ed03f423ca3d09939dc3e","permalink":"https://lethean.github.io/2010/01/09/getting-predefined-macros-in-gcc/","publishdate":"2010-01-09T00:00:00Z","relpermalink":"/2010/01/09/getting-predefined-macros-in-gcc/","section":"post","summary":"멀티플랫폼에서 동작하는 C/C++ 코드를 gcc를 이용해 컴파일할때 플랫폼이나 운영체제를 확인하는 방법 중 하나는 gcc 툴체인이 만들어질때 정의되는 매크로를 사용하는 것","tags":["GCC","iPhone","Linux","MacOSX","Windows"],"title":"GCC 미리 정의된 매크로 얻기","type":"post"},{"authors":null,"categories":null,"content":"시간이 갈수록 자주 사용하는 명령어를 기억하지 못해 동일한 검색어로 구글링을 반복하는 경우가 점점 많아져서, 그런 수고를 덜기 위해 여기에 적어두는 글입니다.\nSSH 원격 셸 명령어를 이용하여 디렉토리 전체를 복사하고자 할 때, 특히 파일의 수정일시, 권한, 심볼릭 링크 등을 그대로 이전하고자 할때 다음과 같이 실행하면 됩니다.\n$ tar czpf - . | ssh lethean@hades \u0026quot;tar xzpvf - -C /home/lethean/backup\u0026quot;  위 명령어는 현재 디렉토리의 모든 내용을 그대로 hades 서버에 lethean 계정으로 접속해서 /home/lethean/backup 디렉토리에 복사합니다.\n[UPDATED] 네트웍 속도가 충분하고 CPU 점유율을 낮춘 상태로 빨리 복사하고 싶다면 다음과 같이 압축 옵션을 사용하지 않아도 됩니다.\n$ tar cpf - . | ssh lethean@hades \u0026quot;tar xpvf - -C /home/lethean/backup\u0026quot;  :)\n","date":1262304000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1262304000,"objectID":"5bd1f9ee492b6ffe9edf017462a9c1bb","permalink":"https://lethean.github.io/2010/01/01/backup-directories-using-ssh/","publishdate":"2010-01-01T00:00:00Z","relpermalink":"/2010/01/01/backup-directories-using-ssh/","section":"post","summary":"시간이 갈수록 자주 사용하는 명령어를 기억하지 못해 동일한 검색어로 구글링을 반복하는 경우가 점점 많아져서, 그런 수고를 덜기 위해 여기에 적어두는 글입니다. SSH 원","tags":["Network","Shell"],"title":"SSH 디렉토리 백업하기","type":"post"},{"authors":null,"categories":null,"content":"Linux / MacOS X 플랫폼에서 CPU 갯수를 얻어오는 함수입니다. 잊어버릴까봐 기록해 둡니다.\n#include \u0026lt;stdio.h\u0026gt; #ifdef __linux__ #include \u0026lt;sys/sysinfo.h\u0026gt; #else #ifdef __APPLE__ #include \u0026lt;sys/param.h\u0026gt; #include \u0026lt;sys/sysctl.h\u0026gt; #else #error \u0026quot;Only Linux or OSX is supported!\u0026quot; #endif /* __APPLE__ */ #endif /* __linux__ */ static int get_cpu_nr (void) { #ifdef __linux__ return get_nprocs (); #endif #ifdef __APPLE__ int i = 0; size_t s = sizeof (i); if (sysctlbyname (\u0026quot;hw.ncpu\u0026quot;, \u0026amp;i, \u0026amp;s, NULL, 0)) return 1; return i; #endif } int main (int argc, char **argv) { printf (\u0026quot;cpu_nr:%dn\u0026quot;, get_cpu_nr ()); return 0; }  출처는 이 소스 입니다. 참고로 리눅스의 /usr/include/sys/sysinfo.h 파일을 들여다보면 램 크기 / 스왑 크기 / 물리 페이지 크기 등과 같은 시스템 관련 정보를 얻을 수 있는 함수가 여럿 보이는군요. /proc 정보를 파싱하는 것보다 더 편리할 것 같습니다.\n","date":1261872000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1261872000,"objectID":"c9390780b342e1410ea87c66d8f05ee7","permalink":"https://lethean.github.io/2009/12/27/get-number-of-cpu-on-linux-and-macosx/","publishdate":"2009-12-27T00:00:00Z","relpermalink":"/2009/12/27/get-number-of-cpu-on-linux-and-macosx/","section":"post","summary":"Linux / MacOS X 플랫폼에서 CPU 갯수를 얻어오는 함수입니다. 잊어버릴까봐 기록해 둡니다. #include \u0026lt;stdio.h\u0026gt; #ifdef __linux__ #include \u0026lt;sys/sysinfo.h\u0026gt; #else #ifdef __APPLE__ #include \u0026lt;sys/param.h\u0026gt; #include \u0026lt;sys/sysctl.h\u0026gt; #else #error \u0026quot;Only Linux or OSX is supported!\u0026quot; #endif /* __APPLE__ */ #endif /* __linux__ */ static int get_cpu_nr (void) {","tags":["glibc","Linux","MacOSX"],"title":"리눅스 / 맥오에스에서 CPU 갯수 얻기","type":"post"},{"authors":null,"categories":null,"content":" 리눅스 커널 2.6.32 릴리스 소식 을 들은지 한참 지난 지금에서야 정리해 봅니다. 모든 일이 그렇지만, 언제 이 버전의 커널을 프로젝트에 사용할지 모르는 일이므로 게으름부리지 말아야겠다는 생각이 다시 들고 있는 요즘입니다.\n언제나 그렇듯이 제가 관심있는 내용만 정리합니다.\nCFQ IO 스케쥴러 새 기능\n리눅스 커널의 기본 IO 스케쥴러인 CFQ 스케쥴러에 새 기능이 추가되었습니다. 백그라운드 IO 작업이 다른 작업에 영향을 덜 끼치도록 하여 데스크탑 관련 프로세스나 미디어 재생 프로그램의 상호작용성(interactiveness)을 향상시키는 기능인데, 반대로 IO 처리율(throughput) 성능을 떨어뜨릴 수도 있습니다.\n따라서 IO 성능이 더 중요한 시스템, 예를 들어 서버나 GUI 기능이 필요없는 시스템이라면 다음처럼 이 기능을 꺼야 합니다. (/dev/sda 장치의 경우)\n$ echo 0 \u0026gt; /sys/class/block/sda/queue/iosched/low_latency  아마도 배포판의 경우 서버 / 데스크탑별로 자체 튜닝을 하지 않을까 싶습니다. 더 자세한 내용은 LWN.net 페이지 를 참고하시기 바랍니다.\nKVM 성능 향상\n가상화 관련되어서는 KSM(kernel shared memory) 기술이 도입되어 KVM과 같은 가상환경의 메모리 사용량을 더 줄였습니다. 예를 들어 여러 가상머신을 실행하고 있을때 이들이 동일한 소프트웨어 라이브러리나 프로그램을 사용할 경우 이를 하나의 메모리에 공유해서 사용하도록 하여 실제 메모리 사용량을 줄이는 기술입니다. 사용하려면 명시적으로 다음과 같이 실행해야 합니다.\n$ echo 1 \u0026gt; /sys/kernel/mm/ksm/run  Devtmpfs 파일시스템\n/dev 디렉토리를 메모리파일시스템(tmpfs)을 이용해 처리할 수 있도록 devtmpfs 파일시스템이 추가되었습니다. \u0026lsquo;devfs 2.0\u0026rsquo;이라고도 불릴수 있는데, 커널 자신이 부팅하면서 램디스크를 만들어 마운트하고 장치 파일을 만들기 때문에 부팅시간을 줄일 수 있을 뿐 아니라 udev 등을 사용하지 않아도 되고, 이를 위한 initrd 파일시스템 없이 부팅할 수 있도록 도와줍니다.\nX86 플랫폼 지원 향상\n인텔 무어스타운(Moorestown) 플랫폼을 공식적으로 추가되고 아톰(Atom)이 하나의 프로세서로 분리되면서 더 최적화된 지원을 하게 되었습니다. 더불어 인텔의 SFI(Simple Firmware Interface) 를 지원한다고 하는데, ACPI를 대체하기 위해 인텔이 만든 것이라고 합니다. 무어스타운 플랫폼 자체가 스마트폰, MID(Mobile Internet Device) 등과 같은 임베디드 환경을 목표로 하므로 향후 이 플랫폼을 활용하려면 어쩔 수 없이 이 버전 이후 커널을 사용해야 할 것 같습니다.\nACPI 4.0 지원이 추가된 것은 물론 최신 메인 보드의 I/O 장치가 제공하는 실행중 전원 절약 기능을 충분히 사용하도록 개선되면서 전원 관리 기능도 대폭 향상되었습니다.\n성능 분석 도구 추가\n성능 카운터(Performance Counters)가 성능 이벤트(Performance Events)로 이름이 바뀌면서 매우 많은 기능이 추가되었습니다. 프로세스 스케쥴러를 분석하는 작업을 쉽게 해주는 \u0026ldquo; perf sched \u0026rdquo; 도구라든지, \u0026ldquo;perf record\u0026quot;를 이용해 기록한 내용을 SVG 그래픽파일로 변환해주는 \u0026ldquo; Timechart \u0026rdquo; 도구 등이 그것입니다. Timechart는 bootchart와도 비슷하지만, 커널 레벨에서 수집하는 정보를 사용하기 때문에 부팅 시간 단축을 위한 측정에도 유용할 것 같습니다.\nCFS 스케쥴러 성능 개선\n안드로이드(Android)를 비롯한 리눅스 커널을 사용하는 몇몇 프로젝트에서는 이미 반영하고 있어 요즘 이슈가 되고 있는 BFS 스케쥴러와 관련된 패치도 있군요. 오픈소스 H.264 인코더 라이브러리 X264 개발자가 블로그 에서 밝힌 것처럼, 멀티코어 시스템에서 x264 인코딩을 실행하면 BFS 스케쥴러를 사용하는 경우가 리눅스 기본 CFS 스케쥴러보다 80% 정도 성능 향상이 있다는 내용을 리눅스 커널 메일링 리스트에 올리자마자 커널 개발자들이 이를 흔쾌히 받아들여 기존 CFS 스케쥴러의 버그를 수정했다고 하는데, 이번 커널 릴리스에 반영되었습니다.\n\u0026lsquo;localmodconfig\u0026rsquo; 설정 옵션 추가\n커널 빌드를 위해 설정할때 \u0026lsquo;make localmodconfig\u0026rsquo; 명령을 실행하면, 현재 실행중인 커널과 실제로 로드된 커널 모듈 목록만을 가지로 자동으로 최적화된 커널 설정 파일을 만들어주는 기능입니다. 자주 커널을 테스트하는 사람에게 매우 유용한 옵션일 것 같습니다. 비슷하지만 모든 모듈을 컴파일하여 커널에 내장시키도록 해주는 \u0026lsquo;make localyesconfig\u0026rsquo; 명령도 추가되었습니다.\n그외\nbtrfs 파일시스템을 많이 개선했고, 블럭 레이어 확장성(scalability)을 위한 개선 작업이 이루어졌습니다. 하지만 아직 사용하고 있지 않아 별로 감흥은\u0026hellip;\nAMD/ATI 2000,300,4000 라데온 그래픽카드에 대한 커널모드스위치(KMS)와 3D그래픽 지원이 추가되었습니다. 인텔 칩셋은 항상 가장 먼저 지원되므로, 이제 메이저 칩셋 중에서는 NVIDIA 쪽만 남은 것 같기도 하고\u0026hellip; 인텔 드라이버는 프레임버퍼 압축 기능을 지원하여 Idle 상태에서 전원을 0.5W 정도 절약한다고 합니다.\nVMware 설치시에 빌드하던 vmxnet3 기상 이더넷 드라이버가 커널에 공식적으로 포함되었습니다. 하지만 요즘은 VirtualBox를 사용하고 있어서 그다지\u0026hellip;\n아무튼 ALSA 오디오 드라이버 / 비디오 / 이더넷 / 스토리지 등 많은 드라이버가 업데이트되었다고 하니, 더 자세한 내용이 궁금하신 분은 커널뉴비 페이지 를 참고하시기 바랍니다. 커널뉴비 페이지가 너무 길다면 \u0026lsquo; What\u0026rsquo;s new in Linux 2.6.32 \u0026rsquo; 기사를 보셔도 될 것 같습니다.\n","date":1261094400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1261094400,"objectID":"cd55e62fc8054d2e359176bf32621196","permalink":"https://lethean.github.io/2009/12/18/linux-kernel-2-6-32-release/","publishdate":"2009-12-18T00:00:00Z","relpermalink":"/2009/12/18/linux-kernel-2-6-32-release/","section":"post","summary":"리눅스 커널 2.6.32 릴리스 소식 을 들은지 한참 지난 지금에서야 정리해 봅니다. 모든 일이 그렇지만, 언제 이 버전의 커널을 프로젝트에 사용할지 모르는 일이므로 게으름부리","tags":["Kernel","Linux"],"title":"리눅스 커널 2.6.32 릴리스","type":"post"},{"authors":null,"categories":null,"content":"업무상 실제 패킷 사용량을 측정할 필요때문에 여러가지 도구를 찾던 중 마땅한 걸 찾지 못해 직접 측정한 방식을 정리해 봅니다. 물론 이보다 더 좋은 방법들이 당연히 있을테지만, tcpdump 프로그램만 겨우 사용할 수 있는 환경에서 측정하는 법을 정리한 문서를 찾지 못해 남겨둡니다.\n우선 어떤 방식으로든 해당 장비에 tcpdump 프로그램을 설치합니다.\n그리고 측정하려는 과정이나 단계가 시작하는 동시에 다음과 같이 tcpdump 프로그램을 실행합니다.\n$ tcpdump -qvtttt dst xxx.xxx.xxx.xxx \u0026gt; packet-dump.txt  여기서 xxx.xxx.xxx.xxx는 측정에 사용할 대상 장비입니다. 즉, 위 예제는 특정 IP로 전송하는 패킷량만 캡쳐하여 packet-dump.txt 파일에 저장합니다. 중요한 점은 앞의 옵션인데, 이 옵셥을 사용해야 아래에서 사용하는 스크립트가 분석할 수 있는 형태의 결과물로 저장됩니다. 그리고, 필요하다면, 저장한 파일을 리눅스 또는 맥 장비로 복사합니다.\n저장한 파일을 conv2csv.sh 스크립트를 이용해 엑셀이나 오픈오피스에서 읽어들일 수 있는 CSV 파일 형태로 변환합니다.\n$ ./conv2csv.sh packet-dump.txt  변환된 packet-dump.csv 파일은 한 행에 \u0026lsquo;TIMESTAMP BYTES Kbps\u0026rsquo; 형태로 각 초당 데이터가 저장되어 있습니다. 따라서 이 파일을 액셀이나 오픈오피스에서 공백(space)을 구분자로 해서 읽어들인 후 3번째 컬럼을 사용하면 됩니다. 참고로 여기서 측정한 크기는 IP/TCP/UDP 헤더까지 포함한 크기입니다.\n다음은 이렇게 변환한 데이터를 구글 스프레드시트를 이용해 만든 차트입니다.\n위에서 언급한 conv2csv.sh 스크립트는 다음과 같습니다.\n#!/bin/sh CSVFILE=\u0026quot;$(dirname $1)/$(basename $1 .txt).csv\u0026quot; awk '{ print $2, $18 }' $1 | tr '.)' ' ' | awk 'BEGIN { last = \u0026quot;\u0026quot;; sum = 0; } { if (last == $1) { sum += $3 } else { print last, sum, sum * 8 / 1000; last = $1; sum = $3; } }' \u0026gt; $CSVFILE  ;)\n","date":1260835200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1260835200,"objectID":"510a3c5acab5e534d9b6e3b39b98b992","permalink":"https://lethean.github.io/2009/12/15/network-traffic-analysis-using-tcpdump/","publishdate":"2009-12-15T00:00:00Z","relpermalink":"/2009/12/15/network-traffic-analysis-using-tcpdump/","section":"post","summary":"업무상 실제 패킷 사용량을 측정할 필요때문에 여러가지 도구를 찾던 중 마땅한 걸 찾지 못해 직접 측정한 방식을 정리해 봅니다. 물론 이보다 더 좋은 방법들이 당연히 있을테","tags":["Linux","MacOSX","Network","Shell"],"title":"tcpdump를 이용한 네트워크 사용량 측정하기","type":"post"},{"authors":null,"categories":null,"content":"요즘 맥북과 리눅스를 같이 사용하면서 여러가지 방법으로 파일을 공유하고 있는데, SSH 등으로 직접 복사할때 파일 이름에 한글이 포함되어 있으면 깨지는 현상이 발생합니다. 리눅스에서 맥으로 복사할때는 문제가 없는데, 다시 맥에서 리눅스로 복사하면 파일 이름의 한글이 요상하게 보입니다. 동일한 UTF-8 환경이라 문제가 없을 줄 알았는데, 이 때문에 Unison 같은 프로그램도 오동작을 합니다.\n대략 검색해보니 UTF-8을 인코딩할때 리눅스 계열의 운영체제는 NFC(normalization form C) 방식을 사용하는데 맥의 다윈 커널에서는 NFD(normalization form D) 방식을 사용하기 때문이랍니다. 아무튼, 해결하는 방법은 convmv 프로그램을 이용하면 됩니다.\n우선 다음과 같이 convmv 프로그램을 설치합니다.\n$ sudo apt-get install convmv  한글이 깨진 파일이나 디렉토리에서 다음 명령을 실행합니다.\n$ convmv -f utf8 -t utf8 -r --nfc --notest *  더 자세한 사용법은 `man convmv\u0026lsquo;를 입력하시길~\n","date":1254787200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1254787200,"objectID":"47ba1a6b5d9988f2bd23db02b100d101","permalink":"https://lethean.github.io/2009/10/06/fix-broken-hangul-filename-from-mac-os-x-in-linux/","publishdate":"2009-10-06T00:00:00Z","relpermalink":"/2009/10/06/fix-broken-hangul-filename-from-mac-os-x-in-linux/","section":"post","summary":"요즘 맥북과 리눅스를 같이 사용하면서 여러가지 방법으로 파일을 공유하고 있는데, SSH 등으로 직접 복사할때 파일 이름에 한글이 포함되어 있으면 깨지는 현상이 발생합니","tags":["Hangul","Linux","MacOSX"],"title":"MacOS X의 한글 이름 파일을 리눅스에 복사하면 깨지는 현상 고치기","type":"post"},{"authors":null,"categories":null,"content":"회사에서 개발하는 모든 프로젝트 소스는 (이제는 당연하겠지만) 버전 관리 시스템을 이용해 관리합니다. 2001년부터 CVS를 사용하다가 2004년에 Subversion으로 이전하여 지금까지 사용했습니다. 그리고 이번달에 사전 조사와 학습, 개발자 세미나 등을 거쳐 Git으로 이전하게 되었는데, 그 과정에서 몇 가지 기록해 둘 만한 내용을 정리했습니다.\nGit 자체를 학습하고 이해하는데는 Pro Git 책이 가장 유용했습니다. 서버 구축과 계정 관리 뿐 아니라 수많은 Git 관련 온라인 문서를 보면서 애매하고 답답했던 내용을 가장 쉽게 설명한 책인 것 같습니다. 국내에는 아직 수입이 안된 것 같지만, 온라인으로 공개되어 있어 읽는데 문제는 없습니다.\n기존 Subversion 저장소를 Git으로 변환하기 위해 svn2git 프로그램을 조금 수정해서 사용했습니다. svn2git 프로그램은 여러 스크립트 버전이 있는데 링크한 펄 버전이 가장 튼튼했습니다. 수정한 부분은 변환 작업 마지막의 trunk 브랜치를 master 로 자동으로 변경해 주는 부분인데, 몇몇 저장소에서 오동작을 일으켜 실행하지 않도록 주석 처리한 것 뿐입니다. 한가지 유의할 점은, 서브버전에서 마지막 커밋이 이루어진 브랜치가 Git에서 master 브랜치가 되므로, trunk에서 마지막 커밋임을 확인해야 합니다. 변환 작업은 저장소가 운영되고 있는 서버에서 직접 \u0026lsquo;file:///\u0026rsquo; URL 접근을 이용해 처리했는데, 왜냐하면 가끔 네트웍 오류나 웹서버 오류가 발생할 경우 처음부터 다시 실행해야 하는 문제가 있기 때문입니다.\n윈도우(Windows)에서는 msysgit + TortoiseGit 프로그램을 사용하고, 맥(Mac)은 기본으로 제공하는 설치 프로그램을 이용했습니다. Git Extensions 은 비주얼 스튜디오 확장 기능도 있지만, 안정성이나 유용성이 조금 부족하다는 느낌을 받았습니다.\n\u0026lsquo;git push\u0026rsquo;시에 자동으로 메일링 리스트나 특정 메일 주소로 메일을 전송하는 기능은 Git 소스에 들어있는 기본 훅(hook) 스크립트 대신 GNOME Git 관리 스크립트 에 들어있는 gnome-post-receive-mail 스크립트를 조금 수정해서 사용했습니다. 커밋 로그 메시지에 \u0026lsquo;Bug #1111\u0026rsquo; 같은 문자열이 있으면 자동으로 버그질라 데이터베이스에 추가하는 기능은 아직 이전하지 못했습니다. 구글링을 해보면 몇몇 비슷한 스크립트를 찾을 수 있으나 맘에 드는 게 없다는 점도 이유 중 하나이지만, GNOME 프로젝트처럼 \u0026lsquo;git bz\u0026rsquo; 같은 명령을 이용해 직접 버그질라에 버그를 등록하거나(file), 첨부파일로 커밋 로그 추가, 상태 변화 등을 할 수 있는 방식으로 변화를 꾀하는 것도 좋을 것 같아 고민 중에 있습니다.\n기본 Subversion 저장소를 Git으로 이전할때 가장 고민이 되었던 부분은 Subversion의 svn:externals 속성을 이용해 복잡하게 연결되어 있는 수많은 프로젝트를 어떻게 관리할 것인가였습니다. 처음에는 Git이 제공하는 Submodules 기능을 이용하려 했으나 생각보다 복잡한 것 같아서 일단 팀원들이 모두 Git에 어느 정도 익숙해진 다음에 적용하기로 하고, 대신 자동으로 하위 모듈까지 내려 받는 스크립트(예:git-pull-all.sh)를 최상위 디렉토리에 두고 사용하기로 했습니다. 대신 여러 프로젝트에서 공유하는 여러 프로젝트를 하나의 프로젝트로 소스를 합친 뒤 모든 프로젝트에서는 단 하나의 공유 프로젝트만 연결하도록 저장소 구조를 대폭 단순화했습니다.\n아무튼 이전 작업은 마무리했지만, 한동안은 Subversion에서 벗어나 Git에 익숙해지기까지 시행착오를 많이 겪을 것 같고, 작업 방식이나 브랜치 / 안정버전 관리 방식 등도 Git에 더 친숙한 방식으로 변경해가야 할 것 같은 생각이 듭니다.\n","date":1254355200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1254355200,"objectID":"708e5348a89f9e549e6052e81e17137b","permalink":"https://lethean.github.io/2009/10/01/migration-projects-from-subversion-to-git/","publishdate":"2009-10-01T00:00:00Z","relpermalink":"/2009/10/01/migration-projects-from-subversion-to-git/","section":"post","summary":"회사에서 개발하는 모든 프로젝트 소스는 (이제는 당연하겠지만) 버전 관리 시스템을 이용해 관리합니다. 2001년부터 CVS를 사용하다가 2004년에 Sub","tags":["Git"],"title":"Subversion 프로젝트 Git 기반으로 이전","type":"post"},{"authors":null,"categories":null,"content":" GLib 2.22.0 안정버전 출시 소식 이 도착했습니다. 물론 GTK+ 2.18.0 버전도 함께 출시 되었지만 이 포스트에서는 일단 GLib에 대한 내용만 다루고, GTK+ 변경사항은 다른 포스트에서 정리할 예정입니다. 물론 그대로 우리말로 옮기는 건 지루하고 재미없는 작업이라, 한두가지 눈에 띄는 것만 정리합니다.\n제일 먼저 눈에 띄는 추가 사항은, 이전 포스트 에서 언급했던 GMainContext 객체를 쓰레드별로 자동 관리해주는 API가 추가되었다는 점입니다. 새로 추가된 g_main_context_get_thread_default () 함수는 쓰레드별 GMainContext 객체를 돌려주는데, 이 객체는 자동으로 생성되는 건 아니고, 쓰레드가 생성되자마자 바로 g_main_context_push_thread_default () 함수를 이용해 등록해야 합니다. 그럼 별로 달라지는 게 없는 게 아니냐고 생각할 수도 있지만, 일단 이 API를 사용하면 쓰레드별 컨텍스트 객체나 메인루프 객체를 프로그래머가 관리해야하는 수고를 조금 덜어줍니다. 하지만 그보다 더 좋은 예는, 어떤 작업을 처리하는 비동기 호출 함수가 여러 쓰레드에서 호출될 수 있을때, 하지만 비동기 작업 자체는 호출한 쓰레드의 메인 루프에서 실행되기를 원한다면, 그 함수에서는 그저 g_main_context_get_thread_default () 함수가 돌려주는 컨텍스트에 원하는 소스를 추가하기만 하면 되므로 코드가 상당히 간결하고 명료해집니다. 동일한 작업의 효율을 위해 비동기 방식으로 복수 쓰레드에 분산시키는 구조로 설계된 코드라면 특히 더 편해질 수 있습니다. (참고로 이번 버전의 GIO 모듈을 구현하는데 많이 사용하고 있습니다. 아마도 그쪽을 구현하다 보니 필요해져서 새로 추가된 API가 아닐까 추측해봅니다)\n그리고 위 내용을 포함한 몇몇 객체에 대한 참조 카운터 지원과 소소한 변경사항을 제외하면, 이번 릴리스는 대부분 GIO 모듈에 대한 기능 추가가 대부분인 것 같습니다. 특히 엄청나게 많은 네트워크 관련 API가 새로 추가되었는데, IP 주소와 유닉스 도메인 소켓 주소 관리, 비동기 방식으로 도메인 이름에 대한 주소를 얻어오거나 혹은 반대로 주소에 대한 도메인 이름을 얻어오기, 일반적인 소켓 / 유닉스 도메인 소켓 API 지원 등은 놀라울 따름입니다. 만일 리눅스 뿐 아니라 GLib 라이브러리가 동작하는 모든 플랫폼에서 문제없이 동작한다면, 향후 개발하는 네트워크 관련 프로젝트에서 이 API를 적극 이용할 용의가 있음도 물론입니다. 다만, GLib 라이브러리 기본 모듈이 아닌 GIO 모듈에 추가되었다는 점이 큰 아쉬움이긴 하지만\u0026hellip; ( GLib 라이브러리에는 고작 문자열이 IPv4 또는 IPv6 주소 형식인지 검사해주는 g_hostname_is_ip_address () 등과 같은 함수들만 몇 개 추가되었을 뿐이니\u0026hellip;)\n아무튼, 별로 내용이 길지 않은 릴리스 원문과 더불어 각 모듈별 매뉴얼 목차 마지막에 있는 `Index of new symbols in 2.22' 페이지도 꼭 확인하시기 바랍니다.\n","date":1253750400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1253750400,"objectID":"5d5a2fb20ea1e39be264b89c9d9cf928","permalink":"https://lethean.github.io/2009/09/24/glib-2-22-0-release/","publishdate":"2009-09-24T00:00:00Z","relpermalink":"/2009/09/24/glib-2-22-0-release/","section":"post","summary":"GLib 2.22.0 안정버전 출시 소식 이 도착했습니다. 물론 GTK+ 2.18.0 버전도 함께 출시 되었지만 이 포스트에서는 일단 GLib에 대한 내용만 다루고, GTK+ 변경사항은 다른 포스트에서 정","tags":["GLib"],"title":"GLib 2.22.0 출시","type":"post"},{"authors":null,"categories":null,"content":"GLib API를 이용한 멀티쓰레드 프로그래밍에서 비동기 메시지 큐를 이용하는 방법은 지난 포스트 에서 설명한 적이 있는데, 이번에는 애플 GCD의 libdispatch와 비교되는 GLib의 메인루프 를 이용하는 방법을 정리해 보았습니다. 이 방법은 어떤 관점에서 보면 더 쉽고, 이미 많은 기능이 기본적으로 지원되기 때문에 몇몇 경우를 제외하면 더 좋은 방법입니다. 다만 API 사용법을 이해하기가 처음에 조금 까다롭다는 점이 걸림돌입니다.\n일반적으로 GLib / GTK 어플리케이션은 메인 쓰레드에서 실행되는 메인 이벤트 루프 기반에서 동작합니다. 키보드 / 마우스 이벤트 처리, 화면 표시, 사용자가 등록한 Idle / Timeout 함수 처리 등이 모두 이 메인 이벤트 루프에서 처리됩니다. 그런데 이 메인 이벤트 루프라는 건 마냥 개념적인게 아니라, 실제로 GMainLoop 객체를 기반으로 동작합니다. 그런데 g_main_loop_*() 계열 함수를 살펴보면 몇 개 안됩니다. 루프 객체를 생성하고, 참조하고, 해제하고, 돌리고[g_main_loop_run()], 종료하고[g_main_loop_quit()], 돌아가는 중인지 확인하기 등의 함수만 있습니다. 아, 하나 더 있군요. 객체를 생성할때 전달하는 GMainContext 객체를 얻어오는 함수[g_main_loop_get_context()]가 있군요.\n모든 GMainLoop는 하나의 GMainContext와 함께 사용됩니다. GMainContext 객체는 실행할 소스[ GSource ] 목록을 관리합니다. 소스는 파일, 파이프, 소켓 등의 디스크립터를 기반으로 한 이벤트 소스일 수도 있고, Idle / Timeout 등과 같은 시간 소스일 수도 있습니다. 컨텍스트는 실행 소스 각각을 검사해서 원하는 이벤트가 발생했는지, 아니면 실행할 시간이 되었는지를 판단해 등록한 콜백함수를 호출합니다. 참고로, 메인 쓰레드에서 동작하기 위한 컨텍스트[g_main_context_default()]는 기본적으로 제공합니다. 이 기본 컨텍스트는 gtk_main() 함수가 사용하는 것은 물론, g_idle_add(), g_timeout_add() 등과 같은 함수도 이 기본 컨텍스트를 사용합니다.\n아무튼 조금 더 구체적이고 자세한 내용은 공식 문서 를 참고하시고, 이제 이를 이용한 멀티쓰레드 프로그래밍을 해보겠습니다. 말이 길었으니 코드를 먼저 보여드리겠습니다.\n#include \u0026lt;glib.h\u0026gt; static GThread *my_thread; static GMainLoop *my_loop; static void add_idle_to_my_thread (GSourceFunc func, gpointer data) { GSource *src; src = g_idle_source_new (); g_source_set_callback (src, func, data, NULL); g_source_attach (src, g_main_loop_get_context (my_loop)); g_source_unref (src); } static void add_timeout_to_my_thread (guint interval, GSourceFunc func, gpointer data) { GSource *src; src = g_timeout_source_new (interval); g_source_set_callback (src, func, data, NULL); g_source_attach (src, g_main_loop_get_context (my_loop)); g_source_unref (src); } static gpointer loop_func (gpointer data) { GMainLoop *loop = data; g_main_loop_run (loop); return NULL; } static void start_my_thread (void) { GMainContext *context; context = g_main_context_new (); my_loop = g_main_loop_new (context, FALSE); g_main_context_unref (context); my_thread = g_thread_create (loop_func, my_loop, TRUE, NULL); } static void stop_my_thread (void) { g_main_loop_quit (my_loop); g_thread_join (my_thread); g_main_loop_unref (my_loop); }  함수 먼저 설명하면, start_my_thread() 함수는 쓰레드를 시작하고, stop_my_thread() 함수는 쓰레드를 중지합니다. add_idle_to_my_thread() 함수는 바로 실행되는 Idle 콜백 함수를 추가하고, add_timeout_to_my_thread() 함수는 주기적으로 실행되는 Timeout 콜백 함수를 추가합니다. 마지막 두 함수의 인수는 g_idle_add(), g_timeout_add() 함수와 각각 동일합니다. 따라서, 콜백 함수가 TRUE를 리턴하면 자동으로 반복해서 계속 실행되고, FALSE를 리턴하면 한번만 실행되고 종료합니다.\n위 코드의 핵심은 GMainContext 객체를 만들고 이를 기반으로 GMainLoop 객체를 만든 뒤 별도 쓰레드에서 실행하도록 하는 부분입니다. 그리고, 필요한 모든 작업은 Idle / Timeout 소스 객체를 만들어 컨텍스트에 추가(attach)해서 동작하도록 하는 겁니다. 참고로, 관련 API는 모두 쓰레드에 안전합니다.\n물론 위 함수를 조금 더 확장하면 콜백함수가 종료될때 자동으로 호출되는 notify 함수도 등록할 수 있고, 우선순위도 조절할 수 있습니다. 또한 여러 쓰레드를 종류별로 만들어 필요한 쓰레드에게 해당 작업만 전달해도 됩니다. 하지만 그 정도는 응용하는데 별로 어려움이 없을 거라 생각하고 한가지만 더 설명하겠습니다.\n예를 들어 네트워크 소켓(socket)을 하나 만들고 이 소켓에 읽을 데이터가 도착했을 경우에만 호출되는 함수를 등록하고 싶은 경우, 다음과 같은 코드를 사용하면 됩니다.\nstatic gboolean socket_read (GIOChannel *source, GIOCondition condition, gpointer data) { /* Use g_io_channel_read_chars() to read data... */ return TRUE; } static void add_socket_to_my_thread (gint sock_fd) { GIOChannel *channel; GSource *src; channel = g_io_channel_unix_new (sock_fd); src = g_io_create_watch (channel, G_IO_IN); g_source_set_callback (src, (GSourceFunc) read_socket, NULL, NULL); g_source_attach (src, g_main_loop_get_context (my_loop)); g_source_unref (src); }  자세한 내용은 위 코드와 비슷하지만 기본 메인 이벤트 루프에서 동작하도록 하는 g_io_add_watch() API 설명 부분을 참고하시기 바랍니다. 어쨌든, 기본적으로 GMainContext 객체는 유닉스 시스템의 폴링(polling) 메카니즘을 사용하기 때문에 이론적으로는 거의 모든 파일 디스크립터를 사용할 수 있습니다. 물론 비슷한 방식으로 윈도우 운영체제에서 이벤트 핸들이나 소켓 핸들도 사용할 수도 있습니다.\n글머리에서 적은 것처럼 비동기 메시지 큐를 이용하는 방식보다 아주 약간의 오버헤드는 있겠지만, 훨씬 더 많은 기능을 제공하는 것 같지 않나요?\n","date":1253491200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1253491200,"objectID":"44bafa8876184b771787a169d167fc0f","permalink":"https://lethean.github.io/2009/09/21/using-glib-mainloop/","publishdate":"2009-09-21T00:00:00Z","relpermalink":"/2009/09/21/using-glib-mainloop/","section":"post","summary":"GLib API를 이용한 멀티쓰레드 프로그래밍에서 비동기 메시지 큐를 이용하는 방법은 지난 포스트 에서 설명한 적이 있는데, 이번에는 애플 GCD의 libdispat","tags":["Coding","GLib","GTK+"],"title":"GLib 메인루프 이용하기","type":"post"},{"authors":null,"categories":null,"content":"GTK 메일링 리스트에 흥미있는 포스트 가 있어서 정리해 봅니다.\n스노우 레오파드 출시와 더불어 오픈 소스로 공개되면서 요즘 한창 이슈가 되고 있는 애플의 GCD(Grand Central Dispatch) 의 일부인 libdispatch 라이브러리와 GLib 메인루프를 비교한 내용인데, 정리해 보면 다음과 같습니다.\nlibdispatch는 세 종류의 실행 큐를 제공하는데 다음과 같습니다.\n 메인 큐(main queue) : GLib의 메인 이벤트 루프와 동일 전역 큐(global queue) : 쓰레드풀(thread pool) 방식으로 동작하며 모든 작업(job)은 이 큐로 보내진 다음 임의의 쓰레드에서 비동기(asynchronously) 실행됩니다 개인 큐(private queue) : 이 큐의 작업은 순서대로 실행됩니다.  개인 큐와 메인 큐는 전역 큐의 쓰레드로 동작하는데, 이 방식은 GLib에서 GSource(g_idle / g_timeout / etc) 콜백함수를 다른 쓰레드에서 처리하게 위해 GMainLoop + GThreadPool 조합을 사용하는 것보다 사용자에게 더 편한 것 같습니다. 물론 libdispatch는 GCC를 확장한 블럭(blocks)이라는 문법을 이용하므로 사용하려면 GCC 패치가 필요합니다. 참고로, 블럭(blocks)은 함수형 언어나 스크립트 언어에서 지원되는 일종의 익명(anonymous) 함수인데, GLib의 GClosure와 비슷한 역할을 합니다. 예를 들어 C 언어에서는 특정 이벤트나 시그널이 발생할때 처리를 하려면 함수를 정의하고 이 함수를 콜백함수로 등록해야 하는데, 블럭(blocks)을 사용하면 함수를 따로 정의하지 않고 코드 블럭을 직접 시그널에 연결할 수 있는 셈입니다.\n그런데 이 포스트에 달린 댓글을 보면 GLib을 이용해 GCD와 비슷한 역할을 하는 라이브러리인 iris 와 catalina 라이브러리도 소개하고 있군요. 어쩌면 얼마 안있어 GCD를 참고한 라이브러리나 혹은 새로운 GLib API가 추가될 지도 모른다고 예측해 봅니다. 워낙 오픈소스 쪽은 부지런한 사람이 많아서 말이죠\u0026hellip; :)\n얼마전에는, 작은 웹서버를 띄우고 웹페이지에서 실행중인 GTK 어플리케이션의 모든 GObject 객체를 보여주는 것은 물론 바로 객체 속성도 수정할 수 있는 gtkwebd 유틸리티가 소개 되었고, 구글 어스나 나사의 월드윈드처럼 3차원으로 지구 지도를 보여주도록 도와주는 AWether 라이브러리도 공개 되었습니다. 물론 이전 포스트 에서 다룬 libchamplain 라이브러리에 더 관심이 많아 그다지 흥미롭지는 않았는데, 모르고 있던 Blue Marble NG , SRTM 30 Plus 등과 같은 무료 지도 데이터 정보를 알 수 있게 되어 고마울 따름입니다.\n아무튼 이쪽 세상은 끊임없이 상용 코드를 벤치마킹하고 모방하면서 조금씩 계속 진화하고 있습니다.\n","date":1253145600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1253145600,"objectID":"58df031efc9bbb7b677f79a9f676987d","permalink":"https://lethean.github.io/2009/09/17/glib-mainloop-vs-libdispatch-of-apple-gcd/","publishdate":"2009-09-17T00:00:00Z","relpermalink":"/2009/09/17/glib-mainloop-vs-libdispatch-of-apple-gcd/","section":"post","summary":"GTK 메일링 리스트에 흥미있는 포스트 가 있어서 정리해 봅니다. 스노우 레오파드 출시와 더불어 오픈 소스로 공개되면서 요즘 한창 이슈가 되고 있는 애플의 GCD(Grand Central Dispatch) 의 일부인","tags":["GLib","GTK+","MacOSX"],"title":"GLib 메인루프와 애플 GCD의 libdispatch","type":"post"},{"authors":null,"categories":null,"content":"어김없이 리눅스 커널 2.6.31 버전이 릴리스 되었습니다. 그리고, 갈수록 내용이 부실해지고 있지만, 역시 제가 관심있는 변경 사항만 간추려 정리해 보았습니다.\n사용자 공간 문자 장치 (CUSE, Character Devices in User Space)\nFUSE가 사용자 공간에서 구현할 수 있는 파일시스템 드라이버를 제공한다면, 사용자 공간 문자 장치(?)는 문자 장치를 사용자 공간에서 구현할 수 있도록 도와줍니다. 특히 이를 이용해 ALSA가 대체한 OSS 장치에 대한 프록시 디바이스를 구현하고 있는데, 예를 들어 OSS 장치인 것처럼 보이지만 사용자 공간 드라이버이기 때문에 ALSA 라이브러리를 직접 호출해 구현할 수도 있고, 다른 네트워크 장치로 전달할 수도 있습니다. 더 나아가 PulseAudio 라이브러리를 이용할 수도 있고 다채널 믹싱 기능도 구현할 수도 있습니다. 이를 통해 커널의 ALSA OSS 에뮬레이션 모듈을 대체하면서 OSS 오디오 장치를 사용하는 많은 유닉스 어플리케이션이 리눅스에서 더 쉽게 동작할 수 있도록 도와줍니다.\n아무튼 처음 시작은 OSS 프록시 장치를 구현하려고 포함된 기능이지만, 활용 방도는 FUSE처럼 무궁무진할 것으로 보입니다. 위와 같은 예가 오디오 장치에만 국한되는 건 아니니까요. 예를 들어 비디오 캡쳐 라이브러리가 바이너리 형태로만 제공되는 하드웨어를 사용하고 싶은데, 기존 어플리케이션이 V4L2 인터페이스 기반으로 만들어져 있다면, 캡쳐 카드용 V4L2 장치 파일을 CUSE 기반으로 만든 다음 V4L2 API 호출을 라이브러리 호출로 변환해도 되겠지요.\n성능 카운터 (Performance Counters)\n성능 카운터는 일종의 프로파일 도구입니다. 최근 CPU들이 기본적으로 지원하는 하드웨어 카운터 레지스터를 이용하기 때문에 커널이나 어플리케이션의 성능 저하를 야기하지 않습니다. 사용한 CPU 싸이클 수, 캐시 참조 회수, 캐시 미스 회수, 페이지 폴트 등과 같은 정보를 확인할 수 있는데, 현재 X86, PPC 플랫폼을 완전히 지원하고 S390, FRV 등은 부분적으로 지원하는 것 같습니다.\n성능 정보를 추출하거나 확인하려면 커널 소스에 포함된 perf 라는 커맨드라인 도구를 이용합니다. 커널 뉴비의 예제를 보면 특정 프로그램과 라이브러리를 지정하면서 디버깅 정보를 전달하면 함수 단위로 실행 정보를 보여주는 기능도 있습니다. top 명령어처럼 실시간으로 상태를 보는 기능도 있는 것 같고\u0026hellip; 어플리케이션 성능 디버깅을 위해 OProfile을 사용하기가 부담될때 사용하면 좋을 것 같은 기능입니다.\nBtrfs 파일 시스템 개선\nExt4 파일시스템을 대체할 차세대 파일시스템으로 각광받고 있는 Btrfs는 리누스 토발즈가 자신의 노트북 루트 파일 시스템으로 사용하고 있다고 해서 더 유명하죠. 솔라리스 ZFS 파일시스템과 비교도 많이 되고\u0026hellip; 아무튼 이번 버전에서 많이 안정화가 되었다고 하는데, 다음이나 다다음 릴리스 즈음엔 (1~2년 뒤?) 일반 배포판에서도 공식적으로 지원할 수 있을 정도의 상태인 것 같습니다. 더 자세한 기술적인 내용이 LWN에 포스팅 되어 있는데, 언제 여유가 되면 따로 정리해봐야 할 것 같습니다.\n기타\nOProfile 기능이 인텔 아톰과 코어 i7 칩셋도 지원하게 되었군요. (지금까지 아톰칩에서 안되고 있었단 말인가\u0026hellip;) 아직 시장에 제품도 안나온 USB 3.0 지원이 포함되고, 커널 메모리 디버깅 관련 몇 가지 기능(Kmemcheck / Kmemleak)이 추가되었습니다. 데스크탑 반응성을 향상시키는 미리읽기(readahead)와 메모리 관리 관련 변경이 있었으며, inotify / dnotify 등이 FSNotify 기반으로 다시 구현되었다고 합니다. 인텔 칩셋에 이어 ATI 라데온 칩셋의 커널 모드 셋팅 지원도 추가되었고, GCC 커버리지 기능(gcov)도 포함되었습니다. 물론 그외 많은 드라이버가 새로 추가되었고 버그도 많이 고쳐졌다고 합니다.\n더 자세한 내용에 관심있는 분은 커널뉴비 를 방문하시기 바랍니다.\n","date":1252886400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1252886400,"objectID":"6a01b8dcafb170059bc6a41e7ea8c22d","permalink":"https://lethean.github.io/2009/09/14/linux-kernel-2-6-31-release/","publishdate":"2009-09-14T00:00:00Z","relpermalink":"/2009/09/14/linux-kernel-2-6-31-release/","section":"post","summary":"어김없이 리눅스 커널 2.6.31 버전이 릴리스 되었습니다. 그리고, 갈수록 내용이 부실해지고 있지만, 역시 제가 관심있는 변경 사항만 간추려 정리해 보았습니다. 사용자 공","tags":["Kernel","Linux"],"title":"리눅스 커널 2.6.31 릴리스","type":"post"},{"authors":null,"categories":null,"content":"` Design experience and demos in GTK and Clutter ' 라는 포스트가 얼마 전에 올라왔는데 이제야 리뷰를 해봅니다. 이 포스트를 클릭해서 들어가 보시면 데모 동영상이 여러개 있는데, 클러터 안에 GTK 노트북 위젯을 넣어 여러가지 효과를 보여주고 있습니다. 이 포스트는 ` animating GTK+, Clutter-Gtk, client-side-windows and demos ' 포스트에서 설명한 방식을 더 확장하고 실용적인 예제를 보여주고 있는 셈인데, GTK Client Side Window + ClutterGtk를 이용하고 있습니다.\n클러터를 이용해 사용자 인터페이스를 만들때 불편한 점 중 하나는 버튼, 입력상자, 라디오 버튼 등과 같은 위젯 툴킷이 없기 때문에 모두 직접 만들어야 한다는 점입니다. 물론 모블린 프로젝트에서 사용하고 있는 클러터 기반 툴킷 라이브러리도 있고 클러터 예제 디렉토리에 여러가지 참고할 만한 샘플이 있긴 하지만, QT나 GTK 같은 라이브러리처럼 풍부한 기능은 제공하지 않습니다. 이 데모가 유용한 이유는, GTK 위젯을 그대로 클러터 안에 포함할 수 있는 것은 물론, 기존 GTK 위젯의 동작을 확장하여 자연스러운 애니메이션 효과를 마음대로 추가할 수 있다는 점을 보여주고 있기 때문입니다.\n물론, 단순히 예쁘고 화려한 인터페이스 효과를 추가하는게 목적이 아니라, 이를 통해 사용자가 더 쉽게 이해하고 사용하기 편한 인터페이스를 제공할 수 있다는 점이 더 중요한 것 같습니다.\n","date":1252368000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1252368000,"objectID":"1e450137e9ebd95a7ec10e31a10adca7","permalink":"https://lethean.github.io/2009/09/08/clutter-and-gtk/","publishdate":"2009-09-08T00:00:00Z","relpermalink":"/2009/09/08/clutter-and-gtk/","section":"post","summary":"` Design experience and demos in GTK and Clutter ' 라는 포스트가 얼마 전에 올라왔는데 이제야 리뷰를 해봅니다. 이 포스트를 클릭해서 들어가 보시면 데모 동영상이 여러개 있는데, 클러터 안에 GTK","tags":["Clutter","GUI","Linux"],"title":"클러터와 GTK","type":"post"},{"authors":null,"categories":null,"content":"이전 글에 계속 이어집니다.\n객체 속성 정보 얻기\nEdcHost 객체의 속성 정보를 실행 중에 얻어볼까 합니다.\n왜 또 갑자기 불필요한 예제를 꺼내냐고 물어보실 분이 있을 것 같아 말하자면, 가끔 요긴한 경우가 있기 때문입니다. 예를 들어 EdcHost 객체를 상속받은 EdcHostDoosan, EdcHostKia, EdcHostLitte 객체가 여러 개 존재할 경우, 이 객체들은 EdcHost의 공통 속성 뿐 아니라 본인의 속성도 따로 가집니다. 이러한 여러 객체를 관리할때, 특정 속성이 있는지 여부를 검사해서 관련 UI를 활성 / 비활성하거나, 편집 UI 자체를 속성 스펙과 목록을 이용해 100% 자동화하는 게 가능합니다. (Glade 처럼 말이죠) 물론 옵션 같은 플래그(flags) 변수를 정의하는 방법 등 여러가지 대안이 가능하겠지만, 최초 객체 설계시 고려하지 못했던 기능이나 속성을 나중에 계속 추가해 나가야 하는 경우 기존에 만든 객체를 매번 다시 수정하고 업그레이드하는 것보다 더 안전하고 깔끔한 방법이 될 수 있습니다. 그리고 당연히 더많은 응용이 있겠지만, 일단 알아두면 나중에 어떤 식으로든 도움이 되리라 생각합니다.\n일단, 다음 코드는 객체가 가지고 있는 속성 이름과 각 속성의 현재 값을 출력합니다.\nstatic void print_properties (GObject *object) { GObjectClass *oclass; GParamSpec **specs; guint n; guint i; oclass = G_OBJECT_GET_CLASS (object); specs = g_object_class_list_properties (oclass, \u0026amp;n); for (i = 0; i \u0026lt; n; i++) { GParamSpec *spec; GValue value = { 0 }; gchar *str; spec = specs[i]; g_value_init (\u0026amp;value, spec-\u0026gt;value_type); g_object_get_property (G_OBJECT (object), spec-\u0026gt;name, \u0026amp;value); str = g_strdup_value_contents (\u0026amp;value); g_print (\u0026quot;property '%s' is '%s'n\u0026quot;, spec-\u0026gt;name, str); g_value_unset (\u0026amp;value); g_free (str); } g_free (specs); } { EdcHost *host; /* ... */ host = g_object_new ( EDC_TYPE_HOST, \u0026quot;address\u0026quot;, \u0026quot;demo.emstone.com\u0026quot;, \u0026quot;port\u0026quot;, 8081, NULL); print_properties (G_OBJECT (host)); g_object_unref (host); /* ... */ }  위 코드에서 분명하게 이해해야 하는 점은, 객체 인스턴스가 아닌 객체 클래스에게 속성 정보를 질의한다는 점입니다. 모든 속성의 스펙을 얻기 위해 g_object_class_list_properties() 함수를 사용하고, GValue 객체에 속성 값을 가져온 다음, 문자열로 출력하기 위해 g_strdup_value_contents() 함수를 이용해 변환하고 있습니다.\n객체에 어떤 속성이 있는지 알아보려면 g_object_class_find_property() 함수를 이용하면 됩니다.\n속성 변경 알림 시그널 이용하기\n객체의 속성 값을 변경할 때 g_object_set() 함수를 이용하면 좋은 점은, 값을 변경하면 자동으로 시그널(signal)이 발생한다는 점입니다. GObject 시스템에서 시그널은 특정 사건(event)이 일어나면 발생(emit)합니다. 대부분의 경우 시그널은 객체 클래스 초기화시에 정의해야 하지만, 다행히도 속성 값이 변경될때 발생하는 시그널은 특별한 작업을 해주지 않아도 기본적으로 동작합니다. 따라서 \u0026ldquo;notify::property-name\u0026rdquo; 형식의 이름을 가지는 시그널에 콜백 함수를 연결하면 객체 값이 변경될때 자동으로 호출되는 함수를 등록할 수 있습니다.\nstatic void property_notified (GObject *object, GParamSpec *pspec, gpointer data) { GValue value = { 0 }; gchar *str; g_value_init (\u0026amp;value, pspec-\u0026gt;value_type); g_object_get_property (object, pspec-\u0026gt;name, \u0026amp;value); str = g_strdup_value_contents (\u0026amp;value); g_print (\u0026quot;property '%s' is set to '%s'n\u0026quot;, pspec-\u0026gt;name, str); g_value_unset (\u0026amp;value); g_free (str); } { EdcHost *host; host = g_object_new (EDC_TYPE_HOST, NULL); g_signal_connect (host, \u0026quot;notify::address\u0026quot;, G_CALLBACK (property_notified), NULL); g_signal_connect (host, \u0026quot;notify::port\u0026quot;, G_CALLBACK (property_notified), NULL); g_object_set (host, \u0026quot;address\u0026quot;, \u0026quot;192.168.0.1\u0026quot;, \u0026quot;port\u0026quot;, 8087, NULL); edc_host_set_address (host, \u0026quot;192.168.0.22\u0026quot;); g_object_unref (host); }  참고로 이 기능은, 디자인 패턴에서 말하는 관찰자(observer) 패턴일 수도 있고, GObject 매뉴얼에서 사용하는 것처럼 일종의 메시징 시스템 역할도 합니다. 예를 들어 모델(model)의 값이 변경되면 자동으로 뷰(view) 역할을 하는 GUI에 반영하는 코드를 작성할 경우 기존 객체 구현 코드를 수정하지 않고, 다시 말해 의존성을 추가하지 않고 기능을 구현할 수 있게 도와주어 객체간 결합도를 없애 줍니다.\n자 그런데, 위 예제에서 edc_host_set_address() 를 사용할 때는 콜백함수가 호출이 안되는 문제점이 있습니다. 왜냐하면 이 함수는 내부 address 변수를 직접 수정하기 때문에 값이 변경되었는지 여부를 GObject 시스템이 알 방법이 없기 때문입니다. 따라서 기존 코드를 수정해야 하는데, 첫번째 방법은 접근자를 이용하더라도 내부적으로 g_object_set() 을 호출하도록 하는 겁니다. (여기서는 \u0026lsquo;address\u0026rsquo; 관련 API만 보여드립니다)\nvoid edc_host_set_address (EdcHost *host, const gchar *address) { g_return_if_fail (EDC_IS_HOST (host)); g_return_if_fail (address != NULL); g_object_set (host, \u0026quot;address\u0026quot;, address, NULL); }  하지만 이 방법은 약간의 오버헤드가 있을 수 있습니다. 두번째 방법은, g_object_notify() 함수를 이용해 직접 알려주는 겁니다.\nvoid edc_host_set_address (EdcHost *host, const gchar *address) { EdcHostPrivate *priv; g_return_if_fail (EDC_IS_HOST (host)); g_return_if_fail (address != NULL); priv = EDC_HOST_GET_PRIVATE (host); g_free (priv-\u0026gt;address); priv-\u0026gt;address = g_strdup (address); g_object_notify (G_OBJECT (host), \u0026quot;address\u0026quot;); }  edc_host_set_property() 함수 안에서 중복되는 코드도 정리해 봅시다.\nstatic void edc_host_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec) { EdcHost *host = EDC_HOST (object); EdcHostPrivate *priv; priv = EDC_HOST_GET_PRIVATE (host); switch (property_id) { case EDC_HOST_PROP_NAME: edc_host_set_name (host, g_value_get_string (value)); break; case EDC_HOST_PROP_ADDRESS: edc_host_set_address (host, g_value_get_string (value)); break; case EDC_HOST_PROP_PORT: edc_host_set_port (host, g_value_get_int (value)); break; case EDC_HOST_PROP_USER: edc_host_set_user (host, g_value_get_string (value)); break; case EDC_HOST_PROP_PASSWORD: edc_host_set_password (host, g_value_get_string (value)); break; default: /* We don't have any other property... */ G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec); break; } }  시그널이 중복 발생할 경우를 염려할 필요는 없습니다. 시그널은 GObject 내부적으로 알아서 잘 정리되어 한 번 변경하면 한 번만 시그널이 발생합니다.\n오늘은 여기까지입니다\u0026hellip; :)\n","date":1251072000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1251072000,"objectID":"663c724e891b7d4b6e69a8f4cd50c30d","permalink":"https://lethean.github.io/2009/08/24/oop-with-gobject-4/","publishdate":"2009-08-24T00:00:00Z","relpermalink":"/2009/08/24/oop-with-gobject-4/","section":"post","summary":"이전 글에 계속 이어집니다. 객체 속성 정보 얻기 EdcHost 객체의 속성 정보를 실행 중에 얻어볼까 합니다. 왜 또 갑자기 불필요한 예제를 꺼내냐고 물어보실 분이 있을 것 같아 말하","tags":["Agile","Coding","GLib","GTK+"],"title":"GObject 객체 지향 프로그래밍 (4)","type":"post"},{"authors":null,"categories":null,"content":"이 글은 회사 개발팀 내부 세미나를 위해 작성중인 글입니다. 하지만, 블로그란 매체의 특성상 외부에도 공개되고 있는데, 댓글은 달지 않아도 접속하는 사람들 대부분이 제가 아는 분일 거라 생각하고 한마디 하자면, 세상에 공짜가 어디 있는가, 주저하지 말고 내게 연락해서 술 한 잔 사게! (언젠가부터 술 강요 청탁 협박 블로그가 되어 가고 있군\u0026hellip;)\n속성 (Properties) 추가하기\n이제, GObject 속성(properties) 기능을 추가하려고 하는데, 왜 쓸데없이 일을 만들어서 하냐고 물으면 할 말이 있어야할 것 같아서, GObject 속성의 특징을 요약해 봤습니다.\n 단일 API로 모든 속성 값을 얻어오거나 변경하기 속성 변경시 자동으로 호출되는 함수 등록하기 (시그널 이용) 실행 중에 속성에 대한 정보 얻어내기  물론 이미 많은 언어와 라이브러리가 그 이상의 기능을 지원하기도 하고, 일정 능력 이상의 개발자라면 직접 구현하는게 아주 어려운 것도 아닙니다. 하지만 이미 잘 구현되어 검증받은 라이브러리가 있는데 굳이 새로운 바퀴를 만들 필요는 없겠지요? 아무튼, 정확한 내용은 글을 적으면서 하나씩 설명해 나가겠습니다.\nGObject 객체에 속성을 추가하려면 속성의 값(value)이 어떤 형(type)인지, 이름이 무엇인지, 값의 범위는 어떻게 되는지, 기본값은 무엇인지 등을 정의해서 알려주어야 합니다. (C++이나 Java에서 클래스 멤버 변수를 정의하는 것과 비슷합니다) 이러한 정보를 줄임말로 스펙(spec.)이라고 한다면, 속성을 추가한다는 건 다른 말로, 스펙으로 명시한 속성 정보를 클래스에 설치(install)하는 것을 의미합니다. 객체 인스턴스마다 속성의 실제 값(value)은 모두 다르겠지만, 어떤 속성이 있는지 그 속성은 어떻게 구성되어는지는 모두 동일하겠지요. (참고로 GObject 관련 API를 훑어보시면 정확히 모르더라도 지금 언급한 개념의 단어로 이루어진 API가 꽤 많은 걸 아시게 될 겁니다) 그렇기 때문에, 속성을 추가하는 작업은 클래스 초기화 함수에서 이루어집니다.\n다음은 기존 예제에서 속성을 추가한 코드입니다. (변경된 부분만 보여드립니다)\nedc-host.c\n/* ...[snip]... */ enum { EDC_HOST_PROP_0, /* ignore */ EDC_HOST_PROP_NAME, EDC_HOST_PROP_ADDRESS, EDC_HOST_PROP_PORT, EDC_HOST_PROP_USER, EDC_HOST_PROP_PASSWORD }; /* ...[snip]... */ static void edc_host_get_property (GObject *object, guint property_id, GValue *value, GParamSpec *pspec) { EdcHost *host = EDC_HOST (object); EdcHostPrivate *priv; priv = EDC_HOST_GET_PRIVATE (host); switch (property_id) { case EDC_HOST_PROP_NAME: g_value_set_string (value, priv-\u0026gt;name); break; case EDC_HOST_PROP_ADDRESS: g_value_set_string (value, priv-\u0026gt;address); break; case EDC_HOST_PROP_PORT: g_value_set_int (value, priv-\u0026gt;port); break; case EDC_HOST_PROP_USER: g_value_set_string (value, priv-\u0026gt;user); break; case EDC_HOST_PROP_PASSWORD: g_value_set_string (value, priv-\u0026gt;password); break; default: /* We don't have any other property... */ G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec); break; } } static void edc_host_set_property (GObject *object, guint property_id, const GValue *value, GParamSpec *pspec) { EdcHost *host = EDC_HOST (object); EdcHostPrivate *priv; priv = EDC_HOST_GET_PRIVATE (host); switch (property_id) { case EDC_HOST_PROP_NAME: g_free (priv-\u0026gt;name); priv-\u0026gt;name = g_value_dup_string (value); break; case EDC_HOST_PROP_ADDRESS: g_free (priv-\u0026gt;address); priv-\u0026gt;address = g_value_dup_string (value); break; case EDC_HOST_PROP_PORT: priv-\u0026gt;port = g_value_get_int (value); break; case EDC_HOST_PROP_USER: g_free (priv-\u0026gt;user); priv-\u0026gt;user = g_value_dup_string (value); break; case EDC_HOST_PROP_PASSWORD: g_free (priv-\u0026gt;password); priv-\u0026gt;password = g_value_dup_string (value); break; default: /* We don't have any other property... */ G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec); break; } } /* ...[snip]... */ /* class initializer */ static void edc_host_class_init (EdcHostClass *klass) { GObjectClass *gobj_class; GParamSpec *pspec; gobj_class = G_OBJECT_CLASS (klass); gobj_class-\u0026gt;finalize = edc_host_finalize; gobj_class-\u0026gt;set_property = edc_host_set_property; gobj_class-\u0026gt;get_property = edc_host_get_property; g_type_class_add_private (gobj_class, sizeof (EdcHostPrivate)); pspec = g_param_spec_string (\u0026quot;name\u0026quot;, /* name */ \u0026quot;Name\u0026quot;, /* nick */ \u0026quot;the name of a host\u0026quot;, /* blurb */ \u0026quot;\u0026quot;, /* default */ G_PARAM_READWRITE); g_object_class_install_property (gobj_class, EDC_HOST_PROP_NAME, pspec); pspec = g_param_spec_string (\u0026quot;address\u0026quot;, \u0026quot;Address\u0026quot;, \u0026quot;the address of a host\u0026quot;, \u0026quot;\u0026quot;, G_PARAM_READWRITE); g_object_class_install_property (gobj_class, EDC_HOST_PROP_ADDRESS, pspec); pspec = g_param_spec_int (\u0026quot;port\u0026quot;, \u0026quot;Port\u0026quot;, \u0026quot;the port number of a host\u0026quot;, 0, /* minimum */ 65535, /* maximum */ 0, /* default */ G_PARAM_READWRITE); g_object_class_install_property (gobj_class, EDC_HOST_PROP_PORT, pspec); pspec = g_param_spec_string (\u0026quot;user\u0026quot;, \u0026quot;User\u0026quot;, \u0026quot;password for authetication\u0026quot;, \u0026quot;\u0026quot;, G_PARAM_READWRITE); g_object_class_install_property (gobj_class, EDC_HOST_PROP_USER, pspec); pspec = g_param_spec_string (\u0026quot;password\u0026quot;, \u0026quot;Password\u0026quot;, \u0026quot;password for authetication\u0026quot;, \u0026quot;\u0026quot;, G_PARAM_READWRITE); g_object_class_install_property (gobj_class, EDC_HOST_PROP_PASSWORD, pspec); }  제일 먼저 정의된 열거형 타입에 대해 설명하자면, 클래스 내부에서 속성은 정수형 숫자로 관리됩니다. 예를 들어 1번 속성, 3번 속성처럼 직접 정수형을 사용해도 되지만, 관례적으로 가독성을 위해 열거형으로 정의합니다. 이렇게 정의한 번호를 클래스에 속성을 설치할때 지정하면 [ g_object_class_install_property() ], edc_host_{get/set}_property() 속성 읽기 / 쓰기 함수의 인자로 `property_id\u0026lsquo;가 전달되는데, 이 ID가 바로 속성 번호입니다. 물론 속성 번호는 g_object_class_override_property() 같은 다른 API에서도 사용합니다.  edc_host_class_init() 클래스 초기화 함수를 보면, g_param_spec_*() 함수를 이용하여 각 속성의 스펙을 정의해서 g_object_class_install_property() 함수를 이용해 클래스 객체에 설치합니다. 그리고,속성 읽기 /쓰기 메쏘드를 재정의합니다. 참고로 API 문서를 확인하시면, 다양한 형(type)을 위한 스펙 정의 함수가 있는 걸 알 수 있습니다. 속성 스펙을 정의할때 마지막에 넣어주는 플래그(flags)는 속성의 특성을 정의하는데, GParamFlags 설명을 한 번 읽어보시면 어렵지 않게 이해할 수 있습니다. 여기서는 모든 속성을 읽고 쓰기 가능하게 했습니다.\n재정의된 edc_host_{get/set}_property() 속성 읽기 / 쓰기 메쏘드 함수를 보면, 접근자(accessor) 함수와 동일한 작업을 합니다. 다른 점이라면 속성 ID에 따라 GValue 객체에서 값을 읽거나, 값을 할당한다는 점입니다. GValue 객체는 쉽게 말해 어떤 형(type)의 값이라도 담을 수 있는 일반적인 값(generic values)입니다. 참고로 이 역시 다양한 형(type)을 위한 g_value_{set,get}_*() 형태의 함수가 존재하므로 이를 그대로 이용하면 됩니다. (물론 더 능숙하게 사용하려면 API 문서를 한 번 훑어보는게 좋겠지요)\n여기까지 이해하셨다면 아시겠지만, GObject 시스템은 속성에 전반적인 틀과 관리 체계만 제공할 뿐 실제 속성을 다루는 작업은 대부분 직접 구현해야 합니다. 이는 프로그래머의 자유도를 높여 주기도 하지만, 불필요한 반복 작업을 유발하기도 합니다. 그리고 이 때문에 Vala 같은 GObject 기반 언어가 새로 만들어지기도 했습니다.\n**속성 (Properties) 사용하기 **\n이렇게 정의한 속성을 객체 외부에서 사용하기 위해 몇 가지 방법이 있지만, 가장 쉽고 많이 사용하는 방법은 g_object_get() / g_object_set() 함수를 이용하는 겁니다.\n{ EdcHost *host; gchar *address; gint port; g_type_init (); host = edc_host_new (); g_object_set (host, \u0026quot;address\u0026quot;, \u0026quot;192.168.0.100\u0026quot;, \u0026quot;port\u0026quot;, 8080, NULL); address = edc_host_get_address (host); g_assert_cmpstr (address, ==, \u0026quot;192.168.0.100\u0026quot;); g_free (address); g_object_get (host, \u0026quot;address\u0026quot;, \u0026amp;address, \u0026quot;port\u0026quot;, \u0026amp;port, NULL); g_assert_cmpstr (address, ==, \u0026quot;192.168.0.100\u0026quot;); g_assert_cmpint (port, ==, 8080); g_free (address); g_object_unref (host); }   g_object_new() 함수를 이용하여 객체를 생성할때 아예 속성을 함께 지정할 수도 있습니다.\n{ EdcHost *host; gchar *address; gint port; g_type_init (); host = g_object_new (EDC_TYPE_HOST, \u0026quot;address\u0026quot;, \u0026quot;demo.emstone.com\u0026quot;, \u0026quot;port\u0026quot;, 8081, NULL); g_object_get (host, \u0026quot;address\u0026quot;, \u0026amp;address, \u0026quot;port\u0026quot;, \u0026amp;port, NULL); g_assert_cmpstr (address, ==, \u0026quot;demo.emstone.com\u0026quot;); g_assert_cmpint (port, ==, 8081); g_free (address); g_object_unref (host); }  눈여겨 보신 분은 아시겠지만, edc_host_new() 함수는 g_object_new (EDC_TYPE_HOST, NULL) 호출로 만들어진 객체를 돌려주는 역할만 합니다.\n이렇게 대략 GObject 속성 기본 사용법을 설명한 것 같습니다. 물론 이 예제 코드에는 몇 가지 오류가 남아있는데, 이는 위에서 언급한 것처럼 객체 속성을 다루는 다른 부분을 설명하면서 보완해 나갈 예정입니다.\n오늘은 여기까지입니다.\n","date":1250553600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1250553600,"objectID":"e038ac32d8439f47d4dde65ba8c02ef8","permalink":"https://lethean.github.io/2009/08/18/oop-with-gobject-3/","publishdate":"2009-08-18T00:00:00Z","relpermalink":"/2009/08/18/oop-with-gobject-3/","section":"post","summary":"이 글은 회사 개발팀 내부 세미나를 위해 작성중인 글입니다. 하지만, 블로그란 매체의 특성상 외부에도 공개되고 있는데, 댓글은 달지 않아도 접속하는 사람들 대부분이","tags":["Agile","Coding","GLib","GTK+"],"title":"GObject 객체 지향 프로그래밍 (3)","type":"post"},{"authors":null,"categories":null,"content":"첫번째 글이 당연한 내용을 너무 길게 설명했다는 의견이 있어서, 이번 글부터는 더 짧고 간결하게 정리해 보려고 노력하고 있습니다. 그리고, 이 글의 대상은 한 번이라도 GTK+ / GLib 라이브러리를 사용한 경험이 있는 개발자입니다. 그래서 정말로 기초적인 내용은 피하고 있습니다.\n접근자 (Accessors)\n소프트웨어 공학에서 모듈이나 객체 설계시 기본적으로 강조하는 정보은닉(information hiding), 캡슐화(encapsulation), 결합도(coupling) 등과 같은 개념에 의하면, C 언어처럼 구조체의 필드 변수를 외부로 직접 공개하는 건 좋지 않다고 합니다. 그리고 대부분의 경우 직접 접근 방식보다 읽고 쓰는 접근자(accessors)를 제공하는 게 여러모로 좋다고 하지요. 물론 성능 문제로 직접 접근 방식을 고려해야 하는 경우도 있지만, 지금까지 경험에 비춰보면, 병목을 일으키는 부분은 프로파일러를 돌려서 정확하게 파악한 다음에 해결하는 게 대부분 좋기 때문에 처음부터 그럴 필요는 없을 것 같습니다.\n참고로 현재 개발 중인 GTK+ 3.0 에서도 기존에 공개되었던 변수들을 모조리 안으로 숨기고, GTK+ 2.x 어플리케이션의 이전(migration)을 위해 GSEAL() 매크로 를 2.14 버전부터 제공하고 있습니다.\n아무튼 그래서, 일단 지난 글에서 예제로 사용한 호스트 객체의 필드를 숨기고 접근 API를 구현해 보았습니다. (변경되거나 수정한 부분만 보여드립니다)\nedc-host.h\ntypedef struct _EdcHostClass EdcHostClass; typedef struct _EdcHost EdcHost; struct _EdcHost { GObject parent; }; struct _EdcHostClass { GObjectClass parent_class; }; GType edc_host_get_type (void) G_GNUC_CONST; EdcHost *edc_host_new (void); const gchar *edc_host_get_name (EdcHost *host); void edc_host_set_name (EdcHost *host, const gchar *name); const gchar *edc_host_get_address (EdcHost *host); void edc_host_set_address (EdcHost *host, const gchar *address); gint edc_host_get_port (EdcHost *host); void edc_host_set_port (EdcHost *host, gint port); const gchar *edc_host_get_user (EdcHost *host); void edc_host_set_user (EdcHost *host, const gchar *user); const gchar *edc_host_get_password (EdcHost *host); void edc_host_set_password (EdcHost *host, const gchar *password);  edc-host.c\n#include \u0026quot;edc-host.h\u0026quot; typedef struct _EdcHostPrivate EdcHostPrivate; struct _EdcHostPrivate { gchar *name; gchar *address; gint port; gchar *user; gchar *password; }; #define EDC_HOST_GET_PRIVATE(host) G_TYPE_INSTANCE_GET_PRIVATE (host, EDC_TYPE_HOST, EdcHostPrivate) G_DEFINE_TYPE (EdcHost, edc_host, G_TYPE_OBJECT); EdcHost * edc_host_new (void) { return EDC_HOST (g_object_new (EDC_TYPE_HOST, NULL)); } /* object initializer */ static void edc_host_init (EdcHost *host) { EdcHostPrivate *priv; priv = EDC_HOST_GET_PRIVATE (host); priv-\u0026gt;name = g_strdup (\u0026quot;\u0026quot;); priv-\u0026gt;address = g_strdup (\u0026quot;\u0026quot;); priv-\u0026gt;port = 0; priv-\u0026gt;user = g_strdup (\u0026quot;\u0026quot;); priv-\u0026gt;password = g_strdup (\u0026quot;\u0026quot;); } /* object finalizer */ static void edc_host_finalize (GObject *self) { EdcHost *host = EDC_HOST (self); EdcHostPrivate *priv; priv = EDC_HOST_GET_PRIVATE (host); g_free (priv-\u0026gt;name); g_free (priv-\u0026gt;address); g_free (priv-\u0026gt;user); g_free (priv-\u0026gt;password); /* call our parent method (always do this!) */ G_OBJECT_CLASS (edc_host_parent_class)-\u0026gt;finalize (self); } /* class initializer */ static void edc_host_class_init (EdcHostClass *klass) { GObjectClass *gobj_class; gobj_class = G_OBJECT_CLASS (klass); gobj_class-\u0026gt;finalize = edc_host_finalize; g_type_class_add_private (gobj_class, sizeof (EdcHostPrivate)); } const gchar * edc_host_get_name (EdcHost *host) { EdcHostPrivate *priv; g_return_val_if_fail (EDC_IS_HOST (host), NULL); priv = EDC_HOST_GET_PRIVATE (host); return priv-\u0026gt;name; } void edc_host_set_name (EdcHost *host, const gchar *name) { EdcHostPrivate *priv; g_return_if_fail (EDC_IS_HOST (host)); g_return_if_fail (name != NULL); priv = EDC_HOST_GET_PRIVATE (host); g_free (priv-\u0026gt;name); priv-\u0026gt;name = g_strdup (name); }  먼저 헤더 파일을 보면, EdcHost 구조체에서 공개되었던 객체 변수가 모두 사라지고, 대신 edc_host_{get,set}_*() 형태의 API 선언이 추가되었습니다. 소스 파일에는 새로 EdcHostPrivate 구조체를 정의하고 모든 비공개 변수를 집어 넣은 뒤, 클래스 초기화 함수[edc_host_class_init ()] 마지막 부분에서 이 크기만큼의 공간을 확보하도록 합니다.[ g_type_class_add_private() ] 그리고 모든 함수에서 이 구조체를 쉽게 얻어오기 위해 정의한 EDC_HOST_GET_PRIVATE() 매크로를 사용해 필요한 작업을 수행합니다.\n부가적으로 조금만 더 설명하면, 모든 문자열을 넘겨주는 API는 문자열을 복사해서 넘겨주어 원본 문자열을 보호합니다. 따라서 API 문서에 넘겨받은 문자열을 반드시 해제하라고 명시되어 있어야 하겠죠. 또한 지난 글에서 잠시 언급한 것처럼, 공개된 함수 진입 시점에서 인수 적합성 검사를 할때 EDC_IS_HOST() 매크로를 사용해 NULL 여부 뿐 아니라 정확하게 해당 객체인지 검사하도록 합니다.\n참고로 위 예제에서 비공개(private) 객체에 접근하는 방법은 설명을 위해 오버헤드가 존재하는 단순한 방식입니다. 따라서 실제로 사용하려면 반드시 이 포스트 를 참고하시기 바랍니다.\n이렇게 해서 기본적인 객체 속성에 대한 접근자를 구현했습니다. 물론 이게 다는 아니고, 다음에 설명할 GObject 속성(properties) 기능을 이용하면 사실 접근자를 구현할 필요도 없습니다. 하지만, GTK+와 같은 대부분의 GObject 기반 객체는 함수 API 기반의 접근자를 동시에 제공하고 있으므로 관례를 따르는 게 나쁘지는 않겠지요.\n글머리에서 언급했듯이, 계속 적다 보면 내용도 길어지고 포스팅 주기도 길어질 것 같아 오늘은 일단 여기까지만 적습니다. 다음에는 본격적으로 GObject 속성(properties)을 추가할 예정인데, 설명할 게 많아서\u0026hellip; ;)\n","date":1250208000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1250208000,"objectID":"ad2a09436550e359d70b6ba7e5890b93","permalink":"https://lethean.github.io/2009/08/14/oop-with-gobject-2/","publishdate":"2009-08-14T00:00:00Z","relpermalink":"/2009/08/14/oop-with-gobject-2/","section":"post","summary":"첫번째 글이 당연한 내용을 너무 길게 설명했다는 의견이 있어서, 이번 글부터는 더 짧고 간결하게 정리해 보려고 노력하고 있습니다. 그리고, 이 글의 대상은 한 번이라도","tags":["Agile","Coding","GLib","GTK+"],"title":"GObject 객체 지향 프로그래밍 (2)","type":"post"},{"authors":null,"categories":null,"content":"이더넷 랜카드를 교체하거나, 온보드 이더넷을 CMOS에서 비활성화하고 랜카드만 사용하고 싶거나 또는 그 반대인 경우, 우분투에서 사용하는 udev 데몬은 자동으로 새로 인식한 이더넷 장치에게는 기존 이더넷 장치와 충돌하지 않도록 새로운 이더넷 번호를 할당하고 기억합니다. 예를 들면, eth0 장치가 없는데도, eth0 대신 eth1 장치로 인식하게 됩니다.\n이는 장치마다 다른 설정을 장비 구성이 달라지더라도 고유하게 계속 유지할 수 있도록 하기 위함인데, 때로는 거슬리기도 하고, 당연히 eth0 장치가 있다고 가정하고 동작하는 프로그램이 있는 경우 골치 아파집니다.\n이럴 때 쉽게 해결하는 방법은, 다음과 같이 이 정보를 기억하고 있는 파일을 지우고 재부팅하면 됩니다.\n$ sudo rm /etc/udev/rules.d/70-persistent-net.rules  참고로 CDROM 관련 설정도 있는데, 타이핑이 귀찮을 경우 다음과 같이 해도 됩니다.\n$ sudo rm /etc/udev/rules.d/*  왜냐하면 건드리면 피곤해지는 udev 기본 설정 파일은 /lib/udev/rules.d/ 디렉토리에 따로 저장되기 때문입니다.\n","date":1250208000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1250208000,"objectID":"d91ac0253a302dc981036b430cf3230e","permalink":"https://lethean.github.io/2009/08/14/init-eth-dev-number-when-lan-card-changes-in-ubuntu/","publishdate":"2009-08-14T00:00:00Z","relpermalink":"/2009/08/14/init-eth-dev-number-when-lan-card-changes-in-ubuntu/","section":"post","summary":"이더넷 랜카드를 교체하거나, 온보드 이더넷을 CMOS에서 비활성화하고 랜카드만 사용하고 싶거나 또는 그 반대인 경우, 우분투에서 사용하는 udev 데몬은 자동으로 새","tags":["Linux","Network","Ubuntu","Udev"],"title":"우분투에서 이더넷 장치 변경시 장치번호 초기화","type":"post"},{"authors":null,"categories":null,"content":"GTK+, Clutter 등과 같은 라이브러리는 C 언어로 구현되었지만 객체 지향 개념을 충실히 따르고 있는데, 그 중심에는 GLib 라이브러리의 GObject가 있습니다. 따라서 이러한 라이브러리를 제대로 이해하고 사용하려면 필수적으로 GObject 개념을 잘 이해하고 있어야 합니다. 그런데, 생각보다 GObject 개념은 이해하기 어렵습니다. 이해하더라도 이를 응용하려면 그만큼 시간이 또 필요합니다.\n그래서 이번 글을 시작으로 GObject 라이브러리를 이용한 C 언어에서 객체 지향 프로그래밍이라는 거창한 주제를 예제 형식을 이용해 다루어 보려고 합니다. 바로 새 GTK+ 위젯을 구현하거나 클러터 객체를 분석하는 방식이 아니라 왜 GObject가 이런 방식으로 설계되었는지 그 철학을 따라가 보려고 합니다. 그리고, 가능한 기존 GObject 튜토리얼의 어려운 설명이 아니라 실제 사용하는 코드를 중심으로 설명할 예정이니, 그래도 무슨 말인지 모르겠거나 더 풀어서 설명을 하는 게 좋을 것 같을 경우 의견 주시기 바랍니다.\n여기서 예제로 사용할 개념은 네트워크 카메라 호스트와 호스트 목록입니다. (하는 일이 이쪽 분야라서\u0026hellip; :)\n네트워크 카메라 호스트는 이름(name), 주소(address), 포트번호(port), 사용자(user), 비밀번호(password) 등과 같은 항목을 포함합니다. 필요한 함수로는 새 객체를 만들거나 해제, 그리고 각 필드값을 얻어오거나 변경하는 정도입니다. (아마도 나중에는 값이 변경되면 자동으로 호출되는 콜백 함수도 추가할 겁니다)\n모든 코드는 GLib API를 이용하여 작성합니다.\n**객체 (Objects) + 참조 카운터 (Reference Counter) **\n소프트웨어 공학자들이 객체라고 부르기 전부터 C 언어에는 구조체(struct)가 있었습니다. GObject 시스템 역시 기본 바탕은 구조체입니다. 그러면 GObject 프로그래밍을 하기 전에, 일반 C 언어 구조체를 이용해 네트워크 카메라 호스트를 정의하면, 다음과 같은 코드가 나오지 않을까요?\ntypedef struct _EdcHost EdcHost; struct _EdcHost { gchar *name; gchar *address; gint port; gchar *user; gchar *password; };  만일 상속이나 함수 오버로딩(overloading)을 전혀 사용하지 않는다면, 굳이 새로운 함수를 추가할 필요를 못 느끼는 분들이 많을 겁니다. 왜냐하면, 직접 구조체 크기만큼 메모리를 할당한 뒤 해제하고, 직접 모든 필드를 접근하면 되니까요. 하지만, 할당하고 해제하는 코드가 여러 곳에 분산되어 있다면 디버깅도 힘들고 유지 보수도 힘드니까 최소한 객체를 생성하고 해제하는 함수만이라도 만들어 봅시다.\nEdcHost * edc_host_new (void) { EdcHost *host; host = g_new0 (EdcHost, 1); return host; } void edc_host_destroy (EdcHost *host) { g_return_if_fail (host != NULL); g_free (host-\u0026gt;name); g_free (host-\u0026gt;address); g_free (host-\u0026gt;user); g_free (host-\u0026gt;password); g_free (host); }  간단한 코드라서 설명할 필요는 없을 것 같습니다. 참고로 g_free() 함수는 인수가 NULL일 경우 무시하므로 NULL 검사 코드는 필요없습니다.\n그런데, 이 객체는 단순히 목록 관리 뿐 아니라 여러 다른 모듈에서도 사용할 예정입니다. 여기서 갑자기, 모든 모듈이 하나의 객체를 공유하고 싶은 욕망이 꿈틀대기 시작합니다. 모듈 간에 객체를 전달할때 복사할 필요도 없고, 모듈 별로 객체를 따로 만들어 정보를 보관하는 것보다 메모리를 절약할 수 있으며, 필드 하나가 변경되었을 경우 그 정보를 모든 관련 객체에 반영할 수고도 덜 수 있기 때문입니다. 그렇다고 무턱대고 모든 모듈에서 객체 주소(pointer)만 참조하게 하면 객체를 어느 시점에 할당하고 해제해야 하는지 매우 까다로워집니다. 특히 동적으로 임시 객체를 생성해 다른 모듈에게 넘겨주는 경우라면, 객체를 어느 시점에서 해제해야 하는지도 실수하기 딱 좋습니다. 더 나아가 멀티 쓰레드 환경까지 고려한다면, 단순히 포인터만 가리키는 방식은, 아마추어나 사용하는 옛날 UML 클래스 빌더가 자동으로 생성해주는 코드만으로는, 힘들 수 밖에 없습니다.\n이런 경우 자주 사용하는 방식이 참조 카운터(reference counter) 기법입니다. 짧게 설명하자면, 모든 모듈에서 몇 가지 원칙만 지키면 됩니다. 첫번째 원칙은, 객체(메모리)를 할당한 모듈에서 반드시 해제하기입니다. 두번째는, 모듈 관점에서 내가 필요한 시점부터 객체의 참조 카운터를 증가하고, 더이상 사용하지 않으면 객체의 참조 카운터를 감소합니다. 새로 생성된 객체는 참조 카운터 값이 1이고, 참조 카운터가 감소되어 0이 되면 객체는 자동으로 해제됩니다. 참고로, 참조 카운터 기법은 멀티미디어 프레임 버퍼, 네트워크 패킷 등과 같은 버퍼 관리에도 널리 사용하는 것은 물론, 오브젝티브-C 언어(Objective-C)의 NSObject 객체가 기본적으로 제공하는 기능이기도 합니다.\n자 이제, 호스트 객체를 참조 카운터 기법을 적용해 수정해 보면 다음과 같습니다.\nedc-host.h\n#ifndef __EDC_HOST_H__ #define __EDC_HOST_H__ #include \u0026lt;glib.h\u0026gt; #ifdef __cplusplus extern \u0026quot;C\u0026quot; { #endif typedef struct _EdcHost EdcHost; struct _EdcHost { gchar *name; gchar *address; gint port; gchar *user; gchar *password; gint ref_count; }; EdcHost *edc_host_new (void); EdcHost *edc_host_ref (EdcHost *host); void edc_host_unref (EdcHost *host); #ifdef __cplusplus } #endif #endif /* __EDC_HOST_H__ */  edc-host.c\n#include \u0026quot;edc-host.h\u0026quot; EdcHost * edc_host_new (void) { EdcHost *host; host = g_new0 (EdcHost, 1); if (!host) return NULL; host-\u0026gt;ref_count = 1; return host; } static void edc_host_destroy (EdcHost *host) { g_return_if_fail (host != NULL); g_free (host-\u0026gt;name); g_free (host-\u0026gt;address); g_free (host-\u0026gt;user); g_free (host-\u0026gt;password); g_free (host); } EdcHost * edc_host_ref (EdcHost *host) { g_return_val_if_fail (host != NULL, NULL); g_atomic_int_inc (\u0026amp;host-\u0026gt;ref_count); return host; } void edc_host_unref (EdcHost *host) { g_return_if_fail (host != NULL); if (g_atomic_int_dec_and_test (\u0026amp;host-\u0026gt;ref_count)) edc_host_destroy (host); }  제일 먼저 설명할 부분은 역시 g_atomic_int_inc() / g_atomic_int_dec_and_test() 함수입니다. 멀티 쓰레드에서 안전하게 카운터 변수를 증가하고 감소할 수 있게 도와주는 GLib API입니다. 이를 이용해 위에서 설명한 참조 카운터 개념을 구현하고 있습니다. 공개했던 edc_host_destroy() 함수는 모듈 내부에서만 접근할 수 있도록 static 키워드를 붙였습니다. 또한 C++ 소스에서 포함(include)할때 문제를 일으키지 않도록 헤더파일에 \u0026lsquo;extern \u0026quot;c\u0026quot; {}\u0026rsquo; 키워드도 추가했습니다.\n그런데 참조 카운터가 필요한 객체마다 이렇게 구현하면 비슷한 작업을 하는 코드가 중복될 수 밖에 없습니다. 이를 일반적인 API로 분리해 다시 구현하면 재활용이 가능할테니, 다음과 같이 수정해 보겠습니다.\nedc-object.h\n#ifndef __EDC_OBJECT_H__ #define __EDC_OBJECT_H__ #include \u0026lt;glib.h\u0026gt; #ifdef __cplusplus extern \u0026quot;C\u0026quot; { #endif typedef struct _EdcObject EdcObject; struct _EdcObject { gint ref_count; GDestroyNotify finalize; }; static inline gpointer edc_object_alloc (GDestroyNotify finalize, gint obj_size) { EdcObject *obj; obj = g_malloc (obj_size); if (!obj) return NULL; obj-\u0026gt;ref_count = 1; obj-\u0026gt;finalize = finalize; return obj; } static inline gpointer edc_object_ref (gpointer obj) { EdcObject *object = obj; if (object) g_atomic_int_inc (\u0026amp;object-\u0026gt;ref_count); return object; } static inline void edc_object_unref (gpointer obj) { EdcObject *object = obj; if (!obj) return; if (g_atomic_int_dec_and_test (\u0026amp;object-\u0026gt;ref_count)) { if (object-\u0026gt;finalize) object-\u0026gt;finalize (object); g_free (object); } } #ifdef __cplusplus } #endif #endif /* __EDC_OBJECT_H__ */  edc-host.h\n#ifndef __EDC_HOST_H__ #define __EDC_HOST_H__ #include \u0026quot;edc-object.h\u0026quot; #ifdef __cplusplus extern \u0026quot;C\u0026quot; { #endif typedef struct _EdcHost EdcHost; struct _EdcHost { EdcObject parent; gchar *name; gchar *address; gint port; gchar *user; gchar *password; }; EdcHost *edc_host_new (void); #ifdef __cplusplus } #endif #endif /* __EDC_HOST_H__ */  edc-host.c\n#include \u0026quot;edc-host.h\u0026quot; static void edc_host_finalize (gpointer obj) { EdcHost *host = obj; g_free (host-\u0026gt;name); g_free (host-\u0026gt;address); g_free (host-\u0026gt;user); g_free (host-\u0026gt;password); } EdcHost * edc_host_new (void) { EdcHost *host; host = edc_object_alloc (edc_host_finalize, sizeof (EdcHost)); if (!host) return NULL; host-\u0026gt;name = NULL; host-\u0026gt;address = NULL; host-\u0026gt;user = NULL; host-\u0026gt;password = NULL; return host; }  객체 지향 상속(또는 파생 객체)을 C 언어로 구현하는 가장 쉬운 방법은 위 코드에서 보는 것처럼 부모(또는 원본 객체)를 구조체 맨 앞에 두는 겁니다. 그러면 부모와 자식 API 모두 사용할 수 있게 되죠. 위 코드의 경우 개념상으로 보면 EdcObject 객체를 상속 받아 EdcHost 객체를 구현한 셈이 되죠. 따라서 다음과 같이 사용할 수 있습니다.\nvoid func_a (EdcHost *host) { edc_object_ref (host); // do some stuff for long time... edc_object_unref (host); } { EdcHost *host; host = edc_host_new (); ... func_a (host); ... edc_object_unref (host); /* destroy */ }  참고로 C 언어에서 `void *' 형은 어떤 포인터와도 양방향 대입(assignment)을 할 수 있으므로 컴파일 경고를 피하기 위해 불필요한 형변환을 할 필요가 없습니다. ( gpointer / GDestroyNotify API도 설명도 확인해 보시기 바랍니다)\n이제 지금까지 구현한 부분을 GObject 객체 기반으로 옮겨 봅니다. 자세히 보시면, 지금까지 프로그래밍한 내용과 거의 비슷한 점을 알아챌 수 있을 겁니다.\nedc-host.h\n#ifndef __EDC_HOST_H__ #define __EDC_HOST_H__ #include \u0026lt;glib-object.h\u0026gt; G_BEGIN_DECLS #define EDC_TYPE_HOST (edc_host_get_type ()) #define EDC_HOST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), EDC_TYPE_HOST, EdcHost)) #define EDC_HOST_CLASS(obj) (G_TYPE_CHECK_CLASS_CAST ((obj), EDC_TYPE_HOST, EdcHostClass)) #define EDC_IS_HOST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), EDC_TYPE_HOST)) #define EDC_IS_HOST_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE ((obj), EDC_TYPE_HOST)) #define EDC_GET_HOST_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), EDC_TYPE_HOST, EdcHostClass)) typedef struct _EdcHostClass EdcHostClass; typedef struct _EdcHost EdcHost; struct _EdcHost { GObject parent; gchar *name; gchar *address; gint port; gchar *user; gchar *password; }; struct _EdcHostClass { GObjectClass parent_class; }; GType edc_host_get_type (void) G_GNUC_CONST; EdcHost *edc_host_new (void); G_END_DECLS #endif /* __EDC_HOST_H__ */  edc-host.c\n#include \u0026quot;edc-host.h\u0026quot; G_DEFINE_TYPE (EdcHost, edc_host, G_TYPE_OBJECT); EdcHost * edc_host_new (void) { return EDC_HOST (g_object_new (EDC_TYPE_HOST, NULL)); } /* object initializer */ static void edc_host_init (EdcHost *host) { host-\u0026gt;name = NULL; host-\u0026gt;address = NULL; host-\u0026gt;port = 0; host-\u0026gt;user = NULL; host-\u0026gt;password = NULL; } /* object finalizer */ static void edc_host_finalize (GObject *self) { EdcHost *host = EDC_HOST (self); g_free (host-\u0026gt;name); g_free (host-\u0026gt;address); g_free (host-\u0026gt;user); g_free (host-\u0026gt;password); /* call our parent method (always do this!) */ G_OBJECT_CLASS (edc_host_parent_class)-\u0026gt;finalize (self); } /* class initializer */ static void edc_host_class_init (EdcHostClass *klass) { GObjectClass *gobject_class; gobject_class = G_OBJECT_CLASS (klass); gobject_class-\u0026gt;finalize = edc_host_finalize; }  갑자기 코드량이 증가했다고 놀랄 필요는 없습니다. 뭐든지 다 그렇지만, 알고 보면 별 거 아닙니다.\n먼저 헤더 파일을 설명하면, GObject 객체를 사용하기 위해 glib-object.h 파일을 포함했습니다. 이는 EdcHost 객체가 GObject 객체만 사용하기 때문에, 더 정확히는 GObject의 파생 객체(derived objects), 다른 말로는 GObject 객체만 상속(inheritance)하기 때문에 그렇습니다. 만일 다른 객체에서 파생한다면 그 객체를 정의하는 헤더 파일을 포함해야 합니다. \u0026lsquo;extern \u0026quot;c\u0026quot; {}\u0026rsquo; 키워드는 GLib의 G_BEGIN_DECLS / G_END_DECLS API로 대체했습니다.\nEdcHost 인스턴스와 EdcHostClass 클래스를 정의하고 있는 부분을 설명하면, 클래스 객체는 전역으로 하나만 존재하고 그냥 객체는 인스턴스(instance) 역할을 합니다. 또한 여기서는 인스턴스 객체의 모든 필드가 공개되어 있지만, 물론 외부에 공개하지 않는(private) 필드를 정의할 수도 있습니다. (이는 다른 글에서 따로 설명하겠습니다)\n복잡해 보이는 몇몇 매크로는 자주 사용하는 긴 API를 간편화한 것입니다. 런타임 중에 인스턴스가 유효하고 EdcHost 객체로 형변환까지 해주거나[EDC_HOST(obj)], 인스턴스가 EdcHost 객체인지 확인하거나[EDC_IS_HOST(obj)], 인스턴스의 클래스 객체를 얻어오거나[EDC_GET_HOST_CLASS(obj)] 하는 등 일종의 RTTI 관련 매크로입니다. 아마 제일 많이 사용하는 매크로는 `EDC_HOST(obj)\u0026lsquo;일 겁니다.\n소스를 살펴 보면, 제일 먼저 나오는게 ` G_DEFINE_TYPE(TN, t_n, T_P) \u0026rsquo; 입니다. 여담이지만, 이 매크로가 추가되기 전에 작성한 GObject 기반 코드는 귀찮은 작업을 많이 해야 했는데, 이 매크로가 자동으로 해주는 기능이 많아서 불필요하게 중복되는 코드가 많이 줄어들었습니다. 그래서 GTK+ 소스 코드 중에도 가끔 그렇게 작성한 코드도 있고, GObject 관련 초기 문서를 보면 이 매크로를 사용하지 않고 구현되어 있는 경우도 있습니다.\n이 매크로가 하는 일은 다음과 같습니다. 지정한 `t_n` 이름으로 시작하는 클래스 초기화 함수[*_class_init()] / 인스턴스 초기화 함수[*_init()] 모두 구현되어 있다고 가정하고 `*_get_type()' 함수를 자동으로 삽입해 줍니다. 더불어 부모 클래스 객체를 가리키는 `*_parent_class' 전역 변수도 만들어 줍니다. 따라서 프로그래머는 최소한 함수 두 개만 구현해 주면 되는 셈입니다. [edc_host_init() / edc_host_class_init()]\n하지만 위 예제에서는 클래스 초기화 함수에서 인스턴스 객체가 해제될때 호출되는 finalize 함수를 교체하고 있습니다. 이를 통해 객체가 해제될때 사용하던 리소스를 해제해 줍니다. 그리고, 반드시 상위 클래스의 finalize 함수를 호출해 주어야 정상적으로 부모 객체의 해제 함수가 차례대로 호출될 수 있습니다.\n자 이제 GObject의 핵심 기능 중 하나인 객체 참조 카운터(object reference counter) 기능을 쉽게 이용할 수 있습니다. 이렇게 작성한 객체는 g_object_ref() / g_object_unref() 함수 등을 이용해 참조 카운터를 제어할 수 있습니다. GObject 소스 코드를 확인해 보시면 알겠지만, 실제 객체 참조 카운터 기능은 거의 비슷하게 구현되어 있습니다. 더 많은 경우의 수를 고려하고 더 많은 기능을 제공하다보니 코드가 더 복잡한 것 뿐입니다.\n더 중요한 점은 모든 GObject 기반 객체, 예를 들어 GTK+ 위젯이나 클러터 객체 모두 GObject 기반이기 때문에 객체간 연결(부모-자식, 컨테이너-아이템 등)시 객체에 대한 포인터를 유지하면서 동시에 참조 카운터를 유지하여 메모리를 관리한다는 점입니다. 이 부분에 대한 더 자세한 설명은 GTK+ 메모리 관리 글에서 확인하시기 바랍니다.\n오늘은 일단 여기까지만\u0026hellip; ;)\n","date":1249862400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1249862400,"objectID":"4961fa2acc7b385a73e95e2df32bead7","permalink":"https://lethean.github.io/2009/08/10/oop-with-gobject-1/","publishdate":"2009-08-10T00:00:00Z","relpermalink":"/2009/08/10/oop-with-gobject-1/","section":"post","summary":"GTK+, Clutter 등과 같은 라이브러리는 C 언어로 구현되었지만 객체 지향 개념을 충실히 따르고 있는데, 그 중심에는 GLib 라이브러리의 GObject가 있습니다. 따라서 이러한","tags":["Agile","Coding","GLib","GTK+"],"title":"GObject 객체 지향 프로그래밍 (1)","type":"post"},{"authors":null,"categories":null,"content":" 2009 GCDS / GUADEC 발표 슬라이드가 공개 되었는데, 그 중에서 관심이 가는 발표 자료 두 개를 정리해 보았습니다. 하지만, 발표자료인만큼 가능하면 직접 보시는게 더 효과적일 것 같습니다. 두 발표 모두 캐노니컬(Canonical) 소속 Matthew Paul Thomas 의 발표자료이면서 내용이 중복됩니다.\n사용자 테스트 과정에서 중요한 점은, 절대로 사용자가 하는 말을 듣고 그대로 하면 안된다는 점입니다. 대신 사용자가 어떻게 무엇을 하는지 관찰하고 분석하는게 중요합니다. 사람은 대개 자신이 생각하는 것과 말하는 것, 실제로 하는 게 다르기 때문에 사람의 말에 근거를 두면 안됩니다. 또한 특정한 한 사람의 경험만 고려해도 안됩니다.\n어찌되었든, 캐노니컬에서는 여러가지 방법으로 사용자 테스트를 진행하는데 , 이를 통해 얻은 여러가지 교훈은 다음과 같습니다.\n 제일 먼저 언급하는 게 소프트웨어 이름을 지을때 잘 지으라는 얘기입니다. 가능하면 소프트웨어가 목표로 하는 기능이나 동작을 이름에 포함하는 방식이 일반 사용자에게 더 잘 어필할 수 있다고 합니다. 자주 사용하는 전문가가 아닌 처음 사용하는 사용자를 배려한 마법사, 친절한 설명 등이 중요합니다. 왜냐하면 대부분의 사용자는 첫인상을 통해 소프트웨어를 계속 사용할 지 여부를 결정하는 경우가 많기 때문입니다. 처음 실행되었을 때 적절하게 모든 인터페이스가 표시될 수 있도록 윈도우 기본 크기를 적절하게 설정해 주는 것도 중요합니다. 또한 800x600 화면 크기를 가지는 넷북같은 장비가 많이지는 만큼 불필요하게 윈도우를 크게 하지 않아야 합니다. 당연한 얘기같지만, 윈도우 제목(title)에 표시되는 내용을 윈도우 안에서 중복 표현하면서 불필요하게 공간을 차지하지 않는 것이 좋습니다. 오류가 발생했을 경우 개발자에게만 유용한 메시지를 보여주고 끝내는 것보다 사용자 관점에서 어떻게 해야 이를 해결할 수 있는 지 대안을 제시해 주는 것도 필요합니다. 더불어 불필요한 공백을 남발하는 것도 피해야 합니다. 다이얼로그에서 사용자가 엔터(Enter)키나 이스케이프(Escape)키를 눌렀을 경우 원하는 동작을 할 수 있도록 세심한 배려도 필요합니다. 물론 사용자가 옵션을 검토하지 않은 채 눌렀을 경우를 의도록적으로 막아야 하는 경우는 제외합니다. 마지막으로, 개발자끼리만 통하는 용어로 일반 사용자를 겁주거나 거짓말하지 않는 것이 중요합니다. 가능한 일반인에게 친화적인 단어를 선택하고 사용자가 익숙한 개념의 단어를 사용하는게 좋습니다.  ","date":1249257600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1249257600,"objectID":"ef8b71de110a6dd87ed32d91ca1ef1e8","permalink":"https://lethean.github.io/2009/08/03/avoid-common-user-interface-bloopers/","publishdate":"2009-08-03T00:00:00Z","relpermalink":"/2009/08/03/avoid-common-user-interface-bloopers/","section":"post","summary":"2009 GCDS / GUADEC 발표 슬라이드가 공개 되었는데, 그 중에서 관심이 가는 발표 자료 두 개를 정리해 보았습니다. 하지만, 발표자료인만큼 가능하면 직접 보시는게 더 효과적일 것","tags":["GNOME","GUI"],"title":"사용자 인터페이스 실수 줄이기","type":"post"},{"authors":null,"categories":null,"content":" 구글 크롬(Google Chrome) 의 리눅스 버전 오픈소스 프로젝트인 크로미엄(Chromium)을 우분투에 설치하고 사용하고 있습니다. 이 사이트 에서 설명한 방법을 따라 쉽게 저장소를 추가하고 자동으로 일일 업데이트가 가능하도록 했는데, 저는 karmic 개발 버전을 사용하고 있으므로, 저장소 경로에서 \u0026lsquo;jaunty\u0026rsquo; 대신 \u0026lsquo;karmic\u0026rsquo;을 사용했습니다.\n물론 크로미엄을 예전에도 사용해 보았지만, 불안정하고 아직 많은 기능이 구현되지 않았던 시절이라 한동안 사용을 미루어 두었는데, 최근 개발 관련 소식이 많이 보이길래 한 번 다시 설치해 본 건데, 안정성은 물론 체감 성능이 매우 쾌적해졌군요. 이를 느낄 수 있는 것 중 하나가 바로, 제가 사용하는 장비 중 하나인 IBM ThinkPad X40에서 워드프레스 에디터 비주얼(Visual) 방식으로 글을 적는데 아무 불편함이 없습니다. 파이어폭스 3.5 버전과 비교해도 역시 전반적인 체감 속도가 훨씬 빠르게 느껴집니다. 인텔 드라이버 성능이 개선된 것 또는 Compiz 사용 여부와는 상관없이 상대적으로 체감 속도는 빠릅니다. 게다가 작은 노트북 화면을 충분히 사용할 수 있도록 배려한 UI도 맘에 들고\u0026hellip; (메모리 사용량은 아직 어떻게 비교해야할 지 모르겠군요. 크로미엄은 워낙 여러 프로세스가 사용되기 때문에\u0026hellip;)\n그래서 낼름 기본 브라우저를 크로미엄으로 변경하고, 가끔 테스트하고 사용해보던 웹킷 기반 브라우저 패키지도 다 지우고(epiphany-browser, midori, arora) 이것 저것 익숙해져 가고 있는데, 뉴스에서 본 것처럼 플래시 같은 플러그인이 지원되긴 하지만 아직 불안정해서 기본으로 꺼져 있군요. 하지만 뭐, 플래시가 필요한 사이트를 자주 접속하면 편이 아니라서\u0026hellip; :)\n아무튼, 윈도우에서 인터넷 익스플로러가 거의 독점이었듯이 오랬동안 리눅스에서, 어쩔수없이, 독점이었던 파이어폭스를 아쉬워하면서 계속 사용할 이유가 점점 사라져 가는 듯한 느낌이 드는군요.\n","date":1249257600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1249257600,"objectID":"eba08d1dd837520d3700f911eb0e2a78","permalink":"https://lethean.github.io/2009/08/03/chromium-browser-in-ubuntu/","publishdate":"2009-08-03T00:00:00Z","relpermalink":"/2009/08/03/chromium-browser-in-ubuntu/","section":"post","summary":"구글 크롬(Google Chrome) 의 리눅스 버전 오픈소스 프로젝트인 크로미엄(Chromium)을 우분투에 설치하고 사용하고 있습니다. 이 사이트 에서 설명한 방법","tags":["Chromium","Ubuntu"],"title":"우분투 구글 크롬 브라우저","type":"post"},{"authors":null,"categories":null,"content":" 클러터 1.0 버전이 릴리스 된지 한참 되었습니다\u0026hellip;:) 몇몇 GLES 플랫폼에서 동작하지 않는다는 보고도 있고, clutter-gst / clutter-gtk 같은 라이브러리는 지금도 동작은 하지만 의존하는 다른 프로젝트 진행상황과 맞물린 관계로 완전히 마무리된 1.0 버전은 조금 지연 된다는 말도 있고 하지만, 1.0 정식 버전은 매우 많은 성능 개선과 API가 추가되었습니다.\n이 글에서는 1.0 API 변경 내용 중에 우선 애니메이션 관련 내용 을 정리해 보았습니다.\n0.8 버전까지 간단한 일회성 애니메이션 효과를 구현하기 위해 사용하던 ClutterEffect API가 사라지고 clutter_actor_animate() 함수로 완전히 교체되었습니다. 물론 복잡한 애니메이션에는 여전히 ClutterBehaviour / ClutterTimeline / ClutterScore 등과 같은 객체를 사용해야 하지만, 단순한 효과를 위해 복잡하게 ClutterEffectTemplate 객체를 만들어 사용하던 방식이 완전히 바뀐 셈입니다.\nclutter_actor_animate() 함수의 원형(prototype)을 보면 다음과 같습니다.\nClutterAnimation * clutter_actor_animate (ClutterActor *actor, gulong mode, guint duration, const gchar *first_property_name, ...);  인수를 살펴보면, 액터(actor)에 대해 애니메이션 모드 (mode)와 기간(duration)을 지정한 뒤 변화시킬 속성(properties) 목록과 목표값을 원하는만큼 지정하면 됩니다. 이 함수가 돌려주는 ClutterAnimation 객체는 애니메이션이 끝나면 \u0026ldquo;completed\u0026rdquo; 시그널을 발생하고 자동으로 소멸됩니다. 물론 단순한 애니메이션 뿐 아니라 기존 ClutterTimeline / ClutterAlpha 객체와 연동하여 더 다양하고 정교한 제어도 가능합니다.\n예를 들어 다음 코드는 250 밀리초 동안 \u0026lsquo;rectangle\u0026rsquo; 액터의 크기(width*height)를 현재 크기에서 100*100 크기로 변경하면서 투명도를 0으로 서서히 변경합니다.\nclutter_actor_animate (rectangle, CLUTTER_LINEAR, 250, \u0026quot;width\u0026quot;, 100.0, \u0026quot;height\u0026quot;, 100.0, \u0026quot;opacity\u0026quot;, 0, NULL);  액터의 속성(properties)을 변경하지 않고 애니메이션 동안 특정값으로 고정시킬 수도 있습니다. 다음 예제는 애니메이션 기간 동안 \u0026ldquo;rotation-angle-z\u0026rdquo; 속성을 현재 각도에서 360도로 변경하지만, \u0026ldquo;rotation-center-z\u0026rdquo; 속성은 고정된 \u0026ldquo;center\u0026rdquo; 변수값으로 고정합니다.\nclutter_actor_animate (actor, CLUTTER_EASE_IN, 100, \u0026quot;rotation-angle-z\u0026quot;, 360, \u0026quot;fixed::rotation-center-z\u0026quot;, \u0026amp;center, NULL);  단순히 액터의 속성을 변경하는 것 뿐 아니라 ClutterAnimation 객체의 시그널 핸들러를 직접 연결할 수도 있습니다. 다음 예제는 투명도가 0이 되어 애니메이션이 완료되면 자동으로 액터를 안보이게 합니다.\nstatic void on_animation_completed (ClutterAnimation *animation, ClutterActor *actor) { clutter_actor_hide (actor); } clutter_actor_animate (actor, CLUTTER_EASE_IN, 100, \u0026quot;opacity\u0026quot;, 0, \u0026quot;signal::completed\u0026quot;, on_animation_completed, actor, NULL);  또는 다음과 같이 사용할 수도 있습니다.\nstatic void on_animation_completed (ClutterActor *actor, gpointer data) { clutter_actor_hide (actor); } clutter_actor_animate (actor, CLUTTER_EASE_IN, 100, \u0026quot;opacity\u0026quot;, 0, \u0026quot;signal-swapped::completed\u0026quot;, on_animation_completed, actor, NULL);  지금까지 간단하게 설명했지만, 언제나 그렇듯이, 애니메이션 관련 API 종류와 동작 방식에 대한 더 세부적인 내용은 튜토리얼 과 참고 설명서 를 반드시 참고하시기 바랍니다.\n","date":1249257600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1249257600,"objectID":"4fc5b09e21af71f3e52f7bd1670f06a8","permalink":"https://lethean.github.io/2009/08/03/clutter-1-0-animation-api/","publishdate":"2009-08-03T00:00:00Z","relpermalink":"/2009/08/03/clutter-1-0-animation-api/","section":"post","summary":"클러터 1.0 버전이 릴리스 된지 한참 되었습니다\u0026hellip;:) 몇몇 GLES 플랫폼에서 동작하지 않는다는 보고도 있고, clutter-gst / clutter-gtk 같은 라이브러리는 지금도 동작은 하지","tags":["Clutter"],"title":"클러터 1.0 애니메이션 API","type":"post"},{"authors":null,"categories":null,"content":" 클러터 블로그 에 GUADEC 2009에서 발표한 클러터 관련 발표 자료가 공개되었습니다.\n클러터 1.0에 대한 간략한 소개와 더불어 향후 개발 방향에 대한 설명한 게 하나, 1.0에서 대폭 변경된 애니메이션 API를 이용해 더 복잡한 애니메이션을 만드는 기본적인 방법을 설명한 게 하나 있군요. 발표 자료까지 공개한 걸 보니, 이제 정말로 클러터 1.0 릴리스가 임박한 것 같습니다.\n여담이지만, GUI 라이브러리 개발자들이라서 그런지, 슬라이드 역시 그래픽컬(?)하고 아기자기한 인상을 주는군요. :)\n사족) 새벽 취중에 끄적였던 노랫말 가사 일부가 재수없으면 개정된 저작권법에 걸릴 수도 있지 않겠냐는 친구의 농담을 대낮에 듣고 덜컥 겁이 나는 바람에 결국 맘 편하게 지워버렸습니다\u0026hellip; :(\n","date":1248480000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1248480000,"objectID":"a935384bae1778208c7763bacf2de593","permalink":"https://lethean.github.io/2009/07/25/2009-guadec-clutter-slides/","publishdate":"2009-07-25T00:00:00Z","relpermalink":"/2009/07/25/2009-guadec-clutter-slides/","section":"post","summary":"클러터 블로그 에 GUADEC 2009에서 발표한 클러터 관련 발표 자료가 공개되었습니다. 클러터 1.0에 대한 간략한 소개와 더불어 향후 개발 방향에 대한 설명한 게 하나, 1","tags":["Clutter"],"title":"2009 GUADEC 클러터 발표 자료","type":"post"},{"authors":null,"categories":null,"content":"아이폰 3GS용으로 이런 어플리케이션도 있군요. \u0026lsquo;acrossair\u0026rsquo;의 \u0026lsquo; New York Nearest Subway \u0026lsquo;라는 어플리케이션인데, 기술과 아이디어가 절묘하게 결합한 멋진 작품인 것 같습니다.\n백문이불여일견, 동영상을 보시는게 빠를 것 같습니다.\n[youtube=http://www.youtube.com/watch?v=ps49T0iJwVg\u0026amp;w=425\u0026amp;h=344]\nhttp://www.youtube.com/watch?v=ps49T0iJwVg\n","date":1248307200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1248307200,"objectID":"400466cb2dc0bc8707b9531629f2717b","permalink":"https://lethean.github.io/2009/07/23/iphone-augmented-reality-application/","publishdate":"2009-07-23T00:00:00Z","relpermalink":"/2009/07/23/iphone-augmented-reality-application/","section":"post","summary":"아이폰 3GS용으로 이런 어플리케이션도 있군요. \u0026lsquo;acrossair\u0026rsquo;의 \u0026lsquo; New York Nearest Subway \u0026lsquo;라는 어플리케이션인데, 기","tags":["GUI","iPhone"],"title":"아이폰 증강 현실 어플리케이션","type":"post"},{"authors":null,"categories":null,"content":"지난 번에 공개한 Doxygen -\u0026gt; DocBook 변환기 doxy2dbook 프로그램의 업그레이드 버전입니다. 20090706 버전 이후 변경 사항은 다음과 같습니다.\n 함수 인수(parameters) 이름 줄맞춤 (indent) struct / enum 에 속성(attributes) 이름 줄맞춤 (indent) \u0026lsquo;inline\u0026rsquo; 함수 + \u0026lsquo;union\u0026rsquo; 형 문서화 지원 링크에 사용하는 ID를 doxygen ID가 아닌 읽기 쉬운 API 이름을 그대로 사용 \u0026lt;indexterm\u0026gt; 태그 추가 (DocBook 문서에 \u0026lsquo;\u0026lt;index/\u0026gt;\u0026rsquo; 태그를 넣으면 C/C++ API 색인이 자동으로 생성됨)  사용법은 안에 들어있는 README 파일을 참고하시기 바랍니다.\n이 프로그램은 업무상 회사에서 작성한 코드이기 때문에 저작권은 당연히 회사에게 있습니다. 라이센스는 GPL입니다.\n","date":1248048000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1248048000,"objectID":"e068192baa355634f8efc169dd6926b1","permalink":"https://lethean.github.io/2009/07/20/doxy2dbook/","publishdate":"2009-07-20T00:00:00Z","relpermalink":"/2009/07/20/doxy2dbook/","section":"post","summary":"지난 번에 공개한 Doxygen -\u0026gt; DocBook 변환기 doxy2dbook 프로그램의 업그레이드 버전입니다. 20090706 버전 이후 변경 사항은 다음과 같습니다. 함수 인수(parameters) 이름 줄맞춤 (indent)","tags":["DocBook","doxy2dbook","Doxygen"],"title":"doxy2dbook 업그레이드","type":"post"},{"authors":null,"categories":null,"content":"리눅스를 비롯한 유닉스 방식 운영체제에서 주기적인 작업을 수행하기 위해 cron 데몬을 많이 사용합니다. 루트 권한으로 시스템 관리에 필요한 작업을 예약할 수도 있지만, 일반 사용자 계정도 \u0026lsquo;crontab -e\u0026rsquo; 명령으로 작업 예약이 가능합니다. 현재 활발하게 개발 중인 프로젝트의 일일 빌드(daily build)를 위해 crontab 작업을 다음과 같이 예약했는데, 문제는 동일한 설정이 한 장비에서만 동작을 안한다는 점입니다. (dooly 계정으로 작업한다고 가정합니다)\n# m h dom mon dow command 0 23 * * * /home/dooly/build-cms.sh  빌드 스크립트(/home/dooly/build-cms.sh) 내용은 다음과 같습니다.\n#!/bin/sh cd /home/dooly/svn/dooly svn update \u0026amp;\u0026amp; sudo make install-depends \u0026amp;\u0026amp; make clean \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make packages \u0026amp;\u0026amp; make upload  인터넷을 찾아보니 다음과 같이 수정하여 로그 파일을 분석하라고 해서 따라해 보았습니다.\n# m h dom mon dow command * * * * * /home/dooly/build-cms.sh \u0026gt;\u0026gt; /home/dooly/cron.log 2\u0026gt;\u0026amp;1 * * * * * env \u0026gt; /home/dooly/env.log 2\u0026gt;\u0026amp;1  로그 파일을 분석하니, 환경 변수 LANG이 ko_KR.UTF-8 로 설정되지 않아서 서브버전 갱신(update) 도중 에러가 발생하고 있었습니다. 그래서 스크립트를 다음과 같이 수정해서 일단 문제는 해결했습니다.\n#!/bin/sh export LANG=ko_KR.UTF-8 cd /home/dooly/svn/dooly svn update \u0026amp;\u0026amp; sudo make install-depends \u0026amp;\u0026amp; make clean \u0026amp;\u0026amp; make \u0026amp;\u0026amp; make packages \u0026amp;\u0026amp; make upload  하지만 향후 문제 발생시 디버깅을 위해 다음과 같이 crontab 항목도 아예 변경해 두었습니다.\n# m h dom mon dow command 0 23 * * * /home/dooly/build-cms.sh \u0026gt; /home/dooly/cron.log 2\u0026gt;\u0026amp;1 #* * * * * env \u0026gt; /home/dooly/env.log 2\u0026gt;\u0026amp;1  물론, 자동으로 메일을 전송하도록 하거나 하는 다른 추가 기능도 가능하겠지만, 일단 이 정도 수준에서 만족하고 현재는 잘 동작하고 있습니다.\n","date":1247788800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1247788800,"objectID":"575bd1e53a3ff12ee8fc7b909668ae60","permalink":"https://lethean.github.io/2009/07/17/debugging-crontab-job-not-running/","publishdate":"2009-07-17T00:00:00Z","relpermalink":"/2009/07/17/debugging-crontab-job-not-running/","section":"post","summary":"리눅스를 비롯한 유닉스 방식 운영체제에서 주기적인 작업을 수행하기 위해 cron 데몬을 많이 사용합니다. 루트 권한으로 시스템 관리에 필요한 작업을 예약할 수도 있지만,","tags":["Agile","Linux","Shell"],"title":"실행 안되는 crontab 작업 디버깅하기","type":"post"},{"authors":null,"categories":null,"content":"회사에서 사용하는 버전 관리 시스템을 Git으로 이전하기 전에, 나중에 또 언젠가 다시 필요할 지 모르는 일이므로, 7년동안 운영해 왔던 Subversion 서버 구성과 운영 방식을 기록해 둡니다. 물론, 우분투 리눅스 환경이고 로컬 / 외부 네트웍 모두에서 svn.example.com 주소로 어디에서든 서브버전에 접근할 수 있도록 환경을 구성하는데 목적이 있습니다.\n제일 먼저 서브버전 패키지를 설치합니다.\n$ sudo apt-get install subversion  우분투처럼 데비안(Debian GNU/Linux) 기반 리눅스는 대부분 저장소(repository) 기본 디렉토리가 /var/lib/svn 디렉토리입니다. 배포판 규칙을 어기는게 괜히 꺼림칙하므로 이 디렉토리를 지우고 다른 디스크 또는 파티션에 있는 디렉토리를 심볼링 링크로 연결합니다. (여기서는 /opt/svn 입니다)\n$ sudo rm /var/lib/svn $ sudo ln -sf /opt/svn /var/lib/svn  HTTP 방식으로 서브버전을 운영하기 위해 설정합니다. 서브버전이 동작하는 서버는 외부 인터넷에 공개되지 않은 내부 서버입니다. 하지만 내부 서버는 아파치 뿌락찌(proxy) 기능을 이용해 외부에서도 접근 가능하도록 합니다.\n어쨌듯 아파치(Apache) 웹 서버에서 HTTP 방식으로 접근할 수 있도록 서브버전 아파치 모듈을 설치하고 활성화합니다.\n$ sudo apt-get install libapache2-svn $ sudo a2enmod dav_svn  서브버전 아파치 모듈 설정(/etc/apache2/mods-available/dav_svn.conf)을 다음과 같이 수정합니다.\n\u0026lt;Location /svn\u0026gt; DAV svn SVNParentPath /var/lib/svn AuthType Basic AuthName \u0026quot;Subverion Repositories\u0026quot; AuthUserFile /etc/subversion/dav_svn.passwd Require valid-user Order allow,deny Allow from all AuthzSVNAccessFile /etc/subversion/dav_svn.authz \u0026lt;/Location\u0026gt;  이 설정은 http://svn.example.com/svn/ URL을 시작으로 여러 서브버전 저장소를 두도록 합니다.\n이제 사용자 인증 관련 설정을 해야하는데 우선 /etc/subversion/dav_svn.authz 파일을 다음과 같이 설정합니다. 이 파일을 각 저장소별로 접근할 수 있는 사용자를 그룹지어 접근 권한을 제어하는데 사용합니다.\n# Groups configuration [groups] developers = lethean,user1,user2,user3 project1 = user1,user2 project2 = user2,user3 guests = guest # Repositories configuration [project1:/] @project1 = rw [project2:/] @developers = rw @project2 = r # All repositories [/] @developers = rw * =  이제 실제 사용자 목록을 담고 있는 /etc/subversion/dav_svn.passwd 파일을 만듭니다. 이 파일은 htpasswd 프로그램을 이용해 갱신하는데, 여기서는 \u0026lsquo;Basic\u0026rsquo; 인증 방식으로 사용하므로 \u0026lsquo;-m\u0026rsquo; 옵션을 추가해야 합니다.\n$ sudo touch /etc/subversion/dav_svn.passwd $ sudo htpasswd -m /etc/subversion/dav_svn.passwd lethean $ sudo htpasswd -m /etc/subversion/dav_svn.passwd user1  이제 사용자 관리와 웹서버 관련 설정은 끝났으니 서브버전 저장소 설정을 할 차례입니다.\n서브버전 저장소를 HTTP 웹 프로토콜을 통해 무리없이 접근하려면 먼저 사용자 권한을 수정해야 합니다. 우분투의 기본 웹서버 접근 계정은 www-data 이므로, 이를 src 그룹에 추가합니다.\n$ sudo addgroup www-data src  그리고 서브버전 저장소의 권한을 변경하여 src 그룹이 서브버전 저장소에 접근할 수 있도록 합니다.\n$ sudo chgrp -R src /var/lib/svn $ sudo chmod -R g+rws /var/lib/svn  아파치 웹서버를 재시작합니다.\n$ sudo /etc/init.d/apache2 restart  이제 서브버전 저장소를 설정합니다. 이 작업은 모든 저장소에 각각 해야 하므로 여기서는 \u0026lsquo;hello\u0026rsquo; 프로젝트라고 가정합니다. 제일 먼저 소스가 제출(commit)되었을때 메일이 발송되고, 버그질라(Bugzilla) 댓글(comments)에 자동으로 추가되도록 /var/lib/svn/hello/hooks/post-commit 파일을 다음과 같이 편집합니다. 여기서는 모든 소스 코드, 문서가 UTF-8 인코딩을 사용한다고 가정하고, svn-commit-log@example.com 주소로 메일을 전송합니다.\n#!/bin/sh REPOS=\u0026quot;$1\u0026quot; REV=\u0026quot;$2\u0026quot; REPOS_NAME=`basename $REPOS` # uncomment below if system locale is not UTF-8 #export LANG=ko_KR.UTF-8 /usr/lib/subversion/hook-scripts/commit-email.pl --from \u0026quot;svn-commit@example.com\u0026quot; -s \u0026quot;SVN: $REPOS_NAME\u0026quot; -h example.com \u0026quot;$REPOS\u0026quot; \u0026quot;$REV\u0026quot; svn-commit-log@example.com /usr/lib/subversion/hook-scripts/svn2bugzilla.rb \u0026quot;$REPOS\u0026quot; \u0026quot;$REV\u0026quot;  그리고 실행 권한을 줍니다.\n$ sudo chmod +x /var/lib/svn/hello/hooks/post-commit  참, 버그질라로 메일을 보내기 위해 루비를 설치하고,\n$ sudo apt-get install ruby  /usr/lib/subversion/hook-scripts/svn2bugzilla.rb 파일을 다음 내용으로 채운뒤,\n#!/usr/bin/ruby require 'rubygems' require 'active_record' require 'set' require 'fileutils' # If your Subversion usernames are not the same as your # Bugzilla usernames, map them here. USER_MAP = {\u0026quot;lovemetender\u0026quot; =\u0026gt; \u0026quot;lovemetender@example.com\u0026quot;} USER_DOMAIN = \u0026quot;example.com\u0026quot; # Location of svnlook binary. Change as necessary. SVNLOOK = \u0026quot;/usr/bin/svnlook\u0026quot; # Configure your AR connection here. # Bugzilla supports both MySQL and PostgreSQL. AR_CONFIG = {:adapter =\u0026gt; 'mysql', :host =\u0026gt; 'database.example.com', :port =\u0026gt; 3306, :database =\u0026gt; 'bugzilla', :username =\u0026gt; 'bugmaster', :password =\u0026gt; 'bugpassword' } # You should not have to change anything below this line. if ARGV[0].nil? || ARGV[1].nil? puts \u0026quot;Usage: svn2bugzilla.rb repos_path revision\u0026quot; puts \u0026quot;To be used as a subversion post-commit hook.\u0026quot; exit end REPOS_PATH = ARGV[0] REVISION = ARGV[1] ActiveRecord::Base.establish_connection(AR_CONFIG) ActiveRecord::Base.connection.execute 'set character set utf8' # These are the three Bugzilla tables we'll be dealing with. # It'd probably be less code just to query the database directly, # bug using ActiveRecord is more fun! class Bug \u0026lt; ActiveRecord::Base set_primary_key \u0026quot;bug_id\u0026quot; # longdescs has a column named 'type' which doesn't play well with AR. # select the columns we need manually. has_many :longdescs, :select =\u0026gt; \u0026quot;comment_id, bug_id, who, bug_when, thetext\u0026quot; end # longdescs is the comments table. class Longdesc \u0026lt; ActiveRecord::Base set_primary_key \u0026quot;comment_id\u0026quot; belongs_to :bug belongs_to :profile, :foreign_key =\u0026gt; \u0026quot;who\u0026quot; end # profiles is the user table class Profile \u0026lt; ActiveRecord::Base set_primary_key \u0026quot;userid\u0026quot; end class Commit def initialize(repository_path, revision_number) @repository = File.basename repository_path @revision_number = revision_number @log_message = `#{SVNLOOK} log #{repository_path} -r #{revision_number}`.strip @date = `#{SVNLOOK} date #{repository_path} -r #{revision_number}`.strip @files_changed = `#{SVNLOOK} changed #{repository_path} -r #{revision_number}`.strip @author = `#{SVNLOOK} author #{repository_path} -r #{revision_number}`.strip end def message \u0026lt;\u0026lt;MESSAGE #{@log_message} Repository: #{@repository} Revision: #{@revision_number} Author: #{@author} Date: #{@date} Changes: #{@files_changed} http://svn.example.com/cgi-bin/viewvc.cgi/#{@repository}?revision=#{@revision_number}\u0026amp;view=revision MESSAGE end def author if USER_MAP[@author].nil? return \u0026quot;#{@author}@#{USER_DOMAIN}\u0026quot; end USER_MAP[@author] end # return a Set of unique bug numbers in the commit message def bug_numbers bugs = Set.new @log_message.scan(/bugD{1,3}(d+)/i).each do |match| bugs \u0026lt;\u0026lt; match[0] end bugs end end # Do the actual work of submitting the comment to the database commit = Commit.new(REPOS_PATH, REVISION) commit.bug_numbers.each do |bug| bug = Bug.find_by_bug_id(bug) next if bug.nil? user = Profile.find_by_login_name(commit.author) next if user.nil? bug.longdescs.create(:who =\u0026gt; user.id, :thetext =\u0026gt; commit.message, :bug_when =\u0026gt; Time.now) end  이 스크립트 소스를 조금 살펴보시면 버그질라 MySQL 데이터베이스 서버에 대한 접근 정보를 설정하는 부분과, 메일 텍스트 본문에 ViewVC 웹인터페이스를 직접 연결하는 부분이 있으므로, 필요에 맞게 수정해야 합니다. 이제 스크립트에 실행 권한을 줍니다.\n$ sudo chmod +x /usr/lib/subversion/hook-scripts/svn2bugzilla.rb  자 이제 마지막, 외부로 공개된 서버에서 접근시 내부 서브버전 서버로 연결하기 위해 공개 서버의 /etc/apache2/sites-available/svn.example.com 파일을 다음과 같이 편집합니다. 여기서는 공식 서브버전 서버 도메인 이름이 svn.example.com이고 (물론 네임서버에서 IP 주소는 외부로 공개된 서버와 동일합니다) 실제 서브버전 서버 IP는 192.168.0.141 이라고 가정합니다.\n\u0026lt;VirtualHost *\u0026gt; ServerAdmin lethean@example.com ServerName svn.example.com ErrorLog /var/log/apache2/svn.example.com-error.log CustomLog /var/log/apache2/svn.example.com-access.log combined UseCanonicalName Off ProxyVia On ProxyRequests Off ProxyPreserveHost On ProxyPass / http://192.168.0.141:80/ ProxyPassReverse / http://192.168.0.141:80/ ProxyPassReverse / http://svn.example.com:80/ \u0026lt;/VirtualHost\u0026gt;  그리고 이 호스트를 활성화하고 아파치를 재시작합니다.\n$ sudo a2ensite svn.example.com $ sudo /etc/init.d/apache2 restart  음\u0026hellip; 더 이상 생각나는게 있으면 채워 나가야겠지만, 일단 오늘은 여기까지\u0026hellip; :)\n","date":1247702400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1247702400,"objectID":"9878902eaac9c94916df711de2737bd9","permalink":"https://lethean.github.io/2009/07/16/manage-subversion-repositories-in-ubuntu/","publishdate":"2009-07-16T00:00:00Z","relpermalink":"/2009/07/16/manage-subversion-repositories-in-ubuntu/","section":"post","summary":"회사에서 사용하는 버전 관리 시스템을 Git으로 이전하기 전에, 나중에 또 언젠가 다시 필요할 지 모르는 일이므로, 7년동안 운영해 왔던 Subversion 서버 구성과 운영 방식을 기","tags":["Subversion","Ubuntu"],"title":"우분투에서 서브버전 저장소 운영하기","type":"post"},{"authors":null,"categories":null,"content":"기존 X 윈도우 프로그래밍에서 하드웨어 가속 기능을 이용하여 YUV 형식의 비디오를 재생하거나 MPEG2 코덱을 디코딩하려면 Xv (X Video) 와 XvMC (X Video Motion Compensation) 확장(extension) API를 사용해야 합니다. 하지만 몇년 전부터 이러한 X 윈도우 확장 API의 한계를 벗어나기 위해 업체별로 각각 별도의 API 라이브러리를 제공하고 있는데, 인텔의 VA (Video Acceleration) API , NVIDIA의 VDPAU (Video Decode and Presentation API for Unix) , ATI의 XvBA (X-Video Bitstream Acceleration) API 등이 그 예입니다. (물론 이를 지원하는 최신 그래픽카드 칩셋이 장착되어 있어야 하는데, 인텔의 경우 G45 칩셋부터 가능하다고 합니다) 참고로 CPU 점유율 66.3 ~ 98.4% 정도를 사용하는 고해상도 H.264 / VC1 비디오 재생이 하드웨어 가속 기능을 이용하면 0.6% 이하로 낮아진다는 벤치마킹 결과 도 있습니다.\n이러한 여러 업체의 독자적인 API가, LWN 기사 에서 정리한 것처럼, 이제는 인텔 API로 통합되어 가고 있습니다. VDPAU / XvBA 기능이 VA API의 백엔드(backend)로 구현하는 작업이 진행되고 있어 VA API만 지원해도 응용 프로그램은 쉽게 다른 업체의 하드웨어 가속 기능을 사용할 수 있게 되는 것입니다. 물론 MPlayer, FFmpeg, VLC 같은 대표적인 비디오 관련 응용 프로그램은 VA API를 이미 지원하거나 지원하기 위해 준비하고 있습니다.\nVA API는 비디오 디코딩 뿐 아니라 기존 Xv 확장 API에서 처리하던 색상 공간 변환 (color space conversion), 감마 교정 (gamma correction), 확대 (scaling) 외에 기타 비디오 작업을 처리합니다. 게다가 앞으로는 인텔에서 제공하는 하드웨어 가속 인코딩 기능까지 지원할 예정인 것 같습니다. (2009년 하반기에 발표할 예정인 인텔 Moorestown 모바일 플랫폼에서 지원하는 것 같습니다) 더 나아가 클러터(Clutter) 같은 툴킷 라이브러리에서 직접 사용할 수 있도록 OpenGL 텍스쳐(texture)에 직접 렌더링하는 기능도 지원할 예정이라는군요.\n그래픽 하드웨어 칩셋의 인코더 / 디코더 기능을 이용하는 기능은 얼핏 리눅스 커널 V4L2 기반의 하드웨어 인코더 / 디코더 API와 중복된다는 느낌도 있지만, VA API는 디코딩한 데이터가 바로 그래픽 카드 프레임 버퍼에 저장되어 표시되기 때문에 별도의 디스플레이 과정이 불필요하다는 점이 다릅니다. 또한 인코더 / 디코더 보드는 대부분 다채널 동시 인코딩 / 디코딩을 지원하지만, VA API는 한 번에 하나의 비디오만 처리할 수 있다는 점도 다릅니다.\n아직은 모두 오픈소스가 아닌 업체가 제공하는 바이너리 X 윈도우 드라이버에서만 동작하는 것 같지만, 나중에 분명 필요하게 될 때가 있을 것 같으니, VA API 사용법도 한 번 둘러봐야 할 것 같습니다.\n","date":1247443200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1247443200,"objectID":"b4e22f3eed41a4086edfb6af5c9806df","permalink":"https://lethean.github.io/2009/07/13/x-window-video-acceleration-api-overview/","publishdate":"2009-07-13T00:00:00Z","relpermalink":"/2009/07/13/x-window-video-acceleration-api-overview/","section":"post","summary":"기존 X 윈도우 프로그래밍에서 하드웨어 가속 기능을 이용하여 YUV 형식의 비디오를 재생하거나 MPEG2 코덱을 디코딩하려면 Xv (X Video) 와 XvMC (X Video Motion Compensation) 확장(extension","tags":["Clutter","Kernel","Linux","Xorg"],"title":"X 윈도우 비디오 가속(VA) API","type":"post"},{"authors":null,"categories":null,"content":"최근 들어 제 블로그에 방문수가 많아지는 게 이상해서 확인해보니 클러터(clutter) 라이브러리 관련 정보를 찾다가 오신 분이 많더군요.\n2008년 10월 즈음부터 메일링 리스트에서 메인 개발자 이메일 주소가 인텔로 바뀌는가 싶더니 조금 후에 인텔에서 공식적으로 클러터 프로젝트를 지원하는 것을 공표하고, 급기야 인텔이 차세대 넷북 플랫폼으로 밀고 있는 모블린(Moblin) 프로젝트의 핵심 라이브러리로 자리잡으면서 사람들이 클러터에 관심을 가지게 된 게 아닌가 싶습니다. 물론 그놈 3.0 셸(shell)을 클러터 기반으로 개발 중이고, 현재 개발 버전 GTK+ (2.17) 메인 소스에 클러터에 GTK+ 위젯을 쉽게 넣어 연동할 수 있도록 도와주는 클라이언트-방식-윈도우(client-side-windows) 구현이 반영된 것도 사람들의 호기심을 증가시킨 것 같습니다. 게다가 이제는 인터넷을 찾아보면 클러터를 사용하는 게임이나 프로젝트도 점점 늘어나는 추세이고, 조만간 성능과 API가 대폭 개선된 클러터 1.0 버전이 출시될 예정이라 기다리는 사람이 많은 것 같습니다.\n모블린 프로젝트를 인텔이 대놓고 지원하는 이유를 명확히 알 수는 없지만, 제 개인적으로는 꽤 관심이 가는 플랫폼입니다. 모블린의 명시적인 타겟은 인텔칩 기반 넷북 또는 모바일 장비지만, 산업용 임베디드 시스템에 적용해도 매우 유용하지 않을까 생각해 봅니다. 많은 분들이 알고 계실테지만, 전철 광고 모니터나 아파트 엘레베이터 광고 모니터, DVR, 티겟 발권기, 키오스크 등등 헤아릴 수 없이 많은 산업용 장비가 실제로는 PC 메인보드를 기반으로 한 임베디드 시스템인데, 대부분 윈도우 XP 또는 윈도우 XP 임베디드를 사용하고 있습니다. (물론 ARM, PowerPC를 기반으로 한 소형 임베디드 시스템도 많지요\u0026hellip;) 그런데 만일 안정적이고 네트웍에 강한 리눅스 운영체제 위에 3D 그래픽 기술을 몰라도 쉽게 화려한 효과의 GUI 인터페이스를 구현할 수 있는 클러터 라이브러리가 무료로 제공되다면, 비록 당장은 아니더라도, 개발자라면 한 번쯤은 진지하게 고민해봐야 할 것 같습니다. 라이센스 비용이 절감되는 것은 물론, 모든 소스가 공개되어 있는 것은 말할 필요도 없고, 대부분의 리눅스 소프트웨어를 그대로 컴파일해서 사용할 수 있다는 점도 매력적인 장점입니다. (물론 윈도우 개발자가 리눅스 개발자로 거듭나기 위한 비용을 무시할 수는 없겠지만\u0026hellip;)\n아무튼, 클러터 1.0이 공식적으로 출시되면 변경사항도 정리해야 하고, 틈틈히 모블린 문서도 들여다봐야 하고\u0026hellip; H.264, HD, ONVIF, iPhone, Git, \u0026hellip;\n누가 술 한 잔 사주면 좋을 것 같은 시절입니다. :)\n","date":1246924800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1246924800,"objectID":"999494a09b23845bb32a560d3ee1c132","permalink":"https://lethean.github.io/2009/07/07/clutter-and-moblin/","publishdate":"2009-07-07T00:00:00Z","relpermalink":"/2009/07/07/clutter-and-moblin/","section":"post","summary":"최근 들어 제 블로그에 방문수가 많아지는 게 이상해서 확인해보니 클러터(clutter) 라이브러리 관련 정보를 찾다가 오신 분이 많더군요. 2008년 10월 즈","tags":["Clutter","Moblin"],"title":"클러터와 모블린(Moblin)","type":"post"},{"authors":null,"categories":null,"content":"소스 코드 문서화에 Doxygen 을 이용하고 매뉴얼이나 공식 문서 작성에는 DocBook 을 사용하신다면 혹시 둘을 합칠 수 있는 방법이 있으면 좋겠다는 생각을 해보지 않으셨나요?\n긴 말 필요없이 소개하자면, doxy2dbook 프로그램이 그런 역할을 합니다. Doxygen XML 결과물을 DocBook XML로 변환해서 기존 DocBook 문서 안에 자연스럽게 포함할 수 있도록 해줍니다. 제가 GLib 라이브러리 문서 형식에 익숙해서 결과물 역시 비슷하게 출력합니다.\n물론 인터넷을 찾아보면, Boost 라이브러리에서 사용하는 것도 있고, XSLT 프로세싱을 이용하는 방법도 있는데, 생각보다 제게는 커스터마이징이 쉽지 않더군요. 그래서 결국 목마른 자 우물 파는 법, 직접 만들어 보았습니다. 처음에는 펄 / 루비로도 만들어 보았으나 Doxygen XML 파싱과 객체 관리에 너무 시간이 오래 걸리는 점이 맘에 들지 않아, 결국 GLib 라이브러리 기반 C 언어로 만들게 되었습니다. 따라서 GLib 라이브러리 + GCC + Make 만 있으면 빌드할 수 있습니다. (하지만 Doxygen XML을 하나로 묶으려면 xsltproc 프로그램도 필요하게 됩니다) 지원하는 Doxygen 태그도 많지 않아서 제가 특정 매뉴얼을 작성하면서 사용하는 태그만 일단 지원합니다.\n아직 홈페이지도 따로 없고, 이 블로그 자체가 별로 유명하지도 않기 때문에 얼마나 많은 피드백이나 패치가 올지 모르는데 괜히 처음부터 거창할 필요는 없을 것 같아서, 외부로 공개된 버전 관리 저장소도 없이 달랑 소스 코드 묶음만 공개합니다.\n사용법은 안에 들어있는 README 파일을 참고하시기 바랍니다.\n이 프로그램은 업무상 회사에서 작성한 코드이기 때문에 저작권은 당연히 회사에게 있습니다. 라이센스는 GPL입니다.\n","date":1246838400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1246838400,"objectID":"2b56af6680b7dba795759e1c6d215cb1","permalink":"https://lethean.github.io/2009/07/06/doxy2dbook-doxygen-to-docbook-converter/","publishdate":"2009-07-06T00:00:00Z","relpermalink":"/2009/07/06/doxy2dbook-doxygen-to-docbook-converter/","section":"post","summary":"소스 코드 문서화에 Doxygen 을 이용하고 매뉴얼이나 공식 문서 작성에는 DocBook 을 사용하신다면 혹시 둘을 합칠 수 있는 방법이 있으면 좋겠다는 생각을 해보지 않으셨나요? 긴 말 필요","tags":["Coding","DocBook","doxy2dbook","Doxygen"],"title":"doxy2dbook: Doxygen-DocBook 변환기","type":"post"},{"authors":null,"categories":null,"content":"저는 개발자(developer)보다 프로그래머(programmer)라고 부르는 걸 더 좋아합니다. 왜냐하면 프로그래머라는 단어는 프로그램(program)을 만드는 이라고 명확하게 나타내주기 때문입니다. 개발자라는 단어는 어쩐지 프로그래머라는 직업이 단순 코더(coder)로 인식되기 시작하면서, 그보다 더 많은 일을 하고 있다고 포장하기 위해 그럴듯한 단어로 대체한 것처럼 느껴집니다.\n프로그램은 코드(code)입니다. 아무리 많은 기술과 기법을 사용했어도 그 마지막 결과물은 결국 코드입니다. 그래서 저한테 프로그래밍(programming)이란 곧 코딩(coding)을 의미합니다. 또한 코딩은 머릿속 추상적인 개념이 구체화되는 과정이기도 합니다. 언제부터 소프트웨어 공학이 프로그래밍에서 설계와 구현(코딩)을 구분했는지는 모르지만, 제게는 코딩이 곧 프로그래밍의 중심입니다. 나머지는 코딩을 더 잘하기 위해 필요한 도구이며 과정일 뿐입니다. (물론 디버깅도 프로그래밍의 큰 과정 중 하나입니다. 정확하게 요구사항을 분석하는 것, 코딩을 시작하기 위한 기본 개념을 선택하고 설계하는 것 등도 당연히 프로그래머의 일입니다. 하지만, 이 글에서는 코딩이 주인공이라서 다른 부분은 과소평가 할테니 소프트웨어 공학 하시는 분은 태클 걸지 말아 주시길 :)\n아무튼, 댓가를 받고 업으로 프로그래밍을 하기 시작한지 약 15년 즈음 되는 지금, 언젠가부터 현업 프로그래머 중에서는 선배보다 후배들이 많아지다 보니, 가끔 술자리에서 실력도 안되는 제게 어려운 질문을 하는 후배들에게 항상 취중에 중언부언하던 개인적인 생각을, (역시 취중에) 대략 세 가지로 감히 정리해 보았습니다.\n좋은 코드를 작성하려면 다른 사람의 코드를 많이 읽어야 합니다.\n글 쓰는 사람이 책 한 권을 쓰기 위해 열 배 백 배 이상의 독서를 하듯이, 프로그래머도 많은 코드를 읽어야 합니다. 좋은 코드에서는 배움을 얻고, 나쁜 코드에서는 금해야 할 게 무엇인지 알게 됩니다. 그런데, 유독 프로그래머는 다른 사람의 코드를 읽는 일에 인색합니다. 심지어 매뉴얼이나 API 문서에 나온 예제 코드도 읽지 않고, 동료가 작성한 코드도 읽지 않으며 오직 자신이 만든 코드만 읽고 또 읽습니다.\n모든 프로그래밍은 모방에서 시작합니다. 우리 용어로 하면 카피 앤 페이스트(copy \u0026amp; paste) 쯤 되겠지요. 하지만, 보는 만큼 아는 만큼 프로그래밍하게 됩니다. 경험이 아무리 많아도 새로운 지식이 없으면 결국 아는 한도 내에서 똑같은 틀의 코드만 계속 만들 뿐, 나아지는 건 없습니다.\n참고로, 저는 이런 관점에서 오픈소스 프로젝트를 지지하는 편입니다. 프로그래머를 성장시키는 가장 빠른 방법 중 하나는 오픈소스 프로젝트에 참여시키는 것이라는 말도 공감합니다.\n좋은 코드를 작성하려면 많이 쓰고 자주 고쳐야 합니다.\n하나의 기능을 구현하기 위해 수없이 많은 시행착오를 겪어야 결국 좋은 코드가 나옵니다. 글 쓰는 사람 예를 다시 들어보면, 한 번 쓴 글을 바로 내보내는 경우는 없습니다. 수없이 다시 쓰고 퇴고의 과정을 거쳐, 심지어 쉼표 하나 마침표 하나까지 고치고 또 고칩니다. 프로그램은 더 고약한 놈이라, 릴리스 이후에도 언제든 다시 손을 대야 합니다.\n저는 프로그래밍할때 가장 중요한 부분부터 간단하게 코딩하는 습관이 있습니다. 똑똑한 편이 아니라서, 대부분의 개념은 코딩하면서 구체화되는 경우가 대부분입니다. 변수 이름부터 구조체, API 방식, 동작 알고리즘 모두 계속 코딩하고 테스트하면서 계속 바뀝니다. (보통 다른 사람의 다섯 배 정도는 코드를 다시 고쳐 쓴다고 자부합니다. 자랑은 아닌데\u0026hellip;) 그래서 저는 처음에 만든 코드 형태가 그대로 있는 경우가 별로 없습니다.\n프로그래머는 결국 코드로 자신의 생각을 표현해야 하고, 자신의 주장을 뒷받침해야 합니다. 코드의 가독성(readability)을 높이기 위해 노력해야 하는 이유이기도 합니다.\n쉽게 레벨업 되려는 욕심은 버려야 하지만, 꾸준이 노력하는 습관은 욕심내야 합니다.\n프로그래머는 알아야 할 게 너무 많습니다. 새 언어, 라이브러리, 디자인패턴, 기술 , 개발 도구, 플랫폼, 코딩 스타일, 디버깅 기법\u0026hellip; 거기에다 글도 잘써야 하고, 영어도 잘해야 하고, 말도 잘해야 하고\u0026hellip; 알면 알수록 모르는 게 더 많다는 걸 느끼고 기본 개념이 중요하다는 걸 깨닫게 됩니다. 그리고 좌절과 무기력도 동시에 느낍니다. 이럴때 대부분은 머리가 나빠서, 혹은 소질이 없는 것 같다고 핑계를 대는데\u0026hellip; 제 경험엔 모두 핑계일 뿐, 노력하지 않고 게으르거나 또는 투자를 하지 않고 바라기만 하기 때문입니다.\n제가 자주 인용하는 표현이지만, 강물에 아무리 돌을 던져도 티가 나지 않습니다. 하지만, 좌절하지 않고 계속 던지다 보면 물 밑에서 돌무더기는 계속 쌓이게 되고, 어느 순간 수면위로 올라오게 되면, 그때부터는 한 개만 던져도 바로 쌓이는 게 티가 납니다. 프로그래밍도 마찬가지라, 어느 순간 흩어져있던 여러 가지가 한 가지로 연결되면서 깨닫게 되는 순간이 있습니다. 이미 알고 있던 지식의 다른 관점, 다른 개념도 조금씩 보이기 시작합니다. 그리고 그 후부터는 조금만 노력해도 다른 사람에 비해 쉽게 이해할 수 있게 됩니다.하지만, 대부분 이 단계까지 오기 전에 포기하거나, 자기합리화를 선택합니다.\n 여기까지 적다보니, 역시나 대가들이 했던 말을 앵무새처럼 되풀이하고 있군요. 아, 몇 시간 동안 적은 글 버리기는 아까워 그냥 내버려 두니, 저보다 나중에 시작하시는 분들에게 조금이라도 도움이 되길 바랍니다. 그리고, 지극히 개인적인 생각이라 나중엔 바뀔 수도 있고 논리적 오류도 많을 테지만, 개인 블로그에 돈 받지 않고 적는 글이니, 이렇게 생각하는 사람도 있구나 하고 넘어가 주시길~\n","date":1246838400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1246838400,"objectID":"3f8ec3b1ff8551d96518ba03c4a04933","permalink":"https://lethean.github.io/2009/07/06/how-to-code-well/","publishdate":"2009-07-06T00:00:00Z","relpermalink":"/2009/07/06/how-to-code-well/","section":"post","summary":"저는 개발자(developer)보다 프로그래머(programmer)라고 부르는 걸 더 좋아합니다. 왜냐하면 프로그래머라는 단어는 프로그램(pro","tags":["Agile","Coding"],"title":"코딩 잘하는 방법?","type":"post"},{"authors":null,"categories":null,"content":"리눅스에서 메모리 침범이나 메모리 누수, 혹은 복잡한 메모리 접근 관련 오류를 디버깅할때는 대부분 Valgrind 도구를 이용합니다. 하지만 Valgrind는 많은 메모리를 사용하고 실행 속도가 현저하게 느려지기 때문에, 별도의 타겟 장비에서 제한된 조건으로 동작하는 어플리케이션에는 조금 무리가 있습니다. 게다가 Valgrind의 메모리 검사 도구는 프로그램이 종료된 시점에서 누수된 메모리만 찾기 때문에, 실행 중에는 엄청나게 메모리를 사용하다가 정상적인 객체 해제 루틴이 호출되면 모든 메모리가 정리되어 찾을 수 없는 경우는 발견하지 못합니다.\n 구글 성능 도구 를 다시 검토하고 사용하게 된 이유도 바로 여기에 있습니다. 현재 디버깅 중인 프로그램의 문제가 대략 이렇습니다. 몇날 며칠이고 문제없이 가동해야 하는 프로그램이 특정 설정을 적용한 후에는, 자고 일어나면 10~20메가씩 메모리 점유율이 한꺼번에 올라갑니다. 하지만 Valgrind 도구를 사용해도 어느 부분이 문제인지 찾을 수가 없습니다. 지난 글에서 TCMalloc 메모리 할당자로 교체한 후 문제가 해결된 줄 알았던 바로 그 패턴이기도 합니다. 그래서 이번에는 프로파일 기능을 이용해 직접 메모리 누수를 디버깅 해보고, 나중을 위해 그 과정을 정리해 보았습니다.\n디버깅 환경\n디버깅 환경은 우분투 9.04 x86_32 플랫폼입니다. x86_64 플랫폼에서는 이상하게 호출 그래프가 그려지지 않아서 일단 무시했습니다. 사용한 버전은 공식 홈페이지 에서 다운로드 받은 1.2 버전입니다. 1.3 버전은 이상하게 프로파일 기능이 동작하지 않아 역시 무시했습니다.\nTCMalloc 도구 설치 및 연결\n호출 그래프를 생성하기 위해 dot 프로그램이 필요한데 이 프로그램은 graphviz 패키지에 들어있으므로 설치해야 합니다.\n$ sudo apt-get install graphviz  우선, 공식 홈페이지에서 google-perftools 압축 파일을 다운로드 한 뒤 다음과 같이 빌드하고 설치합니다. [2011.05.02 추가] INSTALL 문서에도 명시되어 있듯이, x86_64 환경에서는 libunwind 라이브러리를 미리 설치한 뒤 빌드해야 정상적으로 동작합니다.\n$ cd google-perftools* $ ./configure --prefix=/usr $ make $ sudo make install  TCMalloc 라이브러리를 연결하는 방법은 공식 문서 에도 나와 있듯이 디버깅할 프로그램 링크 마지막에 \u0026lsquo;-ltcmalloc\u0026rsquo; 옵션을 추가하거나, 실행할때 프로그램 앞에 \u0026lsquo;LD_PRELOAD=/usr/lib/libtcmalloc.so execute-file\u0026rsquo; 처럼 라이브러리를 먼저 로드해주면 됩니다. 저는 첫번째 방법을 사용했습니다. [2011.05.02 갱신] 언제부터인지는 확실치 않지만 첫번째 방법은 동작하지 않고 두번째 방법으로 해야 메모리 프로파일이 정상적으로 동작합니다.\n참고로, 디버깅할 프로그램을 컴파일할때는 디버깅 심볼 옵션(-g)이 있어야 호출 그래프에서 정확한 함수 이름이 표시됩니다. 또한 최적화 옵션(-O2 등)을 사용 안하면 더 정확한 함수 호출 그래프를 얻을 수 있습니다.\n프로파일 데이터 얻기\nTCMalloc 라이브러리를 연결해도 기본적으로 프로파일 기능은 동작하지 않습니다. HEAPPROFILE 환경변수에 프로파일 정보를 주기적으로 덤프할 파일 이름 접두사(prefix)를 지정해야만 동작합니다.\n$ HEAPPROFILE=/tmp/profile execute-file  접두사는 파일 절대 경로로 디렉토리를 포함할 수 있습니다.\n만일 덤프 파일이 너무 자주 생성되거나 반대로 너무 드물게 생성된다면 환경 변수를 통해 간격을 조절할 수 있습니다.\n$ HEAPPROFILE=/tmp/profile HEAP_PROFILE_ALLOCATION_INTERVAL=107374182400 execute-file  더 자세한 옵션은 공식 문서 를 확인해 보시기 바랍니다.\n위 예제에서 지정한 방식대로 프로그램을 실행하면 /tmp/profile.0001.heap, /tmp/profile.0002.heap, /tmp/profile.0003.heap 등과 같은 프로파일 덤프 파일이 실행 도중 계속 생성됩니다.\n결과 그래프 얻기\n포스트스크립트(PostScript) 파일 형식으로 메모리 프로파일 정보를 포함한 함수 호출 그래프를 얻으려면 다음과 같이 형식으로 pprof 프로그램을 실행하면 됩니다.\n$ pprof --ps --lines execute-file /tmp/profile.0001.heap \u0026gt; profile-0001.ps  프로파일 덤프 파일에 대하여 하나씩 그래프를 생성해 직접 눈과 손으로 비교하는 것도 나쁘지 않지만, 두 프로파일의 차이점만 그래프로 만들어주는 옵션이 있으므로 이를 사용하면 더 편리합니다. 즉, 시간대별 메모리 사용량의 달라진 부분이 정확하게 어느 함수 호출 때문인지 알 수 있게 해줍니다.\n$ pprof --ps --lines --base /tmp/profile.0001.heap execute-file /tmp/profile.0002.heap \u0026gt; profile-0002-diff.ps  물론, PDF(--pdf), GIF(--gif) 등과 같은 다른 형식으로 그래프 파일을 얻을 수도 있습니다. 더 자세한 옵션은 \u0026lsquo;pprof --help\u0026lsquo;를 참고하시면 됩니다.\n결론\n며칠간 디버깅에 적용해보니 문제가 발생한 패턴이 무엇이었는지도 찾아내고, 간과했던 작은 메모리 누수 버그들도 함께 발견할 수 있었습니다. 하지만, 언제나 그렇듯이, 디버깅 사태까지 오기 전에 더 튼튼하게 설계하고, 더 꼼꼼하게 프로그래밍하고, 더 철저하게 코드 리뷰와 테스트를 거치는 게 정도임을 새삼 깨닫습니다.\n","date":1245283200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1245283200,"objectID":"13d6d6c3b7def506fb2feada2c313942","permalink":"https://lethean.github.io/2009/06/18/debugging-memory-leaks-with-tcmalloc-google-perftools/","publishdate":"2009-06-18T00:00:00Z","relpermalink":"/2009/06/18/debugging-memory-leaks-with-tcmalloc-google-perftools/","section":"post","summary":"리눅스에서 메모리 침범이나 메모리 누수, 혹은 복잡한 메모리 접근 관련 오류를 디버깅할때는 대부분 Valgrind 도구를 이용합니다. 하지만 Valgrind는 많은 메모리를","tags":["Coding","glibc"],"title":"TCMalloc 구글 성능 도구를 이용한 메모리 누수 디버깅","type":"post"},{"authors":null,"categories":null,"content":"어김없이 리눅스 커널 2.6.30 버전 이 나왔습니다. 에휴\u0026hellip;\n20대에는 릴리스마다 변경된 커널 코드를 읽어 보기도 했는데, 30대 초반 들어서는 기술 분석 문서를 읽는 것도 벅차더니, 30대 중반을 달리고 있는 요즘은 어디 잘 요약해 놓은데 없나 찾아 다니기만 하는 것 같습니다. 물론 갈수록 게을러지는 게 가장 큰 원인이겠지만, 매 릴리스마다 변경되는 기술의 폭이 커지는 것도 하나의 변명이 될 수 있지 않을까 생각합니다. 게다가 요즘은 초창기와 다르게 릴리스 전에 많은 전문가들이 먼저 시험해 보고 잘 정리해 놓으니까, 직접 API를 사용해 보거나 코드를 확인하는 건 정말 업무에 사용하게될 때 뿐인 것 같습니다. 어찌되었든, 중요한 변경 사항은 놓치지 않고 확인해놔야 먹고 사는데 지장이 없을 것 같아 제가 관심 있는 부분만 정리해 봅니다. 물론 더 자세한 내용은 커널 뉴비 사이트 를 보시면 지나치게 잘 정리되어 있으니 놓치지 마시길!\n파일시스템 잔치 : NILFS2, POHMELFS, DST, EXOFS, EXT4, EXT3, \u0026hellip;\n일본 NTT Lab에서 개발한 NILFS2 파일시스템이 정식으로 커널에 포함되었습니다. 아직 개선이 조금 더 필요하지만 SSD 저장장치에서 엄청난 성능을 뿜어낸다고 하는군요. 아주 오래전부터 공식 커널 밖에서 개발되던 로그-구조(Log-structured) 방식 파일시스템이 드디어 실생활에 사용될 수 있을지 조금 기대가 됩니다. 참고로 로그-구조란, 로그 파일에 로그 메시지가 계속 추가되듯이, 기존 내용을 덮어쓰지 않고 추가 / 수정된 부분만 계속 새로운 공간에 배치하기 때문에 공간이 허락하는 한 무한대 롤백 / 스냅샷이 가능합니다. 그리고 이러한 특성 때문에 쓰기 제한이 있는 SSD 매체에 적합한 파일시스템이라는 얘기도 가능합니다.\n오랫동안 커널 플래닛 에서 개발 과정을 지켜봤던 POHMELFS 파일시스템도 포함되었습니다. 지금까지 존재하는 어떤 네트웍 파일시스템보다 성능이 더 좋다고 하는데, 써 볼 기회가 없는게 아쉽네요. 또한 NFS / AFS 등의 성능 개선을 이끌어낸 FS-Cache 캐싱 파일시스템도 추가되었다고 합니다. DST, EXOS 파일시스템은 잘 모르는 거라서\u0026hellip;\nEXT3 / EXT4 파일시스템에서 fsync() 호출에 대한 반응속도(latency)도 많은 논의 끝에(?) 개선되었고, EXT3 파일시스템에서 relatime 옵션이 기본으로 켜지게 되었습니다. 더불어 EXT4 파일시스템도 많이 안정화된 것처럼 보입니다.\n아무튼, 요즘 리눅스 커널은 BTRFS, EXT4, UnionFS 등을 포함한 차세대 파일시스템들이 EXT3 다음 자리를 놓고 치열하게 경쟁하는 덕분에, 개발자들 공부 많이 하게 해 주는군요\u0026hellip;\n쓰레드 방식 인터럽트 핸들러 지원\n솔라리스나 실시간 커널에서는 이미 몇십년 전부터 사용하고 있는 방식이지만, 여러 정치적인 이유로 실시간 커널 브랜치에만 있던 쓰레드 방식 인터럽트 핸들러 기능 이 이제서야 메인 커널에 추가되었습니다. 물론 인터럽트 핸들러가 실행이 길어질수록 시스템의 다른 부분이 아무 일도 할 수 없기 때문에 리눅스 커널은 아주 오래전부터 상단/하단 부분(top/bottom half)이나 태스크릿(tasklet)을 비롯해 많은 메카니즘을 제공함으로써 커널 레이턴시(latency)를 훌륭하게 보장하고 있지만, 아무래도 실시간 시스템 하는 사람들에겐 부족했던 모양입니다.\n기존 방식으로 동작하려면 지금과 동일하게 request_irq() 함수를 사용하면 되고, 각각의 핸들러가 별도 커널 쓰레드로 동작하게 하려면 request_threaded_irq() 함수를 이용해 등록하면 됩니다. 두번째 방식은 핸들러 함수(quick_check_handler)가 하나 더 있는데, 인터럽트가 발생하면 이 핸들러가 먼저 실행된 후 인터럽트가 자신의 것이 맞는지 여부와, 그렇다면 그에 따라 인터럽트 핸들러 쓰레드를 깨울지, 직접 인터럽트 문맥에서 실행할 지 등을 결정하는 리턴값을 돌려주면 그에 따라 인터럽트 핸들러 쓰레드가 동작하는 방식입니다. 따라서 이로 인해 기존 태스크릿(tasklet)은 사라질 수도 있다고 합니다.\n기타\n커널 부팅 속도를 빠르게 하기 위해 한번에 하나씩 장치를 스캔하지 않고, 한꺼번에 장치 스캔 요청을 보낸 뒤 나중에 비동기(async)로 응답을 받아 처리할 수 있는 API 도 추가되었습니다.\n메모리 관리자는 또 개선되어, 커널 메모리 추적자(kmemtrace)라는 녀석도 추가되어 kmalloc(), kfree(), kmem_cache_alloc() 등과 같은 메모리 관련 API 추적 정보를 사용자 영역 프로세스에게 전달해 분석에 사용할 수 있게 되었습니다. 더불어 DMA API 디버깅을 위한 기능 도 추가되었습니다.\nX86_32 아키텍쳐에서 커널 스택 보호 기능도 추가되고, 이제 더 이상 zImage 형식은 지원하지 않게 되었고, /sys 밑에 새로운 항목들이 추가되고, 수많은 디바이스 드라이버가 업데이트되고 추가되었고\u0026hellip;\n아무튼, 오늘은 여기까지!\n","date":1244764800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1244764800,"objectID":"6d039f6a7708f7c647a48274dcebdbeb","permalink":"https://lethean.github.io/2009/06/12/linux-kernel-2-6-30-release/","publishdate":"2009-06-12T00:00:00Z","relpermalink":"/2009/06/12/linux-kernel-2-6-30-release/","section":"post","summary":"어김없이 리눅스 커널 2.6.30 버전 이 나왔습니다. 에휴\u0026hellip; 20대에는 릴리스마다 변경된 커널 코드를 읽어 보기도 했는데, 30대 초반 들어서는 기술 분석 문","tags":["Kernel","Linux"],"title":"리눅스 커널 2.6.30 릴리스","type":"post"},{"authors":null,"categories":null,"content":"GNOME 3.0의 기본 프로그램 역할을 하게 될 그놈 셸(GNOME Shell) 에 대한 소식이 요즘 많이 보이는군요. 하지만 역시 엔지니어라서 그런지, 사용자 관점의 변화보다 기술적인 면에 더 관심이 갈 수 밖에 없는터라 그 부분을 조금 정리해 보았습니다.\n새로운 셸은 기존에 컴피즈(Compiz)가 했던 3D 컴포지트 기능을 내장하면서 메타시티(Metacity)가 담당했던 윈도우 관리자 역할과 그놈 패널(GNOME Panel) 역할을 동시에 담당합니다. 그런데, 지금보다 더 직관적이고 화려한(?) 인터페이스를 구현하는 것은 물론 많은 개발자가 쉽게 패널 애플릿을 작성할 수 있도록 과감하게도 클러터(Clutter) 라이브러리와 자바스크립트(JavaScript) 언어를 이용해 구현하고 있습니다.\n물론 그렇다고 모든 그놈 플랫폼에서 GTK+ 라이브러리를 클러터 라이브러리로 대체하는 것은 아니고 그놈 셸을 작성하는데만 사용하는 것으로 일단 제한하고 있습니다. 클러터보다는 아무래도 GTK+ 자체가 더 복잡한 인터페이스를 요구하는 많은 어플리케이션에 적합하기 때문입니다. 그러나 그놈 셸처럼 화려하고 직관적인 인터페이스를 구현하기 위해서는 클러터 라이브러리가 더 적합하다는 판단인 것 같습니다.\n하지만 자바스크립트 언어의 도입은 약간 충격적입니다. 그동안 파이썬, 루비, 펄, 심지어 Vala 등과 같은 언어까지 새로 만들어가면서도 무언지 모를 아쉬움에 선택을 못하더니, (그래도 결국 C++은 사용하지 않고 :-) C 언어를 대체할 언어를 찾아가던 그놈 개발자들이 결국 전 세계에서 가장 많은 (웹 프로그래머) 사용자를 가진 언어를 선택하게 된 셈입니다. 물론 여기에는 점점 성능이 좋아지는 자바스크립트 인터프리터 엔진의 역할도 큰 것 같습니다.\n자바스크립트 인터프리터 엔진은 현재 모질라 트레이스몽키(TraceMonkey) 기반의 Gjs 와 웹킷(WebKit) 자바스크립트 엔진 기반의 Seed 를 동시에 고려하고 있는듯 합니다. 둘 모두 활발하게 개발되고 있고 각각의 장단점이 있기 때문에 지금 현 시점에서 굳이 하나를 선택하지는 않는 것 같습니다.( LWN 기사 참조)\n또한 쉽게 자바스크립트 언어를 선택하게 된 배경에는 최근에 멋지게 데뷔한 GObject Introspection 라이브러리의 역할도 큰 것 같습니다. 참고로 이 라이브러리는 GObject 기반 라이브러리를 어떤 언어에도 쉽게 바인딩할 수 있도록 도와줍니다.\n언제나 그렇듯이, 직접적인 그놈 개발자는 아니지만, KDE처럼 성급하게 새로운 기술을 실험하지 않고 점진적으로 이미 잘 개발된 라이브러리를 바탕으로 조금씩 혁신을 이루어가는 그놈 쪽 개발 과정을 보고 있노라면 흐뭇하기만 합니다. 특히나 저처럼 이쪽으로 먹고 사는 사람들한테는 더욱\u0026hellip; :)\n","date":1243900800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1243900800,"objectID":"171eff61337f315062ba52afd5d0adaa","permalink":"https://lethean.github.io/2009/06/02/gnome-3-shell/","publishdate":"2009-06-02T00:00:00Z","relpermalink":"/2009/06/02/gnome-3-shell/","section":"post","summary":"GNOME 3.0의 기본 프로그램 역할을 하게 될 그놈 셸(GNOME Shell) 에 대한 소식이 요즘 많이 보이는군요. 하지만 역시 엔지니어라서 그런지, 사용자 관점의 변화보다 기술","tags":["Clutter","GLib","GNOME"],"title":"GNOME 3.0 셸(GNOME Shell) 소개","type":"post"},{"authors":null,"categories":null,"content":"장기간 실행되면서 빈번하게 메모리를 할당 / 해제하는 것은 물론 수십 개의 쓰레드가 동작하는 프로그램에서는 어쩔 수 없이 메모리 단편화(Memory Fragmentation)가 발생합니다. 메모리 단편화가 많을 경우 어플리케이션 로직에 메모리 누수(memork leak)가 없어도 C 라이브러리 메모리 관리자가 메모리를 커널에 반환하지 않기 때문에 프로세스의 메모리 사용량은 계속 늘어납니다.(참고로 이러한 경우인지 여부는 주기적으로 mallinfo() 정보를 확인하면 됩니다) 물론 이를 회피하기 위한 기법이나 아키텍쳐는 많이 있지만, 그리 쉽게 원하는 성능과 효율을 얻기는 힘들더군요.\n그런데, 며칠 동안 이와 비슷한 문제를 디버깅하다가 예전에 무심코 지나쳤던 Google Performance Tools 라이브러리를 다시 발견하고, 그 안에 들어 있는 TCMalloc(Thread-Caching Malloc) 모듈을 사용해 보았는데 사용하지 않을 때와 비교해 놀랄만큼 많은 차이를 보이는군요. 문서에 보면 성능과 효율을 동시에 향상시킨다고 하는데 성능은 사실 잘 모르겠지만, 장기간 실행시 메모리 사용량 변동률은 너무나 맘에 듭니다.\n간단하게 TCMalloc의 동작 방식을 설명하면, 일단 중앙 메모리 관리자와 쓰레드별 메모리 관리자를 구분합니다. 작은 크기(32K 이하)의 메모리 할당 / 해제 요청은 쓰레드별 메모리 관리자가 처리하고, 부족할 경우 중앙 메모리 관리자에서 얻어오는 방식입니다. 따라서 메모리 할당시 불필요한 동기화 과정이 이론상 거의 없어 성능 향상을 얻을 수 있습니다. 메모리 크기를 60개의 클래스로 나누어 관리하게 때문에 단편화도 줄어듧니다. 큰 메모리(32K 이상)는 전역 관리자에서 페이지 크기(4K) 단위로 클래스를 나누어 mmap()을 이용하여 할당하는 것을 제외하고 전체적으로 비슷하게 처리합니다.\n소스를 빌드하고 프로젝트에 라이브러리를 링크하는 방법은 위키페이지 에 설명되어 있으며, 문제가 발생하거나 더 복잡한 튜닝을 원한다면 소스 묶음 안에 있는 README , INSTALL 파일 등을 참고하면 됩니다. (특히 리눅스 x86_64 환경에서는 configure 실행시 \u0026lsquo;--enable-frame-pointers\u0026rsquo; 옵션을 추가하는 것이 좋습니다)\n","date":1240963200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1240963200,"objectID":"d600e4121184de359b1ae388f6e882c0","permalink":"https://lethean.github.io/2009/04/29/tcmalloc-google-perftools/","publishdate":"2009-04-29T00:00:00Z","relpermalink":"/2009/04/29/tcmalloc-google-perftools/","section":"post","summary":"장기간 실행되면서 빈번하게 메모리를 할당 / 해제하는 것은 물론 수십 개의 쓰레드가 동작하는 프로그램에서는 어쩔 수 없이 메모리 단편화(Memory Fragme","tags":["Coding","GCC","glibc"],"title":"TCMalloc, 구글 성능 도구","type":"post"},{"authors":null,"categories":null,"content":"우분투 9.04 버전이 릴리스 되었지만 안정화되려면 업데이트를 조금 더 기다려야 할 것 같습니다. 릴리스 노트 를 보면 인텔 드라이버 성능 저하와 디스플레이 멈춤(freeze), EXT4 파일 시스템 불안정, 945보드에서 디스크 인식 문제 등 많은 문제가 언급되어 있군요. 한글 글꼴 설정도 조금 문제가 있어 수정이 필요한 것 같고\u0026hellip;\n6개월 간격으로 정식 릴리스를 무조건 해야 하니 발생하는 어쩔 수 없는 일이긴 하지만, 이번 릴리스는 X서버와 비디오 드라이버, 커널과 드라이버가 모두 급격하게 신기술로 이전되어 아직 충분히 안정화가 안 된 상황과 배포판 릴리스 시기가 맞물려 더욱 심한 것 같습니다.\n물론, 인텔 그래픽 카드 사용 안하면 됩니다. EXT4 파일시스템 대신 그대로 안정적인 EXT3 파일 시스템을 사용하면 됩니다. 몇가지 부족한 부분은 튜닝하면 되겠지요. 하지만, 하드웨어를 교체할 수 없거나 제품에 사용하려고 계획 중이라면 아쉬운 기분으로 조금 더 기다려야 할 것 같습니다. 대부분의 문제가 굳이 우분투 배포판만의 문제는 아니니까요\u0026hellip;\n그나저나, Btrfs 파일시스템 벤치마크 기사 가 나올 정도로 안정화가 눈에 띄게 좋아진 것 같군요. 과연 성능과 기능 두 마리 토끼를 모두 잡을 수 있을 지 정말 기대됩니다.\n","date":1240444800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1240444800,"objectID":"7e86e758fc0a1248317d9bde71fe86a6","permalink":"https://lethean.github.io/2009/04/23/ubuntu-904-release-however/","publishdate":"2009-04-23T00:00:00Z","relpermalink":"/2009/04/23/ubuntu-904-release-however/","section":"post","summary":"우분투 9.04 버전이 릴리스 되었지만 안정화되려면 업데이트를 조금 더 기다려야 할 것 같습니다. 릴리스 노트 를 보면 인텔 드라이버 성능 저하와 디스플레이 멈춤(free","tags":["Linux","Ubuntu"],"title":"우분투 9.04 릴리스, 하지만...","type":"post"},{"authors":null,"categories":null,"content":"맥 코코아 프레임웍을 공부하면서 GTK+ / GObject 라이브러리에도 있으면 참 좋겠다고 생각한 것 중 하나가 특정 속성(property)을 다른 객체의 속성과 결합하는(binding) 개념입니다. 이를 이용해 자동으로 모델과 뷰를 클릭 몇 번으로 연결하고, 더 나아가 객체 배열은 물론 선택한 항목까지 자동으로 동기화되는 걸 보면서 정말 잘 만들어진 프레임웍이라는 걸 새삼 느낍니다. 또한 사용자가 직접 설계한 클래스를 인터페이스 빌더의 객체로 등록해서 마우스 클릭만으로 자연스럽게 연결이 되는 걸 보면 정말 부럽습니다.\n물론 GObject 객체의 속성 묶기(property binding)를 지원하기 위해 ExoBinding 과 같은 라이브러리도 존재하지만, 이 역시 개발자가 직접 코드를 추가해주어야 하는 방식일 뿐 Glade와 같은 인터페이스 빌더에서 직접 사용할 수는 없습니다. 아쉽게도 GTK+ 3.0 로드맵 / GLib 2.22 예정 에도 없는 걸 보면 GTK+ 개발자들은 아무래도 직접 코딩하는 걸 더 선호하거나 혹은 필요성을 못 느끼거나, 또는 아직 괜찮다고 생각하는 구현이 없는 거라고 생각하고 싶을 뿐입니다.\n","date":1240185600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1240185600,"objectID":"b5faadd15ef231c681bb903b3637d36d","permalink":"https://lethean.github.io/2009/04/20/gobject-property-binding-required/","publishdate":"2009-04-20T00:00:00Z","relpermalink":"/2009/04/20/gobject-property-binding-required/","section":"post","summary":"맥 코코아 프레임웍을 공부하면서 GTK+ / GObject 라이브러리에도 있으면 참 좋겠다고 생각한 것 중 하나가 특정 속성(property)을 다른 객체의 속성과 결합하는(bi","tags":["GLib","GTK+"],"title":"GObject Property Binding 기능이 필요함","type":"post"},{"authors":null,"categories":null,"content":"리눅스에서 개발할때 \u0026lsquo;man\u0026rsquo; 명령을 이용해 매뉴얼 페이지를 많이 참고하는데, 자주 시스템을 다시 설치하다 보니 설치되지 않은 매뉴얼 때문에 매번 구글을 찾는라 귀찮은 적이 많아 적어둡니다. 우분투나 데비안에서만 유효합니다.\n기본적인 C 라이브러리 관련 매뉴얼 패이지는 `manpages-dev' 패키지를 설치하면 되고, pthread_*() 류의 함수는 `glibc-doc' 패키지를 설치하면 됩니다. 즉, 터미널에서 다음과 같이 입력하면 됩니다.\nsudo apt-get install manpages-dev glibc-doc  ","date":1239148800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1239148800,"objectID":"d04f2a9de35aa50e6d509952b275b01a","permalink":"https://lethean.github.io/2009/04/08/pthread-man-pages-in-ubuntu-or-debian/","publishdate":"2009-04-08T00:00:00Z","relpermalink":"/2009/04/08/pthread-man-pages-in-ubuntu-or-debian/","section":"post","summary":"리눅스에서 개발할때 \u0026lsquo;man\u0026rsquo; 명령을 이용해 매뉴얼 페이지를 많이 참고하는데, 자주 시스템을 다시 설치하다 보니 설치되지 않은 매뉴얼 때문에 매번 구글을 찾는라 귀찮은 적이","tags":["Coding","glibc"],"title":"우분투에서 C 라이브러리 맨페이지(manpage) 설치하기","type":"post"},{"authors":null,"categories":null,"content":"2009년 4월 1일을 기준으로 GNOME 프로젝트의 핵심이 되는 glib, gtk, pango, atk 프로젝트가 기존 서브버전에서 git으로 소스 버전 관리 시스템을 변경 했습니다. 한동안 어떤 버전 관리 시스템을 사용할지 논의가 많았는데, 결국 대세를 거를 수는 없었던 모양입니다. 달라진 사용법은 Git이전하기 위키 페이지에 계속 정리되고 있으니 참고하시기 바랍니다.\n참고로, 초기 버전과 달리 최신 버전의 git은 이진(binary) 파일 처리 / 외부(external) 프로젝트 연결 등을 지원합니다. 또한 기존 서브버전 저장소와 동시에 유지할 수 있는 방법(git-svn)도 존재합니다. 하지만 아직 아쉬운 점은 멀티플랫폼 지원, 물론 커맨드 라인 방식으로는 지금도 가능하지만, 하지만 윈도우 탐색기 인터페이스에서 벗어나기 싫어하는 게으른 개발자들에게 커맨드 라인 방식을 강요할 근거가 아직은 부족한 것 같습니다. 윈도우 플랫폼에서 TortoiseSVN처럼 탐색기와 통합된 git 클라이언트만 있다면 지금 당장이라도 회사 개발 프로젝트에 도입할 수 있을 것 같은데\u0026hellip; :)\n","date":1238544000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1238544000,"objectID":"b2cb9b490980c154462c79273e411634","permalink":"https://lethean.github.io/2009/04/01/glib-gtk-moved-to-git/","publishdate":"2009-04-01T00:00:00Z","relpermalink":"/2009/04/01/glib-gtk-moved-to-git/","section":"post","summary":"2009년 4월 1일을 기준으로 GNOME 프로젝트의 핵심이 되는 glib, gtk, pango, atk 프로젝트가 기존 서브버전에서 git으로 소스 버전 관리 시스템을 변경 했습니다. 한동안 어떤 버","tags":["Git","GNOME","GTK+","Subversion"],"title":"GLib과 GTK+도 Subversion에서 Git으로 이동","type":"post"},{"authors":null,"categories":null,"content":" 리눅스 커널 2.6.29 버전이 릴리스 되었군요. 이번에도 역시 제가 관심있는 부분만 우리말로 다시 요약해 보았습니다. 물론, 커널뉴비 에서 더 자세한 내용을 확인할 수 있습니다.\n커널 모드 셋팅 (Kernel Modesetting)\n커널이 그래픽 모드 설정을 직접 제어하는 이 기능은 오랫동안 기다렸지만, 아직은 인텔 그래픽 카드만 지원하기 때문에 다른 비디오 카드 사용자는 더 기다려야 합니다. 하지만, 윈도우, 맥 같은 다른 데스크탑 운영체제처럼 드디어 리눅스도 그래픽컬한 운영체제로 변신하기 시작했다는 이정표는 분명히 될 것 같습니다. 개발자와 사용자 모두에게 많은 장점이 있지만, 이미 많은 사이트에서 이미 잘 설명하고 있으므로 자세한 내용은 생략합니다.\nBtrfs / Squashfs / Ext4 파일시스템\n썬과 애플의 ZFS에 견줄만한 유일한 파일시스템이 드디어 메인 커널에 추가되었습니다. 오라클의 지원하에 EXT4를 대체할 파일시스템 자리를 노리며 활발하게 개발되고 있지만, 아직은 테스트용으로만 추천하고 있습니다. 하물며 안정화되었다는 EXT4 파일시스템도 우분투 9.04에 포함되기 위해 일반 사용자 테스트를 받는 도중 데이터 손실이라는 심각한 버그로 인해 고생하고 있는 상황에서\u0026hellip; :)\n임베디드 시스템이나 라이브CD 환경에서 사용하기 적합한 읽기 전용 파일시스템 Squashfs도 드디어 메인 커널에 들어왔습니다. 높은 압축률 때문에 기존 읽기 전용 파일시스템을 대체하기에 적합합니다.\nExt4 파일시스템에는 저널링 없이 사용하는 기능이 추가되었는데 Ext2 파일시스템과 견줄만큼은 아니지만 (당연한 얘기지만) 조금 더 성능이 좋다고 합니다. 어떤 용도에 사용될 지 아직 이해할 수는 없지만.\n파일시스템 얼리기 (Filesystem freeze)\n파일시스템을 백업해야 하는데 백업 시점에서 모든 파일 쓰기 작업을 잠시 멈추게 해야할 필요가 있는데 이 경우에 유용하게 사용할 수 있습니다. 예를 들어, 이벤트 로그를 특정 시점까지만 백업하려고 해도 동작을 멈추면 안되는 서버가 이벤트 로그를 계속 발생하고 있다면 파일시스템을 갱신하는 모든 작업을 잠시 지연시키고(얼려버리고) 백업이 끝난다음 자연스럽게 다시 처리되도록 하면 됩니다. 물론 이 기능은 대기모드(suspend)로 들어갔다가 나오는 경우에도 활용됩니다.\n빨리 부팅하기\n한때 큰 이슈가 된 5초 안에 리눅스 부팅하기 프로젝트에서 구현한 기능 중 일부(scsi / libata 검사 비동기 실행하기)가 포함되었습니다. 하지만 기본값은 사용하지 않도록 되어 있습니다.\n속도 향상?\n 2.6.24 ~ 2.6.29 버전별 성능을 벤치마킹 한 걸 보면, 2.6.29 버전에서는 멀티 쓰레드 관련 성능이 개선되어 OpenMP를 이용하는 어플리케이션은 물론 멀티쓰레드를 활용한 많은 어플리케이션의 성능이 좋아졌다고 합니다.\n또한 2.6.26 ~ 2.6.28 버전에 있었던 SQLite 성능 저하 문제가 고쳐져서 이를 이용하는 파이어폭스 등과 같은 데스크탑 어플리케이션의 체감 속도도 나아질 것 같습니다.\n","date":1238025600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1238025600,"objectID":"d9cd52e8e9355268e062b37b98e94d04","permalink":"https://lethean.github.io/2009/03/26/linux-kernel-2629-release/","publishdate":"2009-03-26T00:00:00Z","relpermalink":"/2009/03/26/linux-kernel-2629-release/","section":"post","summary":"리눅스 커널 2.6.29 버전이 릴리스 되었군요. 이번에도 역시 제가 관심있는 부분만 우리말로 다시 요약해 보았습니다. 물론, 커널뉴비 에서 더 자세한 내용을 확인할 수 있습니","tags":["Kernel","Linux"],"title":"리눅스 커널 2.6.29 릴리스","type":"post"},{"authors":null,"categories":null,"content":" GTK+ 2.16 버전이 릴리스 되었는데, 추가된 기능 중에서 관심 있는 부분만 우리말로 정리해 보았습니다.\n새로 추가된 API\n 가로 / 세로 방향성을 가지는 위젯이 모두 GtkOrientable 인터페이스를 기반으로 다시 구현되었습니다. 상자(GtkBox), 버튼상자(GtkButtonBox), 스케일(GtkScale), 볼륨버튼(GtkVolumeButton), 스크롤바(GtkScrollBar), 구분자(GtkSeparator) 등을 비롯한 다수의 위젯을 이제  gtk_orientable_set_orientation() API를 이용하면 실행중에도 쉽게 방향을 변경할 수 있습니다. 메뉴 / 툴바 등을 하나의 사용자 액션으로 통합 관리하는데 매우 효율적인 GtkAction 객체와 연결할 수 있는 위젯을 사용자가 쉽게 구현할 수 있도록 GtkActivatable 인터페이스가 새로 추가되었습니다. 즉, 이제 메뉴와 툴바 버튼이 아닌 다른 어떤 위젯도 액션과 연결할 수 있게 된 셈입니다. 더불어 이전에는 직접 GtkAction 객체의 속성을 조절해야 했던 레이블 / 툴팁 등을 수정할 수 있는 API도 추가되었습니다.  GtkEntry 기능 강화\n 엔트리 양쪽 끝에 아이콘을 표시할 수 있게 되었습니다. 클릭할 수도 있고, 드래그 앤 드롭도 지원합니다. 자주 사용하던 libsexy GTK+ 위젯 라이브러리의 SexyIconEntry 위젯이 이제서야 공식적으로 포함된 셈입니다. 엔트리에 표시된 텍스트 뒤로 진행 상태(progress information)를 표시할 수도 있습니다. 비밀 번호 입력시 사용할 문자를 지정할 수 있게 되었고, \u0026lsquo;Caps Lock\u0026rsquo;키가 눌려 있으면 경고 메시지도 보여줍니다. 더불어 GdkKeymap 객체는 \u0026lsquo;Cap Lock\u0026rsquo;키 상태가 변경될 때마다 \u0026ldquo; state-changed \u0026rdquo; 시그널로 알려줍니다. 어플리케이션 윈도우 단위가 아닌 위젯 단위로 다른 입력기를 사용할 수 있도록 개선되었습니다.  GtkScale 추가 기능\n gtk_scale_add_mark() API를 이용하여 표식(mark)을 추가할 수 있게 되었습니다. 어떻게 응용할 수 있는지는 아래 그림을 보면 될 것 같습니다.\n모든 기능은 Ubuntu 9.04 / Fedora 11 배포판의 GNOME 데스크탑과 함께 사용이 가능합니다. 물론 윈도우에서는 지금도 다운로드 해서 개발에 사용할 수 있습니다.\n","date":1237766400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1237766400,"objectID":"a4dfe8c857788dbc384a63e2133851f5","permalink":"https://lethean.github.io/2009/03/23/gtk-216-release/","publishdate":"2009-03-23T00:00:00Z","relpermalink":"/2009/03/23/gtk-216-release/","section":"post","summary":"GTK+ 2.16 버전이 릴리스 되었는데, 추가된 기능 중에서 관심 있는 부분만 우리말로 정리해 보았습니다. 새로 추가된 API 가로 / 세로 방향성을 가지는 위젯이 모두 GtkOrientable 인터페이스","tags":["GTK+"],"title":"GTK+ 2.16 릴리스","type":"post"},{"authors":null,"categories":null,"content":" GTK+ 메일링 리스트 에서 카이로(cairo) API를 이용해 깔끔하게 외곽선 효과 를 구현하는 방법의 글을 보고 테스트 삼아 위젯으로 만들어 보았습니다. 이름하여 \u0026lsquo;GtkOutlineLabel\u0026rsquo; 위젯, 실행 화면은 다음과 같습니다.\nAPI는 간단하게 외곽선 색상과 굵기를 지정할 수 있는 기능만 있습니다. 다음은 테스트 프로그램의 일부입니다.\nint main (int argc, char **argv) { GtkWidget *window; GtkWidget *label; GtkWidget *vbox; gtk_init (\u0026amp;argc, \u0026amp;argv); window = gtk_window_new (GTK_WINDOW_TOPLEVEL); make_transparent_window (window); gtk_widget_show (window); vbox = gtk_vbox_new (FALSE, 0); gtk_widget_show (vbox); gtk_container_add (GTK_CONTAINER (window), vbox); label = gtk_outline_label_new (\u0026quot;\u0026lt;span font=\u0026quot;Bold 50\u0026quot;\u0026gt;Hello, 안녕?\u0026lt;/span\u0026gt;\u0026quot;); gtk_widget_show (label); gtk_box_pack_start (GTK_BOX (vbox), label, TRUE, TRUE, 0); label = gtk_outline_label_new (\u0026quot;\u0026lt;span font=\u0026quot;Bold 30\u0026quot; color=\u0026quot;red\u0026quot;\u0026gt;Hello, 안녕?\u0026lt;/span\u0026gt;\u0026quot;); gtk_widget_show (label); gtk_box_pack_start (GTK_BOX (vbox), label, TRUE, TRUE, 0); gtk_outline_label_set_line_color (GTK_OUTLINE_LABEL (label), \u0026quot;#000000\u0026quot;); gtk_outline_label_set_line_width (GTK_OUTLINE_LABEL (label), 1.0); gtk_main (); return 0; }  ","date":1236297600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1236297600,"objectID":"eb6555fa7501e1ca04f285a74d690e0b","permalink":"https://lethean.github.io/2009/03/06/gtk-outline-label/","publishdate":"2009-03-06T00:00:00Z","relpermalink":"/2009/03/06/gtk-outline-label/","section":"post","summary":"GTK+ 메일링 리스트 에서 카이로(cairo) API를 이용해 깔끔하게 외곽선 효과 를 구현하는 방법의 글을 보고 테스트 삼아 위젯으로 만들어 보았습니다. 이름하여 \u0026lsquo;GtkOutlineLabel\u0026rsquo;","tags":["GTK+"],"title":"GTK+ 글자 외곽선 효과 (GtkOutlineLabel)","type":"post"},{"authors":null,"categories":null,"content":"윈도우 비주얼 스튜디오 환경에서 디버깅을 하다보면 시스템에서 기본으로 제공하는 DLL 라이브러리에 대한 디버깅 심볼 정보가 없어 불편한 경우가 많습니다. 이 문제를 해결하려면 DLL 라이브러리에 대한 디버깅 심볼을 설치하면 됩니다.\n 이 사이트 에서 자신의 운영체제와 서비스 팩에 맞는 윈도우 심볼 패키지(Windows Symbol Packages)를 다운로드해서 설치한 뒤 \u0026lsquo;호출 스택(Call Stack)\u0026lsquo;을 확인해 보면, 아래 그림과 같이, 전과 다르게 ntdll.dll, kernel32.dll, user32.dll 등의 함수 이름이 표시됩니다.\n참고로, 위 사이트에 보면 비주얼 스튜디오를 설치하지 않아도(되는지 확인은 안해보았지만) 실행 중인 프로그램을 디버깅할 수 있도록 도와주는 WinDbg 디버깅 도구도 다운로드할 수 있습니다.\n","date":1234396800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1234396800,"objectID":"86ad96aa28ff4ef1a8092c89d93c467c","permalink":"https://lethean.github.io/2009/02/12/using-windows-symbol-packages/","publishdate":"2009-02-12T00:00:00Z","relpermalink":"/2009/02/12/using-windows-symbol-packages/","section":"post","summary":"윈도우 비주얼 스튜디오 환경에서 디버깅을 하다보면 시스템에서 기본으로 제공하는 DLL 라이브러리에 대한 디버깅 심볼 정보가 없어 불편한 경우가 많습니다. 이 문제를 해","tags":["Coding","Windows"],"title":"윈도우 심볼 패키지 사용하기","type":"post"},{"authors":null,"categories":null,"content":"서브버전(Subversion) 기반으로 개발할때 브랜치(branches) 작업은 빈번하게 발생합니다. 서브버전은 브랜치 작업을 효율적으로 수행할 수 있도록 스위치(switch) 명령어를 지원하는데, 생각보다 이 명령어를 활용하는 사람이 별로 없는 것 같아 간단하게 사용법을 소개하려 합니다. 여기서 소개하는 방법은 커맨드 라인 명령어를 사용하고 있지만 TortoiseSVN 등과 같은 GUI 프로그램을 이용해도 동일한 작업을 처리할 수 있습니다.\n현재 작업 중인 소스 트리를 그대로 이용하기\n디스크 공간이 부족하거나 다른 브랜치 작업 내용을 잠시만 확인하고 수정할 필요가 있을 경우, 굳이 다른 브랜치를 새로 체크아웃(checkout) 할 필요 없이 현재 소스 트리를 변경만 하면 됩니다. 특히 방대한 전체 소스가 아닌 특정 디렉토리만 해당 브랜치의 디렉토리로 변경하면 시간도 절약됩니다.\n예를 들어 \u0026lsquo;$SVN/dooly/trunk\u0026rsquo; 소스 트리에서 작업하다가 \u0026lsquo;$SVN/dooly/branches/cms-2.1-0-remote\u0026rsquo; 브랜치 소스를 작업하고 싶은데, 변경할 부분이 \u0026lsquo;$SVN/dooly/branches/cms-2.1-0-remote/cms/src\u0026rsquo; 디렉토리 뿐이라면 다음과 같이 작업하면 됩니다. (현재 디렉토리가 소스 시작 디렉토리라고 가정합니다)\ncd cms/src svn switch $SVN/dooly/branches/cms-2.1-0-remote/cms/src  이렇게 하면 다른 디렉토리는 그대로 \u0026lsquo;trunk\u0026lsquo;를 이용하고 \u0026lsquo;cms/src\u0026rsquo; 디렉토리만 \u0026lsquo;cms-2.1-0-remote\u0026rsquo; 브랜치 소스로 변경됩니다. 이후 이 디렉토리에 작업하는 내용을 커밋하면 모두 해당 브랜치로 커밋됩니다. 물론 다시 원래 소스 트리로 되돌아오고 싶은 경우 다음과 같이 작업하면 됩니다.\ncd cms/src svn switch $SVN/dooly/trunk  물론 혼란을 막기 위해 가능한 수정 중인 파일이 없는 게 좋겠지요?\n새로운 브랜치 빨리 내려 받기\n한 번 빌드하는데 많은 시간이 걸리는 소스 트리를 새로 받는 작업은 지루하고 재미없습니다. 만일 브랜치 작업 내용이 소스 디렉토리 전체가 아닌 특정 디렉토리에서만 이루어진다면 다음과 같이 빨리 새로운 브랜치를 구성할 수 있습니다. (현재 디렉토리 밑에 \u0026lsquo;dooly-trunk\u0026rsquo; 소스 트리가 이미 존재한다고 가정합니다)\ncp -a dooly-trunk dooly-remote cd dooly-remote/cms/src svn switch $SVN/dooly/branches/cms-2.1-0-remote/cms/src  이렇게 하면 쉽고 빠르게 새로운 브랜치에 대한 소스 트리가 준비됩니다. 물론 특정 디렉토리가 아닌 전체 디렉토리에 걸쳐 있는 작업이라도 다음과 같이 하면 새로운 소스를 내려받아 다시 모든 라이브러리를 빌드하는 수고는 줄어듭니다.\ncp -a dooly-trunk dooly-remote cd dooly-remote svn switch $SVN/dooly/branches/cms-2.1-0-remote  처음에도 언급한 것처럼 위의 모든 작업은 어느 운영체제 하에 어떤 서브버전 도구를 이용해도 동일합니다.\n","date":1233878400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1233878400,"objectID":"8ffa47bf56bccdf9b3ebab62e424a329","permalink":"https://lethean.github.io/2009/02/06/using-subversion-switch-command/","publishdate":"2009-02-06T00:00:00Z","relpermalink":"/2009/02/06/using-subversion-switch-command/","section":"post","summary":"서브버전(Subversion) 기반으로 개발할때 브랜치(branches) 작업은 빈번하게 발생합니다. 서브버전은 브랜치 작업을 효율적으로 수행할 수","tags":["Subversion"],"title":"서브버전 스위치 명령어 사용하기","type":"post"},{"authors":null,"categories":null,"content":"역사학자가 옛 것에서 소중한 의미를 발견하려 애쓰고, 과학자가 미래의 가치를 창조하기 위해 노력한다면, 엔지니어는 현재의 자산을 조합하여 최선의 솔루션을 만드느라\u0026hellip; 머리가 아프다.\n","date":1233878400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1233878400,"objectID":"ba68103eee8245bd2b2fd2197d899dec","permalink":"https://lethean.github.io/2009/02/06/engineers-scientists-and-histroians/","publishdate":"2009-02-06T00:00:00Z","relpermalink":"/2009/02/06/engineers-scientists-and-histroians/","section":"post","summary":"역사학자가 옛 것에서 소중한 의미를 발견하려 애쓰고, 과학자가 미래의 가치를 창조하기 위해 노력한다면, 엔지니어는 현재의 자산을 조합하여 최선의 솔루션을 만드느","tags":[],"title":"엔지니어와 과학자, 역사학자","type":"post"},{"authors":null,"categories":null,"content":" Review Board 는 코드 리뷰(Code Reviews)를 도와주는 웹 기반 소프트웨어입니다. VMware 개발팀에서 사용하는 걸 외부로 공개한 것 같은데, 파이썬으로 작성되었고, MIT 라이센스를 따릅니다.\n리뷰 보드는 커밋전(pre-commit) / 커밋후(post-commit) 리뷰를 지원합니다. 커밋전 리뷰란 공용 저장소나 안정 브랜치(master / trunk) 같은 주 저장소에 체크인 되기 전에 검토(review)하는 것을 말합니다. 검토자가 사인하기 전까지 코드는 커밋되지 않게 때문에 제품 안정성을 얻는데 도움을 줍니다. 커밋후 리뷰는 일단 저장소에 커밋된 이후 검토하는 방식입니다. 구조가 많이 변경되거나 여러 사람이 함께 코드를 검토하면서 작업을 해야하는 개발 브랜치에 적합한 방법입니다.\n리뷰 과정에서는 단순히 검토만 받는게 아니라 서로 의견을 주고 받고, 이를 근거로 커밋할 코드를 다시 업데이트하는 작업이 반복됩니다. 마지막에 코드가 검토 과정을 통과하면 코드는 자동으로 저장소에 커밋됩니다. 기본 개념은 이러하더라도 기존 이메일과 버그트랙킹 소프트웨어만으로는 무언가 부족한 부분을 채워주어야 하는데, 실제로 데모 사이트에 접속해서 사용해 보면 코드 변경 사항(diff) 라인 단위로 쉽게 의견(comment)을 달 수 있고, 이 모든 과정이 기록으로 남는 점이 매우 실용적임을 알 수 있습니다.\n아직 알파 1 버전이고 서브버전과 Perforce 등만 지원하지만, 조만간 정식 버전이 나오면 개발팀 프로세스에 한 번 적용해 보고 싶은 생각이 들게 합니다.\n","date":1233619200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1233619200,"objectID":"a5fe0f8e55989fb6f76cb6af4e35c2ae","permalink":"https://lethean.github.io/2009/02/03/review-board/","publishdate":"2009-02-03T00:00:00Z","relpermalink":"/2009/02/03/review-board/","section":"post","summary":"Review Board 는 코드 리뷰(Code Reviews)를 도와주는 웹 기반 소프트웨어입니다. VMware 개발팀에서 사용하는 걸 외부로 공개한 것 같은데, 파이썬으로 작성되었고,","tags":["Agile"],"title":"Review Board 소개","type":"post"},{"authors":null,"categories":null,"content":"\u0026lsquo; Location-aware software comes to the Linux platform \u0026rsquo; 글에서 모바일 위치 정보와 지도 렌더링을 오픈소스 리눅스 플랫폼에서 처리하는 방법을 정리해 놓았는데, 나중을 위해 간략하게 정리해 보았습니다.\n가장 먼저 소개하는 프레임웍은 GeoClue 입니다. GeoClue는 로컬에 장착된 GPS 장치 뿐 아니라 GSMLoc 등과 같은 여러가지 위치 정보를 일종의 표준화된 형식으로 D-Bus를 통해 알려줍니다. (GSMLoc은 이 글을 통해 처음 알게된 건데 GSM 방식 휴대폰의 무선기지국 위치를 측정해 현재 휴대폰의 위치를 판단하는 기법이라고 합니다) GeoClue는 이미 Glib 기반 C API도 제공하고 있기 때문에 이를 이용한 위치 정보 어플리케이션을 개발하면 여러가지 GPS 장치 뿐 아니라 GeoClue 방식을 따르는 다양한 위치 정보를 이용할 수 있다는 장점이 있습니다.\n이렇게 얻어진 위치 정보를 표시하기 위해 가장 관심받고 있는 라이브러리는 libchamplain 입니다. OpenStreetMap이나 OpenAerialMap 같은 인터넷 지도 서버를 이용하면서, 렌더링에는 Clutter 라이브러리를 사용하지만 GTK+ 위젯 기반이기 때문에 쉽게 그놈 / GTK+ 어플리케이션에도 사용이 가능합니다. 이미 그놈 프로젝트의 기본 이미지 보기 프로그램인 EOG에도 플러그인이 추가되었고, 인스턴트 메신저에도 적용되고 있습니다. (예를 들어 iPhone이나 최신 디지털 카메라는 촬영시 GPS 정보를 이미지에 저장하는데, 이를 읽어들여 이미지를 볼때 이미지를 촬영한 장소의 지도 이미지를 함께 보여줍니다. 또한 메신저 친구 목록에서 친구를 클릭하면 현재 친구가 위치한 장소가 어디인지 알려주고 지도에 표시해 주기도 하는 거죠. 허락없이 무단링크한 다음 스크린샷을 확인해 보시길\u0026hellip;)\n참고로, 이 소프트웨어들은 일반 데스크탑이나 서버 뿐 아니라 휴대폰, PDA 등과 같은 모바일 장치에서도 사용할 수 있습니다. 따라서 앞으로는 웹서비스 뿐 아니라 일반 어플리케이션도 위치 정보와 지도 서비스를 활용해 계속 진화하지 않을까 예측해 봅니다.\n","date":1233619200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1233619200,"objectID":"c47c0a105b588e58b41ba371a594497b","permalink":"https://lethean.github.io/2009/02/03/location-aware-softwares-in-linux/","publishdate":"2009-02-03T00:00:00Z","relpermalink":"/2009/02/03/location-aware-softwares-in-linux/","section":"post","summary":"\u0026lsquo; Location-aware software comes to the Linux platform \u0026rsquo; 글에서 모바일 위치 정보와 지도 렌더링을 오픈소스 리눅스 플랫폼에서 처리하는 방법을 정리해 놓았는데, 나중을 위해 간략하게 정리해 보았습니다","tags":["Clutter","GTK+","Linux"],"title":"리눅스에서 위치 인식 소프트웨어","type":"post"},{"authors":null,"categories":null,"content":"\u0026lsquo; Multi-Pointer X Support For GTK+ \u0026rsquo; 기사를 보면 이미 GTK+ 라이브러리에 멀티 포인터 기능을 지원하기 위한 작업이 진행중입니다. 비록 X 서버는 Ubuntu 9.04 버전에 탑재될 1.6 버전에 멀티 포인터 기능이 이미 포함되어 있지만 기본적으로 비활성화되어 있고, 올해 말 즈음에 릴리스할 1.7 버전에 X Input 2.0 스펙과 함께 포함되면서 공식적으로 지원이 될 것 같습니다.\nWindows 7이 멀티 터치 인터페이스를 공식적으로 지원하고, 멀티 터치를 지원하는 LCD 모니터 까지 등장하고 있으니 이제는 일반 데스크탑 GUI 어플리케이션도 멀티 터치를 고려해서 인터페이스가 만들어져야 하겠네요.\n아, 프로그래머의 피곤한 삶이여\u0026hellip;\n","date":1232496000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1232496000,"objectID":"7691c2011cbb8ff8c93d783785f7db92","permalink":"https://lethean.github.io/2009/01/21/mpx-gtk-multi-pointer-x-support/","publishdate":"2009-01-21T00:00:00Z","relpermalink":"/2009/01/21/mpx-gtk-multi-pointer-x-support/","section":"post","summary":"\u0026lsquo; Multi-Pointer X Support For GTK+ \u0026rsquo; 기사를 보면 이미 GTK+ 라이브러리에 멀티 포인터 기능을 지원하기 위한 작업이 진행중입니다. 비록 X 서버는 Ubuntu 9.04 버전에 탑재될 1.6 버전에 멀티 포인터 기능","tags":["GTK+","GUI"],"title":"GTK+ 멀티 포인터 X 지원","type":"post"},{"authors":null,"categories":null,"content":"리눅스에서 VMware 사용시 방향키를 제대로 인식하지 못하고 오동작한다면 다음과 같이 처리하면 됩니다.\n~/.vmware/config 파일이나 /etc/vmware/config 파일에 다음 내용을 추가합니다. (파일이 없다면 새 파일을 만듭니다)\nxkeymap.noKeycodeMap = \u0026quot;TRUE\u0026quot; xkeymap.keycode.93 = 0x076 xkeymap.keycode.97 = 0x073 xkeymap.keycode.98 = 0x078 xkeymap.keycode.99 = 0x077 xkeymap.keycode.100 = 0x079 xkeymap.keycode.101 = 0x070 xkeymap.keycode.102 = 0x07b xkeymap.keycode.103 = 0x05c xkeymap.keycode.104 = 0x11c xkeymap.keycode.105 = 0x11d xkeymap.keycode.106 = 0x135 xkeymap.keycode.107 = 0x137 xkeymap.keycode.108 = 0x138 xkeymap.keycode.109 = 0x000 xkeymap.keycode.110 = 0x147 xkeymap.keycode.111 = 0x148 xkeymap.keycode.112 = 0x149 xkeymap.keycode.113 = 0x14b xkeymap.keycode.114 = 0x14d xkeymap.keycode.115 = 0x14f xkeymap.keycode.116 = 0x150 xkeymap.keycode.117 = 0x151 xkeymap.keycode.118 = 0x152 xkeymap.keycode.119 = 0x153 xkeymap.keycode.120 = 0x16f xkeymap.keycode.121 = 0x120 xkeymap.keycode.122 = 0x12e xkeymap.keycode.123 = 0x130 xkeymap.keycode.124 = 0x15e xkeymap.keycode.125 = 0x059 xkeymap.keycode.126 = 0x14e xkeymap.keycode.127 = 0x100 xkeymap.keycode.128 = 0x000 xkeymap.keycode.129 = 0x07e xkeymap.keycode.130 = 0x000 xkeymap.keycode.131 = 0x000 xkeymap.keycode.132 = 0x07d xkeymap.keycode.133 = 0x15b xkeymap.keycode.134 = 0x15c xkeymap.keycode.135 = 0x15d xkeymap.keycode.136 = 0x168 xkeymap.keycode.146 = 0x131 xkeymap.keycode.148 = 0x121 xkeymap.keycode.150 = 0x15f xkeymap.keycode.151 = 0x163 xkeymap.keycode.160 = 0x10a xkeymap.keycode.163 = 0x16c xkeymap.keycode.164 = 0x166 xkeymap.keycode.165 = 0x16b xkeymap.keycode.166 = 0x16a xkeymap.keycode.167 = 0x169 xkeymap.keycode.171 = 0x119 xkeymap.keycode.172 = 0x122 xkeymap.keycode.173 = 0x110 xkeymap.keycode.174 = 0x124 xkeymap.keycode.180 = 0x132 xkeymap.keycode.181 = 0x167 xkeymap.keycode.191 = 0x05d xkeymap.keycode.192 = 0x05e xkeymap.keycode.193 = 0x05f xkeymap.keycode.199 = 0x133 xkeymap.keycode.220 = 0x10b xkeymap.keycode.225 = 0x165 xkeymap.keycode.234 = 0x16d xkeymap.keycode.244 = 0x109 xkeymap.keycode.246 = 0x157  참고한 문서는 다음과 같습니다.\n  Linux Hosts That Use the evdev Driver for Keyboards Do Not Map Keys Correctly in Any Guest   Keyboard Mapping on a Linux Host   ","date":1232496000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1232496000,"objectID":"0ee4b13b16308494a76f452b57ca7c29","permalink":"https://lethean.github.io/2009/01/21/vmware-arrow-keys-in-linux-host/","publishdate":"2009-01-21T00:00:00Z","relpermalink":"/2009/01/21/vmware-arrow-keys-in-linux-host/","section":"post","summary":"리눅스에서 VMware 사용시 방향키를 제대로 인식하지 못하고 오동작한다면 다음과 같이 처리하면 됩니다. ~/.vmware/config 파일이나 /etc/vmware/config 파일에 다음 내용을 추가합니다. (파일이 없다면 새","tags":["Linux","VMware"],"title":"리눅스에서 VMware 방향키 문제 해결하기","type":"post"},{"authors":null,"categories":null,"content":" (클러터 튜토리얼 내용이 조금 더 남아 있지만 여기까지만 정리할 생각입니다. 나머지는 아직까지 관심 밖이라서\u0026hellip; 아무튼 클러터 API 문서 는 대강이라도 한 번 훑어봐야 더 정확하게 사용할 수 있을 것 같습니다)\n클러터가 제공하는 액터만으로 뭔가 부족함을 느낀다면 이제 직접 새로운 액터를 구현할 때입니다. 새로운 액터를 구현하는 작업은 GTK+ 위젯처럼 GObject 기반 객체를 만드는 과정과 거의 비슷합니다. 제일 먼저 G_DEFINE_TYPE() 매크로를 이용해 ClutterActor 파생 객체를 정의합니다. 예를 들어 새로운 객체 이름이 ClutterTriangle이라면 다음과 같습니다.\nG_DEFINE_TYPE (ClutterTriangle, clutter_triangle, CLUTTER_TYPE_ACTOR);  그리고 ClutterActor::paint() 가상 함수를 구현합니다.\nstatic void clutter_triangle_class_init (ClutterTriangleClass *klass) { ClutterActorClass *actor_class = CLUTTER_ACTOR_CLASS (klass); actor_class-\u0026gt;paint = clutter_triangle_paint; ... }  기본적인 액터 정보는 ClutterActor 기본 클래스에서 얻을 수 있습니다. 가령 clutter_actor_get_geometry() 함수로 좌표와 크기를 얻을 수 있고, clutter_actor_get_opacity() 함수로 불투명도를 얻을 수 있습니다.\nClutterActor::paint() 함수에서 실제 그리기 작업을 구현할때는 OpenGL API를 사용해야 합니다. OpenGL ES나 일반적인 OpenGL 환경에서 문제없이 동작하게 하려면 클러터에서 제공하는 COGL API를 사용합니다. 예를 들면 cogl_rectangle() 이나 cogl_push_matrix() 등이 그것입니다.\n그리기 함수와 더불어 지정한 색상으로 실루엣(silhouette)을 그려주는 ClutterActor::pick() 가상 함수도 구현해야 합니다. 클러터는 이 함수를 이용해 스크린외영역(offscreen)에 단일한 색상으로 모든 액터의 실루엣을 그려 놓은 뒤 커서가 위치한 좌표의 액터가 무엇인지 확인하는데 사용합니다. 따라서 새로운 액터가 단순하다면 그리기 함수에서 사용한 코드를 그대로 사용해도 됩니다.\n나머지 대부분의 가상 함수는 필요한 경우에만 다시 구현하면 됩니다.\n다음 예제는 삼각형을 그려주는 액터를 구현한 코드입니다.\n파일 : triangle-actor.h\n#ifndef _CLUTTER_TUTORIAL_TRIANGLE_ACTOR_H #define _CLUTTER_TUTORIAL_TRIANGLE_ACTOR_H #include \u0026lt;glib-object.h\u0026gt; #include \u0026lt;clutter/clutter-actor.h\u0026gt; #include \u0026lt;clutter/clutter-color.h\u0026gt; G_BEGIN_DECLS #define CLUTTER_TYPE_TRIANGLE clutter_triangle_get_type() #define CLUTTER_TRIANGLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), CLUTTER_TYPE_TRIANGLE, ClutterTriangle)) #define CLUTTER_TRIANGLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), CLUTTER_TYPE_TRIANGLE, ClutterTriangleClass)) #define CLUTTER_IS_TRIANGLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CLUTTER_TYPE_TRIANGLE)) #define CLUTTER_IS_TRIANGLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), CLUTTER_TYPE_TRIANGLE)) #define CLUTTER_TRIANGLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), CLUTTER_TYPE_TRIANGLE, ClutterTriangleClass)) typedef struct _ClutterTriangle ClutterTriangle; typedef struct _ClutterTriangleClass ClutterTriangleClass; typedef struct _ClutterTrianglePrivate ClutterTrianglePrivate; struct _ClutterTriangle { ClutterActor parent; /*\u0026lt; private \u0026gt;*/ ClutterTrianglePrivate *priv; }; struct _ClutterTriangleClass { ClutterActorClass parent_class; }; GType clutter_triangle_get_type (void) G_GNUC_CONST; ClutterActor *clutter_triangle_new (void); ClutterActor *clutter_triangle_new_with_color (const ClutterColor *color); void clutter_triangle_get_color (ClutterTriangle *triangle, ClutterColor *color); void clutter_triangle_set_color (ClutterTriangle *triangle, const ClutterColor *color); G_END_DECLS #endif  파일 : triangle-actor.c\n#include \u0026quot;triangle_actor.h\u0026quot; #include \u0026lt;cogl/cogl.h\u0026gt; G_DEFINE_TYPE (ClutterTriangle, clutter_triangle, CLUTTER_TYPE_ACTOR); enum { PROP_0, PROP_COLOR }; #define CLUTTER_TRIANGLE_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), CLUTTER_TYPE_TRIANGLE, ClutterTrianglePrivate)) struct _ClutterTrianglePrivate { ClutterColor color; }; static void do_triangle_paint (ClutterActor *self, const ClutterColor *color) { ClutterTriangle *triangle = CLUTTER_TRIANGLE(self); ClutterTrianglePrivate *priv; ClutterGeometry geom; ClutterFixed coords[6]; triangle = CLUTTER_TRIANGLE(self); priv = triangle-\u0026gt;priv; cogl_push_matrix(); clutter_actor_get_geometry (self, \u0026amp;geom); cogl_color (color); /* Paint a triangle: * * The parent paint call will have translated us into position so * paint from 0, 0 */ coords[0] = CLUTTER_INT_TO_FIXED (0); coords[1] = CLUTTER_INT_TO_FIXED (0); coords[2] = CLUTTER_INT_TO_FIXED (0); coords[3] = CLUTTER_INT_TO_FIXED (geom.height); coords[4] = CLUTTER_INT_TO_FIXED (geom.width); coords[5] = CLUTTER_INT_TO_FIXED (geom.height); cogl_path_polygon (coords, 3); cogl_path_fill (); cogl_pop_matrix(); } static void clutter_triangle_paint (ClutterActor *self) { ClutterTriangle *triangle = CLUTTER_TRIANGLE(self); ClutterTrianglePrivate *priv = triangle-\u0026gt;priv; /* Paint the triangle with the actor's color: */ ClutterColor color; color.red = priv-\u0026gt;color.red; color.green = priv-\u0026gt;color.green; color.blue = priv-\u0026gt;color.blue; color.alpha = clutter_actor_get_opacity (self); do_triangle_paint (self, \u0026amp;color); } static void clutter_triangle_pick (ClutterActor *self, const ClutterColor *color) { /* Paint the triangle with the pick color, offscreen. This is used by Clutter to detect the actor under the cursor by identifying the unique color under the cursor. */ do_triangle_paint (self, color); } static void clutter_triangle_set_property (GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec) { ClutterTriangle *triangle = CLUTTER_TRIANGLE(object); switch (prop_id) { case PROP_COLOR: clutter_triangle_set_color (triangle, g_value_get_boxed (value)); break; default: G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec); break; } } static void clutter_triangle_get_property (GObject *object, guint prop_id, GValue *value, GParamSpec *pspec) { ClutterTriangle *triangle = CLUTTER_TRIANGLE(object); ClutterColor color; switch (prop_id) { case PROP_COLOR: clutter_triangle_get_color (triangle, \u0026amp;color); g_value_set_boxed (value, \u0026amp;color); break; default: G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec); break; } } static void clutter_triangle_finalize (GObject *object) { G_OBJECT_CLASS (clutter_triangle_parent_class)-\u0026gt;finalize (object); } static void clutter_triangle_dispose (GObject *object) { G_OBJECT_CLASS (clutter_triangle_parent_class)-\u0026gt;dispose (object); } static void clutter_triangle_class_init (ClutterTriangleClass *klass) { GObjectClass *gobject_class = G_OBJECT_CLASS (klass); ClutterActorClass *actor_class = CLUTTER_ACTOR_CLASS (klass); /* Provide implementations for ClutterActor vfuncs: */ actor_class-\u0026gt;paint = clutter_triangle_paint; actor_class-\u0026gt;pick = clutter_triangle_pick; gobject_class-\u0026gt;finalize = clutter_triangle_finalize; gobject_class-\u0026gt;dispose = clutter_triangle_dispose; gobject_class-\u0026gt;set_property = clutter_triangle_set_property; gobject_class-\u0026gt;get_property = clutter_triangle_get_property; /** * ClutterTriangle:color: * * The color of the triangle. */ g_object_class_install_property (gobject_class, PROP_COLOR, g_param_spec_boxed (\u0026quot;color\u0026quot;, \u0026quot;Color\u0026quot;, \u0026quot;The color of the triangle\u0026quot;, CLUTTER_TYPE_COLOR, G_PARAM_READABLE | G_PARAM_WRITABLE)); g_type_class_add_private (gobject_class, sizeof (ClutterTrianglePrivate)); } static void clutter_triangle_init (ClutterTriangle *self) { ClutterTrianglePrivate *priv; self-\u0026gt;priv = priv = CLUTTER_TRIANGLE_GET_PRIVATE (self); priv-\u0026gt;color.red = 0xff; priv-\u0026gt;color.green = 0xff; priv-\u0026gt;color.blue = 0xff; priv-\u0026gt;color.alpha = 0xff; } /** * clutter_triangle_new: * * Creates a new #ClutterActor with a rectangular shape. * * Return value: a new #ClutterActor */ ClutterActor* clutter_triangle_new (void) { return g_object_new (CLUTTER_TYPE_TRIANGLE, NULL); } /** * clutter_triangle_new_with_color: * @color: a #ClutterColor * * Creates a new #ClutterActor with a rectangular shape * and with @color. * * Return value: a new #ClutterActor */ ClutterActor * clutter_triangle_new_with_color (const ClutterColor *color) { return g_object_new (CLUTTER_TYPE_TRIANGLE, \u0026quot;color\u0026quot;, color, NULL); } /** * clutter_triangle_get_color: * @triangle: a #ClutterTriangle * @color: return location for a #ClutterColor * * Retrieves the color of @triangle. */ void clutter_triangle_get_color (ClutterTriangle *triangle, ClutterColor *color) { ClutterTrianglePrivate *priv; g_return_if_fail (CLUTTER_IS_TRIANGLE (triangle)); g_return_if_fail (color != NULL); priv = triangle-\u0026gt;priv; color-\u0026gt;red = priv-\u0026gt;color.red; color-\u0026gt;green = priv-\u0026gt;color.green; color-\u0026gt;blue = priv-\u0026gt;color.blue; color-\u0026gt;alpha = priv-\u0026gt;color.alpha; } /** * clutter_triangle_set_color: * @triangle: a #ClutterTriangle * @color: a #ClutterColor * * Sets the color of @triangle. */ void clutter_triangle_set_color (ClutterTriangle *triangle, const ClutterColor *color) { ClutterTrianglePrivate *priv; g_return_if_fail (CLUTTER_IS_TRIANGLE (triangle)); g_return_if_fail (color != NULL); g_object_ref (triangle); priv = triangle-\u0026gt;priv; priv-\u0026gt;color.red = color-\u0026gt;red; priv-\u0026gt;color.green = color-\u0026gt;green; priv-\u0026gt;color.blue = color-\u0026gt;blue; priv-\u0026gt;color.alpha = color-\u0026gt;alpha; clutter_actor_set_opacity (CLUTTER_ACTOR (triangle), priv-\u0026gt;color.alpha); if (CLUTTER_ACTOR_IS_VISIBLE (CLUTTER_ACTOR (triangle))) clutter_actor_queue_redraw (CLUTTER_ACTOR (triangle)); g_object_notify (G_OBJECT (triangle), \u0026quot;color\u0026quot;); g_object_unref (triangle); }  테스트 프로그램은 다음과 같습니다.\n#include \u0026lt;clutter/clutter.h\u0026gt; #include \u0026quot;triangle_actor.h\u0026quot; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv[]) { ClutterColor stage_color = { 0x00, 0x00, 0x00, 0xff }; ClutterColor actor_color = { 0xff, 0xff, 0xff, 0x99 }; clutter_init (\u0026amp;argc, \u0026amp;argv); /* Get the stage and set its size and color: */ ClutterActor *stage = clutter_stage_get_default (); clutter_actor_set_size (stage, 200, 200); clutter_stage_set_color (CLUTTER_STAGE (stage), \u0026amp;stage_color); /* Add our custom actor to the stage: */ ClutterActor *actor = clutter_triangle_new_with_color (\u0026amp;actor_color); clutter_actor_set_size (actor, 100, 100); clutter_actor_set_position (actor, 20, 20); clutter_container_add_actor (CLUTTER_CONTAINER (stage), actor); clutter_actor_show (actor); /* Show the stage: */ clutter_actor_show (stage); /* Start the main loop, so we can respond to events: */ clutter_main (); return EXIT_SUCCESS; }  ","date":1232064000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1232064000,"objectID":"dbf1ca48987dfdcac529e51666ae6b6e","permalink":"https://lethean.github.io/2009/01/16/implementing-clutter-actors/","publishdate":"2009-01-16T00:00:00Z","relpermalink":"/2009/01/16/implementing-clutter-actors/","section":"post","summary":"(클러터 튜토리얼 내용이 조금 더 남아 있지만 여기까지만 정리할 생각입니다. 나머지는 아직까지 관심 밖이라서\u0026hellip; 아무튼 클러터 API 문서 는 대강이라도","tags":["Clutter"],"title":"Clutter 액터 구현하기 (Implementing Actors)","type":"post"},{"authors":null,"categories":null,"content":" 클러터 튜토리얼 계속 이어집니다.\n**효과(Effects) - 자연스러운 애니메이션 **\n클러터는 애니메이션을 쉽게 구현하기 위해 효과(effect) 기능을 제공합니다. 시간에 따라 하나의 액터 속성을 변경하기 위해 타임라인과 간단한 숫자 계산을 이용한 여러가지 효과(effect) 함수 를 이용할 수 있습니다. 예를 들어 clutter_effect_fade() 는 액터의 불투명도(opacity)를 단계적으로 변화시키고, clutter_effect_rotate() 는 단계적으로 액터를 회전시키는데(rotate), 이때 불투명도와 회전도는 프로그래머가 등록하는 alpha_func 콜백을 호출해서 계산합니다.\n효과 기능을 사용하려면 제일 먼저 clutter_effect_template_new() 를 이용하여 ClutterEffectTemplate 객체를 하나 만들어야 합니다. 이때 타임라인 객체와 ClutterAlphaFunc 형태의 콜백을 함께 지정해야 합니다. 이 콜백은 clutter_alpha_get_timeline() 을 호출해서 타임라인 객체를 얻은 뒤, 현재 프레임 번호( clutter_timeline_get_current_frame() )와 총 프레임 수( clutter_timeline_get_n_frames() )를 기반으로 알파값을 계산하여 반환하면 됩니다. 반환하는 값은 0과 CLUTTER_ALPHA_MAX_ALPHA 사이의 값이어야 하며, 이 값의 의미는 사용하는 효과에 따라 다릅니다. 예를 들어 clutter_effect_fade() 를 사용할때 CLUTTER_ALPHA_MAX_ALPHA 값은 불투명도 100%를 의미합니다. 물론 모든 계산을 직접 할 수도 있지만 CLUTTER_ALPHA_SINE 처럼 미리 정의된 콜백 함수를 이용하면 쉽게 자연스러운 움직임을 얻을 수 있습니다. 다음 그림은 미리 정의된 몇가지 알파 콜백 함수가 반환하는 값을 그래프로 표현한 것입니다.\n이렇게 만들어진 ClutterEffectTemplate 객체를 사용하려는 clutter_effect_*() 함수를 호출하면서 전달하면 됩니다.\n여러가지 타임라인을 여러가지 효과와 사용할때는 clutter_effect_template_set_timeline_clone() 을 이용하여 타임라인을 복제하도록 하면, 원본 타임라인을 변경해서 다른 효과에 사용할 수 있으므로, 다른 효과에 영향을 주지 않고 쉽게 재활용이 가능합니다. ClutterTimeline 객체와 마찬가지로 ClutterEffectTemplate 객체도 사용이 끝난후 g_object_unref()를 이용하여 리소스를 해제해야 합니다. 참고로, 효과 함수를 호출한 이후 템플릿을 더 이상 사용하지 않는다면 바로 해제해도 됩니다.\n효과 함수는 실제로 ClutterBehaviour 객체를 감싼 단순화된 API라고 말할 수 있습니다. 하지만 효과 함수는 한 번에 하나의 액터만 제어할 수 있고 타임라인이 실행중인 동안에는 효과를 변경할 수 없습니다. 이러한 단점을 피하고 더 복잡한 효과를 원한다면 움직임(Behaviours) 객체를 직접 사용해야 합니다.\n움직임(Behaviours) - 더 자연스럽고 강력한 애니메이션\n효과 기능은 간단하지만, 더 복잡하고 다양한 애니메이션을 제어하기에는 부족하기 때문에 가끔은 움직임(Behaviours) 객체를 직접 사용해야 하는 경우가 있습니다. 효과 함수와 달리 움직임 객체를 사용하면 여러 액터를 동시에 제어할 수 있고 타임라인이 실행중이라도 움직임 파라메터를 변경할 수 있습니다. 예를 들어 ClutterBehaviourPath 는 액터를 지정한 경로(path)를 따라 움직이는데, 매 프레임마다 alpha_func 콜백을 호출해서 경로상의 위치를 계산합니다. 다음 그림은 경로 상에서 알파 함수의 효과를 그래프로 표현한 것입니다.\n콜백 함수 동작 방식은 효과(effect) 함수에서 사용하는 것과 동일합니다.\n타임라인이 무한루프 방식으로 동작하지 않을 경우, 움직임(behaviour)의 타임라인이 시작되면 움직임은 항상 마지막 점에 도달한 뒤 거기서 끝납니다. 예를 들자면, 액터는 타임라인에서 지정한 총 프레임 수와 초당 프레임 수에서 지정한 만큼 변경되면서 마지막 지점에 도달할때까지 경로를 따라 움직입니다.\n액터와 마찬가지로 ClutterAlpha 객체도 부동 참조(floating reference)를 가지고 있으므로 움직임 객체에 더한 다음에 따로 리소스를 해제할 필요가 없습니다. 하지만 움직임 객체는 아니므로 사용이 끝난 뒤에 g_object_unref()를 이용하여 리소스를 해제해야 합니다.\n클러터에서 제공하는 기본 움직임은 다음과 같습니다.\n  ClutterBehaviourBspline : 스플라인을 따라 액터가 이동  ClutterBehaviourDepth : Z축을 따라 액터가 이동  ClutterBehaviourEllipse : 타원을 따라 액터가 이동  ClutterBehaviourOpacity : 액터의 불투명도 변화  ClutterBehaviourPath : 일련의 점으로 정의된 경로를 따라 액터가 이동  ClutterBehaviourRotate : 액터가 회전  ClutterBehaviourScale : 액터가 확대 또는 축소  ","date":1232064000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1232064000,"objectID":"335f6faa8fa43fbb56a30eb12fe61270","permalink":"https://lethean.github.io/2009/01/16/using-clutter-5/","publishdate":"2009-01-16T00:00:00Z","relpermalink":"/2009/01/16/using-clutter-5/","section":"post","summary":"클러터 튜토리얼 계속 이어집니다. **효과(Effects) - 자연스러운 애니메이션 ** 클러터는 애니메이션을 쉽게 구현하기 위해 효과(effect) 기능","tags":["Clutter"],"title":"클러터(Clutter) 사용하기 (5)","type":"post"},{"authors":null,"categories":null,"content":"지금까지 예제가 단편적이라면 이번에는 조금 제대로 된 기능하는 코드입니다. 이 예제는 이미지 파일을 읽어들여 타원 주위로 회전시키며 보여줍니다. 사용자가 이미지를 클릭하면 맨 앞으로 오면서 확대되면서 파일 이름도 보여줍니다. 먼저 스크린샷부터.\n여러 타임라인과 움직임 객체를 이용해서 조금 복잡해 보이지만, 아마도 실제 어플리케이션은 이보다 훨씬 더 유연하고 기능적으로 동작해야겠지요. 주석을 우리말로 번역하고, 원본보다 조금 더 속도감있게 변경한 소스는 다음과 같습니다. (조금 길지요\u0026hellip;)\n#include \u0026lt;clutter/clutter.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; static ClutterActor *stage = NULL; /* 파일 이름을 보여주기 위한 레이블 액터 */ static ClutterActor *label_filename = NULL; /* 모든 이미지를 타원 주위로 회전화기 위한 타임라인 */ static ClutterTimeline *timeline_rotation = NULL; /* 이미지 하나를 위로 올리고 확대하기 위한 타임라인과 움직임 객체 */ static ClutterTimeline *timeline_moveup = NULL; static ClutterBehaviour *behaviour_scale = NULL; static ClutterBehaviour *behaviour_path = NULL; static ClutterBehaviour *behaviour_opacity = NULL; /* 이미지 목록을 보여줄 타원의 좌표와 크기 */ static const gint ELLIPSE_Y = 390; static const gint ELLIPSE_HEIGHT = 450; /* 90도 회전된 상태에서 앞뒤 거리 */ static const gint IMAGE_HEIGHT = 100; static double angle_step = 30; typedef struct _Item { ClutterActor *actor; ClutterBehaviour *ellipse_behaviour; gchar* filepath; } Item; /* 맨 앞으로 오게 할 이미지 항목 */ static Item *item_at_front = NULL; static GSList *list_items = NULL; static void rotate_all_until_item_is_at_front (Item *item); static gdouble angle_in_360 (gdouble angle) { gdouble result = angle; while (result \u0026gt;= 360) result -= 360; return result; } static void on_foreach_clear_list_items (gpointer data, gpointer user_data) { Item* item = (Item*)data; /* 액터는 스테이지가 없어질때 자동으로 정리되므로 해제할 필요가 없습니다. */ g_object_unref (item-\u0026gt;ellipse_behaviour); g_free (item-\u0026gt;filepath); g_free (item); } static void scale_texture_default (ClutterActor *texture) { int pixbuf_height = 0; /* 이미지의 세로 크기를 얻습니다. */ clutter_texture_get_base_size (CLUTTER_TEXTURE (texture), NULL, \u0026amp;pixbuf_height); const gdouble scale = pixbuf_height ? IMAGE_HEIGHT / (gdouble)pixbuf_height : 0; /* 기준 높이에 맞게 스케일링합니다. */ clutter_actor_set_scale (texture, scale, scale); } static void load_images (const gchar* directory_path) { g_return_if_fail (directory_path); /* 현재 이미지 목록을 비웁니다. */ g_slist_foreach (list_items, on_foreach_clear_list_items, NULL); g_slist_free (list_items); /* 새로운 목록을 초기화합니다. */ list_items = NULL; /* 디렉토리에 있는 이미지 목록을 얻습니다. */ GError *error = NULL; GDir* dir = g_dir_open (directory_path, 0, \u0026amp;error); if (error) { g_warning (\u0026quot;g_dir_open() failed: %sn\u0026quot;, error-\u0026gt;message); g_clear_error (\u0026amp;error); return; } const gchar* filename = NULL; while ((filename = g_dir_read_name(dir))) { gchar* path = g_build_filename (directory_path, filename, NULL); /* 이미지 파일로부터 텍스쳐 액터를 만듭니다. */ ClutterActor *actor = clutter_texture_new_from_file (path, NULL); if (actor) { Item* item = g_new0 (Item, 1); item-\u0026gt;actor = actor; item-\u0026gt;filepath = g_strdup (path); /* 모든 이미지가 같은 높이가 되도록 스케일링합니다. */ scale_texture_default (item-\u0026gt;actor); list_items = g_slist_append (list_items, item); } g_free (path); } g_dir_close (dir); } static gboolean on_texture_button_press (ClutterActor *actor, ClutterEvent *event, gpointer user_data) { /* 이미지 회전 타임라인이 실행중이면 이벤트를 무시합니다. * 즉, 이미지가 움직이고 있는 도중에 발생하는 마우스 버튼 클릭을 무시합니다. */ if (timeline_rotation \u0026amp;\u0026amp; clutter_timeline_is_playing (timeline_rotation)) { printf (\u0026quot;on_texture_button_press(): ignoringn\u0026quot;); return FALSE; } Item *item = (Item *) user_data; /* 선택한 아이템이 맨 앞에 올때까지 이미지 목록을 회전시킵니다. */ rotate_all_until_item_is_at_front (item); return TRUE; } static void add_to_ellipse_behaviour (ClutterTimeline *timeline_rotation, gdouble start_angle, Item *item) { g_return_if_fail (timeline_rotation); ClutterAlpha *alpha = clutter_alpha_new_full (timeline_rotation, CLUTTER_ALPHA_SINE_INC, NULL, NULL); /* 타원을 따라 동작할 움직임 객체를 만듭니다. */ item-\u0026gt;ellipse_behaviour = clutter_behaviour_ellipse_new (alpha, 320, ELLIPSE_Y, ELLIPSE_HEIGHT, ELLIPSE_HEIGHT, CLUTTER_ROTATE_CW, angle_in_360 (start_angle), angle_in_360 (start_angle + 360)); /* X축 기준으로 타원의 축 기울입니다. */ clutter_behaviour_ellipse_set_angle_tilt ( CLUTTER_BEHAVIOUR_ELLIPSE (item-\u0026gt;ellipse_behaviour), CLUTTER_X_AXIS, -90); /* ClutterAlpha 객체는 따로 해제할 필요가 없습니다. */ /* 액터에 움직임을 적용합니다. */ clutter_behaviour_apply (item-\u0026gt;ellipse_behaviour, item-\u0026gt;actor); } static void add_image_actors (void) { int x = 20; int y = 0; gdouble angle = 0; GSList *list = list_items; /* 이미지 갯수로 회전시 이미지 간격을 계산합니다. */ if (list) angle_step = 360 / g_slist_length (list); while (list) { /* 이미지 액터를 스테이지에 넣습니다. */ Item *item = (Item *) list-\u0026gt;data; ClutterActor *actor = item-\u0026gt;actor; clutter_container_add_actor (CLUTTER_CONTAINER (stage), actor); /* 초기 좌표를 지정합니다. */ clutter_actor_set_position (actor, x, y); y += 100; /* 기본적으로 스테이지만 이벤트를 발생할 수 있으므로, * 액터도 이벤트를 발생할 수 있게 합니다. */ clutter_actor_set_reactive (actor, TRUE); /* 버튼 클릭 시그널에 핸들러 함수를 연결합니다. */ g_signal_connect (actor, \u0026quot;button-press-event\u0026quot;, G_CALLBACK (on_texture_button_press), item); /* 타원 액터에 움직임을 추가합니다. */ add_to_ellipse_behaviour (timeline_rotation, angle, item); angle += angle_step; clutter_actor_show (actor); list = g_slist_next (list); } } /* 이 기그널 핸들러는 선택한 이미지가 확대되어 위로 이동하는 타임라인이 * 완료되었을때 호출됩니다. */ static void on_timeline_moveup_completed (ClutterTimeline* timeline, gpointer user_data) { /* 타임라인 객체를 해제합니다. */ g_object_unref (timeline_moveup); timeline_moveup = NULL; g_object_unref (behaviour_scale); behaviour_scale = NULL; g_object_unref (behaviour_path); behaviour_path = NULL; g_object_unref (behaviour_opacity); behaviour_opacity = NULL; } /* 이 시그널 핸들러는 이미지가 타원을 따라 회전하는 타임라인이 완료되었을때 * 호출됩니다. */ static void on_timeline_rotation_completed (ClutterTimeline* timeline, gpointer user_data) { /* 모든 이미지가 회전하다가 클릭한 이미지가 맨 앞에 온 상태입니다. * 이제 맨 앞의 이미지를 크게 보여주고 파일 이름도 표시합니다. */ /* 이미지를 변형합니다. */ ClutterActor *actor = item_at_front-\u0026gt;actor; timeline_moveup = clutter_timeline_new(15 /* frames */, 30 /* frames per second */); ClutterAlpha *alpha = clutter_alpha_new_full (timeline_moveup, CLUTTER_ALPHA_SINE_INC, NULL, NULL); /* 현재 크기에서 약 2배 크기로 확대합니다. */ gdouble scale_start = 0; clutter_actor_get_scale (actor, \u0026amp;scale_start, NULL); const gdouble scale_end = scale_start * 1.8; behaviour_scale = clutter_behaviour_scale_new (alpha, scale_start, scale_start, scale_end, scale_end); clutter_behaviour_apply (behaviour_scale, actor); /* 그림을 위 방향을 이동합니다. */ ClutterKnot knots[2]; knots[0].x = clutter_actor_get_x (actor); knots[0].y = clutter_actor_get_y (actor); knots[1].x = knots[0].x; knots[1].y = knots[0].y - 250; behaviour_path = clutter_behaviour_path_new (alpha, knots, G_N_ELEMENTS(knots)); clutter_behaviour_apply (behaviour_path, actor); /* 파일 이름을 조금씩 보여줍니다. */ clutter_label_set_text (CLUTTER_LABEL (label_filename), item_at_front-\u0026gt;filepath); behaviour_opacity = clutter_behaviour_opacity_new (alpha, 0, 255); clutter_behaviour_apply (behaviour_opacity, label_filename); /* 모든 움직임(behaviours)을 시작합니다. * 또한 완료되었을때 핸들러를 연결합니다. */ g_signal_connect (timeline_moveup, \u0026quot;completed\u0026quot;, G_CALLBACK (on_timeline_moveup_completed), NULL); clutter_timeline_start (timeline_moveup); } static void rotate_all_until_item_is_at_front (Item *item) { g_return_if_fail (item); clutter_timeline_stop(timeline_rotation); /* 선택한 이미지를 위로 올려 보여주는 타임라인이 동작중이라면 * 당장 멈추게 합니다. */ if (timeline_moveup) clutter_timeline_stop (timeline_moveup); clutter_actor_set_opacity (label_filename, 0); /* 선택한 이미지 항목의 번호를 얻습니다. */ const gint pos = g_slist_index (list_items, item); g_assert (pos != -1); if (!item_at_front \u0026amp;\u0026amp; list_items) item_at_front = (Item *) list_items-\u0026gt;data; /* 현재 맨 앞에 있는 항목의 번호를 얻습니다. */ gint pos_front = 0; if (item_at_front) pos_front = g_slist_index (list_items, item_at_front); g_assert (pos_front != -1); /* 첫번째 항목의 시작 / 끝 각도를 계산합니다. */ const gdouble angle_front = 180; gdouble angle_start = angle_front - (angle_step * pos_front); angle_start = angle_in_360 (angle_start); gdouble angle_end = angle_front - (angle_step * pos); gdouble angle_diff = 0; /* 모든 이미지 항목의 끝 각도를 설정합니다. */ GSList *list = list_items; while (list) { Item *this_item = (Item*)list-\u0026gt;data; /* 이미지 크기를 원래대로 되돌립니다. */ scale_texture_default (this_item-\u0026gt;actor); angle_start = angle_in_360 (angle_start); angle_end = angle_in_360 (angle_end); /* 현재 맨 앞 있는 항목일 경우 360도 더 회전하게 함니다. */ if (item_at_front == item) angle_end += 360; angle_end = angle_in_360 (angle_end); clutter_behaviour_ellipse_set_angle_start ( CLUTTER_BEHAVIOUR_ELLIPSE (this_item-\u0026gt;ellipse_behaviour), angle_start); clutter_behaviour_ellipse_set_angle_end ( CLUTTER_BEHAVIOUR_ELLIPSE (this_item-\u0026gt;ellipse_behaviour), angle_end); /* 선택한 항목일 경우 */ if (this_item == item) { if (angle_start \u0026lt; angle_end) angle_diff = angle_end - angle_start; else angle_diff = 360 - (angle_start - angle_end); } /* TODO: Set the number of frames, depending on the angle. * otherwise the actor will take the same amount of time to reach * the end angle regardless of how far it must move, causing it to * move very slowly if it does not have far to move. */ angle_end += angle_step; angle_start += angle_step; list = g_slist_next (list); } /* 속도는 같지만 이동해야 할 거리만큼 프레임 수를 조절합니다. */ gint pos_to_move = 0; if (pos_front \u0026lt; pos) { const gint count = g_slist_length (list_items); pos_to_move = count + (pos - pos_front); } else { pos_to_move = pos_front - pos; } clutter_timeline_set_n_frames (timeline_rotation, angle_diff / 5); /* 타임라인이 끝난뒤 맨 앞에 위치해야할 항목을 기억합니다. */ item_at_front = item; clutter_timeline_start (timeline_rotation); } int main (int argc, char *argv[]) { ClutterColor stage_color = { 0xB0, 0xB0, 0xB0, 0xff }; /* light gray */ clutter_init (\u0026amp;argc, \u0026amp;argv); /* 스테이지를 얻어 크기와 색상을 정합니다. */ stage = clutter_stage_get_default (); clutter_actor_set_size (stage, 800, 600); clutter_stage_set_color (CLUTTER_STAGE (stage), \u0026amp;stage_color); /* 파일 이름을 보여주기 위한 레이블 액터를 만들고, 일단 안보이게 합니다. */ label_filename = clutter_label_new (); ClutterColor label_color = { 0x60, 0x60, 0x90, 0xff }; /* blueish */ clutter_label_set_color (CLUTTER_LABEL (label_filename), \u0026amp;label_color); clutter_label_set_font_name (CLUTTER_LABEL (label_filename), \u0026quot;Sans 24\u0026quot;); clutter_actor_set_position (label_filename, 10, 10); clutter_actor_set_opacity (label_filename, 0); /* hidden */ clutter_container_add_actor (CLUTTER_CONTAINER (stage), label_filename); clutter_actor_show (label_filename); /* 이미지 목록 밑에 보여줄 사각형을 만듭니다. */ ClutterColor rect_color = { 0xff, 0xff, 0xff, 0xff }; /* white */ ClutterActor *rect = clutter_rectangle_new_with_color (\u0026amp;rect_color); clutter_actor_set_height (rect, ELLIPSE_HEIGHT + 20); clutter_actor_set_width (rect, clutter_actor_get_width (stage) + 100); /* 사각형을 이미지 목록 밑에 위치하도록 합니다. */ clutter_actor_set_position (rect, -(clutter_actor_get_width (rect) - clutter_actor_get_width (stage)) / 2, ELLIPSE_Y + IMAGE_HEIGHT - (clutter_actor_get_height (rect) / 2)); /* X축을 기준으로 사각형을 눕힙니다. */ clutter_actor_set_rotation (rect, CLUTTER_X_AXIS, -90, 0, (clutter_actor_get_height (rect) / 2), 0); clutter_container_add_actor (CLUTTER_CONTAINER (stage), rect); clutter_actor_show (rect); /* 스테이지를 보이게 합니다. */ clutter_actor_show (stage); /** 이미지를 회전시킬 타임라인을 만들고, * 회전이 끝났을때 실행할 핸들러를 연결합니다. */ timeline_rotation = clutter_timeline_new(60 /* frames */, 30 /* frames per second */); g_signal_connect (timeline_rotation, \u0026quot;completed\u0026quot;, G_CALLBACK (on_timeline_rotation_completed), NULL); /* 이미지를 로드하고 각각에 대한 액터를 만듭니다. */ load_images (\u0026quot;./images/\u0026quot;); add_image_actors (); /* clutter_timeline_set_loop(timeline_rotation, TRUE); */ /* 첫번째 이미지가 선택된 것처럼 회전을 시작합니다. */ if (list_items) rotate_all_until_item_is_at_front ((Item*)list_items-\u0026gt;data); /* 메인 이벤트 루프를 시작합니다. */ clutter_main (); /* 모든 이미지 목록을 해제합니다. */ g_slist_foreach(list_items, on_foreach_clear_list_items, NULL); g_slist_free (list_items); g_object_unref (timeline_rotation); return EXIT_SUCCESS; }  ","date":1232064000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1232064000,"objectID":"c81a2f0b119e4505379799e407545113","permalink":"https://lethean.github.io/2009/01/16/using-clutter-6/","publishdate":"2009-01-16T00:00:00Z","relpermalink":"/2009/01/16/using-clutter-6/","section":"post","summary":"지금까지 예제가 단편적이라면 이번에는 조금 제대로 된 기능하는 코드입니다. 이 예제는 이미지 파일을 읽어들여 타원 주위로 회전시키며 보여줍니다. 사용자가 이미지","tags":["Clutter"],"title":"클러터(Clutter) 사용하기 (6)","type":"post"},{"authors":null,"categories":null,"content":" 클러터 튜토리얼 내용을 계속 정리해 봅니다.\n액터 (Actors) - 배우\n클러터는 3차원 공간 속에서 2차원 표면(surfaces)을 다루는 캔버스 API입니다. 그래서, 기본 클러터 액터는 2차원 도형이지만 좌표는 3차원입니다. 하지만, 깊이(depth) 개념은 없습니다. 따라서 액터 테두리만 정면 화면에 걸치도록 정확하게 회전되었다면 이론적으로 안보이게 됩니다. 복잡한 3차원 객체가 필요하다면 OpenGL ES API를 이용해 새로운 액터를 구현해도 되지만, 이 방법은 나중에 살펴보기로 하고 여기서는 기본 액터 종류를 살펴보겠습니다.\n  ClutterStage : 무대 자체  ClutterRectangle : 사각형  ClutterLabel : 텍스트 표시하기  ClutterEntry : 사용자 편집 가능한 텍스트  ClutterTexture : 이미지  액터는 clutter_container_add()를 이용하여 스테이지에 추가할 수 있습니다. 물론 위치와 크기가 명시되어야 합니다. 모든 액터는 ClutterActor 객체에서 파생하므로 clutter_actor_set_position() 을 이용해 x,y 좌표를 설정하고 clutter_actor_set_depth() 를 이용해 z 좌표를 설정합니다. z 좌표값이 클수록 화면에서 멀어집니다. clutter_actor_set_size() 는 액터의 크기를 조절합니다. 액터의 위치는 스테이지(부모 컨테이너)의 좌상단(0,0)을 기준으로 상대적인 위치입니다. 이 기준값은 clutter_actor_set_anchor_point()를 이용해 변경할 수 있습니다.\nGTK+ 위젯과 마찬가지로 클러터 액터도 처음 생성되었을 때는 보이는 상태가 아니기 때문에 clutter_actor_show() 를 호출해야 비로소 보여집니다. 물론 다시 안보이게 하려면 clutter_actor_hide() 를 사용하면 됩니다. 또한 GTK+ 위젯 시스템과 동일한 부동 참조(floating reference) 개념을 사용하여 리소스를 관리합니다. (더 자세한 내용이 궁금하신 분은 \u0026lsquo; GTK+ 메모리 관리 \u0026rsquo; 항목을 참고하세요)\n모든 액터는 당연히 확대 및 축소(scaling), 회전(rotation) 시킬 수 있고, 부분적으로 투명하게 할 수도 있습니다.\n액터의 크기를 확대하거나 축소하려면 clutter_actor_set_scale() 을 호출합니다. 유의할 점은 clutter_actor_set_size() 로 지정한 크기는 변하지 않습니다. 그래서 clutter_actor_set_scale() 을 다시 호출하면 원래 크기를 기준으로 스케일됩니다.\n clutter_actor_set_rotation() 을 호출하면 지정한 축(axis)을 기준으로 원하는 각도만큼 회전합니다. 예를 들어, 축으로 CLUTTER_X_AXIS을 지정하면 y,z 방향 인수만 지정할 수 있습니다. 이 기능 역시 액터의 위치와 크기에는 영향을 미치지 않습니다.\n액터의 일부 영역만 보이도록(clipping) 하려면 clutter_actor_set_clip() 을 호출하면 됩니다. 예를 들어 매우 큰 컨테이너 액터를 만들고 스크롤 효과를 내면서 일부 영역만 보이도록 하는데 사용할 수 있습니다. 클립핑 영역을 해제하려면 clutter_actor_remove_clip() 을 호출하면 됩니다. 클립핑 밖의 영역은 비디오 메모리도 사용안하고, 연산 작업에서도 제외됩니다.\n액터를 현재 위치에서 상대적으로 움직이라면 clutter_actor_move_by() 또는 clutter_actor_set_depth() 를 호출하면 됩니다.\n이제 여기까지 설명한 액터의 기본 동작에 대한 예제 코드를 살펴보시기 바랍니다.\n#include \u0026lt;clutter/clutter.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv[]) { ClutterColor stage_color = { 0x00, 0x00, 0x00, 0xff }; ClutterColor actor_color = { 0xff, 0xff, 0xff, 0x99 }; clutter_init (\u0026amp;argc, \u0026amp;argv); /* 스테이지를 얻어 크기와 색상을 정합니다. */ ClutterActor *stage = clutter_stage_get_default (); clutter_actor_set_size (stage, 200, 200); clutter_stage_set_color (CLUTTER_STAGE (stage), \u0026amp;stage_color); /* 스테이지에 사각형을 더합니다. */ ClutterActor *rect = clutter_rectangle_new_with_color (\u0026amp;actor_color); clutter_actor_set_size (rect, 100, 100); clutter_actor_set_position (rect, 20, 20); clutter_container_add_actor (CLUTTER_CONTAINER (stage), rect); clutter_actor_show (rect); /* X축을 기준으로 20도 회전합니다. * (상단 테두리 기준으로 돌기) */ clutter_actor_set_rotation (rect, CLUTTER_X_AXIS, -20, 0, 0, 0); /* 스테이지에 레이블을 추가합니다. */ ClutterActor *label = clutter_label_new_full (\u0026quot;Sans 12\u0026quot;, \u0026quot;Some Text\u0026quot;, \u0026amp;actor_color); clutter_actor_set_size (label, 500, 500); clutter_actor_set_position (label, 20, 150); clutter_container_add_actor (CLUTTER_CONTAINER (stage), label); clutter_actor_show (label); /* X축 방향으로 300% 확대합니다. */ clutter_actor_set_scale (label, 3.00, 1.0); /* 오른쪽으로 10, 위쪽으로 10 이동합니다. */ clutter_actor_move_by (label, 10, -10); /* Z축으로 20 더 가깝게 이동합니다. */ clutter_actor_set_depth (label, -20); /* 스테이지를 보이게 합니다. */ clutter_actor_show (stage); /* 메인 이벤트 루프를 시작합니다. */ clutter_main (); return EXIT_SUCCESS; }  이 코드를 실행하면 다음과 같은 화면을 얻을 수 있습니다.\n","date":1231977600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1231977600,"objectID":"f56e8a40c0be2ab1527ce0ebab4eb59e","permalink":"https://lethean.github.io/2009/01/15/using-clutter-2/","publishdate":"2009-01-15T00:00:00Z","relpermalink":"/2009/01/15/using-clutter-2/","section":"post","summary":"클러터 튜토리얼 내용을 계속 정리해 봅니다. 액터 (Actors) - 배우 클러터는 3차원 공간 속에서 2차원 표면(surfaces)을 다루는 캔버스 API입니다. 그래서,","tags":["Clutter"],"title":"클러터(Clutter) 사용하기 (2)","type":"post"},{"authors":null,"categories":null,"content":" 클러터 튜토리얼 내용 계속됩니다.\n컨테이너 (Containers) - 그릇\n어떤 클러터 액터는 ClutterContainer 인터페이스를 구현합니다. 이 액터는 자식 액터를 담을 수 있고, 목록이나 표 형태처럼 각각에 상대적인 위치를 지정할 수도 있습니다. 더 나아가 변환(transformation)이나 속성(properties) 변경을 한꺼번에 모든 자식에게 적용할 수 있습니다. clutter_container_add() 함수를 이용하면 자식 액터를 컨테이너에 추가할 수 있습니다.\n ClutterStage 자신도 하나의 컨테이너입니다. 따라서 모든 종류의 자식 액터를 담을 수 있습니다. ClutterGroup 도 또다른 컨테이너입니다. 스테이지와 달리 그룹은 복수 객체가 가능하고, ClutterGroup이 다시 다른 ClutterGroup을 포함할 수도 있습니다. 그리고, 이 역시 하나의 액터이기 때문에 clutter_actor_*() API를 모두 사용할 수 있습니다.\nGTK+ 프로그래밍 경험이 있는 분이라면 이쯤에서, ClutterActor 객체가 GTK+에서 GtkWidget 객체와 동일한 개념이라는 걸 알 수 있을 겁니다. 그래서 모든 클러터 액터 / 그룹 / 스테이지를 새로 만들면 반환되는 객체 형식은 항상 ClutterActor입니다.\n다음 예제는 하나의 그룹에 두 액터를 넣은 다음, 그룹을 변경하면 자동으로 자식 액터에게 적용되는 모습을 보여주고 있습니다.\n#include \u0026lt;clutter/clutter.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(int argc, char *argv[]) { ClutterColor stage_color = { 0x00, 0x00, 0x00, 0xff }; ClutterColor actor_color = { 0xff, 0xff, 0xff, 0x99 }; clutter_init (\u0026amp;argc, \u0026amp;argv); /* 스테이지를 얻어 크기와 색상을 정합니다. */ ClutterActor *stage = clutter_stage_get_default (); clutter_actor_set_size (stage, 200, 200); clutter_stage_set_color (CLUTTER_STAGE (stage), \u0026amp;stage_color); /* 스테이지에 그룹을 추가합니다. */ ClutterActor *group = clutter_group_new (); clutter_actor_set_position (group, 40, 40); clutter_container_add_actor (CLUTTER_CONTAINER (stage), group); clutter_actor_show (group); /* 사각형을 그룹에 추가합니다. */ ClutterActor *rect = clutter_rectangle_new_with_color (\u0026amp;actor_color); clutter_actor_set_size (rect, 50, 50); clutter_actor_set_position (rect, 0, 0); clutter_container_add_actor (CLUTTER_CONTAINER (group), rect); clutter_actor_show (rect); /* 레이블을 그룹에 추가합니다. */ ClutterActor *label = clutter_label_new_full (\u0026quot;Sans 9\u0026quot;, \u0026quot;Some Text\u0026quot;, \u0026amp;actor_color); clutter_actor_set_position (label, 0, 60); clutter_container_add_actor (CLUTTER_CONTAINER (group), label); clutter_actor_show (label); /* 그룹을 X축 방향으로 120% 확대합니다. */ clutter_actor_set_scale (group, 3.00, 1.0); /* 그룹을 Z축 기준으로 회전합니다. */ clutter_actor_set_rotation (group, CLUTTER_Z_AXIS, 10, 0, 0, 0); /* 스테이지를 보이게 합니다. */ clutter_actor_show (stage); /* 메인 이벤트 루프를 시작합니다. */ clutter_main (); return EXIT_SUCCESS; }  더 자세한 컨테이너 기능은 clutter_container_*() API를 참고하시기 바랍니다.\n이벤트 (Events) - 사용자 입력 처리\nClutterActor 객체는 사용자와 액터가 상호작용할때 발생하는 시그널(signals)을 가지고 있습니다.\n  button-press-event : 액터 위에서 마우스 버튼을 누르면 발생  button-release-event : 액터 위에서 마우스 버튼을 떼면 발생  motion-event : 액터 위에서 마우스 포인터가 움직이면 발생  enter-event : 마우스 포인터가 액터 영역 안으로 들어왔을때 발생  leave-event : 마우스 포인터가 액터 영역 밖으로 나갔을때 발생  예를 들어, 액터를 사용자가 눌렀는지 감지하려면 다음과 같이 시그널 핸들러 콜백을 연결하면 됩니다.\ng_signal_connect (actor, \u0026quot;button-press-event\u0026quot;, G_CALLBACK (actor_button_pressed), NULL);  다른 방법으로, 액터의 부모가 되는 ClutterStage에 시그널 핸들러 콜백을 연결한 뒤, clutter_stage_get_actor_at_pos() 를 이용하여 어떤 액터와 관련이 있는 이벤트인지 확인할 수 있습니다.\n성능 최적화를 위해 클러터는 모든 이벤트 시그널을 기본적으로 발생하지 않습니다. 그래서, 스테이지가 아닌 액터로부터 이벤트 시그널을 받으려면 clutter_actor_set_reactive() 를 호출해서 액터가 이벤트를 수신할지 여부를 설정해야 합니다. 움직임 관련 이벤트(motion-event, enter-event, leave-event)를 한꺼번에 모든 액터가 수신할지 여부는 clutter_set_motion_events_enabled() 를 이용해 설정할 수 있습니다. 이는 마치 GTK+에서 gtk_widget_set_events()를 이용하여 위젯별로 처리할 이벤트를 설정하는 것과 비슷합니다.\n이벤트 시그널 핸들러가 발생한 이벤트에 대한 모든 처리를 다 수행한다면 TRUE 값을 반환해서 연결된 다른 핸들러나 다른 액터에게 더 이상 전달되지 않도록 해야 합니다. 반대의 경우 FALSE를 반환해서 다른 핸들러나 다른 액터에게 전달되도록 할 수 있습니다. 클러터는 스테이지가 가장 먼저 이벤트를 수신하도록 하고, 이때 capture-event 시그널을 발생합니다. 스테이지가 이벤트를 처리하지 않으면, 계층적으로 자식 액터에게 전달되면서 capture-event 시그널을 발생합니다. 만일 어떤 액터도 이 이벤트를 처리하지 않았다면 다시 각각 세부적인 이벤트(가령 button-press-event, key-press-event)가 자식 액터부터 발생해서 반대로 상위 방향으로 올라가면서 처리될때까지 시그널을 발생합니다. 따라서 처리가 완료되었다면 반드시 TRUE를 반환해야 클러터 어플리케이션 전체가 효율적으로 동작하게 됩니다.\n일반적으로 액터는 키 초점(key focus)을 가지고 있을때만 키보드 이벤트를 받지만, clutter_grab_pointer() 와 clutter_grab_keyboard() 를 이용하여 포인터나 키보드를 강제로 잡게 함으로써(grabbing) 모든 이벤트를 받게 할 수도 있습니다. 예를 들어, 드래그 앤 드롭 기능을 구현할때 마우스 버튼을 누른 다음 포인터가 스테이지 윈도우 바깥으로 나가더라도 마우스 버튼 떼기 이벤트를 받게 할 수 있습니다.\n다음 예제는 지금까지 설명한 내용을 보여주기 위해 이벤트 발생시 관련 메시지를 콘솔에 출력합니다.\n#include \u0026lt;clutter/clutter.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; static gboolean on_stage_button_press (ClutterStage *stage, ClutterEvent *event, gpointer data) { gint x = 0; gint y = 0; clutter_event_get_coords (event, \u0026amp;x, \u0026amp;y); g_print (\u0026quot;Clicked stage at (%d, %d)n\u0026quot;, x, y); /* 마우스 버튼 누른 위치에 액터가 있는지 검사합니다. * 물론 액터의 시그널에 직접 연결할 수도 있습니다. */ ClutterActor *rect = clutter_stage_get_actor_at_pos (stage, x, y); if (!rect) return FALSE; if (CLUTTER_IS_RECTANGLE (rect)) g_print (\u0026quot; A rectangle is at that position.n\u0026quot;); return TRUE; /* 다른 핸들러가 이벤트를 더이상 처리못하게 합니다. */ } static gboolean on_rect_button_press (ClutterRectangle *rect, ClutterEvent *event, gpointer data) { gint x = 0; gint y = 0; clutter_event_get_coords (event, \u0026amp;x, \u0026amp;y); g_print (\u0026quot;Clicked rectangle at (%d, %d)n\u0026quot;, x, y); /* clutter_main_quit(); */ return TRUE; /* 다른 핸들러가 이벤트를 더이상 처리못하게 합니다. */ } static gboolean on_rect_button_release (ClutterRectangle *rect, ClutterEvent *event, gpointer data) { gint x = 0; gint y = 0; clutter_event_get_coords (event, \u0026amp;x, \u0026amp;y); g_print (\u0026quot;Click-release on rectangle at (%d, %d)n\u0026quot;, x, y); return TRUE; /* 다른 핸들러가 이벤트를 더이상 처리못하게 합니다. */ } static gboolean on_rect_motion (ClutterRectangle *rect, ClutterEvent *event, gpointer data) { g_print (\u0026quot;Motion in the rectangle.n\u0026quot;); return TRUE; /* 다른 핸들러가 이벤트를 더이상 처리못하게 합니다. */ } static gboolean on_rect_enter (ClutterRectangle *rect, ClutterEvent *event, gpointer data) { g_print (\u0026quot;Entered rectangle.n\u0026quot;); return TRUE; /* 다른 핸들러가 이벤트를 더이상 처리못하게 합니다. */ } static gboolean on_rect_leave (ClutterRectangle *rect, ClutterEvent *event, gpointer data) { g_print (\u0026quot;Left rectangle.n\u0026quot;); return TRUE; /* 다른 핸들러가 이벤트를 더이상 처리못하게 합니다. */ } int main(int argc, char *argv[]) { ClutterColor stage_color = { 0x00, 0x00, 0x00, 0xff }; ClutterColor label_color = { 0xff, 0xff, 0xff, 0x99 }; clutter_init (\u0026amp;argc, \u0026amp;argv); /* 스테이지를 얻어 크기와 색상을 정합니다. */ ClutterActor *stage = clutter_stage_get_default (); clutter_actor_set_size (stage, 200, 200); clutter_stage_set_color (CLUTTER_STAGE (stage), \u0026amp;stage_color); /* 스테이지의 마우스 클릭 시그널에 핸들러를 연결합니다. */ g_signal_connect (stage, \u0026quot;button-press-event\u0026quot;, G_CALLBACK (on_stage_button_press), NULL); /* 사각형을 스테이지에 추가합니다. */ ClutterActor *rect = clutter_rectangle_new_with_color (\u0026amp;label_color); clutter_actor_set_size (rect, 100, 100); clutter_actor_set_position (rect, 50, 50); clutter_actor_show (rect); clutter_container_add_actor (CLUTTER_CONTAINER (stage), rect); /* 사각형 액터가 이벤트를 받을 수 있게 합니다. * 기본적으로 스테이지만 이벤트를 받을 수 있습니다. */ clutter_actor_set_reactive (rect, TRUE); /* 사각형 액터의 이벤트 시그널에 핸들러를 연결합니다. */ g_signal_connect (rect, \u0026quot;button-press-event\u0026quot;, G_CALLBACK (on_rect_button_press), NULL); g_signal_connect (rect, \u0026quot;button-release-event\u0026quot;, G_CALLBACK (on_rect_button_release), NULL); g_signal_connect (rect, \u0026quot;motion-event\u0026quot;, G_CALLBACK (on_rect_motion), NULL); g_signal_connect (rect, \u0026quot;enter-event\u0026quot;, G_CALLBACK (on_rect_enter), NULL); g_signal_connect (rect, \u0026quot;leave-event\u0026quot;, G_CALLBACK (on_rect_leave), NULL); /* 스테이지를 보이게 합니다. */ clutter_actor_show (stage); /* 메인 이벤트 루프를 시작합니다. */ clutter_main (); return EXIT_SUCCESS; }  다음은 클러터에서 애니메이션 효과를 구현하는데 사용하는 타임라인(Timelines)에 대해 설명할 예정입니다. 대략 12개 장으로 구성된 튜터리얼을 지금까지 5개 장까지 했으니 대략 7개 정도가 더 남았네요. 근데 이제부터는 점점 내용도 많아지고 분량도 많아져서 슬슬 피곤함이\u0026hellip;\n","date":1231977600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1231977600,"objectID":"8d231bdb1a4ed67b6d2c9bf3c6d9c792","permalink":"https://lethean.github.io/2009/01/15/using-clutter-3/","publishdate":"2009-01-15T00:00:00Z","relpermalink":"/2009/01/15/using-clutter-3/","section":"post","summary":"클러터 튜토리얼 내용 계속됩니다. 컨테이너 (Containers) - 그릇 어떤 클러터 액터는 ClutterContainer 인터페이스를 구현합니다. 이 액터는 자식 액터를 담을 수 있고, 목록이나 표 형태처럼 각각","tags":["Clutter"],"title":"클러터(Clutter) 사용하기 (3)","type":"post"},{"authors":null,"categories":null,"content":" 클러터 튜토리얼 계속 이어집니다.\n타임라인 (Timelines)\n ClutterTimeline 은 시간이 흐르는 동안 액터의 모양이나 위치를 자동으로 변경하는데 사용합니다. 다음에 설명할 효과(effect)나 움직임(behaviour)와 함께 사용할 수도 있지만 직접 사용할 수도 있습니다.\n타임라인 객체는 지정한 초당 프레임 수를 기준으로 시간이 되면 각 프레임이 그려질 수 있도록 new-frame 시그널을 발생합니다. 그러면 시그널 핸들러에서 액터의 속성을 변경하면 됩니다. 물론 스테이지에 있는 여러 액터의 속성을 동시에 변경할 수도 있습니다. (물론 이외에도 몇 가지 시그널이 더 있습니다)\n타임라인 객체를 만드는 clutter_timeline_new() 함수는 총 프레임 수(n_frames)와 초당 프레임 수(fps)를 인수로 받습니다. 따라서 이 값을 기준으로 전체 지속 시간을 예측할 수 있습니다. 타임라인은 clutter_timeline_start() 를 호출해야 비로소 시작합니다. clutter_timeline_stop() 을 호출하기 전까지 clutter_timeline_set_loop() 를 이용하여 무한히 반복하게 할 수도 있습니다.\n여러 타임라인을 동시에 시작하거나 정지, 또는 순서대로 실행하려면 ClutterScore 객체를 사용합니다. 일종의 타임라인 제어기 역할을 하는 셈입니다. clutter_score_append() 는 두 개의 타임라인을 인수로 받는데, 첫번째는 부모(parent) 타임라인이고 두번째가 추가할 타임라인입니다. 추가되는 타임라인은 부모가 끝난 다음에 실행됩니다. 부모가 NULL인 타임라인은 clutter_timeline_start() 을 호출하면 바로 시작합니다.\n예를 들어 다음 예제는 timeline1이 끝난 다음에 timeline2, timeline3가 동시에 시작합니다.\n ClutterTimeline *timeline1, *timeline2, *timeline3; ClutterScore *score; timeline1 = clutter_timeline_new_for_duration (1000); timeline2 = clutter_timeline_new_for_duration (500); timeline3 = clutter_timeline_new_for_duration (500); score = clutter_score_new (); clutter_score_append (score, NULL, timeline1); clutter_score_append (score, timeline1, timeline2); clutter_score_append (score, timeline1, timeline3); clutter_score_start (score);  클러터 액터와 달리 타임라인 객체는 부동 참조(floating reference)가 없기 때문에 사용이 끝난 다음에는 g_object_unref()로 리소스를 해제해야 합니다. 사용이 끝나는 시점이 모호할 경우 completed 시그널에 핸들러를 등록해서 처리해도 됩니다.\n다음 예제는 하나가 끝난 뒤 다른 하나가 시작하는 두 개의 타임라인을 포함하는 하나의 스코어 객체를 보여줍니다. 이 스코어 객체는 무한히 반복하고, 첫번째 타임라인은 사각형을 회전시키며 두번째 타임라인은 사각형을 수평을 이동시킵니다.\n#include \u0026lt;clutter/clutter.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ClutterActor *rect = NULL; gint rotation_angle = 0; gint color_change_count = 0; /* 사각형을 회전시키고 색상을 변경 */ void on_timeline_rotation_new_frame (ClutterTimeline *timeline, gint frame_num, gpointer data) { rotation_angle += 1; if(rotation_angle \u0026gt;= 360) rotation_angle = 0; /* X축을 기준으로 시계방향으로 회전시킵니다. */ clutter_actor_set_rotation (rect, CLUTTER_X_AXIS, rotation_angle, 0, 0, 0); /* 색삭을 변경합니다. * (This is a silly example, making the rectangle flash): */ ++color_change_count; if(color_change_count \u0026gt; 100) color_change_count = 0; if(color_change_count == 0) { ClutterColor rect_color = { 0xff, 0xff, 0xff, 0x99 }; clutter_rectangle_set_color (CLUTTER_RECTANGLE (rect), \u0026amp;rect_color); } else if (color_change_count == 50) { ClutterColor rect_color = { 0x10, 0x40, 0x90, 0xff }; clutter_rectangle_set_color (CLUTTER_RECTANGLE (rect), \u0026amp;rect_color); } } /* 사각형 움직이기 */ void on_timeline_move_new_frame (ClutterTimeline *timeline, gint frame_num, gpointer data) { gint x_position = clutter_actor_get_x (rect); x_position += 1; if (x_position \u0026gt;= 150) x_position = 0; clutter_actor_set_x (rect, x_position); } int main(int argc, char *argv[]) { ClutterColor stage_color = { 0x00, 0x00, 0x00, 0xff }; ClutterColor rect_color = { 0xff, 0xff, 0xff, 0x99 }; clutter_init (\u0026amp;argc, \u0026amp;argv); /* 스테이지를 얻어 크기와 색상을 정합니다. */ ClutterActor *stage = clutter_stage_get_default (); clutter_actor_set_size (stage, 200, 200); clutter_stage_set_color (CLUTTER_STAGE (stage), \u0026amp;stage_color); /* 스테이지에 사각형을 추가합니다. */ rect = clutter_rectangle_new_with_color (\u0026amp;rect_color); clutter_actor_set_size (rect, 70, 70); clutter_actor_set_position (rect, 50, 100); clutter_container_add_actor (CLUTTER_CONTAINER (stage), rect); clutter_actor_show (rect); /* 스테이지를 보이게 합니다. */ clutter_actor_show (stage); /* 스코어 객체를 하나 만들어 타임라인 객체 두개를 추가합니다. * 두번째 타임라인은 첫번째가 멈춘 뒤에 시작합니다. */ ClutterScore *score = clutter_score_new (); clutter_score_set_loop (score, TRUE); ClutterTimeline *timeline_rotation = clutter_timeline_new (200 /* 총프레임수 */, 120 /* 초당프레임수(fps) */); g_signal_connect (timeline_rotation, \u0026quot;new-frame\u0026quot;, G_CALLBACK (on_timeline_rotation_new_frame), NULL); clutter_score_append (score, NULL, timeline_rotation); ClutterTimeline *timeline_move = clutter_timeline_new (200 /* 총프레임수 */, 120 /* 초당프레임수(fps) */); g_signal_connect (timeline_move, \u0026quot;new-frame\u0026quot;, G_CALLBACK (on_timeline_move_new_frame), NULL); clutter_score_append (score, timeline_rotation, timeline_move); clutter_score_start (score); /* 메인 이벤트 루프를 시작합니다. */ clutter_main (); g_object_unref (timeline_rotation); g_object_unref (timeline_move); g_object_unref (score); return EXIT_SUCCESS; }  이제 클러터를 이용한 기본적인 애니메이션 원리를 알게 되었군요.\n","date":1231977600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1231977600,"objectID":"7e47748a89c94a86ec37d7450fefccf6","permalink":"https://lethean.github.io/2009/01/15/using-clutter-4/","publishdate":"2009-01-15T00:00:00Z","relpermalink":"/2009/01/15/using-clutter-4/","section":"post","summary":"클러터 튜토리얼 계속 이어집니다. 타임라인 (Timelines) ClutterTimeline 은 시간이 흐르는 동안 액터의 모양이나 위치를 자동으로 변경하는데 사용합니다. 다음에 설명할 효과(effect","tags":["Clutter"],"title":"클러터(Clutter) 사용하기 (4)","type":"post"},{"authors":null,"categories":null,"content":" PyGTK를 이용해 데스크탑 위젯을 만드는 블로그 를 보고 이를 C 언어로 바꾸어 보았습니다. Compiz나 Metacity의 컴포지팅(compositing) 기능이 활성화되어 있을 경우에만 제대로 동작합니다. 먼저 스크린샷부터.\n여기서 사용한 기법을 요약하면, 윈도우 바탕에 RGBA 컬러맵을 할당하고 배경화면을 직접 그리도록 설정한뒤 \u0026ldquo;expose-event\u0026rdquo; 발생시 Cairo API를 이용하여 원하는 투명 배경을 그리는 겁니다. 소스 코드는 다음과 같습니다.\n#include \u0026lt;gtk/gtk.h\u0026gt; static void make_desktop_window (GtkWidget *window) { gtk_window_set_type_hint (GTK_WINDOW (window), GDK_WINDOW_TYPE_HINT_DOCK); gtk_window_set_keep_below (GTK_WINDOW (window), TRUE); gtk_window_set_decorated (GTK_WINDOW (window), FALSE); gtk_window_stick (GTK_WINDOW (window)); } static gboolean window_exposed (GtkWidget *widget, GdkEventExpose *event, gpointer user_data) { cairo_t *cr; cr = gdk_cairo_create (widget-\u0026gt;window); /* Make it transparent */ cairo_set_operator (cr, CAIRO_OPERATOR_CLEAR); gdk_cairo_region (cr, event-\u0026gt;region); cairo_fill_preserve (cr); /* Make it semi-transparent */ cairo_set_source_rgba (cr, 0.0, 0.0, 0.0, 0.5); cairo_set_operator (cr, CAIRO_OPERATOR_OVER); cairo_fill (cr); cairo_destroy (cr); return FALSE; } static void make_transparent_window (GtkWidget *window) { GdkScreen *screen; GdkColormap *colormap; screen = gtk_widget_get_screen (window); if (!screen) { g_warning (\u0026quot;failed to get window's screen\u0026quot;); return; } colormap = gdk_screen_get_rgba_colormap (screen); if (!colormap) { g_warning (\u0026quot;failed to get RGBA colormap\u0026quot;); return; } gtk_widget_set_colormap (window, colormap); gtk_widget_set_app_paintable (window, TRUE); g_signal_connect (window, \u0026quot;expose-event\u0026quot;, G_CALLBACK (window_exposed), NULL); } static void button_clicked (GtkButton *button, gpointer user_data) { static gint counter = 0; GtkWidget *label = user_data; gchar *str; str = g_strdup_printf (\u0026quot;\u0026lt;span size='larger' \u0026quot; \u0026quot;weight='bold' \u0026quot; \u0026quot;color='white'\u0026gt;안녕하신가? %d\u0026lt;/span\u0026gt;\u0026quot;, ++counter); gtk_label_set_markup (GTK_LABEL (label), str); g_free (str); } int main (int argc, char **argv) { GtkWidget *window; GtkWidget *vbox; GtkWidget *label; GtkWidget *button; gtk_init (\u0026amp;argc, \u0026amp;argv); window = gtk_window_new (GTK_WINDOW_TOPLEVEL); make_transparent_window (window); if (0) make_desktop_window (window); gtk_widget_show (window); vbox = gtk_vbox_new (TRUE, 10); gtk_widget_show (vbox); gtk_container_add (GTK_CONTAINER (window), vbox); label = gtk_label_new (\u0026quot;안녕하신가?\u0026quot;); gtk_widget_show (label); gtk_box_pack_start (GTK_BOX (vbox), label, TRUE, TRUE, 10); button = gtk_button_new_with_label (\u0026quot;Click Here!\u0026quot;); gtk_widget_show (button); gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 10); g_signal_connect (button, \u0026quot;clicked\u0026quot;, G_CALLBACK (button_clicked), label); gtk_main (); return 0; }  참고로, 이를 더 응용하면 필요한 위젯은 모두 반투명하게 만들 수도 있겠지만, 제대로 하려면 Murrine 등과 같은 테마 엔진처럼 GTK+ 테마에서 처리하는게 더 바른 선택일 것 같습니다.\n**[업데이트 - 2009.01.16] **\nGTK+ 테마 엔진 \u0026ldquo;pixmap\u0026quot;을 이용하고 투명도를 지원하는 PNG / SVG 형식의 이미지를 사용하면 버튼 등과 같은 위젯도 투명도가 적용됩니다. 다음은 위 테스트 프로그램을 이러한 테마를 이용했을때 스크린샷입니다.\nGTK+ 테마 엔진을 새로 구현할 필요없이 pixmap 엔진만 사용해도 어플리케이션 전체적으로 반투명 효과를 얻을 수 있습니다. 그런데 pixmap 엔진 관련된 문서가 별로 없어서\u0026hellip; 그나마 찾아낸 건 이 정도 뿐입니다.\n  http://live.gnome.org/GnomeArt/Tutorials/GtkThemes   https://stage.maemo.org/svn/maemo/projects/haf/trunk/sapwood/README   http://www.nabble.com/Pixmap-Theme-Engine-options-td18393063.html   ","date":1231891200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1231891200,"objectID":"8835d0e209d882c1ef3dae102eba8bbf","permalink":"https://lethean.github.io/2009/01/14/gtk-osd-semi-transparent/","publishdate":"2009-01-14T00:00:00Z","relpermalink":"/2009/01/14/gtk-osd-semi-transparent/","section":"post","summary":"PyGTK를 이용해 데스크탑 위젯을 만드는 블로그 를 보고 이를 C 언어로 바꾸어 보았습니다. Compiz나 Metacity의 컴포지팅(compositi","tags":["GTK+"],"title":"GTK+ 반투명 배경 만들기 (OSD 효과)","type":"post"},{"authors":null,"categories":null,"content":"이번에는 컴피즈와 같은 비디오 카드 3D 기능이 필요하지 않은 기법으로 OSD 효과를 만들어 보겠습니다. 물론 부드러운 반투명 배경 등의 효과는 불가능하지만, 윈도우의 특정 영역을 아예 마스킹(masking)해서 비워버리는 방식이기 때문에 마우스 입력도 통과해 버립니다. 이번에도 역시 스크린샷 먼저!\n여기서 사용한 기법은 gtk_widget_shape_combine_mask() 함수를 이용해 위젯(윈도우)의 유효 영역을 비트맵으로 지정하는 것입니다. 여기서 비트맵이란 1비트가 하나의 픽셀을 가리키는 그래픽 형식으로, 위젯의 특정 좌표 픽셀이 유효한 영역인지는 비트맵의 해당 좌표 픽셀 비트가 1인지 여부에 따라 결정됩니다. 즉, 일반적인 경우 X 서버는 사각 형태로만 윈도우 영역을 판단하지만, 비트맵 정보가 전달되면 사각형이 아닌 복잡한 형태의 윈도우로 처리하는 것입니다. 가끔 특이한 모양의 윈도우 형태를 가진 어플리케이션이 있다면 아마도 대부분 이 기능을 이용한 것입니다. 더 정확히는 X 윈도우 Shape 확장(extension)에서 제공하는 XShapeCombineMask() API를 이용합니다. (행복하게도 이 GTK+ API는 윈도우 플랫폼에서도 정상 동작합니다)\ngtk_widget_shape_combine_mask() API는 비트맵 정보로 GdkBitmap 객체를 사용하는데 이 객체를 만들기 위해서는 gdk_bitmap_create_from_data() 함수와 gdk_pixbuf_render_pixmap_and_mask_for_colormap() 함수를 사용해야 합니다. 두번째 함수는 GdkPixbuf 객체로부터 추출하는 방식이기 때문에, 이 테스트 프로그램에서는 첫번째 함수를 이용합니다. 그런데 이 함수가 이용하는 데이터가 XBM 형식이라서 따로 라이브러리를 사용하지 않고 간단하게 GdkPixmap에서 추출합니다. 하지만 GdkPixmap에서 직접 픽셀 정보를 얻을 수 없으므로 GdkImage 객체로 변환한 뒤에 픽셀 정보를 얻어옵니다.\n카이로(cairo) API를 사용하는 것이 대세이긴 하지만 여기서는 간단하게 GDK Drawing API 를 이용해서 사각형과 텍스트를 표시했습니다. 텍스트는 안티 엘리어싱(anti-aliasing) 효과 때문에 테두리가 약간 지저분하지만 그럭저럭 볼만합니다. 물론, 카이로 API를 이용하면 안티 엘리어싱 효과를 끌 수 있습니다. (그런데 gnome-osd 프로그램은 어떻게 해서 깔끔하게 나오는 건지 궁금하네요)\n** 업데이트 (2009.03.06) **\n gdk_draw_layout() 을 이용해 텍스트를 그리는 코드와 더불어 여기 를 참고해 카이로(cairo) 방식도 추가해 보았습니다.\n","date":1231891200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1231891200,"objectID":"badc4190af3ba3669b60646305be7931","permalink":"https://lethean.github.io/2009/01/14/gtk-transparent-background-osd-effect/","publishdate":"2009-01-14T00:00:00Z","relpermalink":"/2009/01/14/gtk-transparent-background-osd-effect/","section":"post","summary":"이번에는 컴피즈와 같은 비디오 카드 3D 기능이 필요하지 않은 기법으로 OSD 효과를 만들어 보겠습니다. 물론 부드러운 반투명 배경 등의 효과는 불가능하지만, 윈도우의 특","tags":["GTK+"],"title":"GTK+ 투명 배경 만들기 (OSD 효과)","type":"post"},{"authors":null,"categories":null,"content":"텍스트나 소스 파일의 차이점을 확인하는데 사용하는 도구는 diff를 비롯해 많지만, 의외로 바이너리 파일간 차이점을 확인하는데 사용하는 쓸만한 도구가 없어 찾아보니 vbindiff 패키지가 있군요. 우분투 리눅스에서는 \u0026lsquo;vbindiff\u0026rsquo; 패키지를 설치하면 됩니다. 사용법도 간단해서 두 파일을 인수로 주면 되고, 텍스트 그래픽(curse) 기반이라 콘솔이나 터미널에서 사용 가능합니다. 더 설명할 필요없이 스크린샷 한 장!\n","date":1231891200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1231891200,"objectID":"53490891692fe55a1ed10177eb95dc79","permalink":"https://lethean.github.io/2009/01/14/vbindiff-binary-diff/","publishdate":"2009-01-14T00:00:00Z","relpermalink":"/2009/01/14/vbindiff-binary-diff/","section":"post","summary":"텍스트나 소스 파일의 차이점을 확인하는데 사용하는 도구는 diff를 비롯해 많지만, 의외로 바이너리 파일간 차이점을 확인하는데 사용하는 쓸만한 도구가 없어 찾아","tags":["Linux"],"title":"VBinDiff - 바이너리 차이점 확인하기(binary diff)","type":"post"},{"authors":null,"categories":null,"content":" 클러터(Clutter) 는 C 언어로 구현한 2D 그래픽 사용자 인터페이스 라이브러리입니다. 2D임에도 불구하고 OpenGL 또는 OpenGL ES를 렌더링에 사용하며, GLib의 GObject 기반으로 API가 구성되어 있습니다. 뭐, 소개하자면 끝이 없고, 더 궁금한 분은 공식 홈페이지를 참고하기 바랍니다. 이 글은 클러터 튜토리얼 을 중심으로 실제 사용하는 방법을 몇 차례에 나누어 정리하려 합니다. (현재 1.0 버전이 활발하게 개발 중이지만, 일단 0.8 버전을 기준으로 작성합니다)\n**소개 / 설치 / 컴파일 **\n제일 먼저, 클러터 세상에서 존재하는 몇가지 개념부터 설명해야겠군요. 첫번째로 설명할 녀석은 액터(actors)입니다. 말 그대로 배우 역할을 하는 다양한 객체입니다. 그 다음에는 스테이지(stage), 즉 무대입니다. 배우가 온갖 연기를 펼치는 공간(canvas)입니다. 클러터는 카이로(cairo) 라이브러리처럼 공간이 보여질때마다 매번 그려야 하는 방식이 아니라 모든 액터의 상태가 유지되는 방식으로, 프로그래머는 액터를 움직이거나 회전시키기만 하면 그려주는 건 클러터 라이브러리가 알아서 합니다. (부분적으로 Z축 이동도 가능합니다)\n3D 엔진을 사용함에도 클러터 라이브러리가 2D 라이브러리라고 표방하는 이유는 사용자 인터페이스에는 아직까지 3D 효과가 가미된 2D 인터페이스가 더 실용적이기 때문입니다. 미려한 2D 인터페이스를 쉽게 구현하도록 애니메이션과 타임라인 등과 같은 기능도 제공합니다. 그리고 임베디드 시스템에서 사용 가능하도록 OpenGL ES를 사용하기 때문에 데스크탑 뿐 아니라 다양한 플랫폼에 적용할 수 있습니다. (물론 아직까지는 리눅스 기반일 뿐입니다)\n클러터를 설치하는 가장 쉬운 방법은 우분투 최신 배포판을 설치하고 libclutter* 패키지를 모두 설치하는 것입니다. 아니라면 각 배포판의 패키지를 찾아보거나 홈페이지에서 언급한 방법대로 설치하시기 바랍니다. (보통 대부분의 라이브러리 설명 문서나 책은 설치에만 몇십 페이지를 할애하지만, 지금 이 글은 목적이 다르기 때문에\u0026hellip;)\n컴파일에 필요한 옵션은 \u0026lsquo;pkg-config clutter-0.8 --cflags\u0026rsquo;, 링크에 필요한 옵션은 \u0026lsquo;pkg-config clutter-0.8 --libs\u0026rsquo; 명령으로 얻을 수 있습니다. 따라서 이 내용을 적당히 Makefile이나 관련 빌드 스크립트에 추가하면 됩니다.\n스테이지 (Stage) - 무대\n클러터 어플리케이션은 최소한 하나의 ClutterStage 객체가 있어야 합니다. 이 스테이지는 사각형, 이미지, 텍스트와 같은 액터(actors)를 가집니다. 아이러니하게도(?) ClutterStage 객체는 ClutterActor 객체에서 파생되었습니다. 따라서 모든 GTK+ 위젯이 GtkWidget 객체를 상속받기 때문에 gtk_widget_*() API를 사용할 수 있듯이, ClutterStage 객체에도 모든 clutter_actor_*() API를 사용할 수 있습니다.\n클러터를 초기화하기 위해서 항상 제일 먼저 clutter_init() 을 호출합니다. 그러면 clutter_stage_get_default() 를 이용하여 기본 스테이지를 얻을 수 있으며, 하나의 윈도우와 연결되어 있습니다. 물론 GtkClutterEmbed 위젯을 이용하면 GTK+ 어플리케이션에서 하나의 위젯처럼 마음껏 스테이지를 사용할 수 있습니다. (하지만 실제로 마음껏은 아니고, 백엔드 엔진이 다중 스테이지를 지원하지는 여부를 clutter_feature_available()를 이용해 확인해야 합니다)\n너무 설명이 길었군요. 마우스 버튼에 반응하는 클러터 스테이지를 한번 만들어 봅시다. (여담이지만, 튜토리얼 코드는 무조건 직접 입력해보시기 바랍니다. 가장 빨리 익숙해지는 방법입니다)\n#include \u0026lt;clutter/clutter.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; static gboolean on_stage_button_press (ClutterStage *stage, ClutterEvent *event, gpointer data) { gint x = 0; gint y = 0; clutter_event_get_coords (event, \u0026amp;x, \u0026amp;y); g_print (\u0026quot;Stage clicked at (%d, %d)n\u0026quot;, x, y); return TRUE; /* 다른 핸들러가 이 이벤트를 처리하지 않게 합니다. */ } int main(int argc, char *argv[]) { ClutterColor stage_color = { 0x00, 0x00, 0x00, 0xff }; /* 검정색 */ clutter_init (\u0026amp;argc, \u0026amp;argv); /* 스테이지를 얻어 크기와 색상을 정합니다. */ ClutterActor *stage = clutter_stage_get_default (); clutter_actor_set_size (stage, 200, 200); clutter_stage_set_color (CLUTTER_STAGE (stage), \u0026amp;stage_color); /* 스테이지를 보이게 합니다. */ clutter_actor_show (stage); /* 스테이지를 마우스 버튼으로 클릭하면 처리할 시그널 핸들러를 연결합니다. */ g_signal_connect (stage, \u0026quot;button-press-event\u0026quot;, G_CALLBACK (on_stage_button_press), NULL); /* 메인 이벤트 루프를 시작합니다. */ clutter_main (); return EXIT_SUCCESS; }  컴파일하는 방법은 다음과 같습니다. (파일 이름이 stage.c일 경우)\ngcc -Wall -g stage.c -o stage `pkg-config clutter-0.8 --cflags --libs`  뭐 싱겁지만, 이렇게 클러터 프로그래밍이 시작되었습니다.\n(참고) 몇몇 그래픽 카드에서 Compiz 환경에서 실행시 오동작한다면 Compiz를 사용하지 않도록 설정을 변경해야 합니다. 왜냐하면 클러터도 3D 하드웨어 가속을 사용하고 Compiz도 사용하기 때문에 충돌이 발생할 수 있기 때문입니다.\n스테이지 위젯 (Stage Widget) - GTK+ 어플리케이션 속으로\n앞에서 잠깐 언급한 것처럼, GtkClutterEmbed 위젯은 ClutterStage 객체를 GTK+ 윈도우 안에 하나의 위젯처럼 넣을 수 있게 합니다. gtk_clutter_embed_new() 로 위젯을 만들어 다른 위젯처럼 컨테이너 안에 넣은 뒤, gtk_clutter_embed_get_stage() 로 ClutterStage 객체를 얻을 수 있습니다. 다만 GtkClutterEmbed 위젯을 사용할때는 clutter_init() 대신 gtk_clutter_init() 를 호출해서 초기화해야 하고, clutter_main() 대신 gtk_main() 함수로 메인 루프를 실행합니다.\n다음 예제는 앞의 예제를 조금 확장해서 GtkClutterEmbed 위젯을 사용하고 버튼을 클릭할때마다 배경 색상을 바꿉니다.\n#include \u0026lt;gtk/gtk.h\u0026gt; #include \u0026lt;clutter/clutter.h\u0026gt; #include \u0026lt;clutter-gtk/gtk-clutter-embed.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; ClutterActor *stage = NULL; static gboolean on_button_clicked (GtkButton *button, gpointer user_data) { static gboolean already_changed = FALSE; if(already_changed) { ClutterColor stage_color = { 0x00, 0x00, 0x00, 0xff }; /* 검정 */ clutter_stage_set_color (CLUTTER_STAGE (stage), \u0026amp;stage_color); } else { ClutterColor stage_color = { 0x20, 0x20, 0xA0, 0xff }; /* 파랑? */ clutter_stage_set_color (CLUTTER_STAGE (stage), \u0026amp;stage_color); } already_changed = !already_changed; return TRUE; /* 다른 핸들러가 이 이벤트를 처리하지 않게 합니다. */ } static gboolean on_stage_button_press (ClutterStage *stage, ClutterEvent *event, gpointer user_data) { gint x = 0; gint y = 0; clutter_event_get_coords (event, \u0026amp;x, \u0026amp;y); g_print (\u0026quot;Stage clicked at (%d, %d)n\u0026quot;, x, y); return TRUE; /* 다른 핸들러가 이 이벤트를 처리하지 않게 합니다. */ } int main(int argc, char *argv[]) { ClutterColor stage_color = { 0x00, 0x00, 0x00, 0xff }; /* 검정색 */ gtk_clutter_init (\u0026amp;argc, \u0026amp;argv); /* 윈도우와 자식 위젯을 만듭니다. */ GtkWidget *window = gtk_window_new (GTK_WINDOW_TOPLEVEL); GtkWidget *vbox = gtk_vbox_new (FALSE, 6); gtk_container_add (GTK_CONTAINER (window), vbox); gtk_widget_show (vbox); GtkWidget *button = gtk_button_new_with_label (\u0026quot;Change Color\u0026quot;); gtk_box_pack_end (GTK_BOX (vbox), button, FALSE, FALSE, 0); gtk_widget_show (button); g_signal_connect (button, \u0026quot;clicked\u0026quot;, G_CALLBACK (on_button_clicked), NULL); /* 윈도우가 닫히면 어플리케이션을 종료합니다. */ g_signal_connect (window, \u0026quot;hide\u0026quot;, G_CALLBACK (gtk_main_quit), NULL); /* 클러터 위젯을 만들어 넣습니다. */ GtkWidget *clutter_widget = gtk_clutter_embed_new (); gtk_box_pack_start (GTK_BOX (vbox), clutter_widget, TRUE, TRUE, 0); gtk_widget_show (clutter_widget); /* 클러터 위젯 크기를 변경합니다. * 왜냐하면 GtkClutterEmbed 위젯을 사용할때는 직접 변경할 수 없기 때문입니다. */ gtk_widget_set_size_request (clutter_widget, 200, 200); /* 스테이지를 얻어 크기와 색상을 정합니다. */ stage = gtk_clutter_embed_get_stage (GTK_CLUTTER_EMBED (clutter_widget)); clutter_stage_set_color (CLUTTER_STAGE (stage), \u0026amp;stage_color); /* 스테이지를 보이게 합니다. */ clutter_actor_show (stage); /* 스테이지를 마우스 버튼으로 클릭하면 처리할 시그널 핸들러를 연결합니다. */ g_signal_connect (stage, \u0026quot;button-press-event\u0026quot;, G_CALLBACK (on_stage_button_press), NULL); /* GTK+ 윈도우를 보이게 합니다. */ gtk_widget_show (GTK_WIDGET (window)); /* 메인 이벤트 루프를 시작합니다. */ gtk_main (); return EXIT_SUCCESS; }  컴파일하는 방법은 다음과 같습니다. (파일 이름이 stage-embed.c일 경우)\ngcc -Wall -g stage-embed.c -o stage-embed `pkg-config clutter-0.8 clutter-gtk-0.8--cflags --libs`  뭐 싱겁지만, 이렇게 클러터 프로그래밍이 시작되었습니다.\n","date":1231891200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1231891200,"objectID":"ce98e67f9e99d36c12290890cc97ad07","permalink":"https://lethean.github.io/2009/01/14/using-clutter-1/","publishdate":"2009-01-14T00:00:00Z","relpermalink":"/2009/01/14/using-clutter-1/","section":"post","summary":"클러터(Clutter) 는 C 언어로 구현한 2D 그래픽 사용자 인터페이스 라이브러리입니다. 2D임에도 불구하고 OpenGL 또는 OpenGL ES를 렌더링에 사용하며, GLib","tags":["Clutter","GTK+"],"title":"클러터(Clutter) 사용하기 (1)","type":"post"},{"authors":null,"categories":null,"content":"리눅스 커널에서 파일 시스템 병합(union) 기능은 이미 존재하는 Unionfs 파일시스템을 이용하면 사용할 수 있습니다. 그런데 이를 별도 파일 시스템이 아닌 리눅스 VFS 레이어에서 직접 지원하기 위한 작업이 진행중입니다. 병합 마운트(union mount) 기능인데, 예를 들어 마운트할때 \u0026lsquo;\u0026ndash;union\u0026rsquo; 옵션을 주면 파일 시스템을 병합해서 마운트합니다.\n파일 시스템 병합에 대해 간략하게 설명하면, 일반적으로 리눅스에서는 디렉토리 하나에 하나의 파일 시스템만 마운트하는게 대부분입니다. 만일 동일한 디렉토리에 둘 이상의 파일 시스템을 마운트하면 항상 마지막에 마운트한 파일 시스템 내용만 보이고 이전에 마운트한 파일 시스템의 내용은 접근이 불가능합니다. 병합 마운트란 하나의 디렉토리에 여러 파일 시스템을 마운트하면 여러 파일 시스템 내용이 합쳐지는 것을 의미합니다. 먼저 마운트한 파일 시스템의 디렉토리 구조는 나중에 마운트한 파일 시스템의 디렉토리 구조와 합쳐집니다. 동일한 파일 이름을 가지고 있다면 나중에 마운트한 파일 시스템 내용을 우선적으로 보여주고, 나중에 마운트한 파일 시스템이 읽기 쓰기가 가능할 경우 파일을 지웠다면 그 정보도 유지되는 방식입니다.\n이러한 개념을 적용한 Unionfs를 가장 많이 사용하는 경우는 라이브 CD/DVD 배포판입니다. 기본 루트 파일 시스템은 읽기 전용으로 CD에서 마운트하고, 사용자가 업데이트한 패키지나 작성한 문서 등을 저장하기 위해 읽기-쓰기 가능한 파일시스템을 그 위해 다시 마운트합니다. 물론 읽기-쓰기 파일시스템은 방식에 따라 사용자가 사용하는 주 운영체제 안의 파일 하나일 수도 있고, USB 플래시일 수도 있습니다.\n병합 마운트 기능은 아직 읽기 전용에 최상위 디렉토리 병합 기능만 제공하지만, 한창 개발 중이고 Unionfs 파일 시스템과 서로 장단점이 있기 때문에, 실무에 적용하려면 조금은 더 기다려야 할 것 같습니다. 예제를 포함한 더 자세한 내용은 LWN.net 페이지 를 참고하면 됩니다.\n","date":1231459200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1231459200,"objectID":"291e96065af34be1de1fa42f1e92285e","permalink":"https://lethean.github.io/2009/01/09/linux-union-mount/","publishdate":"2009-01-09T00:00:00Z","relpermalink":"/2009/01/09/linux-union-mount/","section":"post","summary":"리눅스 커널에서 파일 시스템 병합(union) 기능은 이미 존재하는 Unionfs 파일시스템을 이용하면 사용할 수 있습니다. 그런데 이를 별도 파일 시스템이 아닌 리눅스 VFS 레","tags":["Kernel","Linux"],"title":"리눅스 커널 병합 마운트(union mount)","type":"post"},{"authors":null,"categories":null,"content":"sudo를 이용해 루트 권한으로 프로그램을 실행하거나, 패키지 관리자처럼 루트 권한이 필요한 GUI 프로그램을 실행할때마다 비밀번호 물어보는게 귀찮다면 다음과 같이 안물어보게 할 수 있습니다.\n먼저 /etc/sudoers 파일을 편집하게 위해 visudo 명령을 실행합니다.\n$ sudo visudo  맨 밑으로 가면 기본적으로 admin 그룹에 대한 설정이 있는데, 이 행을 고치거나 자신의 계정에 관한 설정을 새로 추가하면서 \u0026lsquo;NOPASSWD:\u0026rsquo; 항목을 명시하고 편집을 끝냅니다. (여기서 계정은 lethean)\n%admin ALL=(ALL) ALL lethean ALL=(ALL) NOPASSWD: ALL  이후 모든 sudo 명령 실행시 더 이상 비밀번호를 물어보지 않습니다.\n물론, 자리를 비웠을때 누군가 내 계정으로 루트 권한 작업을 마음대로 할 수 있는 보안상의 위험을 상관할 필요가 없을 경우에만 사용하시기 바랍니다.\n","date":1231286400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1231286400,"objectID":"0e0c29c0f9cef548139f52ce00641c84","permalink":"https://lethean.github.io/2009/01/07/skip-sudo-password-prompt/","publishdate":"2009-01-07T00:00:00Z","relpermalink":"/2009/01/07/skip-sudo-password-prompt/","section":"post","summary":"sudo를 이용해 루트 권한으로 프로그램을 실행하거나, 패키지 관리자처럼 루트 권한이 필요한 GUI 프로그램을 실행할때마다 비밀번호 물어보는게 귀찮다면 다음과 같","tags":["Linux","Ubuntu"],"title":"sudo 비밀번호 안물어보게 하기","type":"post"},{"authors":null,"categories":null,"content":"Ubuntu 설치시 한국어를 선택하면 한글을 사용하는데 별 문제가 없는 것 같지만, 글꼴이나 입력기 등이 조금 문제가 있기 때문에 \u0026lsquo;시스템\u0026rsquo; -\u0026gt; \u0026lsquo;관리\u0026rsquo; -\u0026gt; \u0026lsquo;언어\u0026rsquo; 설정에서 \u0026lsquo;지원되는 언어\u0026rsquo;에 \u0026lsquo;한국어\u0026rsquo;를 선택하고, 기본 언어로 \u0026lsquo;한국어\u0026rsquo;를 선택해주면 한글 관련 패키지와 설정이 자동으로 설치됩니다.\n하지만 이렇게 해도 기본 한글 글꼴 설정이 별로 미려하지 않은데, 제 경우 기본 글꼴 설정을 다음과 같이 변경해서 사용하고 있습니다.\n먼저 /etc/fonts/conf.d/29-language-selector-ko-kr.conf 파일은 다음과 같습니다.\n\u0026lt;fontconfig\u0026gt; \u0026lt;!-- Turn on antialias and hinting with hintmedium for ttf-Unfonts --\u0026gt; \u0026lt;match target=\u0026quot;font\u0026quot;\u0026gt; \u0026lt;test name=\u0026quot;family\u0026quot; compare=\u0026quot;contains\u0026quot;\u0026gt; \u0026lt;string\u0026gt;Un\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;antialias\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;bool\u0026gt;true\u0026lt;/bool\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026quot;hinting\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;bool\u0026gt;true\u0026lt;/bool\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026quot;hintsytle\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;const\u0026gt;hintmedium\u0026lt;/const\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Turn off antialias and autohint for ttf-alee depending on pixelsize --\u0026gt; \u0026lt;match target=\u0026quot;font\u0026quot;\u0026gt; \u0026lt;test name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;Guseul\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;autohint\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;bool\u0026gt;true\u0026lt;/bool\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026quot;font\u0026quot;\u0026gt; \u0026lt;test name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;Guseul\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Guseul Mono\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026quot;pixelsize\u0026quot; compare=\u0026quot;more\u0026quot;\u0026gt; \u0026lt;int\u0026gt;11\u0026lt;/int\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;test name=\u0026quot;pixelsize\u0026quot; compare=\u0026quot;less\u0026quot;\u0026gt; \u0026lt;int\u0026gt;16\u0026lt;/int\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;antialias\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;bool\u0026gt;false\u0026lt;/bool\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;edit name=\u0026quot;autohint\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;bool\u0026gt;false\u0026lt;/bool\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;/fontconfig\u0026gt;  두번째로 /etc/fonts/conf.d/69-language-selector-ko-kr.conf 파일은 다음과 같습니다.\n\u0026lt;fontconfig\u0026gt; \u0026lt;!-- Set preferred Korean fonts --\u0026gt; \u0026lt;match target=\u0026quot;pattern\u0026quot;\u0026gt; \u0026lt;test qual=\u0026quot;any\u0026quot; name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;family\u0026quot; mode=\u0026quot;prepend\u0026quot; binding=\u0026quot;strong\u0026quot;\u0026gt; \u0026lt;string\u0026gt;DejaVu Serif\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;NanumMyeongjo\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;UnBatang\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026quot;pattern\u0026quot;\u0026gt; \u0026lt;test qual=\u0026quot;any\u0026quot; name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;sans-serif\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;family\u0026quot; mode=\u0026quot;prepend\u0026quot; binding=\u0026quot;strong\u0026quot;\u0026gt; \u0026lt;string\u0026gt;DejaVu Sans\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;NanumGothic\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;UnDotum\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Guseul\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;match target=\u0026quot;pattern\u0026quot;\u0026gt; \u0026lt;test qual=\u0026quot;any\u0026quot; name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;monospace\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;family\u0026quot; mode=\u0026quot;prepend\u0026quot; binding=\u0026quot;strong\u0026quot;\u0026gt; \u0026lt;string\u0026gt;DejaVu Sans Mono\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Guseul\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;UnDotum\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;!-- Bind EunGuseul Mono with Bitstream Vera Sans Mono --\u0026gt; \u0026lt;match target=\u0026quot;pattern\u0026quot;\u0026gt; \u0026lt;test name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;Guseul\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit mode=\u0026quot;append\u0026quot; binding=\u0026quot;strong\u0026quot; name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;DejaVu Sans Mono\u0026lt;/string\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; \u0026lt;/fontconfig\u0026gt;  위에서는 기본 글꼴로 영문은 DejaVu Sans 글꼴 계열, 한국어는 네이버 나눔 글꼴 계열을 사용하고 있습니다. 참고로, Adobe 플래시에서 한글이 깨지지 않게 하려면 한글 글꼴을 영문 글꼴보다 위에 두면 됩니다.\n","date":1231286400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1231286400,"objectID":"4dc40514d769a1de2e0ea0ab7717df68","permalink":"https://lethean.github.io/2009/01/07/ubuntu-8-10-korean-font-config/","publishdate":"2009-01-07T00:00:00Z","relpermalink":"/2009/01/07/ubuntu-8-10-korean-font-config/","section":"post","summary":"Ubuntu 설치시 한국어를 선택하면 한글을 사용하는데 별 문제가 없는 것 같지만, 글꼴이나 입력기 등이 조금 문제가 있기 때문에 \u0026lsquo;시스템\u0026rsquo; -\u0026gt; \u0026l","tags":["Hangul","Ubuntu"],"title":"Ubuntu 한글 글꼴 설정","type":"post"},{"authors":null,"categories":null,"content":"이름이 \u0026lsquo;메이저버전-마이너버전-릴리스날짜\u0026rsquo; 식으로 구성된 파일 목록이, 예를 들어, 다음과 같이 주어졌을때(list.txt),\n2.0-10-20100101 2.0-2-20080101 2.0-9-20090101  셸(shell)에서 가장 최신 마이너 버전을 얻는 방법은 다음과 같습니다.\n$ sort -t- -k2,3 -n list.txt | tail -1  sort 명령 옵션을 설명하면, \u0026lsquo;-t\u0026rsquo;는 필드 구분자, \u0026lsquo;-k\u0026rsquo;는 정렬 기준으로 사용할 필드 시작,끝 번호, \u0026lsquo;-n\u0026rsquo; 옵션은 필드를 문자가 아닌 숫자로 여겨서 판단하도록 하는 것입니다. 차이점이 궁금하신 분은 아래 두 명령의 결과를 비교해 보시길.\n$ sort -t- -k2,3 -n list.txt $ sort -t- -k2,3 list.txt  ","date":1231113600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1231113600,"objectID":"cf88284264270ce1a998d3b33ee3ce9a","permalink":"https://lethean.github.io/2009/01/05/extract-latest-version-file/","publishdate":"2009-01-05T00:00:00Z","relpermalink":"/2009/01/05/extract-latest-version-file/","section":"post","summary":"이름이 \u0026lsquo;메이저버전-마이너버전-릴리스날짜\u0026rsquo; 식으로 구성된 파일 목록이, 예를 들어, 다음과 같이 주어졌을때(list.txt","tags":["Shell"],"title":"파일 목록에서 최근 버전 얻기","type":"post"},{"authors":null,"categories":null,"content":"GTK+ 포럼에 GTK+ 메모리 관리하기 라는 글이 올라왔는데 내용이 간결해서 이를 참고로 다시 정리해 보았습니다.\n참조 카운터 (Reference Counting)\n모든 GTK 객체는 GObject를 상속하고 있는데, GObject는 메모리 관리를 위해 참조 카운터 기능을 기본적으로 지원합니다. GObject가 새로 생성되면 참조 카운터는 1입니다. 이 참조 카운터는 g_object_ref() / g_object_unref() 함수를 이용해 증가시키거나 감소시킬 수 있습니다. 말 그대로 객체를 사용중이라면(참조하고 있다면) 참조 카운터를 증가시키면 되고, 더 이상 사용하지 않는다면(참조를 안한다면) 참조 카운터를 감소시키면 됩니다. 참조 카운터가 0이 되면 당연히 객체의 모든 리소스는 자동으로 해제됩니다. 하지만 언제나 그렇듯이 예외가 존재하는데 이런 경우 조심하지 않으면 그대로 메모리 누수가 발생하기 쉽상입니다.\n첫번째 경우는 객체간에 결합할 때입니다. 가장 흔한 경우가 GtkTreeModel 인터페이스를 구현한 GtkTreeStore / GtkListStore 객체와 GtkTreeView / GtkComboBox 객체를 연결할 때입니다. 예를 들어 gtk_list_store_new() 함수로 만들어진 GtkListStore 객체의 참조 카운터는 1입니다. gtk_tree_view_set_model() 함수로 트리뷰 객체에 리스트 스토어 객체를 연결하면 참조 카운터는 2가 됩니다. 왜냐하면 트리뷰 객체가 리스트 스토어 객체를 참조하기 때문입니다. 많은 예제 프로그램에서 이 함수를 호출한 뒤 g_object_unref() 함수를 이용해 리스트 스토어 객체의 참조 카운터를 감소하는 이유는, 이후 리스트 스토어 객체에 대한 메모리 관리를 더 이상 프로그래머가 할 필요 없이, 트리뷰 객체가 없어질때 리스트 스트어 객체의 참조 카운터를 감소하면서 자동으로 리소스가 정리되도록 하기 위해서입니다.\n객체 복사 (Object Copying)\n두번째 경우는 객체 데이터를 저장하거나 가져올 때입니다. GtkTreeStore / GtkListStore 객체에서 gtk_tree_model_get() 함수로 데이터를 가져오거나 gtk_list_store_set() / gtk_tree_store_set() 등으로 저장할때, 즉 데이터가 복사될때는 데이터 타입이 GObject 기반이라면 참조 카운터가 증가됩니다. 이미지 데이터를 관리하는데 많이 사용하는 GdkPixbuf 객체도 그 중 하나입니다. 따라서 이러한 객체를 가져온 뒤 사용이 다 끝났다면 g_object_unref() 함수를 이용해 반드시 참조 카운터를 해제해야 합니다. 객체 속성(property)를 설정하거나 가져올때도 마찬가지로 객체 복사 규칙이 적용됩니다. 따라서 g_object_set() / g_object_get() 함수를 사용했을 때도 사용이 끝난 객체에 대한 참조 카운터를 감소해 주어야 합니다. 마찬가지로, GtkCellRenderer 객체의 속성도 동일한 규칙이 적용되므로 유의해야 합니다.\n참고로, 객체 복사시 정수 / 실수 타입 등은 무관하지만 문자열은 항상 새로 할당된 메모리에 복사된 문자열이 전달되기 때문에 사용이 끝나면 g_free() 함수로 해제해야 합니다. GBoxed 타입은 참조 카운터가 없기 때문에 항상 새로 할당된 메모리에 복사된 자료 구조가 전달되므로 마지막에 해당 객체의 해제 함수로 리소스를 정리해야 합니다. ( G_TYPE_DATE , G_TYPE_STRV , G_TYPE_GSTRING , \u0026hellip;)\nGInitiallyUnowned 상속 객체 (Descendants of GInitiallyUnowned)\nGTK 객체 중에서 GObject를 직접 상속하지 않고, GtkObject 객체를 상속받는 객체들이 있습니다. GtkWidget / GtkAdjustment / GtkCellRenderer 등이 대표적이므로, GtkWidget을 상속하는 대부분의 위젯이 이러한 객체입니다. GtkObject 상속도 를 보면 특이하게 GInitiallyUnowned 객체를 상속받는데 이 객체의 참조 카운터 동작 방식은 위에서 설명한 것과 조금 다르기 때문에 더 깊은 이해가 필요합니다.\nGInitiallyUnowned 객체는 생성되면 초기에 참조 카운터가 0입니다. 대신 부동 참조(floating reference) 상태에 있게 됩니다. 누군가가 g_object_ref_sink() 함수를 호출하면 떠있는(floating) 참조가 참조 카운터로 변환되며 닻을 내리게(sink) 됩니다. 이후에는 일반적인 GObject 참조 카운터와 동일하게 동작합니다. 여기서 누군가는 대부분 객체를 자식(child)으로 갖는 부모(parent) 객체입니다. 즉, gtk_container_add() / gtk_box_pack_start() 등과 같은 함수를 이용하여 위젯을 결합하면 상위 위젯이 g_object_ref_sink() 함수를 호출합니다.\nGTK+ 프로그래밍시 위젯을 만들고 상위 위젯에 넣는 작업은 매우 빈번한데 만일 이 과정에 생성하는 모든 위젯 객체 리소스를 프로그래머가 관리해야 한다면 끔찍해질 겁니다. 부동 참조(floating reference) 개념은 이러한 수고를 덜어주는데 유용합니다. 모든 위젯은 생성 후 상위 위젯에 추가되어도 참조 카운터는 1밖에 안되고, gtk_widget_destroy() 등을 이용하여 최상위 위젯을 없애면 모든 하위 위젯 객체는 자동으로 참조 카운터가 0이 되어 메모리가 해제됩니다.\n참고로, 어떤 위젯을 부모 위젯에서 떼어낸 뒤 다른 부모 위젯에 넣기 위해서는 제일 먼저 해당 위젯의 참조 카운터를 증가시켜야 합니다. 왜냐하면 부모 위젯에서 떼어낼 때도 참조 카운터가 자동으로 감소하기 때문에, 떼어내는 순간 객체가 사라지기 때문입니다. 부모 위젯이 더 이상 자식 위젯을 참조 하지 않기 때문에 떼어내는 순간 자식 위젯의 참조 카운터가 감소됩니다.\n문자열 / 문자열 배열 / 리스트 (Strings, String Arrays and Lists)\nGLib 라이브러리는 매우 많은 문자열 관련 API를 제공합니다. 또한 특정 객체에서 어떤 결과나 내부 자료를 얻어올때는 문자열 배열이나 리스트(GList) 등도 많이 사용합니다. 이 경우 프로그래머는 반드시 자신이 사용하는 API 문서를 꼼꼼하게 잘 읽어야 합니다. 대부분의 API 문서는 결과로 넘겨지는 데이터 사용이 끝난 뒤 어떻게 해야 하는지를 분명히 명시하고 있기 때문에 이에 따라 리소스를 처리 해야합니다.\n따라서 예전부터 GLib / GTK+ 프로그래밍시에는 편집기의 자동 완성 (auto-complete) 기능을 잊어버리고, 번거롭더라도 DevHelp프로그램이나 웹브라우저를 이용해 API 리퍼런스를 분명히 열람한 뒤 정확하게 API를 사용할 것을 권장하고 있습니다.\n만일, API 문서에 명확하게 메모리 관리 / 객체 참조 카운터 방식이 명시되지 않았거나 무언가 개운치 않다면, 해당 API 소스 코드를 참고하는 것이 가장 확실한 방법입니다.\n","date":1230422400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1230422400,"objectID":"f96462b71f097c148a866f94379ce6af","permalink":"https://lethean.github.io/2008/12/28/gtk-memory-management/","publishdate":"2008-12-28T00:00:00Z","relpermalink":"/2008/12/28/gtk-memory-management/","section":"post","summary":"GTK+ 포럼에 GTK+ 메모리 관리하기 라는 글이 올라왔는데 내용이 간결해서 이를 참고로 다시 정리해 보았습니다. 참조 카운터 (Reference Counting) 모든 GTK 객체는 GObject를 상속하고 있","tags":["GLib","GTK+"],"title":"GTK+ 메모리 관리","type":"post"},{"authors":null,"categories":null,"content":"리누스 토발즈가 크리스마스 선물로 2.6.28 버전 커널을 내놓았군요. 늘 그랬듯이 변동사항 중에서 관심있는 사항에 대해서만 정리해 보았습니다. 자세한 내용은 물론 커널 뉴비 에서 확인이 가능합니다.\nExt4 파일시스템 공식 지원\nExt3 파일시스템과 하위 호환성을 유지하면서 대안을 각광받고 있는 Ext4 파일시스템이 드디어 실험(experimental) 딱지를 떼고 안정 버전으로 바뀌었습니다. 더 큰 용량 지원, 더 좋아진 성능과 안정성을 기반으로 리눅스의 주 파일 시스템으로 사용될 것 같습니다.\n조금 더 자세히 살펴보면, Ext3는 최대 16TB, 파일 크기는 2TB까지 지원했지만, Ext4는 1EB, 파일 크기는 16TB까지 지원합니다.(1EB = 1024PB, 1PB = 1024TB, 1TB=1024GB) Ext3는 한 디렉토리에 32000개 항목만 지원하지만, Ext4는 무한대의 항목이 가능합니다. 또한 Ext4는 전통적인 Unix 파일시스템의 간적 블럭 맵핑 방식 대신 최신 파일시스템에서 사용하는 익스텐트(extents) 기법을 적용하여 큰 파일을 처리하는데 성능을 개선했습니다. 블럭 할당 알고리즘도 개선하고, 악명놓은 fsck 실행 시간도 개선 했고, 그외 많은 부분에서 분명 Ext3 파일시스템의 한계를 극복했습니다.\n하지만 아직 대부분의 배포판에서 사용하는 GRUB 부트매니저가 지원하지 않고(우분투나 데비안에서는 grub-pc 패키지를 설치하면 됨) 있지만 대부분 배포판의 다음 배포판에서는 다음 릴리스부터 공식적으로 지원할 것 같습니다.(다른 편법은 /boot 디렉토리만 ext3 파일시스템을 사용하면 됩니다) 물론 기본 Ext3 파일 시스템을 Ext4 파일시스템으로 마운트해서 사용할 수도 있고, Ext3 -\u0026gt; Ext4 변환도 가능합니다.\n차세대 리눅스 파일시스템으로 각광받고 있는 Btrfs 파일시스템이 안정화될 때까지 사용하기 위한 임시 방편이라는 말도 있지만, 향후 2~3년 정도는 Ext3의 자리를 물려받아 대세가 될 파일시스템임은 분명할 것 같습니다.\nGPU 메모리 관리자 GEM 추가\n리눅스 커널이 윈도우 커널과 비교될때 가장 취약적으로 지적받던 그래픽 카드 관련 기능은 많은 이슈와 논란을 거쳤지만 결국 리눅스 커널은 프레임버퍼(FB)나 3D 가속을 위한 인터페이스 정도(DRI)만 지원했습니다. 그러던 것이 이제서야 드디어 본격적으로 커널에서 X 서버와 유기적으로 동작하기 위한 기능이 추가되기 시작했는데, 기존 X서버에서 처리하던 GPU 메모리 관리 기능이 리눅스 커널이 처리하게 된 것입니다. (비디오 모드 설정기능은 2.6.29에서 공식 지원할 듯)\n아직 i915 드라이버 기반 최신 인텔 그래픽 칩셋만 지원하지만, 페도라 10 배포판은 이미 이 기능을 이용하여 부팅부터 GDM 로그인까지 화면 깜박임없는 부팅을 지원하고 있습니다. (물론 이를 위해 사용하는 최신 X서버가 NVidia 같은 바이너리 드라이버가 제대로 동작하지 않아 말도 많았지만) 시간은 걸리겠지만 다른 그래픽 드라이버도 모두 이 방식을 지원하게 될 것이고, 리눅스 기반 그래픽 환경도 성능과 안정성에서 다른 운영체제와 차이점이 더 줄어들 것으로 생각됩니다. 물론 드라이버 개발자는 더 골치 아파지겠지만\u0026hellip;\n디스크 충격 방지 기능\n노트북에서 많이 사용하는 충격 방지 기능은 디스크를 사용하지 않을때 헤드를 언로드해서 충격이 발생해도 디스크 표면에 영향을 안끼치는 방식입니다. 이번 릴리스부터 리눅스 커널은 /sys/block/*/device/unload_heads 파일에 밀리초 단위의 정수형을 쓰면 그 시간동안 헤드를 언로드하고, 시간이 지나면 다시 원래대로 되돌리는 기능을 지원합니다. 하지만 모든 디스크를 지원하는 것도 아니고, 어떤 디스크는 오동작을 일으킬 수도 있기 때문에 정확히 지원하는 모델인지 확인하고 사용해야 합니다.\n기타\n그외에도 VM 메모리 관리자를 다시 작성해 많은 메모리 장착시 성능 개선, 커널 부팅 최적화를 도와주는 CONFIG_BOOT_TRACER 옵션 추가, Atheros L2(atl2) 드라이버 공식 지원, Ultra Wide Band / Wireless USB 지원, SSD(solid-state drive) 디스크 지원 강화, ALSA 드라이버 1.0.18 탑재 등 역시나 이번에도 많은 변화가 있었으니 더 관심있는 분은 이 기사 도 읽어보시길\u0026hellip; :)\n","date":1230249600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1230249600,"objectID":"26dec395c8654c6a45f9c72c7cac1a67","permalink":"https://lethean.github.io/2008/12/26/linux-kernel-2628-release/","publishdate":"2008-12-26T00:00:00Z","relpermalink":"/2008/12/26/linux-kernel-2628-release/","section":"post","summary":"리누스 토발즈가 크리스마스 선물로 2.6.28 버전 커널을 내놓았군요. 늘 그랬듯이 변동사항 중에서 관심있는 사항에 대해서만 정리해 보았습니다. 자세한 내용은 물론 커널 뉴","tags":["Kernel","Linux"],"title":"리눅스 커널 2.6.28 릴리스","type":"post"},{"authors":null,"categories":null,"content":"GTK+ 개발자 메일링 리스트에서 GTK+ 속도 관련 질의 응답 이 오가는 걸 지켜보는 도중 g_type_class_add_private() + g_type_instance_get_private() 조합을 사용하면 편하지만, 오버헤드가 크고 느리기 때문에 이를 줄일 수 있는 다른 방법을 소개한 내용 이 있어 결론만 정리해 보았습니다.\n그 방법은, 그놈 프로그래밍 가이드라인 에서도 명시했듯이, 객체 데이터 선언시 \u0026lsquo;priv\u0026rsquo; 등과 같은 필드를 선언하고, g_type_instance_get_private() 함수로 내부 데이터 주소를 얻어 \u0026lsquo;priv\u0026rsquo; 필드에 저장해 둡니다. 그리고 다음부터는 그 필드를 이용하여 내부 데이터(Private Data)에 직접 접근하는 방식입니다.\n예를 들어 기존의 코드가 다음과 같다면,\n/* foo-object.h */ typedef struct _FooObject FooObject; struct _FooObject { GObject parent; }; gint foo_object_do_something (FooObject *foo); /* foo-object.c */ typedef struct _FooObjectPrivate FooObjectPrivate; struct _FooObjectPrivate { gboolean eating; gint size; }; #define FOO_OBJECT_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), FOO_TYPE_OBJECT, FooObjectPrivate)) static void foo_object_class_init (FooObjectClass *klass) { /* ... */ g_type_class_add_private (G_OBJECT_CLASS (klass), sizeof (FooBarPrivate)); } gint foo_object_do_something (FooObject *foo) { FooObjectPrivate *priv; priv = FOO_OBJECT_GET_PRIVATE (foo); priv-\u0026gt;eating = TRUE; /* ... */ }  다음과 같이 변경하면, 매번 g_type_instance_get_private() 함수를 호출하는 오버헤드를 줄일 수 있습니다.\n/* foo-object.h */ typedef struct _FooObjectPrivate FooObjectPrivate; typedef struct _FooObject FooObject; struct _FooObject { GObject parent; FooObjectPrivate *priv; }; gint foo_object_do_something (FooObject *foo); /* foo-object.c */ struct _FooObjectPrivate { gboolean eating; gint size; }; #define FOO_OBJECT_GET_PRIVATE(obj) (((FooObject *) (obj))-\u0026gt;priv) static void foo_object_class_init (FooObjectClass *klass) { /* ... */ g_type_class_add_private (G_OBJECT_CLASS (klass), sizeof (FooBarPrivate)); } static void foo_object_init (FooObject *obj) { /* ... */ obj-\u0026gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (obj, FOO_TYPE_OBJECT, FooObjectPrivate); } gint foo_object_do_something (FooObject *foo) { FooObjectPrivate *priv; priv = FOO_OBJECT_GET_PRIVATE (foo); priv-\u0026gt;eating = TRUE; /* ... */ }  물론 위에서 설명한 방식 대신 객체 초기화시 내부 데이터(private)를 아예 따로 할당해서 관리하는 방식도 비슷하지만, g_type_class_add_private() 함수를 통해 추가한 메모리는 GLib 라이브러리가 알아서 관리해주기 때문에 더 편합니다.\n","date":1229990400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1229990400,"objectID":"9a408fec4d842fb02ad29155b1c60aea","permalink":"https://lethean.github.io/2008/12/23/reduce-accesing-overhead-for-gobject-private-data/","publishdate":"2008-12-23T00:00:00Z","relpermalink":"/2008/12/23/reduce-accesing-overhead-for-gobject-private-data/","section":"post","summary":"GTK+ 개발자 메일링 리스트에서 GTK+ 속도 관련 질의 응답 이 오가는 걸 지켜보는 도중 g_type_class_add_private() + g_type_instance_get_private() 조합을 사용하면 편하지만, 오버헤드가 크고 느리기 때문에 이를 줄일 수 있는 다른 방","tags":["GLib","GTK+"],"title":"GObject Private 데이터 접근 오버헤드 줄이기","type":"post"},{"authors":null,"categories":null,"content":" 프리젠터 먼저하기(Presenter First) 는 모델-뷰-프리젠터(MVP) 디자인 패턴과 테스트 주도 개발(TDD) 등의 아이디어를 버무린 소프트웨어 개발 방법론입니다. 이에 대해 설명하기에 앞서 먼저 모델-뷰-컨트롤러(MVC) 패턴과 비교하여 모델-뷰-프리젠터(MVP) 개념을 정리하면 대략 다음과 같습니다.\n 모델(Model) : 실제 다루고자 하는 데이터 읽기 / 쓰기. 관찰자(Observer) 패턴처럼 이벤트를 제공하면 더 좋습니다. MVC 패턴에서는 모델이 실제 데이터 뿐 아니라 사용자 인터페이스(View)와 연관된 데이터까지 처리하지만, MVP 패턴에서 모델은 순수하게 데이터만 처리합니다. 즉, 모델은 뷰나 프리젠터(사용자 인터페이스)에 대해서는 알 필요도 없고 알아서도 안됩니다. 뷰(View) : 사용자 인터페이스. 데이터 표시 뿐 아니라 사용자 입력까지 모두 처리합니다. MVC 패턴에서는 사용자 입력을 컨트롤러(Controller)에서 처리하지만 MVP 패턴에서는 뷰가 모두 처리합니다. 사용자 이벤트는 프리젠터에게 전달합니다. (관찰자 패턴을 사용합니다) 모델의 데이터가 변경되었다는 이벤트가 발생하면 데이터를 표시합니다. 하지만 초기 MVP 패턴과 달리 요즘에는 뷰와 모델간의 의존성까지 아예 없애버리고, 프리젠터가 디스플레이까지 제어합니다. 프리젠터 먼저하기 방법론에서 특히 이 방식을 이용합니다. 프리젠터(Presenter) : 뷰가 전달한 사용자 이벤트에 기반하여 시나리오에 따라 모델 데이터를 조작합니다. MVC 패턴에서 어플리케이션 역할을 하는 부분이며, 사용자 요구사항이 변경되거나 로직이 변경되면 수정이 되어야 하는 부분이기도 합니다. 결과적으로, 모델과 뷰에 대해 알고있는 건 오직 프리젠터 뿐이고, 모델과 뷰는 프리젠터를 모릅니다. 뷰는 모델에 대해 알 수도 있지만, 프리젠터 먼저하기 방법론에서는 이 의존성도 없애버립니다.  뷰를 오버로딩 가능한 추상 인터페이스로 만들고 프리젠터가 이 인터페이스를 사용하도록 하면, 뷰를 구현한(implementation) 객체는 플러그인처럼 교체 가능합니다. 즉, 뷰는 어쩔 수 없이 플랫폼이나 GUI 라이브러리에 의존하게 구현해야 하지만 모델과 프리젠터, 추상 뷰는 이와 상관없이 구현할 수 있습니다. 따라서 쉽게 이식 가능할 뿐 이나라, 하나의 데이터에 대해 여러가지 모양의 사용자 인터페이스를 지원하는 소프트웨어 개발이 쉬워집니다. 물론 모델 역시 추상 인터페이스로 만들고 같은 방식으로 프리젠터가 이 인터페이스를 사용하도록 하면 모델 구현 역시 쉽게 교체 가능한 구조가 됩니다. 그리고, 이러한 추상화는 테스트 주도 개발에도 응용할 수 있습니다.\n결과적으로, 프리젠터 먼저하기 방법론에서 모델-뷰-프리젠터의 관계는 다음 그림과 같습니다.\n [M] -----\u0026gt; [P] \u0026lt;----- [V] Model \u0026lt;===== Presenter =====\u0026gt; View (---\u0026gt; : Events, ===\u0026gt; : Messages)  모델과 뷰는 프리젠터에게 이벤트를 전달하고, 프리젠터는 모델과 객체를 제어하기 위한 메시지를 전달합니다. 즉, 프리젠터만 모델과 뷰에 대해 알고 있을 뿐, 모델과 뷰는 다른 구성 요소를 알지 못합니다. 뷰는 비즈니스 로직에서 완전히 분리하고 모든 로직은 프리젠터에서 처리합니다. 뷰 인터페이스는 가능한 얇고 단순해야 하고, 이상적인 경우 사용자 이벤트를 그대로 프리젠터에게 전달하고, 표시할 내용을 읽고 쓰는 동작만 해야 합니다.\n프리젠터에게 전달하는 이벤트는 비즈니스 로직에서 사용하는 용어를 사용하여 전달되어야 합니다. 엔지니어 관점의 이벤트가 아닌 사용자 관점의 이벤트를 사용해야 한다는 점입니다. 예를 들어, 비즈니스 로직이 \u0026ldquo;추가 버튼을 누르면 텍스트 입력 내용이 할일목록에 추가되어야 함\u0026quot;이라면, 뷰는 \u0026ldquo;save-button-clicked\u0026rdquo; 이벤트가 정의되어야 하고, 프리젠터는 이 이벤트가 발생했을때 호출할 핸들러를 연결합니다. 핸들러에서는 뷰의 \u0026ldquo;get_text()\u0026rdquo; 함수를 호출하여 텍스트 내용을 얻은 뒤 모델의 \u0026ldquo;add_to_list()\u0026rdquo; 함수를 이용해 모델에 추가합니다. 여기서 만일 버튼 대신 예쁜 아이콘으로 뷰가 달라졌다고 이벤트 이름을 \u0026ldquo;save-image-clicked\u0026quot;로 변경하거나 새로운 이벤트를 추가하면 안됩니다. 사용자가 팝업 메뉴를 원해 메뉴 선택을 이용해 동일한 처리를 하게 되더라도 \u0026ldquo;save-menu-activated\u0026quot;로 변경하거나 새로 추가할 필요도 없습니다. 또는 실제로 버튼의 \u0026ldquo;clicked\u0026rdquo; 이벤트가 아닌 \u0026ldquo;button-pressed\u0026rdquo; 이벤트를 사용하더라도 프리젠터에게 전달하는 이벤트 이름은 변경하면 안된다는 점이 중요합니다.\n위 예를 조금 더 이어보면, 모델의 \u0026ldquo;add_to_list()\u0026rdquo; 함수 내에서는 데이터에 새로운 텍스트 내용을 추가한 뒤 내용이 변경되었음을 알리는 \u0026ldquo;list-changed\u0026rdquo; 이벤트를 발생하고, 프리젠터에서 미리 이 이벤트에 연결한 핸들러는 모델의 \u0026ldquo;get_list()\u0026rdquo; 함수를 호출해 목록을 얻은 뒤, 뷰의 \u0026ldquo;set_list()\u0026rdquo; 함수를 이용해 변경된 데이터를 화면에 표시합니다. 여기까지 설명에서 중요한 점은, 모든 변경사항은 관찰자 패턴처럼 이벤트를 이용해 전달한다는 점이고, 프리젠터가 모델과 뷰 간의 중재 작업을 통해 비즈니스 로직을 완성한다는 점입니다. 만일 할일 목록과 할 일 목록 편집 화면이 분리되어 구현되어 있을 경우 서로 의존성을 가지고 싶지 않을 수도 있습니다. 이런 경우 두 모델을 중재(coordinator)해서 연결하는 새로운 프리젠터, 혹은 어플리케이션 객체를 새로 만들어 이벤트 처리를 하면 두 모델간의 의존성도 사라질 수 있습니다.\n프리젠터 먼저하기 방법론은 지금까지 설명한 MVP 패턴으로 프로그램을 할때 프리젠터 객체를 가장 먼저 코딩합니다. 어차피 모델과 뷰 객체의 인터페이스(API)와 이벤트는 프리젠터 객체 구현이 마무리 될때까지 계속 수정되므로, 모델과 뷰는 가짜 객체(Mock Object)로 구현합니다. 가짜 객체라고 해도 프리젠터가 원하는 작업은 실제로 수행하는 것처럼 동작해야 하므로 가능한 단순한 자료구조를 이용해야 합니다. 이렇게 해서 비즈니스 로직을 모두 프리젠터에 구현한 뒤에, 모델과 뷰를 실제로 데이터 베이스에 접근하거나 파일에 읽고 쓰든, GTK+ 위젯 라이브러리를 이용하거나 콘솔 GUI를 이용하든 해서 구현하면 됩니다.\n하지만 유닛 테스트 도구를 사용하지 않는다면 뷰 없이 프리젠터 동작을 확인하는 코드를 만들기는 조금 불편합니다. 이런 경우 뷰를 가짜 객체 방식으로 만들더라도 어느 정도 기본적인 사용자 입출력이 가능하도록 만들면서 해야 합니다.\n참고한 자료\n  \u0026ldquo;MVP: Model-View-Presenter, The Taligent Programming Model for C++ and Java\u0026rdquo; , Mike Potel, 1996  \u0026ldquo;TWISTING THE TRIAD, The evolution of the Dolphin Smalltalk MVP application framework\u0026rdquo; , Andy Bower, Blair McGlashan, Tutorial Paper for ESUG 2000  \u0026ldquo;Presenter First: Organizing Complex GUI Applications for Test-Drivn Development\u0026rdquo; , agile, pp. 276-288, AGILE 2006 (AGILE'06), 2006.  \u0026ldquo;Big, Complex, and Tested? Just Say \u0026lsquo;When\u0026rsquo;\u0026quot; , Better Software Magazine February, 2007  ","date":1229472000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1229472000,"objectID":"5eef74592d9cb6ac57010c762bc1cf3b","permalink":"https://lethean.github.io/2008/12/17/presenter-first-development/","publishdate":"2008-12-17T00:00:00Z","relpermalink":"/2008/12/17/presenter-first-development/","section":"post","summary":"프리젠터 먼저하기(Presenter First) 는 모델-뷰-프리젠터(MVP) 디자인 패턴과 테스트 주도 개발(TDD) 등의 아이디어를 버무린 소프트웨어 개발 방","tags":["Agile","Coding","GUI"],"title":"Presenter First 개발","type":"post"},{"authors":null,"categories":null,"content":" Xfce 프로젝트에서 사용하는 라이브러리에 포함되어 있는 ExoBinding 이라는 (객체)함수가 있는데, 매우 흥미로워서 소개합니다. (참고로, \u0026lsquo; ExoBinding and Settings Management \u0026rsquo; 블로그를 통해 알게된 내용입니다)\nExoBinding 함수는 기본적으로 GObject 기반 두 객체의 속성(properties) 값을 동기화합니다. 즉, 속성을 묶는(binding) 역할을 합니다. 속성 묶음(binding)의 한쪽 속성이 바뀌면 다른쪽 속성을 자동적으로 새로운 값으로 변경합니다. 단방향(uni-directional) 뿐 아니라 상호(mutual) 바인딩도 지원하는데, 필요할 경우 변환(transform) 함수를 지정할 수도 있습니다. 또한 복수 객체가 복잡하게 묶여 있어도 무한 루프를 자동으로 제거합니다.\n예를 들어 (기혼자일 경우에만 배우자 이름을 입력받도록 하는 경우처럼) 사용자에게 문자열을 입력받는 GtkEntry 위젯이 있고, 이 위젯의 활성화(sensitive) 여부를 결정하는 GtkCheckButton 위젯이 있을 경우 다음과 같은 코드 한 줄이면 모든게 해결됩니다.\n{ GtkWidget *button; GtkWidget *entry; button = gtk_check_button_new_with_label (\u0026quot;Are you married?\u0026quot;); entry = gtk_entry_new (); exo_binding_new (G_OBJECT (button), \u0026quot;active\u0026quot;, G_OBJECT (entry), \u0026quot;sensitive\u0026quot;); }  위 코드처럼, 엔트리 위젯의 \u0026lsquo;sensitive\u0026rsquo;를 체크버튼 위젯의 \u0026lsquo;active\u0026rsquo;에 연결만 하면 됩니다. 시그널 핸들러를 작성해서 복잡하게 처리할 필요가 전혀 없어져 버립니다. 내부적으로 묶음(binding)에 사용한 정보는 둘 중 하나의 객체가 사라지면 자동적으로 사라지므로, 메모리 누수를 걱정할 필요도 없습니다.\n이 객체에 관심을 가지는 이유는 활용도가 무궁무진하기 때문입니다. 특히 복잡한 설정 화면을 만들때 여러가지 조건으로 활성화 / 비활성화, 보여주기 / 안보여주기, 같은 값으로 위젯 간 동기화 등의 기능을 시그널 핸들러와 API를 이용해 직접 코딩하면 실수도 많고 코드 분량도 많아지는데, 위 방식을 이용하면 매우 깔끔하게 처리가 가능합니다. 더 나아가 libgconf-bridge 처럼 GConf 설정 내용을 그대로 GObject 속성에 반영하는 라이브러리와 결합할 경우, 설정 화면 만드는 일은 더욱 더 간편해질 수 있습니다.\n만일 이 기능이 Glade에 통합될 수 있다면, 정말로 UI 부분만 따로 프로그래밍할 수 있는 여건이 마련될 수도 있을 것 같은데\u0026hellip; 조만간에 소스 코드를 분석해서 프로젝트에 활용할 방법을 찾아볼 예정입니다.\n","date":1229299200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1229299200,"objectID":"dc142a23e4b1cc9b64a4a019314f10cf","permalink":"https://lethean.github.io/2008/12/15/exobinding/","publishdate":"2008-12-15T00:00:00Z","relpermalink":"/2008/12/15/exobinding/","section":"post","summary":"Xfce 프로젝트에서 사용하는 라이브러리에 포함되어 있는 ExoBinding 이라는 (객체)함수가 있는데, 매우 흥미로워서 소개합니다. (참고로, \u0026lsquo; ExoBinding and Settings Management \u0026rsquo; 블로그를 통해 알게","tags":["GTK+"],"title":"ExoBinding 소개","type":"post"},{"authors":null,"categories":null,"content":"GTK+ 프로그램 개발시 GtkTreeView / GtkComboBox 위젯은 상당히 많이 사용함에도 불구하고, 주위를 둘러보면 그저 이미 만들어져 있는 코드를 복사 붙여넣기 식으로 개발하는 사람이 많습니다. 그래서 조금만 고급 기능(?)이 필요한 경우 어디부터 시작해야할 지 몰라 당황하는 사람이 대부분인 것 같습니다. 그래서, 이 글에서는 GtkTreeView / GtkComboBox 위젯 등에서 데이터를 표시하는데 사용하는 GtkCellLayout / GtkCellRenderer 객체가 어떤 방식으로 동작하는지 간략하게 설명하려 합니다.\nGtkCellRenderers in GtkCellLayout in GtkTreeView 먼저 GtkTreeView 위젯이 표시될때 객체가 어떻게 구성되는지 설명합니다.\nGtkCellRenderer 객체는 데이터 하나를 표시하는데 사용합니다. 그림 하나, 텍스트 하나, 컴보박스 하나 등등\u0026hellip; 하지만 GtkCellRenderer 객체를 GtkTreeView 같은 위젯에 바로 넣을 수는 없고, 여러 GtkCellRenderer 객체를 하나의 GtkCellLayout 객체에 넣을 수 있습니다. 그리고 다시 GtkCellLayout 객체를 GtkTreeView 객체에 넣을 수 있습니다. 이 관계를 일종의 수식으로 표현하면 아래와 같습니다.\nGtkCellLayout1 \u0026lt;- GtkCellRenderer1 + GtkCellRenderer2 + GtkCellRenderer3 GtkCellLayout2 \u0026lt;- GtkCellRednerer4 + GtkCellRenderer5 GtkTreeView \u0026lt;- GtkCellLayout1 + GtkCellLayout2  GtkCellLayout 객체는 GtkTreeView 위젯에 표시될때 하나의 컬럼(column)으로 표시됩니다. 사용하는 GTK+ 테마에 따라 컬럼 단위로 구분선이 그어질 수도 있고, 제목을 클릭하면 정렬(sort)하는 기능을 구현하면 컬럼 단위로 정렬됩니다. 사실 GtkCellLayout은 직접 사용할 수 있는 객체가 아니고 인터페이스(interface) 역할만 하며, 이 인터페이스를 구현한 객체를 실제로 사용합니다. 예를 들면 GtkTreeViewColumn / GtkIconView / GtkCellView / GtkEntryCompletion / GtkComboBox / GtkComboBoxEntry 등입니다. 따라서 위 수식은 GtkComboBox 위젯 등에도 동일하게 적용됩니다.\n중요한 점은 GtkCellLayout 객체는 실제로 데이터를 표시하는 객체가 아니라 일종의 컨테이너 역할만 하고, 실제로 데이터를 표시하는 작업은 GtkCellRenderer 객체가 담당한다는 점입니다. 그리고 더 중요한 사실은, 이렇게 구성할때 행(row)에 대한 레이아웃과 렌더러만 구성할 수 있다는 점입니다. 즉 GtkTreeModel 객체에 들어있는 모든 데이터를 행(row) 단위 레이아웃을 거쳐 표시합니다.\nGtkCellRenderer 렌더링 프로그래머가 GtkCellRenderer 객체를 직접 사용하는 경우는 거의 없습니다. 대부분 이를 상속한 GtkCellRendererText / GtkCellRendererPixbuf / GtkCellRendererProgresss / GtkCellRendererToggle 등의 객체를 사용합니다.\nGtkCellRenderer 객체는 기본적으로 상태 정보가 없습니다. 대신 객체 속성(properties)을 기준으로 표시하고 프로그래머 역시 속성을 변경해서 원하는 내용을 표시합니다. GTK+ 위젯 시스템은 당연히 데이터 표시가 필요할때만 GtkCellRenderer 객체 속성을 변경해서 원하는 내용을 원하는 위치에 표시합니다.\n예를 들어 GtkTreeModel 객체에 100개의 행(row) 데이터가 있고, 현재 화면에는 1번째부터 10번째까지 행의 데이터만 표시된다고 가정하면 GTK+는 먼저 첫번째 행의 데이터에 대하여 모든 레이아웃, 다시 레이아웃의 모든 렌더러에게 데이터를 표시할 좌표를 알려주고, 렌더러의 속성을 트리모델의 데이터 값으로 변경합니다. 그러면 렌더러는 속성이 변경되었므로 그 속성에 따라 내용을 표시합니다. 그리고 2번째 행으로 이동해 동일한 작업을 수행합니다. 이 작업을 화면에 보이는 10번째 행까지만 반복합니다. 참고로, 이 작업은 EXPOSE 이벤트나 스크롤 이벤트가 발생했을 경우에도 필요한 영역의 데이터만 표시하기 위해 동일하게 동작합니다.\n이제 무심코 사용하는 gtk_tree_view_column_new_with_attributes() API를 한번 분석해 봅시다. 문서에서는 다음과 같이 설명하고 있습니다.\n Creates a new GtkTreeViewColumn with a number of default values. This is equivalent to calling gtk_tree_view_column_set_title() , gtk_tree_view_column_pack_start() , and gtk_tree_view_column_set_attributes() on the newly created GtkTreeViewColumn .\nHere\u0026rsquo;s a simple example:\n enum { TEXT_COLUMN, COLOR_COLUMN, N_COLUMNS }; ... { GtkTreeViewColumn *column; GtkCellRenderer *renderer = gtk_cell_renderer_text_new (); column = gtk_tree_view_column_new_with_attributes (\u0026quot;Title\u0026quot;, renderer, \u0026quot;text\u0026quot;, TEXT_COLUMN, \u0026quot;foreground\u0026quot;, COLOR_COLUMN, NULL); }  |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-| | title : | | cell : | | ... : | | Returns : |\n 기본값으로 GtkTreeViewColumn 객체를 만드는데, 이는 gtk_tree_view_column_new()로 새로운 객체를 만들고gtk_tree_view_column_set_title()로 제목을 정한 다음, gtk_tree_view_colunn_pack_start()로 렌더러를 추가한 뒤, gtk_tree_view_column_set_attributes()로 어트리뷰트를 설정한다고 되어있습니다.\n여기서 말하는 어트리뷰트(attribute)는, 위 예제에서 보는 것처럼, 렌더러의 속성(property)과(\u0026ldquo;text\u0026rdquo;, \u0026ldquo;foreground\u0026rdquo;), 트리모델에서 해당 데이터가 위치한 컬럼 번호(TEXT_COLUMN, COLOR_COLUMN)로 구성됩니다. 즉, 앞서 설명한 루프 작업시 어트리뷰트 정보를 이용해 렌더러의 속성을 트리모델의 해당 컬럼 데이터를 가져와서 매번 g_object_set() API를 이용해 설정하면 렌더러가 해당 좌표에 표시하게 됩니다.\nGtkCellRenderer Advanced? 모든 GtkCellRenderer 객체가 반드시 어트리뷰트 방식으로 동작할 필요는 없습니다. 예를 들어 컴보박스에 표시되는 텍스트 앞에 동일한 아이콘을 표시하기 위해 굳이 트리모델에 새로운 컬럼을 추가할 필요는 없습니다. 다만 다음과 같은 방식으로 텍스트 렌더러를 추가하기 전에 처리해주면 됩니다.\nc = gtk_cell_renderer_pixbuf_new (); g_object_set (G_OBJECT (c), \u0026quot;stock-id\u0026quot;, GTK_STOCK_HARDDISK, NULL); gtk_tree_view_column_set_pack_start (treeview_column, c, FALSE);  참고로 위 예제에서는 \u0026ldquo;stock-id\u0026rdquo; 속성을 사용했지만, 당연히 다른 속성을 사용해도 됩니다.\n또한 gtk_cell_layout_set_cell_data_func() 함수를 이용하면, 렌더러 실행시 호출할 함수를 등록할 수 있습니다. 따라서 반드시 트리모델 데이터 뿐 아니라 외부 데이터나 조건을 기준으로 렌더러의 속성을 가공할 수 있습니다.\n예를 들어 GtkComboBox를 이용해 트리구조 데이터를 서브메뉴 방식으로 표시하다보면, 기본적으로 서브메뉴 위에 상위 항목이 제목처럼 선택할 수 있게 표시됩니다. 이 항목이 불필요한 경우가 있는데, 다음과 같은 코드를 사용하면 됩니다.\nstatic void combo_box_cell_data_func(GtkCellLayout *cell_layout, GtkCellRenderer *cell, GtkTreeModel *tree_model, GtkTreeIter *iter, gpointer data) { gboolean sensitive; sensitive = !gtk_tree_model_iter_has_child (tree_model, iter); g_object_set (cell, \u0026quot;sensitive\u0026quot;, sensitive, NULL); } ... gtk_cell_layout_set_cell_data_func (GTK_CELL_LAYOUT (combobox), renderer, combo_box_cell_data_func, NULL, NULL);  이제, 다른 어플리케이션 소스나 GTK+ 문서를 한번 정독하면 GtkTreeView / GtkComboBox 위젯을 다루는 작업은 더이상 어렵지 않을까요?\n","date":1228089600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1228089600,"objectID":"79c2145a6c91a7e906e77fbd64e04e76","permalink":"https://lethean.github.io/2008/12/01/understanding-gtktreeview-cellrenderer/","publishdate":"2008-12-01T00:00:00Z","relpermalink":"/2008/12/01/understanding-gtktreeview-cellrenderer/","section":"post","summary":"GTK+ 프로그램 개발시 GtkTreeView / GtkComboBox 위젯은 상당히 많이 사용함에도 불구하고, 주위를 둘러보면 그저 이미 만들어져 있는 코드를 복사 붙여넣기 식으로 개발하는 사람이 많습니다.","tags":["GTK+"],"title":"GtkCellRenderer 이해하기","type":"post"},{"authors":null,"categories":null,"content":" Wireshark 프로그램을 이용할때, 문제의 현상이 발생하는 패턴을 모르는 경우 무작정 발생할때까지 패킷을 캡쳐해야 하는 경우가 있습니다. 이때 Wireshark 프로그램으로 무조건 캡쳐를 하면 금방 메모리가 부족해서 프로그램이 죽어버리게 됩니다. 이런 경우 tcpdump 프로그램을 이용하여 패킷을 캡쳐하여 파일에 저장하고, 현상이 발생했을때 멈추고 난뒤 캡쳐한 파일을 다시 Wireshark 프로그램에서 볼 수 있는 방법이 있습니다.\n먼저 tcpdump를 설치합니다.\n$ sudo apt-get install tcpdump  그리고 다음과 같이 패킷 캡쳐를 시작합니다. (물론 모두 한 줄에 적어도 됩니다)\n$ sudo tcpdump -i eth0 -s 1500 -C 5 -W 3 -w capture.pcap 'host 192.168.0.100'  여기서 \u0026lsquo;-i\u0026rsquo; 옵션은 네트웍 장치 이름, \u0026lsquo;-s\u0026rsquo; 옵션은 패킷 크기, \u0026lsquo;-C\u0026rsquo; 옵션은 캡쳐할 파일을 구분할 크기(MB), \u0026lsquo;-W\u0026rsquo; 옵션은 순환할 파일 갯수, \u0026lsquo;-w\u0026rsquo; 옵션은 파일 이름 앞부분, 마지막 필터 조건에서 \u0026lsquo;host\u0026rsquo;는 캡쳐할 캡쳐의 IP 주소를 의미합니다.\n이렇게 실행하면 \u0026lsquo;capture.pcap0\u0026rsquo;, \u0026lsquo;capture.pcap1\u0026rsquo;, \u0026lsquo;capture.pcap2\u0026rsquo; 식으로 5MB 단위로 캡쳐 파일을 생성합니다. 그리고 항상 마지막 3개 파일만 남깁니다. 캡쳐 도중 현상이 발생했다면 CTRL-C 키를 눌러 캡쳐를 멈추고, 마지막 파일을 Wireshark 프로그램 메뉴에서 \u0026lsquo;File\u0026rsquo; -\u0026gt; \u0026lsquo;Open\u0026hellip;\u0026rsquo; 기능을 이용해 읽어오면 됩니다.\n더 자세한 내용은 Wireshark 매뉴얼 과 \u0026lsquo;man tcpdump\u0026rsquo;를 참고하시길\u0026hellip; :)\n","date":1227052800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1227052800,"objectID":"66e272386e3fb176fe66e7d9268f944f","permalink":"https://lethean.github.io/2008/11/19/wireshark-tcpdump/","publishdate":"2008-11-19T00:00:00Z","relpermalink":"/2008/11/19/wireshark-tcpdump/","section":"post","summary":"Wireshark 프로그램을 이용할때, 문제의 현상이 발생하는 패턴을 모르는 경우 무작정 발생할때까지 패킷을 캡쳐해야 하는 경우가 있습니다. 이때 Wireshark 프로그램으로 무조건 캡쳐를","tags":["Linux","Wireshark"],"title":"Wireshark \u0026 tcpdump","type":"post"},{"authors":null,"categories":null,"content":"네트웍 패킷을 검사하기 위해 자주 사용하는 Wireshark 프로그램을 리눅스에서 실행할때 이더넷 장치에 따라 \u0026lsquo;Bad Checksum\u0026rsquo;을 표시하며 패킷이 붉은 색으로 표시되어 눈에 거슬리는 경우가 종종 있습니다.\n이는 패킷 전송시 이더넷 하드웨어가 패킷 체크섬을 계산하도록 하는 기능이 자동으로 켜져있는데, 이 부분에 오류가 있는 경우입니다. 대부분의 경우 문제를 야기하지 않지만, 때로는 IP가 제대로 할당되었는데 실제 동작을 안하는 원인이 되기도 합니다. 따라서 이 기능을 끄고 싶을 경우가 발생하는데, 다음과 같은 명령어만 실행하면 됩니다.\n$ sudo ethtool -K eth0 tx off  여기서 \u0026lsquo;eth0\u0026rsquo;는 장치 이름입니다. 더 궁금하시면 \u0026lsquo;man ethtool\u0026rsquo;을 통해 확인하시기 바랍니다.\n","date":1226880000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1226880000,"objectID":"6688697f640e7bfdb7ec3b2cd0d76db9","permalink":"https://lethean.github.io/2008/11/17/wireshark-bad-checksum/","publishdate":"2008-11-17T00:00:00Z","relpermalink":"/2008/11/17/wireshark-bad-checksum/","section":"post","summary":"네트웍 패킷을 검사하기 위해 자주 사용하는 Wireshark 프로그램을 리눅스에서 실행할때 이더넷 장치에 따라 \u0026lsquo;Bad Checksum\u0026rsquo;을 표시하며 패킷이 붉은 색으로","tags":["Linux","Wireshark"],"title":"Wireshark Bad Checksum","type":"post"},{"authors":null,"categories":null,"content":"GTK+ 또는 GLib 기반 프로그래밍을 할때 g_warning() / g_return_if_fail() 등과 같은 API를 사용한 경고 메시지가 어디서 발생했는지 찾기 어려운 경우가 있습니다. 더 나아가 해당 함수를 호출하는 부분을 알아야 하는데, 사실 메시지만으로는 찾기가 매우 어려운 경우가 많습니다.\n예를 들어 수만라인짜리 프로그램이 실행 도중 다음과 같은 메시지를 출력합니다.\nGtk-CRITICAL **: gtk_widget_set_sensitive: assertion `GTK_IS_WIDGET (widget)' failed  아, gtk_widget_set_sensitive() 함수를 호출할때 첫번째 인수를 잘못 넘겨준 건 알겠는데, 문제는 gtk_widget_set_sensitve() 함수를 호출하는 부분이 수십군데입니다. 마땅히 실행 도중이라 어떤 모듈에서 호출하는지도 애매합니다. 다음에 설명할 방법을 모른다면, 리누스 토발즈의 말 그대로, 모든 소스 코드를 직접 검토할 수 밖에 없죠\u0026hellip;\n만일 이 메시지가 발생하는 시점에서 gdb의 backtrace 명령으로 함수 호출 스택을 알아낼 수 있다면 인생은 편해집니다. 그리고 이를 위해 GLib에는 당연하다는듯이 g_log_set_always_fatal() 이라는 API가 존재합니다. 이 API는 설정하는 레벨의 로그 메시지가 발생하면 강제로 코어 덤프를 발생하고 프로그램 실행을 중지합니다. gdb에서 동작할 경우 해당 지점에서 정확하게 멈춥니다.\n위 예에서 우리가 원하는 레벨은 CRITICAL 레벨인 경우이므로 다음 코드를 프로그램 시작 부분에 넣어주면 위 메시지가 출력되는 시점에서 정확하게 프로그램이 멈추게 됩니다.\ng_log_set_always_fatal (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL);  그리고 gdb에서 backtrace 명령을 실행하면, 정확하게 문제를 일으키는 코드를 찾아낼 수 있겠죠?\n","date":1226620800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1226620800,"objectID":"56220f1aa00941e196eb57d2f62359e8","permalink":"https://lethean.github.io/2008/11/14/tracing-gtk-glib-warning-messages/","publishdate":"2008-11-14T00:00:00Z","relpermalink":"/2008/11/14/tracing-gtk-glib-warning-messages/","section":"post","summary":"GTK+ 또는 GLib 기반 프로그래밍을 할때 g_warning() / g_return_if_fail() 등과 같은 API를 사용한 경고 메시지가 어디서 발생했는지 찾기 어려운 경우가 있습니다. 더 나아가 해당 함수를 호출하는 부분","tags":["GLib","GTK+"],"title":"GTK+ / GLib 경고 메시지 추적하기","type":"post"},{"authors":null,"categories":null,"content":"프로젝트를 빌드할때마다 매번 ssh 프로그램으로 로그인해서 emacs / vi 등의 에디터로 컴파일해서 다시 이를 타겟 장비에 scp 명령어로 복사하고\u0026hellip; 조금 복잡하고 번거롭죠. 또한 개발환경으로 터미널 에디터 밖에 사용이 불가능합니다. 이 글은 이러한 개발 환경을 조금 탈피해서, 실제 소스 파일은 빌드 호스트에 두고 빌드 작업도 빌드 호스트에서 실행하면서, 이클립스(Eclipse) 개발 환경을 이용해 개발하는 방법을 간단하게 설명합니다.\n이 글은 개인 장비에 우분투 리눅스 + Eclipse 개발 환경(3.4 Ganymede 기준)이 구축되어 있다는 가정하에 설명합니다. 원격 빌드 호스트 장비(build-dvr24)는 SSH 서버가 설치되어 있고 개인 계정도 이미 만들어져 있다고 가정합니다.(여기서는 lethean)\nSSH 로그인 비밀번호 안물어보게 하기 SSH 로그인시 비밀번호 확인 과정을 넘어가기 위해 개인공개키를 빌드 호스트에 복사합니다. 그러면 이후 모든 SSH 작업시 비밀번호를 물어보지 않게 되어 편리합니다. 만일 개인공개키가 만들어져 있지 않다면 다음과 같이 생성합니다.\n$ ssh-keygen -t dsa Enter file in which to save the key (/home/lethean/.ssh/id_dsa): [Enter] Enter passphrase (empty for no passphrase): [Enter] Enter same passphrase again: [Enter]  이 경우 개인 공개키 파일은 ~/.ssh/id_dsa.pub 파일입니다. 이 파일을 원격 빌드 호스트 계정의 인증키 목록에 다음과 깉이 추가합니다.\n$ ssh-copy-id -i ~/.ssh/id_dsa.pub lethean@build-dvr24  여기서 \u0026lsquo;lethean@build-dvr24\u0026rsquo; 부분은 \u0026lsquo;접속계정@호스트이름\u0026rsquo; 형식입니다.\n원격 파일시스템 연결하기 제일 먼저 마운트할 디렉토리를 미리 생성합니다.\n$ mkdir -p ~/build-dvr24  터미널에서 다음과 같이 \u0026lsquo;sshfs\u0026rsquo; 프로그램을 설치합니다.\n$ sudo apt-get install sshfs  프로그램을 설치한 뒤 sshfs / fusermount 명령어를 이용해 원격 SSH 서버의 디렉토리를 로컬 파일 시스템에 연결하거나 해제할 수 있습니다. 예를 들어 연결(mount)하려는 원격 디렉토리가 \u0026lsquo;/home/lethean\u0026rsquo;이고, 로컬 홈 디렉토리 밑의 \u0026lsquo;build-dvr24\u0026rsquo; 디렉토리에 연결할 경우 다음과 같이 실행합니다. (원격 디렉토리는 절대경로 방식으로 지정해야 하며 반드시 홈디렉토리일 필요는 없습니다)\n$ sshfs lethean@build-dvr24:/home/lethean ~/build-dvr24  사용이 다 끝났으면 다음과 같이 연결을 해제할 수 있습니다\n$ fusermount -u ~/build-dvr24  이를 부팅시 자동으로 연결하는 방법은 여러가지 방법이 있지만, 쉬운 방법 중 하나는 \u0026lsquo;/etc/rc.local\u0026rsquo; 파일에 다음과 같은 내용을 마지막 \u0026lsquo;exit 0\u0026rsquo; 전에 추가하는 것입니다.\nsu lethean -c 'sshfs lethean@build-dvr24:/home/lethean ~/build-dvr24' exit 0  여기까지 하면 원격 파일 시스템을 마치 로컬 파일 시스템처럼 사용이 가능하므로 이클립스 뿐 아니라 VI, Emacs 등의 에디터를 이용해 쉽게 편집이 가능합니다.\n( /etc/fstab 파일을 수정하는 방법 도 있는데 조금 복잡하군요. 관심이 있으시다면 직접 해보시기 바랍니다)\n이클립스에서 빌드 명령어 실행하기 먼저 연결(mount)한 소스를 기반으로 새로운 프로젝트를 생성해야 합니다. C 언어 기반 프로젝트일 경우를 가정할때 순서는 다음과 같습니다.\n \u0026lsquo;File -\u0026gt; New -\u0026gt; C Project\u0026hellip;\u0026lsquo;를 선택하여 새로운 프로젝트를 시작합니다. 프로젝트 이름(Project name)을 입력합니다. \u0026lsquo;기본 위치 사용(Use default location)\u0026rsquo; 선택을 해제한 뒤, 위치(Location)를 직접 선택하여(Browse\u0026hellip;) \u0026lsquo;~/build-dvr24\u0026rsquo; 디렉토리 밑의 해당 소스 디렉토리를 지정합니다. 프로젝트 종류(Project types)는 \u0026lsquo;Makefile project\u0026rsquo; / \u0026lsquo;Linux GCC\u0026rsquo;를 선택합니다. 그리고 언어 설정 등을 선택한 뒤 마침(Finish) 버튼을 눌러 새로운 프로젝트를 생성합니다.  이제 프로젝트 탐색기(Project Explorer)에서 생성한 프로젝트를 선택하고, 마우스 오른쪽 버튼을 눌러 \u0026lsquo;Properties\u0026rsquo; 메뉴 항목을 선택합니다. 이제 다음 순서대로 빌드 명령어를 변경합니다.\n \u0026lsquo;C/C++ Build\u0026rsquo; 항목을 선택합니다. \u0026lsquo;기본 빌드 명령어 사용(Use default build command)\u0026rsquo; 선택을 해제한 뒤, 빌드 명령어(Build command)를 다음과 같이 입력합니다. ssh lethean@build-dvr24 'make -C project-dir'  여기서 \u0026lsquo;project-dir\u0026rsquo;은 홈디렉토리 기준 원격 디렉토리를 의미합니다. 파일 시스템이 연결된 로컬 파일 시스템과는 상관없이 ssh 로 직접 연결해서 해당 디렉토리를 빌드하도록 하는게 이 방법의 핵심입니다. 물론 이 방법은 이클립스 뿐 아니라 다른 개발 환경에서도 응용이 가능합니다.\n","date":1218412800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1218412800,"objectID":"b2b7284dfd31f20dd80c061abd878d6d","permalink":"https://lethean.github.io/2008/08/11/eclipse-with-remote-ssh-server/","publishdate":"2008-08-11T00:00:00Z","relpermalink":"/2008/08/11/eclipse-with-remote-ssh-server/","section":"post","summary":"프로젝트를 빌드할때마다 매번 ssh 프로그램으로 로그인해서 emacs / vi 등의 에디터로 컴파일해서 다시 이를 타겟 장비에 scp 명령어로 복사하고\u0026hellip; 조금 복잡하","tags":["Eclipse","Linux"],"title":"이클립스(Eclipse) + 원격 SSH 서버 작업하기","type":"post"},{"authors":null,"categories":null,"content":"소프트웨어를 개발하면서 멀티 쓰레드 방식을 사용하는 경우는 많습니다. 하지만 그만큼 복잡도가 증가해서 세심하게 고려하여 설계하지 않으면 디버깅 재앙을 얻는 경우가 많습니다. 이 글은 \u0026lsquo; 멀티쓰레드 프로그래밍 규칙 \u0026lsquo;에서 이어지는 내용입니다. GTK+ 쓰레드 관련 잡설 은 이미 언급한 적이 있으니까, 오늘은 별도의 쓰레드로 동작하는 간단한 예제 모듈을 만들면서 몇가지 유용한 GLib 쓰레드 API를 설명하겠습니다.\n리소스 (Resources) 한 개 이상의 쓰레드가 동작하는 방식의 소프트웨어를 설계할 경우 가장 염두에 두어야 하는 점은 **자원(resources)**입니다. 자원, 즉 리소스는 쉽게 말해 소프트웨어가 사용하는 데이터를 의미합니다. 전역 변수, 디스크 파일, 네트웍 소켓, 외부 장치 심지어 비디오 카드 같은 그래픽 장치 등이 모두 리소스입니다. 물론 넓은 의미에서 보면 리소스는 하나의 기능이나 세부 작업을 나타낼 수도 있습니다.\n멀티쓰레드 프로그래밍에서 가능한 지켜야 하는 가장 중요한 원칙은 \u0026lsquo;하나의 쓰레드만 하나의 리소스에 접근할 수 있어야 한다\u0026lsquo;입니다. 아무 생각없이 하나의 리소스에 여러 쓰레드가 동시에 접근하도록 설계할 경우, 어쩔 수 없이 뮤텍스(mutex) 계열 API를 이용해 접근할 때마다 임계 구역을 보호해야 합니다. 그리고 이러한 기법은 소스 코드가 복잡해지고 커질수록 버그가 많아지고, 디버깅도 점점 어려워집니다. 물론, 쓰레드-풀(thread-pool) 기법처럼 성능 최적화나 확장성을 위해 멀티쓰레드를 사용하는 경우처럼 예외도 사실 많지만, 일단 이 글에서는 무시합니다.\n앞서 예를 들었던 GTK+ 쓰레드 프로그래밍도 리소스 관점에서 보면, 무조건 모든 쓰레드에서 GTK+ / GDK API 호출 전후에 gdk_threads_*() 계열 API를 남용해서 지독한 데드락과 이중락에 고생하던가, 아니면 GTK+ / GDK API 호출을 메인 쓰레드에서만 호출하도록 g_idle_add() / g_timeout_add() API만 이용하는 방법이 있습니다. 두번째 방법을 모델-뷰(Model-View) 개념으로 생각하면 마지막 GTK+ / GDK API 호출을 뷰(view) 갱신으로 볼 수 있고, g_idle_add() 계열 API는 일종의 메시지 전달로 생각할 수도 있습니다. (참고로 Sentry24DVR 2.x 버전은 첫번째 방식을, Sentry24CMS 2.x 버전은 두번째 방식을 사용합니다)\n쓰레드 시작 / 정지 / 실행 가장 먼저 쓰레드를 만들고 종료하는 루틴을 만들어 봅시다. 편의상 모듈 이름은 \u0026lsquo;drink\u0026rsquo;라고 합니다.\n#include \u0026lt;glib.h\u0026gt; typedef struct _Drink Drink; struct _Drink { GThread *thread; gint running; GAsyncQueue *queue; gchar *host; gint port; }; static gpointer drink_process (gpointer data) { Drink *drink = data; while (g_atomic_int_get (\u0026amp;drink-\u0026gt;running)) { // do something... } return NULL; } Drink * drink_new (const gchar *host, gint port) { Drink *drink; g_return_val_if_fail (host != NULL, NULL); g_return_val_if_fail (port \u0026gt; 0, NULL); drink = g_new (Drink, 1); drink-\u0026gt;host = g_strdup (host); drink-\u0026gt;port = port; drink-\u0026gt;queue = g_async_queue_new (); g_atomic_int_set (\u0026amp;drink-\u0026gt;running, 1); drink-\u0026gt;thread = g_thread_new (drink_process, drink, TRUE, NULL); return drink; } void drink_destroy (Drink *drink) { g_return_if_fail (drink != NULL); g_atomic_int_set (\u0026amp;drink-\u0026gt;running, 0); g_thread_join (drink-\u0026gt;thread); g_async_queue_unref (disk-\u0026gt;queue); g_free (drink-\u0026gt;host); g_free (drink); }  drink_new() 함수는 지정한 호스트 / 포트 번호를 이용하여 새로운 Drink 객체를 만듭니다. 그리고 앞으로 나올 모든 데이터는 각각 자신이 속한 Drink 객체만 접근합니다. 즉, Drink 객체를 하나의 리소스로 여기면 됩니다. drink_destroy() 함수는 쓰레드가 종료할때까지 기다렸다가 Drink 객체를 해제하고 마무리합니다.\n쓰레드 함수 무한 루프는 간단하게 정수형 변수를 플래그처럼 사용합니다. 제대로 하려면 플래그 변수 역시 뮤텍스 API로 보호해주어야 하지만 대부분의 경우 간단한 원자연산자(atomic operator)로 처리가 가능합니다. 일단 이렇게 만들어 둡시다.\n마지막으로 설명할 API가 GAsyncQueue 객체인데, 가장 중요한 역할을 담당하는 물건입니다. 설명 그대로 이 API는 쓰레드간 비동기 통신(asynchronous communication between threads)을 하는데 사용합니다. 이 객체를 생성하는데는 g_async_queue_new(), 없애기 위해서는 g_async_queue_unref() 함수를 이용하는데, 일단 지금은 만들어만 놓습니다.\nAPI 추가 + 메시지 전달 제일 먼저 하고 싶은 일은 미리 지정한 서버에 TCP 연결을 하거나, 끊고 싶습니다. 이를 비동기큐를 이용해서 간단하게 구현해 봅시다.\nenum { DRINK_MSG_CONNECT = 1, DRINK_MSG_SHUTDOWN = 2, }; void drink_connect (Drink *drink) { g_return_if_fail (drink != NULL); g_async_queue_push (drink-\u0026gt;queue, GINT_TO_POINTER (DRINK_MSG_CONNECT)); } void drink_shutdown (Drink *drink) { g_return_if_fail (drink != NULL); g_async_queue_push (drink-\u0026gt;queue, GINT_TO_POINTER (DRINK_MSG_SHUTDOWN)); }  이렇게 하면 drink_connect() / drink_shutdown() 함수를 호출하면 g_async_queue_push() 함수를 이용해 메시지를 큐에 넣기만 하고 아무 일도 안합니다. (참고 : 모듈 외부에서 볼때는 내부 구현에 쓰레드를 사용하는지, 메시지 큐를 이용하는지 등은 공개되지도 않고, 공개할 필요도 없습니다) 이제 drink_process() 함수를 다음과 같이 수정합니다.\nstatic gpointer drink_process (gpointer data) { Drink *drink = data; while (g_atomic_int_get (\u0026amp;drink-\u0026gt;running)) { do { GTimeVal tval; gpointer msg; /* wait for messages */ g_get_current_time (\u0026amp;tval); g_timeval_add (\u0026amp;tval, 10000); /* 10msec */ msg = g_async_queue_timed_pop (drink-\u0026gt;queue, \u0026amp;tval); if (!msg) break; switch (GPOINTER_TO_INT (msg)) { case DRINK_MSG_CONNECT: // do connect work... break; case DRINK_MSG_SHUTDOWN: // do shutdown work... break; default: g_warning (\u0026quot;unknown drink msg\u0026quot;); break; } } while (1); // do something else ... } return NULL; }  보는 바와 같이 메시지 큐에서 메시지를 꺼내어 메시지에 해당하는 작업을 처리합니다. 만일 메시지 큐를 사용하지 않고 drink_connect() 함수에서 직접 연결 작업을 수행하면 쓰레드 부분과 공유하는 부분을 모두 뮤텍스로 보호해야 하지만 이처럼 모든 작업을 담당 쓰레드가 처리하도록 메시지만 전송하면 실행 순서도 맞고 쓰레드가 자료 공유를 걱정할 필요도 없게 됩니다.\n여기서 사용한 g_async_queue_timed_pop() 함수는 지정한 시간 동안 아무 메시지도 없으면 NULL을 돌려줍니다. 비슷한 함수로 g_async_queue_pop() 함수는 메시지가 올때까지 무한정 기다랍니다. g_async_queue_try_pop() 함수는 메시지가 없을 경우 바로 NULL을 돌려줍니다. 만일 쓰레드 함수 자체적인 작업은 없고 100% 외부에서 메시지가 올때만 작업이 수행된다면 g_async_queue_pop() 함수를 사용하는 것이 더 좋습니다. 프로세스 동기화나 수면 상태(sleep) 등을 다른 작업을 하면서 자체적으로 하는 경우라면 g_async_queue_try_pop() 함수가 유용합니다.\n이 예제에서는 단순하게 10 밀리초 여유를 두고 메시지를 확인하고, 그외 다른 작업을 처리하도록 했습니다.\n쓰레드 종료 다듬기 예제 처음에 있던 쓰레드 종료 코드가 너무 단순해서 조금 불안할 지도 모르겠네요. 메시지 큐에 데이터가 있을때 종료되면 메모리 누수도 있을 것 같고\u0026hellip; 그래서 쓰레드 종료도 하나의 메시지로 처리하도록 하려고 합니다. 수정하는 부분은 다음과 같습니다.\nenum { DRINK_MSG_STOP_THREAD = -1, DRINK_MSG_CONNECT = 1, DRINK_MSG_SHUTDOWN = 2, }; static gpointer drink_process (gpointer data) { Drink *drink = data; while (TRUE) { GTimeVal tval; gpointer msg; /* wait for messages */ g_get_current_time (\u0026amp;tval); g_timeval_add (\u0026amp;tval, 10000); /* 10msec */ msg = g_async_queue_timed_pop (drink-\u0026gt;queue, \u0026amp;tval); if (msg) { if (msg == GINT_TO_POINTER (DRINK_MSG_STOP_THREAD)) break; switch (GPOINTER_TO_INT (msg)) { case DRINK_MSG_CONNECT: // do connect work... break; case DRINK_MSG_SHUTDOWN: // do shutdown work... break; default: g_warning (\u0026quot;unknown drink msg\u0026quot;); break; } } // do something else ... } void drink_destroy (Drink *drink) { g_return_if_fail (drink != NULL); g_async_queue_push (drink-\u0026gt;queue, GINT_TO_POINTER (DRINK_MSG_STOP_THREAD)); g_thread_join (drink-\u0026gt;thread); g_async_queue_unref (disk-\u0026gt;queue); g_free (drink-\u0026gt;host); g_free (drink); }  쓰레드 함수 무한루프 조건문이 조금 변경되었을 뿐 기본적인 원리는 동일합니다.\n마지막, 조금 더 개선\u0026hellip; 이놈의 메시지 방식을 사용하면 대부분 프로그래머는 쉽게 switch() 문의 유혹을 떨쳐버리지 못합니다. 근데, 만일 당신이 매우 성능 좋은 메시징 서비스를 만들고 있다면 이런 방식의 코드는 유지보수도 힘들고 성능도 나쁠 수 있습니다. 메시지-함수 테이블을 유지해도 되고, 여러가지 방법이 있겠지만 여기서는 약간 가독성(readability)과 유지보수에 중점을 둔 방식을 설명하려 합니다.\ntypedef struct _DrinkMsg DrinkMsg; struct _DrinkMsg { void (*func) (Drink *drink, gpointer data1, gpointer data2); gpointer data1; gpointer data2; }; static gpointer drink_process (gpointer data) { ... DrinkMsg *msg; msg = g_async_queue_try_pop (drink-\u0026gt;queue); if (msg) { if (msg == GINT_TO_POINTER (-1)) break; msg-\u0026gt;func (drink, msg-\u0026gt;data1, msg-\u0026gt;data2); g_slice_free1 (msg); } ... } void drink_destroy (Drink *drink) { ... g_async_queue_push (drink-\u0026gt;queue, GINT_TO_POINTER (-1)); g_thread_join (drink-\u0026gt;thread); ... } static void drink_connect_real (Drink *drink, gpointer data1, gpointer data2) { gchar *host = data1; gint port = GPOINTER_TO_INT (data2); // do connect work... g_free (host); } void drink_connect (Drink *drink, const gchar *host, gint port) { DrinkMsg *msg; msg = g_slice_new (DrinkMsg); msg-\u0026gt;func = drink_connect_real; msg-\u0026gt;data1 = g_strdup (host); msg-\u0026gt;data2 = GINT_TO_POINRTER (port); g_async_queue_push (drink-\u0026gt;queue, msg); }  뭐\u0026hellip; 더 이상의 설명은 피곤해서\u0026hellip;\n궁금한 API는 직접 매뉴얼을 한 번 뒤져보시길\u0026hellip; :)\n","date":1217980800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1217980800,"objectID":"cee9ddbe7bde08b18f50c40b785da962","permalink":"https://lethean.github.io/2008/08/06/glib-thread-programming/","publishdate":"2008-08-06T00:00:00Z","relpermalink":"/2008/08/06/glib-thread-programming/","section":"post","summary":"소프트웨어를 개발하면서 멀티 쓰레드 방식을 사용하는 경우는 많습니다. 하지만 그만큼 복잡도가 증가해서 세심하게 고려하여 설계하지 않으면 디버깅 재앙을 얻는 경우","tags":["Coding","GLib","GTK+"],"title":"GLib 쓰레드 프로그래밍","type":"post"},{"authors":null,"categories":null,"content":"워드프레스로 블로그를 옮기면서 다짐했던 것 중 하나가 가능한 소스를 건드리지 않고 일반 사용자처럼 사용하자였는데\u0026hellip; 카테고리별 RSS 피드를 왜 설정에서 쉽게 변경하지 못하고, 테마나 위젯 소스를 건드려야만 하도록 했을까, 결국 위젯 코드를 수정해서 원하는 기능을 얻었습니다.\npublic_html/wp-includes/widgets.php 2008-07-22 12:09:23 @@ -745,6 +745,8 @@ \u0026lt;ul\u0026gt; \u0026lt;?php $cat_args['title_li'] = ''; + $cat_args['feed'] = 'rss'; + $cat_args['feed_image'] = 'rssfeed.jpg'; wp_list_categories($cat_args); ?\u0026gt; \u0026lt;/ul\u0026gt;  더이상 코드를 수정할 일 없기만을 바랄 뿐\u0026hellip;\n","date":1217980800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1217980800,"objectID":"dc88e125749867330d7faddcd432558b","permalink":"https://lethean.github.io/2008/08/06/adding-category-rss-link/","publishdate":"2008-08-06T00:00:00Z","relpermalink":"/2008/08/06/adding-category-rss-link/","section":"post","summary":"워드프레스로 블로그를 옮기면서 다짐했던 것 중 하나가 가능한 소스를 건드리지 않고 일반 사용자처럼 사용하자였는데\u0026hellip; 카테고리별 RSS 피드를 왜 설정에","tags":["WordPress"],"title":"카테고리 RSS 링크 추가","type":"post"},{"authors":null,"categories":null,"content":" 글레이드(Glade) 매뉴얼 에서 카탈로그(Catalog) 소개 부분을 날림 번역한 내용입니다.\n소개 (Introduction) 사용자 위젯은 여러 방법으로 지원할 수 있는데, 패키지를 만들어 이를 시스템 디렉토리에 설치하거나, 사용자 디렉토리 또는 프로젝트 디렉토리에서 직접 추가적인 카탈로그를 읽어들일 수 있습니다. 라이브러리에 보이는 객체 종류(object type)를 나타내기 위해 필요한 아이콘(icons)을 지원하는 코드를 만들수도 있고, 다음에 설명할 부모(parent) 속성(property)을 이용하여 처리할 수도 있습니다. 인스펙터(inspector)와 팔레트(pallette)가 사용할 아이콘을 제공하지 않으면 글레이드는 단순하게 경고 메시지를 출력하고 기본 아이콘을 사용합니다. 카탈로그 파일은 XML 형식으로 작성되며, DTD 파일은 글레이드 압축파일에서 plugins/ 디렉토리에서 찾을 수 있습니다. 대부분의 경우 GTK+ 파생 위젯은 적은 노력으로 추가할 수 있으며 간단하게 위젯 종류를 명시하는 것으로 충분합니다. 글레이드는 속성(properties)과 시그널(signals)을 조사합니다(introspection). 하지만 위젯 툴킷 구조상의 본질로 인해 예외는 있습니다. 이 문서는 몇가지 기본 예제와 UI 편집을 강화하고 예외를 처리하는데 사용할 수 있는 풍부한 옵션을 제공할 것입니다.\n카탈로그 파일은 카탈로그 이름과 사용할 플러그인 라이브러리를 지정하면서 시작합니다. 다음 예제에서는 \u0026ldquo;Foo\u0026quot;라는 이름공간(namespace)을 가지면서 \u0026ldquo;Frobnicator\u0026rdquo; 객체를 통합한다고 가정합니다.\n\u0026lt;glade-catalog name=\u0026quot;foo\u0026quot; library=\u0026quot;foo\u0026quot; depends=\u0026quot;gtk+\u0026quot;\u0026gt; \u0026lt;init-function\u0026gt;my_catalog_init\u0026lt;/init-function\u0026gt; \u0026lt;glade-widget-classes\u0026gt; \u0026lt;glade-widget-class name=\u0026quot;FooFrobnicator\u0026quot; generic-name=\u0026quot;frobnicator\u0026quot; title=\u0026quot;Frobnicator\u0026quot;/\u0026gt; ... widget classes go here \u0026lt;/glade-widget-classes\u0026gt; \u0026lt;glade-widget-group name=\u0026quot;foo\u0026quot; title=\u0026quot;Foo\u0026quot;\u0026gt; \u0026lt;glade-widget-class-ref name=\u0026quot;FooFrobnicator\u0026quot;/\u0026gt; ... widget class references go here \u0026lt;/glade-widget-group\u0026gt; ... widget groups go here \u0026lt;/glade-catalog\u0026gt;  최상위 카탈로그 속성과 태그 (Toplevel catalog properties and tags) 카탈로그를 정의할때 \u0026lsquo;glade-catalog\u0026rsquo; 태그의 \u0026lsquo;name\u0026rsquo;, \u0026lsquo;library\u0026rsquo; 속성은 반드시 정의되어야 합니다. \u0026lsquo;icon-prefix\u0026rsquo;, \u0026lsquo;depends\u0026rsquo;, \u0026lsquo;domain\u0026rsquo; 속성은 선택사항입니다.\n|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-| | name | 카탈로그 문자열 식별자, 카탈로그를 식별하는데 사용하며 카탈로그간 의존성을 관리하는데 필요합니다. | | version | \u0026lsquo;major.minor\u0026rsquo; 형식의 버전 설명. ([예] version=\u0026quot;1.0\u0026quot;) 동작하기 위한 버전을 검사하는데 필요하지만, 선택사항입니다. | | targetable | 쉼표(comma)로 구분하는 \u0026lsquo;major.minor\u0026rsquo; 형식 버전 목록. 현재 버전 이전 중에서 지원하는 버전을 명시합니다. | | icon-prefix | 위젯의 아이콘 이름을 구성하는데 사용. 이 속성의 기본값은 \u0026lsquo;name\u0026rsquo; 속성 값을 사용합니다. | | library | 형식(type)을 읽어들이고 속성(properties)을 조사하는데 사용. 글레이드가 이 라이브러리를 로드하는데 사용하는데, 위젯을 포함하는 라이브러리 이름일 수도 있고 위젯 라이브러리에 암묵적으로 링크되는 플러그인 라이브러리 이름일 수도 있습니다. 이 라이브러리는 사용자가 지정한 경로나 시스템 플러그인 디렉토리($prefix/lib/glade-3/modules/)에서 읽어들입니다. | | depends | 지 원 코드 상속이 제대로 동작하는데 사용. 즉, 객체가 GTK+ 라이브러리 객체에서 파생한다면 위젯을 가능하도록 하기 위해 gladegtk 플러그인의 기본 지원 코드를 사용합니다. 이 속성은 설치된 다른 글레이드 플러그인의 \u0026lsquo;name\u0026rsquo; 속성입니다. 대개는 \u0026lsquo;depends=\u0026ldquo;gtk+\u0026quot;\u0026lsquo;를 사용할 것입니다. | | domain | 번역 문자열을 검색하는데 사용할 도메인. 카탈로그의 모든 문자열은 이 도메인을 이용해 번역되어 표시됩니다. 지정하지 않으면 \u0026lsquo;library\u0026rsquo; 속성을 사용합니다. | | book | devhelp 문서 라이브러리를 검색하는데 사용할 이름공간을 지정. (특히, gtk-doc Makefile.am 파일에서 $(DOC_MODULE) 항목으로 지정된 이름). | | init-function | 플러그인 전역 시작점을 가져오는데 사용. 백엔드(backend) 초기화 등에 사용하며, 위젯 클래스 인스턴스가 생성되기 전에 호출됩니다. |\n확인하기/ 설치하기 (Validating and installing) 글레이드와 함께 설치되는 DTD 파일은 카탈로그 파일을 검사하는데 사용할 수 있습니다. 유의할 점은 속성(properties)이 DTD에 정의된 것과 같은 순서로 입력되어야합니다.\n파일을 검사하려면 다음과 같이 합니다:\nxmllint --dtdvalid glade-catalog.dtd --noout my-catalog.xml  위젯 플러그인을 설치하기 위해서는 먼저 카탈로그 XML 파일을 카탈로그 디렉토리에 복사해야 합니다. 이 디렉토리는 다음과 같이 얻을 수 있습니다:\npkg-config --variable=catalogdir gladeui-1.0  팔레트에 사용하는 아이콘은 pixmap 디렉토리에 들어갑니다:\npkg-config --variable=pixmapdir gladeui-1.0  플러그인 라이브러리는 modules 디렉토리에 설치되어야 합니다:\npkg-config --variable=moduledir gladeui-1.0  환경변수에 추가 경로를 지정함으로써 사용자 디렉토리에서 카탈로그를 읽어들 수도 있습니다. 예를 들면:\nGLADE_CATALOG_PATH=~/mycatalogs:~/work/foo/glade  같은 방식으로 플러그인 라이브러리 경로도 지정할 수 있습니다::\nGLADE_MODULE_PATH=~/work/foo/src  설치하지 않은 아이콘 읽어들이기는 아직 지원하지 않습니다.\n","date":1216857600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1216857600,"objectID":"2fdf17f19ea8198cb1cac8c42fc8dd84","permalink":"https://lethean.github.io/2008/07/24/glade-catalog/","publishdate":"2008-07-24T00:00:00Z","relpermalink":"/2008/07/24/glade-catalog/","section":"post","summary":"글레이드(Glade) 매뉴얼 에서 카탈로그(Catalog) 소개 부분을 날림 번역한 내용입니다. 소개 (Introduction) 사용자 위젯은 여러 방법으로 지원할 수 있는데, 패키","tags":["GTK+"],"title":"Glade 카탈로그 작성 / 설치하기","type":"post"},{"authors":null,"categories":null,"content":"GDM 등과 같이 덩치가 큰 디스플레이 관리자를 사용하지 않고, 시스템 부팅후 자동으로 X 서버를 실행하고 특정 계정으로 로그인한뒤 자동으로 특정 프로그램을 실행하는 기능은 의외로 많이 사용합니다. 이 글에서는 여러가지 방법 중에 제가 알고 있는 몇가지 방법을 정리해 보았습니다. 적용 가능한 배포판은 데비안(Debian) 혹은 우분투(Ubuntu) 리눅스 기반입니다.\n첫번째 방법 - init 데몬 이용하기 \u0026ldquo; How to autologin X without a display manager \u0026rdquo; 글에서 설명하는 방법입니다.\n먼저 init 데몬이 자동으로 실행할 수 있도록 /etc/inittab 파일에 다음 항목을 추가합니다.\n6:23:respawn:/sbin/getty -L -n -l /usr/local/sbin/autologin  위 항목은 시스템 시작시 자동으로 /usr/local/sbin/autologin 프로그램을 실행합니다. 또한 프로그램이 종료해도 다시 자동으로 재시작합니다. 이제 사용자 로그인 과정을 자동으로 수행하도록 하려면 /usr/local/sbin/autologin 프로그램을 다음과 같이 작성합니다.\n#!/bin/sh /bin/login -f root  여기서 -f 뒤에 로그인할 계정을 적어줍니다. 이제 계정 홈 디렉토리에 있는 셸 스크립트 시작 파일(~/.bash_profile)을 수정해서 마지막에 다음 항목을 넣어줍니다.\nstartx logout  이 스크립트는 X 서버를 시작하고 종료시 자동으로 로그아웃을 합니다. 마지막으로 X 서버가 실행하면서 자동으로 수행될 스크립트를 만들어야 합니다. 계정 홈 디렉토리에 있는 X 서버 시작 파일(~/.xsession 또는 ~/.xinitrc)을 다음과 같이 작성합니다.\n#!/bin/sh my-window-manager \u0026amp; # If the touch screen is not calibrated, run the calibration while [ ! -f /etc/touchscreen-calibration ] do calibrate-touchscreen done # Run the main application: if it ends, the session ends main-application  제일 먼저 창 관리자(여기서는 \u0026lsquo;my-window-manager\u0026rsquo;)를 백그라운드로 실행합니다. 그리고 필요한 선행작업(여기서는 \u0026lsquo;calibrate-touchscreen\u0026rsquo;)을 처리한 뒤 실제 어플리케이션(main-application)을 실행합니다.\n두번째 방법 - upstart 데몬 이용하기 우분투 리눅스는 init 데몬 대신 Upstart 데몬을 이용하여 시스템 초기화 작업을 처리합니다. 따라서 첫번째 방법에서 /etc/inittab 파일을 수정하는 대신 /etc/event.d/ 디렉토리에 시작 파일을 등록해야 합니다. 예를 들면 /etc/event.d/autostart 파일을 다음과 같이 작성합니다.\nstart on runlevel 2 start on runlevel 6 respawn exec /sbin/getty -L -n -l /usr/local/sbin/autologin  위 내용은 런레벨 2,6 에서 해당 프로그램을 실행하고 종료시 자동으로 재시작하도록 합니다. 나머지는 첫번째 방법과 동일합니다.\n세번째 방법 - 런레벨(run-level) 이용하기 init 데몬이든 Upstart 데몬이든 상관없이 동작하는 방법입니다. 먼저 다음과 같은 스크립트를 /etc/init.d/autologin 파일로 만들어 줍니다.\n#!/bin/sh /usr/local/sbin/my-startx \u0026amp; exit 0  그리고 런레벨 2로 동작한다는 가정하에 스크립트가 자동 실행할 수 있도록 다음 명령을 실행합니다.\n# chmod +x /etc/init.d/autologin # update-rc.d autologin defaults 05  여기서 마지막 \u0026lsquo;05\u0026rsquo;는 런레벨에서 다른 데몬보다 먼저 실행하도록 결정해주는 우선순위입니다. 이제 /usr/local/sbin/my-startx 스크립트를 작성합니다.\n#!/bin/sh while true; do sleep 1 echo \u0026quot;xinit /root/.xinitrc -- /etc/X11/xinit/xserverrc\u0026quot; | su - root done  이 스크립트는 루트(root) 계정으로 X를 시작하면서 /root/.xinitrc 파일을 시작 스크립트 파일로 지정합니다. 따라서, 이 방법은 위 두가지와 다르게 사용자 셸(bash)을 거치지 않고 직접 X 서버를 실행합니다. 그리고, 다른 방법과 마찬가지로 종료시 자동으로 X를 재시작합니다. X 실행 이후 시작하는 스크립트는 다른 방법과 동일합니다.\n","date":1216598400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1216598400,"objectID":"da6776c25c90b3f3715bc30270c773e7","permalink":"https://lethean.github.io/2008/07/21/x-window-auto-login/","publishdate":"2008-07-21T00:00:00Z","relpermalink":"/2008/07/21/x-window-auto-login/","section":"post","summary":"GDM 등과 같이 덩치가 큰 디스플레이 관리자를 사용하지 않고, 시스템 부팅후 자동으로 X 서버를 실행하고 특정 계정으로 로그인한뒤 자동으로 특정 프로그램을 실행하는 기","tags":["Linux","Ubuntu","Xorg"],"title":"X 윈도우 자동 로그인하기","type":"post"},{"authors":null,"categories":null,"content":"리눅스 커널 2.6.26 릴리스에는 메모리 검사 기능이 추가되었습니다. 기존에 많이 사용하는, 우분투 리눅스의 경우 grub 부트 메뉴에서 선택해서 실행할 수 있는 Memtest86+ 프로그램처럼 많은 기능이 있는 건 아니지만, 가끔 간단한 메모리 검사가 필요한 경우 요긴하게 사용할 수 있을 것 같습니다.\n아직 X86 플랫폼만 지원하며, 사용하려면 커널 컴파일시 CONFIG_MEMTEST_BOOTPARAM 설정을 선택해야 하고, 부팅시 \u0026lsquo;memtest\u0026rsquo; 인수를 넘겨주면 동작합니다.\n","date":1216166400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1216166400,"objectID":"7415cdf3549b25228ea10c1f52d3d13d","permalink":"https://lethean.github.io/2008/07/16/linux-2626-memory-test-function/","publishdate":"2008-07-16T00:00:00Z","relpermalink":"/2008/07/16/linux-2626-memory-test-function/","section":"post","summary":"리눅스 커널 2.6.26 릴리스에는 메모리 검사 기능이 추가되었습니다. 기존에 많이 사용하는, 우분투 리눅스의 경우 grub 부트 메뉴에서 선택해서 실행할 수 있는 Memtest86+ 프로그램처럼","tags":["Kernel","Linux"],"title":"리눅스 커널 메모리 검사 기능","type":"post"},{"authors":null,"categories":null,"content":"GTK+ 프로그래밍에서 많이 사용하는 GtkTreeModel(GtkListStore / GtkTreeStore)에는 일반적으로 데이터(객체)에서 표시할 내용만 추가해서 사용합니다. 따라서 실제로 데이터가 변경되면 그때마다 GtkTreeModel 내용을 변경해주어야 합니다.(일종의 동기화) 하지만 이러한 프로그래밍 방식은 매우 귀찮고 개발 시간도 오래 걸리는 것은 물론 런타임 오버헤드도 발생할 수 밖에 없습니다. 아예 GtkTreeModel에서 하나의 컬럼에 데이터(객체)를 넣고 관리하는 방법도 있지만, 이 역시 이러한 오버헤드와 비효율은 피할 수 없습니다.\n leveraging GtkTreeModel 위 글에서 저자는 기존 GtkListStore / GtkTreeStore 객체를 상속받은 새로운 GtkTreeModel 인터페이스를 구현하는 방법을 이용해 이러한 오버헤드를 줄이는 방법을 설명하고 있습니다.\n방법은 다음과 같습니다.\n먼저 GtkTreeModel 객체에는 실제 데이터(객체) 하나만 넣습니다. 그리고 외부에 공개하는 컬럼 갯수와 각 컬럼의 종류(type), 값(value)을 에뮬레이션하기 위해 다음 세가지 API를 오버라이딩(overriding)합니다.\n get_n_columns () get_column_type () get_value ()  위 세 API는 GtkTreeModel 외부에서 원하는 행(row)의 컬럼(column) 값을 가져올때만 호출됩니다. 특히 GtkTreeView 등과 같은 위젯에 연결되어 있을 경우 행이 열 개이거나 백만 개이거나 상관없이 현재 화면에 보이는 행의 값만 가져오기 위해 호출됩니다.\n물론 문자열 조합이 복잡하거나 연산이 복잡한 경우 약간의 오버헤드가 발생할 수 있지만, 메모리 사용량은 확 줄어들고 동기화 걱정 자체가 없다는 장점이 더 큽니다.\n","date":1216080000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1216080000,"objectID":"1a410375d7a82e59f4849c34148ead34","permalink":"https://lethean.github.io/2008/07/15/leveraging-gtktreemodel/","publishdate":"2008-07-15T00:00:00Z","relpermalink":"/2008/07/15/leveraging-gtktreemodel/","section":"post","summary":"GTK+ 프로그래밍에서 많이 사용하는 GtkTreeModel(GtkListStore / GtkTreeStore)에는 일반적으로 데이터(객체)에서 표시할 내용만 추가해서 사용합니다. 따라서 실제로 데이터","tags":["GTK+"],"title":"GtkTreeModel 확장하기","type":"post"},{"authors":null,"categories":null,"content":"꽤 오랫동안 마음의 여유가 없었습니다.\n그러다가 이런 저런 이유로 블로그를 다시 시작하게 되었는데, 몇몇 블로그 호스팅 서비스를 이용하던 과거와 달리 이번에는 워드프레스(WordPress) 를 이용해 직접 서버를 운영하기로 했습니다. 원래 강력한 기능으로 유명한 블로그 소프트웨어이기도 하지만, 다른 곳에서 작성한 블로그 자료를 쉽게 가져올 수 있는 기능이 무엇보다도 워드프레스를 선택하게 된 원인이 된 것 같습니다. 어쨌든 이번에는 조금 끈덕지게 운영을 해 볼 생각입니다.\n사실 블로그를 다시 작성하는 첫번째 이유는 회사 개발팀에서 사용할 문서 관리 시스템과 개인 블로그를 효율적으로 연동할 수 있는 방법을 실험하기 위해서입니다. 외부에 공개할 수 없는 문서와 공식적인 문서를 제외한 대부분의 문서를 팀블로그나 플래닛 방식으로 운영할 수 있을 것도 같은데, 구체적인 방안이 떠오르지 않아 하나씩 직접 해볼 예정입니다.\n게시판과 위키, 플론(Plone) 등을 거쳐 이제 웹 2.0 기술을 지식 / 문서 관리에 이용하려는 제 욕심이 지나치지 않기만을 바랄 뿐입니다\u0026hellip; :)\n","date":1215820800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1215820800,"objectID":"930aa70d81a792ceab13b82e6982b1d8","permalink":"https://lethean.github.io/2008/07/12/moved-to-wordpress/","publishdate":"2008-07-12T00:00:00Z","relpermalink":"/2008/07/12/moved-to-wordpress/","section":"post","summary":"꽤 오랫동안 마음의 여유가 없었습니다. 그러다가 이런 저런 이유로 블로그를 다시 시작하게 되었는데, 몇몇 블로그 호스팅 서비스를 이용하던 과거와 달리 이번에는 워드","tags":["WordPress"],"title":"워드프레스(WordPress)로 옮김","type":"post"},{"authors":null,"categories":null,"content":" PowerTop 유틸리티를 실행하면 전원을 절약할 수 있는 여러가지 방법도 친절하게 설명해주는데, 이 정보를 바탕으로 ThinkPad X40 노트북에 맞게 켤때마다 자동으로 설정하는 스크립트를 만들어봤다. Ubuntu Gutsy 배포판에서 사용하면 약간 과장해서 50% 이상 배터리 수명이 연장되는 걸 체감할 수 있다.\n#!/bin/sh # # Power Save Tunings for ThinkPad X40 # # enable wireless power saving mode iwpriv eth1 set_power 5 # enable AC97 powersave mode echo 1 \u0026gt; /sys/module/snd_ac97_codec/parameters/power_save # enable USB autosuspend echo 1 \u0026gt; /sys/module/usbcore/parameters/autosuspend for dev in /sys/bus/usb/devices/*; do file=$dev/power/autosuspend [ -f $file ] \u0026amp;\u0026amp; echo 1 \u0026gt; $file done # increase the VM dirty writeback time from 5.00 to 15 seconds echo 1500 \u0026gt; /proc/sys/vm/dirty_writeback_centisecs # enable laptop-mode echo 5 \u0026gt; /proc/sys/vm/laptop_mode  이 스크립트를 자동으로 실행하게 하는 방법은 다음과 같다. 먼저 다음과 같이 에디터를 열어 위 내용을 입력한다.\n# sudo gedit /etc/init.d/thinkpad-x40-powersave  실행권한을 준다.\n# sudo chmod +x /etc/init.d/thinkpad-x40-powersave  부팅시 자동으로 실행하도록 한다.\n# sudo update-rc.d thinkpad-x40-powersave defaults  바로 적용하려면 sudo /etc/init.d/thinkpad-x40-powersave와 같이 직접 실행해도 된다.\n","date":1190332800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1190332800,"objectID":"7cbe9fb51c54ce5edba920c95ec9b721","permalink":"https://lethean.github.io/2007/09/21/thinkpad-x40-ubuntu-power-saving/","publishdate":"2007-09-21T00:00:00Z","relpermalink":"/2007/09/21/thinkpad-x40-ubuntu-power-saving/","section":"post","summary":"PowerTop 유틸리티를 실행하면 전원을 절약할 수 있는 여러가지 방법도 친절하게 설명해주는데, 이 정보를 바탕으로 ThinkPad X40 노트북에 맞게 켤때마다 자동으로 설정하는 스크립트를","tags":["Linux","Ubuntu"],"title":"ThinkPad X40 + Ubuntu + Power Saving","type":"post"},{"authors":null,"categories":null,"content":"커널트랩에 올라온 마운트 옵션을 이용한 성능 최적화 글을 보고 우분투 리눅스에도 적용시켜보기로 했다. 다른 파티션은 모두 /etc/fstab 파일에서 직접 \u0026lsquo;noatime,data=writeback\u0026rsquo; 옵션만 추가하면 되는데 루트 파일 시스템은 조금 손질이 더 갔다.\n데비안 기반 시스템은 처음에는 루트 파일 시스템을 읽기전용(read-only)으로 마운트한 뒤 initrd 기반 초기화 과정을 수행하고, 나중에 다시 /etc/fstab 정보를 기반으로 루트파일 시스템을 다시 정상적인 쓰기 가능하도록 마운트한다.(remount) 그런데 이때 \u0026lsquo;noatime\u0026rsquo; 등과 같은 옵션은 정상적으로 동작하지만 \u0026lsquo;data=writeback\u0026rsquo; 등과 같은 옵션은 재마운트시 불가능하다는 메시지를 내면서 마운트에 실패하고 읽기전용 상태로 남아버린다.\n이 문제의 해결 방법은 여러가지가 있겠지만, 내가 선택한 방법은 먼저 /etc/fstab 에는 \u0026lsquo;noatime\u0026rsquo; 옵션만 추가하고, /boot/grub/menu.lst 파일에서 defoptions 항목에 \u0026lsquo;rootflags=data=writeback\u0026rsquo; 을 추가하고, update-grub 명령을 실행하고 재부팅하면 적용된다.\n성능이 좋은 PC의 경우 이 옵션이 있을 때와 없을 경우 차이점을 별로 못 느끼지만 X40 노트북에서는 어느 정도 체감 속도가 향상된 것을 느낄 수 있다. 더욱이 tracker 데몬 때문에 디스크가 혹사당하기 시작한 다음부터는 더욱더\u0026hellip;\n","date":1186617600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1186617600,"objectID":"59b85985ac7cd96a5c572dad937da525","permalink":"https://lethean.github.io/2007/08/09/root-filesystem-mount-options-in-ubuntu/","publishdate":"2007-08-09T00:00:00Z","relpermalink":"/2007/08/09/root-filesystem-mount-options-in-ubuntu/","section":"post","summary":"커널트랩에 올라온 마운트 옵션을 이용한 성능 최적화 글을 보고 우분투 리눅스에도 적용시켜보기로 했다. 다른 파티션은 모두 /etc/fstab 파일에서 직접 \u0026lsquo;noatime,data=writeback\u0026rsquo; 옵션만 추가하면 되는데","tags":["Linux","Ubuntu"],"title":"우분투에서 루트 파일시스템 마운트 옵션 변경하기","type":"post"},{"authors":null,"categories":null,"content":"Dbus를 이용해 이제는 시스템 데몬과 같은 프로그램까지 실행할 수 있게 될 것 같다.( Dbus System Activation is upstream 참고) 디자인 문서를 보니, 다음과 같이 서비스 파일을 정의하면 해당 메시지가 발생했을때 해당 서버가 동작하는 방식이다.\n[D-BUS Service] Name=org.me.test Exec=/usr/sbin/dbus-test-server.py User=ftp  다음과 같이 직접 실행할 수도 있다.\ndbus-send --system --print-reply --dest=org.freedesktop.DBus /org/freedesktop/DBus org.freedesktop.DBus.StartServiceByName string:org.freedesktop.Hal uint32:0  이렇게 되면 현재 Ubuntu 시스템의 기반이 되는 upstart나 기존의 sysvinit 등과 같은 시스템 초기화 시스템도 불필요해질 수있다고 하는데, 단순히 메시지 기반 병렬 실행 기능만으로는 서비스간 의존성이나 초기화 과정의 많은 예외처리까지는 어렵지 않을까 싶다.\n","date":1185321600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1185321600,"objectID":"645b4079914c2b07e300f867e4ae3c18","permalink":"https://lethean.github.io/2007/07/25/dbus-or-upstart/","publishdate":"2007-07-25T00:00:00Z","relpermalink":"/2007/07/25/dbus-or-upstart/","section":"post","summary":"Dbus를 이용해 이제는 시스템 데몬과 같은 프로그램까지 실행할 수 있게 될 것 같다.( Dbus System Activation is upstream 참고) 디자인 문서를 보니, 다음과 같이 서비스 파일을 정의하면 해","tags":["Linux","Ubuntu"],"title":"DBus or Upstart","type":"post"},{"authors":null,"categories":null,"content":"점점 화려해지는 GUI 추세를 이제서야 인식했는지, GTK+ / GNOME 에서도 애니메이션 효과에 대한 논의와 구현이 점점 활발해지고 있는 것 같다. 아직 GTK+ 메인 소스에 반영되려면 시간이 더 걸릴 것 같지만 GtkTimeline 이라는 기본적인 시간 관리 객체가 이미 논의 중이고, 이를 기반으로 여러 개발자들이 여기저기에 적용해보기도 하고 있다. ( GtkPathBar 스크롤 효과 , iPhone 방식 슬라이드 효과 , iPhone 방식 가상키보드 )\nGtkTimeline API가 참고한 소스 중 하나라고 하는 Clutter 라이브러리는 OpenGL을 렌더링 엔진으로 사용하는데, GObject 기반으로 GTK+와 친근한 방식의 API를 제공하여 이미 여러 프로젝트에서 사용하고 있는 것 같다. Clutter를 이용한 간단한 프리젠테이션 도구 , 휴대폰 인터페이스 등과 같은 예제도 점점 늘어나고 있다. 하지만 OpenGL 기반이라 임베디드 시스템이나 그래픽칩셋이 3D 가속을 지원하지 않는 환경에서는 활용하기 어렵다는 점이 아쉽다. 아직 OpenGL API로 모든 2D 그래픽을 대체하는 건 시기상조일 수도 있다는 얘기 도 심심챦게 나오고 있고\u0026hellip;\n참고로 더 나열해보자면, QT 계열에서는 이미 코딩하면서 바로 캔버스 API를 테스트할 수 있는 스크립트 엔진 도 지원한다. E17 의 EFL 라이브러리 는 이미 오래전부터 Evas, Edje 등으로 조금 앞선 플랫폼을 제공하더니 이제는 EFL 기반 솔루션을 제공하는 업체 도 생겨났다. 최근의 미지리서치 Prizm 플랫폼 도 휴대폰에서 화려한 UI 효과를 쉽게 구현하도록 도와주고 있다.(glib 기반이라 반가웠다)\n물론 좋은 오픈소스 라이브러리와 플랫폼이 참 많지만, 이미 오랜 시간을 GTK+와 함께 해왔더니 쉽게 다른 플랫폼으로 바꾸기가 어려운 것 같다. 하지만, 언제나 그렇듯이 잘 설계되고 잘 구현된 오픈 소스 프로젝트를 들여다보는 일은 즐겁다. 가능하면 참여중인 프로젝트에 적용해보고도 싶고, 더 나아가 프로젝트에 직접 참여해보기도 싶지만, 언제나 그렇듯이\u0026hellip;\n","date":1185321600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1185321600,"objectID":"0d7563ac15feaa577715431eafca851e","permalink":"https://lethean.github.io/2007/07/25/gtk-animation-effects/","publishdate":"2007-07-25T00:00:00Z","relpermalink":"/2007/07/25/gtk-animation-effects/","section":"post","summary":"점점 화려해지는 GUI 추세를 이제서야 인식했는지, GTK+ / GNOME 에서도 애니메이션 효과에 대한 논의와 구현이 점점 활발해지고 있는 것 같다. 아직 GTK+ 메인 소스에 반영되려면 시","tags":["Clutter","GTK+","GUI"],"title":"GTK+ Animation Effects","type":"post"},{"authors":null,"categories":null,"content":"64비트 장비에 우분투 서버를 설치하고 VMware를 가동하면 다음과 같은 에러가 발생한다.\n[16825.988196] printk: 246 messages suppressed. [16825.988201] rtc: lost some interrupts at 2048Hz.  구글링을 통해 알게된 사이트 에서 /etc/vmware/config 파일에 host.useFastClock = FALSE 항목을 추가하면 된다는 걸 알았는데, 문제는 시각 동기화가 잘 안되어 VMware로 실행하는 이미지 내부에서 ntp 데몬 등을 이용하여 시각동기화를 해주어야 한다.\n","date":1181520000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1181520000,"objectID":"7ca2981dcf38491d6b432a5ce6981e1b","permalink":"https://lethean.github.io/2007/06/11/vmware-rtc-lost-some-interrupts/","publishdate":"2007-06-11T00:00:00Z","relpermalink":"/2007/06/11/vmware-rtc-lost-some-interrupts/","section":"post","summary":"64비트 장비에 우분투 서버를 설치하고 VMware를 가동하면 다음과 같은 에러가 발생한다. [16825.988196] printk: 246 messages suppressed. [16825.988201] rtc: lost some interrupts at 2048Hz. 구글링을 통해 알게된 사이트 에서 /etc/vmware/config 파일","tags":["Linux","VMware"],"title":"VMWare rtc: lost some interrupts","type":"post"},{"authors":null,"categories":null,"content":"어설픈 영한번역을 거치게 된 reactable 프로젝트의 영어 설명은 이렇다.\n The reactable is a collaborative electronic music instrument with a tabletop tangible multi-touch interface. Several simultaneous performers share complete control over the instrument by moving and rotating physical objects on a luminous round table surface. By moving and relating these objects, representing components of a classic modular synthesizer, users can create complex and dynamic sonic topologies, with generators, filters and modulators, in a kind of tangible modular synthesizer or graspable flow-controlled programming language.\n 여러 연주자가 함께 야광의 둥근 테이블 위에 있는 물리적인 물체를 움직이고 돌리면서 악기를 완전하게 제어한다. 이처럼 고전적인 모듈러 신디사이저 요소를 나타내는 물체를 움직이고 연관을 지으면서, 사용자는 복합적이고 생동적인 음파 형상을 만들 수 있으며, 실감형 모듈러 신디사이저나 잡을 수 있는 흐름 제어 프로그래밍 언어의 한 종류인 발진기, 필터, 변조기를 이용한다.\n기본적인 원리는 투명한 유리판(?) 밑에서 카메라를 이용해 사용자 반응을 감지하고 처리하며, 프로젝터를 이용해 다시 표시한다.\n또 눈여겨볼 만한 건 대부분 소프트웨어 소스가 공개 되어 있으며 많은 관련 논문과 자료도 잘 정리되어 있다는 점이다. 특히 Windows, MacOSX, Linux를 동시에 지원하는 크로스 플랫폼 비디오 캡쳐 라이브러리인 PortVideo 라이브러리는 눈여겨볼만 하다. ( PortAudio 프로젝트 이름을 흉내낸 걸까?)\n물론 많은 데모 동영상과 그림 도 볼 수 있다.\n","date":1179792000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1179792000,"objectID":"15f2c431a28ce6469c19708ac2f83531","permalink":"https://lethean.github.io/2007/05/22/reactable/","publishdate":"2007-05-22T00:00:00Z","relpermalink":"/2007/05/22/reactable/","section":"post","summary":"어설픈 영한번역을 거치게 된 reactable 프로젝트의 영어 설명은 이렇다. The reactable is a collaborative electronic music instrument with a tabletop tangible multi-touch interface. Several simultaneous performers share complete control over the instrument by moving and rotating physical objects on a luminous round table surface. By moving and relating these objects, representing components","tags":["GUI"],"title":"reactable : 테이블 표면 실감형 다중 접촉 인터페이스를 통한 협업 전자 음악 악기","type":"post"},{"authors":null,"categories":null,"content":"어김없이 또 리눅스 커널 2.6.21 버전이 릴리스 되었다.\n개인적으로 관심있는 부분만 정리하면 다음과 같다.\nDynticks과 클럭이벤트\n리누스 말로는 타이머 부분이 가장 많이 바뀌었다고 하는데, 멀티태스킹 시분할 시스템(time-sharing system)의 기본 원리라고 할 수 있는 타이머 인터럽트의 오버헤드를 최소화하기 위해, 필요한 경우에만 사용하겠다는(tickless) 아이디어 자체가 신선하다. 전원 관리에도 효과가 있고, 시스템 성능에도 미미하지만 영향을 끼칠 수 있을 뿐 아니라 고해상도 타이머 구현도 더 효율적으로 구현되었다고 한다. 이번 릴리스에서는 X86-32만 지원하지만 다른 아키텍쳐도 곧 지원된다고 한다.\nASoC (ALSA 시스템온칩) 레이어\nASoc는 오디오 시스템을 다음과 같이 세가지로 구성한다.\n 코덱 드라이버 : 플랫폼 독립, 오디오 제어, 코덱 IO 등 플랫폼 드라이버 : DMA, 인터페이스 드라이버(I2S, AC97, PCM) 머신 드라이버 : 장치 관련 제어나 오디오 이벤트 처리  이를 통해 임베디드 시스템처럼 직접 연결된 오디오칩에 대한 드라이버 개발을 더 쉽게 해준다. 더불어 동적 전원 관리 시스템이 더 적은 전원을 사용하도록 도와준다. 예를 들어 실제로 캡쳐나 재생 작업이 있을 경우에만 알아서 전원 스위치를 제어한다.\nGPIO API\n임베디드 시스템 CPU에서 거의 대부분 사용하는 GPIO 관련 API가 공식적으로 추가되었다. 이렇게 단순한 것도 API가 될 수 있구나 하면서도, 왜 이제야 정리되었을까 하는 생각도 든다.\nutrace\nptrace() 시스템콜의 기능을 넘어 dtrace 기능을 준비하기 위한 기본 API로 보인다.\nARM11 oprofile 지원\n가끔 유용하게 사용하는 oprofile이 ARM11 플랫폼도 지원한다.\n그외 가상화 관련 VMI, KVM 도 많이 개선되었다고 하는데, 사실 아직은 별로 관심이 없다. 더 자세한 변경사항은 커널뉴비 페이지 에서 확인할 수 있다. API 변경 사항은 LWN 페이지 에서 확인이 가능하다.\n","date":1177545600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1177545600,"objectID":"e8e72cc08bc3cc96c3490a1d8b544522","permalink":"https://lethean.github.io/2007/04/26/linux-kernel-2621-release/","publishdate":"2007-04-26T00:00:00Z","relpermalink":"/2007/04/26/linux-kernel-2621-release/","section":"post","summary":"어김없이 또 리눅스 커널 2.6.21 버전이 릴리스 되었다. 개인적으로 관심있는 부분만 정리하면 다음과 같다. Dynticks과 클럭이벤트 리누스 말로는 타이머 부분이 가","tags":["Kernel","Linux"],"title":"Linux Kernel 2.6.21 Release","type":"post"},{"authors":null,"categories":null,"content":"Ubuntu 7.04에서 ssh 접속 등을 시도할때 다른 시스템보다 초기 접속이 느린 이유가 avahi-daemon 관련 설정 때문 이라고 한다. 그래서 /etc/nsswitch.conf 파일에서 \u0026lsquo;hosts:\u0026rsquo; 부분을 다음과 같이 수정해보았더니, 역시 빨리 접속된다.\nhosts: files dns  정식 릴리스에 반영되기에는 시간이 촉박한 것 같다\u0026hellip;\n","date":1176940800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1176940800,"objectID":"08a831e1cbd819dfcf9c9fa64a0805c4","permalink":"https://lethean.github.io/2007/04/19/ubuntu-704-feisty-slow-ssh/","publishdate":"2007-04-19T00:00:00Z","relpermalink":"/2007/04/19/ubuntu-704-feisty-slow-ssh/","section":"post","summary":"Ubuntu 7.04에서 ssh 접속 등을 시도할때 다른 시스템보다 초기 접속이 느린 이유가 avahi-daemon 관련 설정 때문 이라고 한다. 그래서 /etc/nsswitch.conf 파일에서 \u0026lsquo;hosts:\u0026rsquo; 부분을 다음과 같이 수정해보았더니","tags":["Linux","Ubuntu"],"title":"Ubuntu 7.04 (feisty) 느린 SSH 접속","type":"post"},{"authors":null,"categories":null,"content":"\u0026lsquo; The lighttpd Web Server\u0026rsquo; 라는 글을 읽다 보니 lighttpd 웹서버가 물건 취급을 받을만 하다는 생각이 든다. 전세계 웹서버 통계에서 Apache, IIS, Unknown(?), iPlanet 다음으로 5번째 점유율을 차지하고, YouTube, Wikipedia 등과 같은 굵직한 사이트에서 메인 서버로 사용할 만큼 검증받은 웹서버라는 점만으로도 일단 흥미를 가질만 하다.\n최신 리눅스 커널에서 지원하는 epoll, sendfile, aio 등과 같은 API를 충분히 활용하여 멀티 쓰레드 방식보다 더 좋은 성능을 낼 수 있도록 구현한 점도 매력적이지만, Apache가 지원하는 대부분의 기능을 그대로 지원한다는 점도 눈여겨볼 만 하다. 다중 사용자 인증 / 접근 권한, 대역폭 제한, 연결 제한, 프록시, 가상 호스팅 등은 물론 FastCGI 방식의 PHP까지도 거뜬히 소화한다.\n하지만 무엇보다도 마음에 드는 건 다양한 플랫폼 지원과, 작은 실행 크기(바이너리 이미지 + 메모리)이다. 현재 개발중인 제품 중에서 웹서버를 탑재한 것 모두를 lighttpd 서버로 교체하고 싶은 생각이 들 정도다. 단순하다는 이유만으로 성능도 안좋고, 기능도 미약한 boa, busybox의 httpd 데몬이여 이제 안녕~\n물론 여러가지 사용되는 라이브러리가 임베디드 환경에 맞추려면 조금 어려울 수도 있지만, 프로젝트의 로드맵이 지향하는 바도 그렇고 앞으로가 더욱 더 기대되는 프로젝트이다.\n","date":1175990400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1175990400,"objectID":"73ca01329125f7ded9ec480fcdd6c963","permalink":"https://lethean.github.io/2007/04/08/lighttpd-web-server/","publishdate":"2007-04-08T00:00:00Z","relpermalink":"/2007/04/08/lighttpd-web-server/","section":"post","summary":"\u0026lsquo; The lighttpd Web Server\u0026rsquo; 라는 글을 읽다 보니 lighttpd 웹서버가 물건 취급을 받을만 하다는 생각이 든다. 전세계 웹서버 통계에서 Apache, IIS, Unknown(?), iPlanet 다음으로 5번째 점유율을 차지하고, YouTube, Wikipedia 등과 같","tags":["Web"],"title":"lighttpd 웹 서버","type":"post"},{"authors":null,"categories":null,"content":"멀티 터치 스크린 관련 데모 동영상:\n이와 더불어 X 서버에서 복수 마우스 입력을 지원하기 위한 프로젝트인 MPX 도 눈여겨둘만 하다.\n참고:\n  Multitouch and GNOME   More Multitouch from Jeff Han   The Multi-Pointer X Server   ","date":1171584000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1171584000,"objectID":"40595ee6c4322bc469168245a7804706","permalink":"https://lethean.github.io/2007/02/16/multi-touch-screen-and-x-server/","publishdate":"2007-02-16T00:00:00Z","relpermalink":"/2007/02/16/multi-touch-screen-and-x-server/","section":"post","summary":"멀티 터치 스크린 관련 데모 동영상: 이와 더불어 X 서버에서 복수 마우스 입력을 지원하기 위한 프로젝트인 MPX 도 눈여겨둘만 하다. 참고: Multitouch and GNOME More Multitouch from Jeff Han The Multi-Pointer X Server","tags":["GUI","Xorg"],"title":"멀티 터치 스크린과 X 서버","type":"post"},{"authors":null,"categories":null,"content":"Ubuntu Feisty에서 공식 compiz 패키지와 함께 gnome-compiz-manager를 사용하는데 가끔씩 윈도우가 빈 상태로 나타나는 현상이 발생했다. 곧 고쳐지겠거니 하고 기다리다 지쳐 검색해보니, 역시 해결방법 이 있었다.\n다음과 같은 옵션 항목을 X서버 설정 파일에(/etc/X11/xorg.conf) 넣어주면 된다.\nSection \u0026quot;Device\u0026quot; Identifier \u0026quot;Intel 82852/855GM\u0026quot; Driver \u0026quot;i810\u0026quot; BusID \u0026quot;PCI:0:2:0\u0026quot; Option \u0026quot;XAANoOffscreenPixmaps\u0026quot; \u0026quot;true\u0026quot; EndSection  물론 약간의 성능 손실은 있겠지만, 일단 정상적으로 동작한다.\n;)\n","date":1171324800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1171324800,"objectID":"d35adf4268523f95e04c427df5144db3","permalink":"https://lethean.github.io/2007/02/13/ubuntu-feisty-compiz-black-window/","publishdate":"2007-02-13T00:00:00Z","relpermalink":"/2007/02/13/ubuntu-feisty-compiz-black-window/","section":"post","summary":"Ubuntu Feisty에서 공식 compiz 패키지와 함께 gnome-compiz-manager를 사용하는데 가끔씩 윈도우가 빈 상태로 나타나는 현상이 발생했다. 곧 고쳐","tags":["Xorg"],"title":"Ubuntu Feisty Compiz 사용시 윈도우가 빈 상태로 나타나는 현상","type":"post"},{"authors":null,"categories":null,"content":"오랜만에 Glib 객체 시스템인 GObject에 대한 글들을 다시 정독해 보았다. 아무 것도 모르고 처음 읽었을때와 몇년동안 GTK+와 친숙해진뒤 다시 읽어볼때는 역시 차이가 있는 법, 이제 GObject 객체를 프로젝트에 하나씩 적용해볼 생각이다.\n참고 사이트:\n  GObject 공식 리퍼런스와 튜토리얼   GNOME 개발자 설명서 모음   위키피디아에 있는 간략한 GObject 소개   GObject Tutorial Copyright Ryan McDougall (2004) - C 언어로 객체지향을 구현하기 위해 GObject를 어떤 이유와 근거로 설계했는지를 단계별로 하나씩 설명해주는 튜토리얼  The Glib Object system - 공식(?) GObject 튜토리얼  GOB(GObject Builder) - 쉽게 GObject C 코드를 생성해주는 전처리기  Beginning GTK+ Programming - 훌륭한 GTK+, GObject 프로그래밍 관련 컨퍼런스 자료  ","date":1170633600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1170633600,"objectID":"bbef8f0df14dcf3e534eff33f7a7b6cb","permalink":"https://lethean.github.io/2007/02/05/gobject-glib-object-system/","publishdate":"2007-02-05T00:00:00Z","relpermalink":"/2007/02/05/gobject-glib-object-system/","section":"post","summary":"오랜만에 Glib 객체 시스템인 GObject에 대한 글들을 다시 정독해 보았다. 아무 것도 모르고 처음 읽었을때와 몇년동안 GTK+와 친숙해진뒤 다시 읽어볼때는 역시","tags":["GLib","GTK+"],"title":"GObject - Glib object system","type":"post"},{"authors":null,"categories":null,"content":"리눅스 커널 2.6.20 버전이 릴리스되었다. 관심있는 사항만 요약하면 다음과 같다.\n소니 플레이스테이션3(PS3) 지원\n아직 그래픽 장치처럼 모든 주변장치를 지원하는 것은 아니고 일반적인 PS3에서 부팅이 가능한 것도 아니지만, 소니 엔지니어에 의해 공식적으로 PS3가 지원되기 시작했다.\nKVM을 이용한 가상화(Virtualization) 지원\n나처럼 구식(?) PC를 사용하는 사람들한테는 그림의 떡이지만, 최신 인텔과 AMD CPU에서 지원하는 가상화 기능(Intel VT / AMD-V)을 이용해 VMWare처럼 가상의 머신을 실행시킬 수 있도록 도와주는 KVM이 공식적으로 지원된다. 물론 QEMU 와 함께 동작하며 아직 윈도우 운영체제는 APIC 문제로 잘 동작하지 않는 문제이지만, 조만간 모두 해결될 것으로 보인다.\ni386에서 병렬가상화(Paravirtualization) 지원\nKVM이 하드웨어의 도움을 받는 가상화솔루션이라면 이 기능은 이미 존재하는 가상화 솔루션에서 이용할 수 있는 공통 모듈이다. 게스트 운영체제에 대한 제어 기능이 커널에서 공식적으로 지원하게 됨에 따라 VMWare, Xen 등의 커널 모듈도 이 기능을 이용하도록 변경될 것으로 생각된다.\nX86에서 재배치가능(relocatable)한 커널 지원\n런타임 오버헤드없이 컴파일시 커널 주소 공간을 지정할 수 있도록 한다. 일반 사용자에게는 별로 중요하지 않지만 kexec 등을 이용해 커널 크래쉬 상태를 덤프하고 다시 로드할때 커널 주소 공간을 다르게 함으로서 유용하게 사용할 수 있다고 한다.\n결함 주입 (Fault Injection)\n실시간 시스템의 결함 허용 중 하나인 결함 주입 기능은 일부러 에러를 일으키는 값이나 환경을 만들어 커널이 이를 얼마나 잘 견디고 처리하는지를 확인하는 것으로 쉽게 찾을 수 없는 에러를 디버깅하는데 유용하다. 구체적으로 이 기능은 메모리 할당 오류와 디스크 I/O 실패를 고의로 발생시키는데, 파일시스템 개발자들은 이에 대한 예외처리를 얼마나 잘 하는지 테스트 가능하다.\n상대적 atime 지원\n마운트시 \u0026lsquo;noatime\u0026rsquo; 옵션을 주면 파일을 읽을때마다 접근 시간(access time)을 갱신하지 않게 되어 실제적으로 매우 많은 디스크 성능 향상을 체험하게 된다. 실제로 kernel.org 사이트도 이 옵션 하나만으로 평균 부하량이 반으로 줄었다고 하며, 현재 우리 회사에서 개발한 DVR 시스템에도 이 옵션이 적용되어 있다. 그런데 이 기능은 무조건 갱신하는 것이 아니라 생성시간(ctime)이나 수정시간(mtime)보다 접근시간(atime)이 더 오래되었을 경우에만 갱신하도록 한다. 이를 통해 정확하면서도 \u0026lsquo;noatime\u0026rsquo; 옵션과 비슷한 성능향상을 얻을 수 있다고 한다. 아직은 OCFS2 파일시스템에서만 지원된다고 하며 mount(8) 에도 \u0026lsquo;reltime\u0026rsquo; 옵션으로 적용되어 있다.\nX86-32에서 \u0026lsquo;regparm\u0026rsquo; 사용\nGCC 확장 기능을 이용하여 함수 인수 전달시 인수 갯수가 3개 이하일 경우 레지스터를 이용하여 전달하도록 하는 방식('-mregparm=3' )을 사용한다. 그런데 내가 알기로는 레드햇 커널에서는 이미 예전부터 기본적으로 사용하고 있는데\u0026hellip;\n워크큐(Workqueue) 구조 변경\n워크큐(struct work_struct) 구조가 변경되어 이를 사용하고 있는 외부 드라이버나 모듈이 있다면 이 페이지 를 참고하여 수정하는 것이 좋다.\nGCC 버전 변경\n이제 커널 2.6.20 버전 이상을 컴파일하려면 최소 gcc 3.2 버전 이상이 필요하다.\ni386에서 300Hz 지원\n25FPS를 사용하는 PAL 방식과 달리 29.99FPS를 사용하는 NTSC 방식 비디오 프레임 처리에 유용하도록 300Hz 클럭을 지원한다. 이 클럭을 사용하면 25 / 30 FPS 모두를 처리하는데 유용하며 성능은 250Hz와 비슷하다고 한다.\n물론 더 자세한 내용은 이미 잘 정리된 KernelNewbies 2.6.20 변경사항 페이지를 참고하면 된다.\n","date":1170633600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1170633600,"objectID":"1c218263280a7a1fea0de1e7ef008612","permalink":"https://lethean.github.io/2007/02/05/linux-kernel-2620-release/","publishdate":"2007-02-05T00:00:00Z","relpermalink":"/2007/02/05/linux-kernel-2620-release/","section":"post","summary":"리눅스 커널 2.6.20 버전이 릴리스되었다. 관심있는 사항만 요약하면 다음과 같다. 소니 플레이스테이션3(PS3) 지원 아직 그래픽 장치처럼 모든 주변장치를 지원하는","tags":["Kernel","Linux"],"title":"Linux Kernel 2.6.20 Release","type":"post"},{"authors":null,"categories":null,"content":"드디어 스티브 잡스가 맥월드 2007에서 아이폰(iPhone) 을 주제로 한 기조연설(keynote) 내용 이 올라왔다. MacOS X 을 탑재해서 그런지 전체적인 UI 느낌은 매킨토시 그대로다. 반투명 검은 유리 느낌의 일루미누스(Illuminous) 인터페이스와 전체적인 하드웨어 디자인 느낌은, 역시 애플이라는 생각을 들게 한다. 애플TV(Apple TV) 는 일종의 셋탑박스(set-top box)인데, 무선랜이 기본으로 장착되어 있고 역시 편리하고 화려한 인터페이스를 구비하고 있다.\nMacOS X 운영체제가 이제는 Linux, WindowsCE, Windows XP/Embedded 가 이미 버티고 있는 임베디드 시스템 분야로 확장하고 있다는 점도 무섭다. 이 기사에서 언급한 것처럼 PowerPC 플랫폼에서 벗어나 인텔 CPU를 지원하게 되면서 다른 플랫폼 포팅에 대한 기반을 다졌기 때문에, ARM과 같은 새로운 프로세서를 지원하는 속도가 점점 빨라질 것이다. 마치 리눅스가 그랬던 것처럼.\n내 경우 가끔 이런 기조 연설을 만나면 내용과 다르게, 프리젠테이션 자료의 화면 구성과 진행 방식도 꽤 유심히 살펴본다. 파워포인트를 이용해 \u0026lsquo;제목 + 목록\u0026rsquo; 형태로 작성하는 구질구질한 프리젠테이션을 벗어나기 위해서는 역시, 모든 일이 그렇지만, 양질의 고급 콘텐트를 자주 보고 느끼는 수 밖에 없는 것 같다.\n한동안 하드웨어 / 소프트웨어적으로 아류 디자인이 범람할 것 같기도 하다. 그리고 그 중 하나는 나일지도 모르고\u0026hellip;\n참고:\n  Live from Macworld 2007: Steve Jobs keynote   The Apple iPhone runs OS X   Apple embeds Mac OS X in phone, set-top box   ","date":1168387200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1168387200,"objectID":"1c01213f86d1512ab3ece9db5df2f261","permalink":"https://lethean.github.io/2007/01/10/macosx-inside-iphone-appletv/","publishdate":"2007-01-10T00:00:00Z","relpermalink":"/2007/01/10/macosx-inside-iphone-appletv/","section":"post","summary":"드디어 스티브 잡스가 맥월드 2007에서 아이폰(iPhone) 을 주제로 한 기조연설(keynote) 내용 이 올라왔다. MacOS X 을 탑재해서 그런지 전체적인 UI","tags":["GUI"],"title":"MacOS X 탑재한 아이폰(iPhone) / 애플TV(Apple TV)","type":"post"},{"authors":null,"categories":null,"content":"요즘 리눅스 2.6.20부터 추가된 가상화 기술 KVM 과 더불어 이슈가 되고 있는 QEMU 에뮬레이터의 내부 구현 원리를 밝힌 기사 를 보면 흥미로운 기법을 소개하고 있다. 제목 그대로 빠르고 포터블한 동작 변환기(a fast and portable dynamic translator)를 말하는데, 이 기법의 동작 원리는 다음과 같다.\nQEMU 는 인터프리터 방식처럼 하나씩 번역해서 가상 상태 머신을 동작시키는 대신, 변환기(translator)가 실행중에 대상 CPU 명령어를 호스트 CPU 명령어로 바꾸어 실행한다. 호스트 명령어로 변환하기 전에, 대상 명령어는 일종의 중간코드인 마이크로작업(micro operations)으로 변환된다. 이 마이크로 작업 각각이 실제 호스트 CPU 명령어로 대치되어 실행된다.\n그런데 이 마이크로 작업에 대한 호스트 CPU 명령어 코드는 어셈블리로 작성된 것이 아니라, 하나의 마이크로 작업에 대해 하나의 C 함수로 구현되어 있다. 그리고, 이를 GCC 컴파일러가 생성한 바이너리를 가져다 그대로 이용한다. 물론 GCC 옵션을 조율해 불필요한 함수 앞/뒤 부분 파싱이나 최적화를 수행한다. 따라서 이론적으로는 GCC가 지원하는 모든 CPU를 쉽게 지원할 수가 있다.\n당연한 얘기지만 플랫폼마다 다른 여러 특성을 모두 구현해야 하기 때문에 새로운 CPU나 플랫폼을 지원하는 일이 그리 쉽지는 않다. 하지만 이미 Linux, Windows, MacOS X 등의 호스트 운영체제를 지원하고 있으며 X86, PowerPC, ARM, Sparc 등의 CPU를 에뮬레이트하고, x86, PowerPC, ARM, Sparc, Alpha, MIPS 등의 실행 호스트 CPU를 지원한다.\n FFMpeg 부터 알게된 Fabrice Bellard 라는 프랑스 사람(?)의 프로그래밍 + 성능 최적화 능력은 항상 내게 존경심을 불러일으키는 동시에, 자괴감에 빠지게 한다\u0026hellip;\n참고:\n  Finally user-friendly virtualization for Linux   KVM: Kernel-based Virtual Machine for Linux   QEMU: open source processor emulator   QEMU, a Fast and Portable Dynamic Translator   ","date":1167782400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1167782400,"objectID":"6148845c570267669e95826c6a0e24c9","permalink":"https://lethean.github.io/2007/01/03/qemu-fast-portable-dynamic-translator/","publishdate":"2007-01-03T00:00:00Z","relpermalink":"/2007/01/03/qemu-fast-portable-dynamic-translator/","section":"post","summary":"요즘 리눅스 2.6.20부터 추가된 가상화 기술 KVM 과 더불어 이슈가 되고 있는 QEMU 에뮬레이터의 내부 구현 원리를 밝힌 기사 를 보면 흥미로운 기법을 소개하고 있다. 제목","tags":["Linux"],"title":"빠르고 포터블한 동적 변환기, QEMU","type":"post"},{"authors":null,"categories":null,"content":"한글 메일링 리스트에서 pango 라이브러리 최적화 논의가 오고 가더니 그 결과가 최신 버전에 이미 반영된 모양이다. 엊그제(?) 우분투 개발 버전에 새로 1.15.2-0ubuntu1 버전 패키지가 올라왔는데, 릴리스 변동 사항에 포함되어 있었다. 문제는 몇몇 한글 글자가 흩어져서(?) 표시되는 현상이 발생하길래, 조금 있으면 버그가 수정되어 올라오겠지 기다리다가 참지 못하고 오늘 결국 직접 원인을 찾아보았더니, 의외로 빨리 해결책을 얻을 수 있었다.\n그놈 버그질라에 이미 \u0026lsquo; Composing jamo is broken in pango-1.15.2\u0026rsquo; 항목으로 같은 현상이 보고되어 있었고 거기에 추가된 패치를 적용해보니 다시 정상적으로 한글이 표시된다.\n이런 경우가 내겐, 오픈소스의 매력을 느끼는 순간이다.\n","date":1166832000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1166832000,"objectID":"35243a81a3f3e5742315dd5df38d9ad3","permalink":"https://lethean.github.io/2006/12/23/pango-1152-hangul-display-problem/","publishdate":"2006-12-23T00:00:00Z","relpermalink":"/2006/12/23/pango-1152-hangul-display-problem/","section":"post","summary":"한글 메일링 리스트에서 pango 라이브러리 최적화 논의가 오고 가더니 그 결과가 최신 버전에 이미 반영된 모양이다. 엊그제(?) 우분투 개발 버전에 새로 1.15.2-0ubuntu1 버전 패키지가 올","tags":["GTK+","OpenSource","Ubuntu"],"title":"Pango 1.15.2 한글 표시 문제","type":"post"},{"authors":null,"categories":null,"content":"리눅스 커널 2.6 이후, 즉 최신 리눅스 환경에서 어플리케이션을 개발할때 멀티쓰레드인 경우 데드락이나 블럭킹 현상을 디버깅하려면 매우 골치가 아프다. strace나 gdb 백트레이스를 추적하다보면 결국 futex() 시스템콜을 호출하고, 여기서 멈춰있는 경우가 대부분이다. 이 경우 대부분 이 시스템콜은 pthread 라이브러리가 호출하는 것이다. 이 경우 정확히 어떤 공유 라이브러리와 연관이 있는지 확인하기 힘든데 여기 블로그에 달린 댓글을 보면 다음 2가지 방법을 권하고 있다.\n export LD_ASSUME_KERNEL=2.4.1식으로 커널 버전을 명시하여 glibc가 NPTL 대신 futex() 를 사용하지 않는 이전 LinuxThread 방식을 사용하도록 하여 디버깅하기 ltrace 프로그램을 이용하여 라이브러리 호출 감시하기  하지만, 뭐 그런다고 쉽게 풀리지는 않는게 멀티쓰레드 프로그래밍인지라\u0026hellip;\n참고:\n  Jeremy Kolb: futex headaches   ","date":1166659200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1166659200,"objectID":"f9ac99324f72e39fbfeae4f3899e67b3","permalink":"https://lethean.github.io/2006/12/21/linux-multithread-futex-call-debugging/","publishdate":"2006-12-21T00:00:00Z","relpermalink":"/2006/12/21/linux-multithread-futex-call-debugging/","section":"post","summary":"리눅스 커널 2.6 이후, 즉 최신 리눅스 환경에서 어플리케이션을 개발할때 멀티쓰레드인 경우 데드락이나 블럭킹 현상을 디버깅하려면 매우 골치가 아프다. strace","tags":["glibc","Kernel","Linux"],"title":"리눅스 멀티쓰레드(futex) 호출 디버깅","type":"post"},{"authors":null,"categories":null,"content":"어느샌가 Upstart가 0.3 버전으로 올라가더니(우분투 개발버전 feisty), 공식적인 Upstart 홈페이지도 생겼다.(아래 링크 참고) 개발자가 0.3 버전에서 새로 추가된 사항을 정리해 놨으니 나도 한 번 다시 정리해 본다.\n작업 만들기(Writing Jobs) 업스타트(Upstart)는 데몬(daemon)의 시작 / 중지 / 감시 작업을 스스로 한다. start-stop-daemon 등을 이용하여 개발자가 스스로 관리해야 하는 것과 다르게 프로그램 경로와 인수만 주면 된다.\nexec /usr/bin/dbus-daemon  물론 셸스크립트도 사용할 수 있다.\nscript echo /usr/share/apport/apport \u0026gt; /proc/sys/kernel/crashdump-helperend script  데몬이 시작(start)되기 전/후(pre/post)와 중지(stop)되기 전/후(pre/post)에 원하는 작업도 할 수 있다.\npre-start script mkdir -p /var/run/dbus chown messagebus:messagebus /var/run/dbusend script post-start script # wait for listen on port 80 while ! nc -q0 localhost 80 /dev/null 2\u0026gt;\u0026amp;1; do sleep 1; doneend script post-stop script rm -f /var/run/dbus/pid pre-stop script # disable the queue, wait for it to become empty fooctl disable while fooq \u0026gt;/dev/null; do sleep 1 doneend script  여기서 script 대신 exec를 사용하면 스크립트(script) 대신 바이너리를 실행할 수도 있다.\n이벤트(Events) 0.3 버전에서 이벤트는 더 정교해졌다고 하는데, 단순히 시스템이 보내는 이벤트 이름 뿐 아니라 인수(arguments)와 환경변수도 전달할 수 있다.\ninitctl emit network-interface-up eth0 -DIFADDR=00:11:D8:98:1B:37  이 명령은 이벤트와 모든 결과를 출력하고 이벤트가 완전히 처리될때까지 끝나지 않게 한다. 이와 같이 전달된 인수는 다음처럼 스크립트에서 사용할 수 있다.\nstart on network-interface-upscript [ $1 = lo ] \u0026amp;\u0026amp; exit 0 grep -q $IFADDR /etc/network/blacklist \u0026amp;\u0026amp; exit 0 # etc.end script  아니면 다음과 같이 start on 과 stop on 구문에서 직접 일치하는지 검사할 수도 있다.\nstart on block-device-added sda*  작업의 상태 변화로 인한 이벤트도 변경되었다. 이전에는 작업이나 이벤트 모두 같은 이름공간(namespace)를 공유했는데, 혼동을 일으킬 뿐 아니라 실제로 작업 이름을 이용하는 이벤트 이름은 문제를 일으키기도 한다.\n이렇게 발생한 두개의 주요 이벤트는 간단하게 started 와 stopped 로 칭한다. 이를 통해 작업이 완전하게 로드되어 실행되고 있거나, 반대로 완전히 종료됨을 알 수 있다. 작업 이름은 이 이벤트의 인수로 받게 된다.\nstart on started dbus  started 이벤트는 post-start 작업이 끝나기 전에는 발생하지 않는다. 따라서 post-start 작업은 데몬에 아직 연결할 수 없는 다른 작업들이 시작하는 것을 지연할 수 있다.\n같은 식으로 stopped 이벤트는 post-stop 작업이 끝날때까지 발생하지 않는다.\n작업이 발생시키는 다른 두개의 이벤트는 약간 특별하다. starting과 stopping이 그것인데, 이 이벤트가 처리될때까지는 작업이 시작하거나 중지하지 못하게 한다. 즉, 데이터베이스 서버가 멈추었을때 해야할 작업이 있는데, 그러나 실제로 종료되기 전에 처리해야 한다면 다음과 같이 사용할 수 있다.\nstart on stopping mysqlexec /usr/bin/backup-db.py  MySQL이 백업이 끝나기 전까지 종료되지 않을 것이다.\n이 런 경우는 특히 다른 데몬에 의존하는 데몬일 경우 유용하다. 예를 들어 HAL은 DBUS를 필요로 하는데, DBUS가 실행되기 전에는 시작하면 안되고 DBUS는 HAL이 끝나기 전에 멈추면 안된다. 따라서 HAL 작업은 다음과 같다.\nstart on started dbusstop on stopping dbus  같은 식으로 Tomcat이 설치되어 있다면 Apache는 Tomcat이 실행되기 전에는 시작하면 안되고, Tomcat는 Apache가 종료될때까지 멈추면 안된다. 따라서 Tomcat 작업은 다음과 같다.\nstart on starting apachestop on stopped apache  실패(Failure)\n항 상 모든게 부드럽게 흘러가는 게 아니므로 가끔 작업이 수행이 태스크가 실패할 수도 있고 데몬이 죽을 수도 있다. upstart는 죽은(crashed) 데몬을 자동으로 재시작하게 할 수도 있고, 다른 작업에게 이를 알려줄 수도 있다. stopping 과 stopped 이벤트에 추가되는 failed 인수가 그것이다.\nstart on stopped typo failedscript echo \u0026quot;typo failed again :-(\u0026quot; | mail -s \u0026quot;type failed\u0026quot; rootend script  이벤트 실패로 인해 어떤 작업이 시작되거나 멈추었다면, 이벤트 자체가 실패했다는 것을 발견할 수도 있다.\nstart on network-interface-up/failed  상태(States) 네트웍 인터페이스를 구성하거나 블럭 장치를 검사하고 마운트하는 작업은 대개 이벤트의 결과로서 동작하는 반면, 서비스는 조금 더 복잡하다.\n서비스는 특정 이벤트가 발생했을때가 아니라 대개 시스템이 어떤 상태에 있을 경우 동작해야 한다. 따라서 upstart는 변화를 정의하는 이벤트를 참조하여 복잡한 시스템 상태를 설명할 수 있도록 한다.\n예를 들어 많은 서비스가 파일시스템이 마운트되어 있을 경우에만 동작해야 하고, 최소 하나의 네트웍 디바이스가 올라와 있어야 한다. 이러한 시기가 시작되고 끝나는 것을 가리키는 이벤트를 이용해 조합하면 다음과 같이 사용할 수 있다.\nfrom fhs-filesystem-mounted until fhs-filesystem-unmountedand from network-up until network-down  until 연산자는 두 이벤트 사이트의 기간을 정의하고, and 연산자는 두 기간을 동시에 적용하도록 한다.\n디스플레이 매니저가 실행되고 있는 경우에만 동작하려면 다음과 같이 기술할 수 있다.\nfrom started gdm until stopping gdmor from started kdm until stopping kdm  네트웍 인터페이스가 올라온뒤 bind9이 시작하기 전에 실행하고 싶다면 다음과 같이 기술하면 된다.\non network-interface-up and from startup until started bind9  이처럼 \u0026ldquo;복합 이벤트 구성\u0026quot;은 어느 작업 파일에나 올 수 있다. 그리고 어느 작업 파일이나 다른 작업에 대한 리퍼런스로 동작할 수 있다. 다른 작업과 동시에 시작하고 멈출 수도 있다.\nwith apache  exec나 script 절을 생략하면, 다른 작업이 리퍼런스로 사용할 수 있도록 상태만 정의한다. 그런 식으로 multiuser 상태 역시 단순히 상태를 정의하는 작업 파일이다.\n보너스로 덧붙이자면, 이러한 상태들도 pre-start, post-stop 등을 응용할 수 있다.\n참고:\n  Upstart 공식 홈페이지 - 언제 생겼지?  Upstart 0.3 - 개발자 블로그  ","date":1166486400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1166486400,"objectID":"54656404f4743c871dabb9137416b3cb","permalink":"https://lethean.github.io/2006/12/19/upstart-03/","publishdate":"2006-12-19T00:00:00Z","relpermalink":"/2006/12/19/upstart-03/","section":"post","summary":"어느샌가 Upstart가 0.3 버전으로 올라가더니(우분투 개발버전 feisty), 공식적인 Upstart 홈페이지도 생겼다.(아래 링크 참고) 개발자가 0.3 버전에서 새로 추가된 사항을","tags":["Linux","Ubuntu"],"title":"Upstart 0.3","type":"post"},{"authors":null,"categories":null,"content":"리눅스에서 디바이스 드라이버는 대개 동적으로 로딩 가능한 커널 모듈 방식이나 커널 자체에 포함시키는 방식으로 구성된다. 사용자공간(userspace)에서 일반 어플리케이션처럼 동작하는 디바이스 드라이버 구조는 X서버, Cupsys 프린터 드라이버 등에서 이미 사용되고 있듯이 새로운 개념은 아니다. 하지만 그 용도가 제한되어 있고, 인터럽트 처리와 성능에 대한 한계로 인해 아직도 대부분의 리눅스용 디바이스 드라이버는 커널 모듈로 작성되는 것이 일반적이다.\n예전에 리눅스용 사용자공간 드라이버 개발 프레임워크가 제안된 적이 있다가 많은 관심과 비판을 함께 받고 사라진 듯 싶더니 이번에 다시 -mm 커널 트리에 UIO 코어라는 이름으로 다시 포함이 된 것 같다. 정식 커널에 포함될지는 아직 잘 모르지만 그 구조가 흥미로울 것 같아 한번 들여다 보았다.\nUIO 코어는 하드웨어가 발생하는 인터럽트를 처리하기 위한 최소한의 커널 드라이버만 작성하고, 나머지 모든 작업은 사용자공간 프로그램으로 작성하도록 한다. 이를 통해 다양한 라이브러리와 개발도구를 사용할 수 있기 때문에 유지보수와 디버깅이 훨씬 쉬워진다. 드라이버 개발자가 느끼는 리눅스 커널의 가장 큰 장점이자 단점인 커널이 변경되어도 드라이버는 거의 변경할 필요도 없어진다. 또한 라이센스 문제도 피해갈 수 있다.\nUIO가 동작하는 방식은 다음과 같다.\n각각의 UIO 장치는 하나의 디바이스 파일과 sysfs 속성 파일을 통해 접근한다. 디바이스 파일 이름은 /dev/uio0, /dev/uio1 식이다. 이 디바이스 파일은 mmap()을 이용해 장치의 특정한 레지스터나 램 영역을 주소 공간처럼 접근하는데 이용한다. 인터럽트는 디바이스 파일을 읽는 작업을 통해 이루어진다. read() 시스템콜을 호출하면 블럭킹 상태에 있다가 인터럽트가 발생하면 깨어나 총 인터럽트 발생 횟수를 돌려준다. 이렇게 돌려받은 총 인터럽트 발생 횟수를 이용해 놓친 인터럽트에 대한 처리도 가능하다.\n인터럽트를 제대로 처리하기 위해 드라이버만의 고유한 커널 모듈 인터럽트 핸들러를 구현할 경우라도 내부 핸들러가 자동으로 호출해 준다. 인터럽트를 발생하지 않고 폴링 방식으로 동작하는 장치일 경우 타이머를 이용해 주기적으로 강제로 인터럽트 핸들러를 호출하게 할 수도 있다.\n드라이버는 sysfs를 통해 추가적인 접근 가능한 속성을 제공할 수도 있는데 다음은 UIO가 제공하는 기본 속성으로, /sys/class/uio/uioX 디렉토리에서 볼 수 있다.\n name : 장치 이름 addr : 맵핑 가능 영역 시작 주소 size : 맵핑 가능 영역 크기 version : 드라이버 버전 정보 event: 마지막으로 장치를 읽은 이후 드라이버가 처리한 인터럽트 총 갯수  커널 모듈에서 동작하는 인터럽트 핸들러를 작성하려면 struct uio_info 구조체에 정보를 채워 uio_register_device()를 이용해 등록하면 된다. 이 정보에는 인터럽트 핸들러 방식, 메모리 맵핑 정보 등을 담고 있다.\n많 은 하드웨어들이 인터럽트 발생후 드라이버 ACK 작업을 해주어야하는데, 사용자공간 프로그램은 동작하지 않을 수도 있고, 어떠한 원인으로 종료할 수도 있으므로 이런 작업은 직접 작성한 인터럽트 핸들러에서 처리하도록 하고 있다. 또한 인터럽트 발생할때마다 데이터를 하드웨어에서 읽어 커널 내부 버퍼에 저장하고 사용자공간 프로그램에게 전달할 수도 있다.\n모노리식 커널의 한계일지도 모르지만 약간 조잡하다는 느낌을 지울 수 없다. 조금 더 편하게 커널 API를 통해 인터럽트 이벤트를 처리할 수 있으면 좋을 것 같다. 또한 커널 내부의 PCI, USB 등의 서브시스템과의 연동은 어떻게 할 것인가? 물론 PCI나 USB 정보 사용자공간에서 접근이 가능하긴 하지만, 아직은 이론적으로 이상적인 프레임웍으로만 보인다. 그렇다면 마이크로커널 기반에서 디바이스 드라이버는 어떤 식으로 인터럽트를 처리할까? 음\u0026hellip;\n참고:\n  Userspace I/O kernel drivers for Linux   UIO Documentation   ","date":1166486400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1166486400,"objectID":"1d1dcc0cef911427fe6f1cc7bbc42870","permalink":"https://lethean.github.io/2006/12/19/uio-linux-userspace-kernel-driver/","publishdate":"2006-12-19T00:00:00Z","relpermalink":"/2006/12/19/uio-linux-userspace-kernel-driver/","section":"post","summary":"리눅스에서 디바이스 드라이버는 대개 동적으로 로딩 가능한 커널 모듈 방식이나 커널 자체에 포함시키는 방식으로 구성된다. 사용자공간(userspace)에서","tags":["Kernel","Linux"],"title":"리눅스 사용자공간 커널 드라이버 - UIO","type":"post"},{"authors":null,"categories":null,"content":"iRex 테크놀로지에서 만든 E-페이퍼, 종이처럼 구부러지면서 컴퓨터 화면처럼 동작하는 디스플레이 장치에 들어가는 소프트웨어 개발자들이 GTK+ 라이브러리를 이용한다고 한다. 여러가지 이유로 GTK+ 라이브러리를 거의 모든 회사 프로젝트에 이용하고 있는 입장으로 반갑기도 하고, 놀라운 점도 있다.\n참고:\n  iRex technologies is using gtk+ for an epaper device   ","date":1166400000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1166400000,"objectID":"b0c7c3f70cc00dd363dfae8eec549ab3","permalink":"https://lethean.github.io/2006/12/18/gtk-for-epaper-device/","publishdate":"2006-12-18T00:00:00Z","relpermalink":"/2006/12/18/gtk-for-epaper-device/","section":"post","summary":"iRex 테크놀로지에서 만든 E-페이퍼, 종이처럼 구부러지면서 컴퓨터 화면처럼 동작하는 디스플레이 장치에 들어가는 소프트웨어 개발자들이 GTK+ 라이브러리를 이용한다","tags":["GTK+","GUI"],"title":"E-페이퍼에 GTK+ 사용","type":"post"},{"authors":null,"categories":null,"content":"리눅스에서 일반적으로 top, ps 명령어를 통해 얻을 수 있는 프로세스의 메모리 정보는 다음과 같이 요약할 수 있다.\n SIZE(VSZ, VIRT) : 프로세스의 주소 공간 크기. 즉, 프로세스가 맵핑한 메모리의 전체 크기를 나타낸다. RSS(RES, Resident Set Size) : 실제 메모리에 올라와 있는 메모리 크기. 물론 스왑(swapped out)된 메모리는 제외된다. RSS는 프로세스에게 유일한 메모리 공간과 다른 프로세스와 공유된 공간도 포함한다. 리눅스 환경에서는 대부분 공유 라이브러리가 차지한다. libc 라이브러리가 대표적이다. SHARE(SHR) : RSS에서 다른 프로세스가 공유된 메모리 크기.  따라서 어플리케이션이 실제 사용하고 있는 메모리는 RSS에서 SHARE를 뺀 크기다. 물론 공유 라이브러리를 하나의 프로세스가 사용하고 있다면 그 크기도 실제 사용량에 포함되겠지만.\n참고:\n  Memory Usage with smaps   Re: Can anything be done to reduce memory usage?   ","date":1166400000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1166400000,"objectID":"73431d528eed384e6438dba63fc1c10c","permalink":"https://lethean.github.io/2006/12/18/process-memory-in-linux/","publishdate":"2006-12-18T00:00:00Z","relpermalink":"/2006/12/18/process-memory-in-linux/","section":"post","summary":"리눅스에서 일반적으로 top, ps 명령어를 통해 얻을 수 있는 프로세스의 메모리 정보는 다음과 같이 요약할 수 있다. SIZE(VSZ, VIRT) : 프로세스의 주소 공간 크기. 즉, 프로세스가 맵핑","tags":["Linux"],"title":"Process Memory in Linux","type":"post"},{"authors":null,"categories":null,"content":"애플(Apple) Mac OS X의 아쿠아(Aqua) 인터페이스가 일루미누스(Illuminous) 인터페이스로 교체된다고 한다. 이미 iTunes 7에서 일부분 선보였듯이, 전체적으로 어둡고 반투명의 검은 유리 같은 패널 위에 심플한 버튼으로 구성되었다. 윈도우즈 비스타의 에어로(Aero)와 비교될 것도 같지만, 언제나 그렇듯이 평범한 것도 애플이 하면 혁신으로 취급받게 되는 것 같다.\n전혀 허락없이 무단 링크하는 스크린샷은 다음과 같다.\niPhoto’s Adjust Window\nFront Row’s sliding dark glass\niTunes 7’s new darker appearance\nAperture 1.5’s navigation window\n참고:\n  Leopard’s Illuminating Graphical User Interface: Illuminous   RUMOR: Aqua to be replaced with Illuminous   ","date":1166400000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1166400000,"objectID":"2243845e813cdf5a771395031ec96b72","permalink":"https://lethean.github.io/2006/12/18/apple-illuminous-interface/","publishdate":"2006-12-18T00:00:00Z","relpermalink":"/2006/12/18/apple-illuminous-interface/","section":"post","summary":"애플(Apple) Mac OS X의 아쿠아(Aqua) 인터페이스가 일루미누스(Illuminous) 인터페이스로 교체된다고 한다. 이미 iTunes 7에서 일부분 선보","tags":["GUI"],"title":"애플의 새 일루미누스(Illuminous) 인터페이스","type":"post"},{"authors":null,"categories":null,"content":"폰트 설정 방식이 바뀐다고 적은지 하루만에 language-selector.conf 파일을 적용하는 기능이 추가되었다. 다만 파이어폭스 등에서 은돋움 폰트 모양이 내 맘에 안들기 때문에 /usr/share/language-selector/fontconfig/ko_KR 파일에서 hintmedium 을 모두 hintfull 로 변경만 해주니 다시 쾌적한 폰트 환경으로 돌아오게 되었다.\n","date":1164931200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1164931200,"objectID":"709064760168ce67a5cea858f0bf7d22","permalink":"https://lethean.github.io/2006/12/01/fontconfig-24-in-ubuntu-feisty-2/","publishdate":"2006-12-01T00:00:00Z","relpermalink":"/2006/12/01/fontconfig-24-in-ubuntu-feisty-2/","section":"post","summary":"폰트 설정 방식이 바뀐다고 적은지 하루만에 language-selector.conf 파일을 적용하는 기능이 추가되었다. 다만 파이어폭스 등에서 은돋움 폰트 모양이 내 맘에 안들기 때문에 /usr/share/language-selector/fontconfig/ko_KR 파일에서 hintmedium 을 모","tags":["Ubuntu","Xorg"],"title":"FontConfig 2.4 in Ubuntu Feisty","type":"post"},{"authors":null,"categories":null,"content":"그렇다. 한동안 잠잠하더니 fontconfig 패키지가 2.4.1 버전으로 올라가면서 폰트 관련 설정이 대폭 변경되었다.\n/etc/fonts/language-selector.conf 파일은 아예 참조도 안하고, 설정 파일도 철저하게(?) 분리되고 위치도 /etc/fonts/conf.d와 /etc/fonts/conf.avail로 나뉘어 설치와 사용을 구분하고 있다. 폰트 캐시 파일은 폰트가 위치한 각 디렉토리에 fonts.cache-1로 유지하더니 이제는 /var/cache/fontconfig로 통합되었다. 변동사항을 보니 이렇게 한군데로 모은뒤 메모리맵핑된 영역을 모든 프로세스가 공유하는 방식으로 바뀌면서 전체적인 어플리케이션 시작 속도 향상을 꾀한 것도 같다.\n","date":1164844800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1164844800,"objectID":"3226c249db8c066921fb240a1618ff7f","permalink":"https://lethean.github.io/2006/11/30/fontconfig-24-in-ubuntu-feisty/","publishdate":"2006-11-30T00:00:00Z","relpermalink":"/2006/11/30/fontconfig-24-in-ubuntu-feisty/","section":"post","summary":"그렇다. 한동안 잠잠하더니 fontconfig 패키지가 2.4.1 버전으로 올라가면서 폰트 관련 설정이 대폭 변경되었다. /etc/fonts/language-selector.conf 파일은 아예 참조도 안하고, 설정 파일도 철저하게(?) 분리되","tags":["Ubuntu","Xorg"],"title":"FontConfig 2.4 in Ubuntu Feisty","type":"post"},{"authors":null,"categories":null,"content":"많은 사람들이 3D 데스크탑 효과를 얻기 위해 Beryl 프로젝트 결과물을 이용하는데, 내 경우 Beryl 보다 심플한 설정 인터페이스를 지닌 오리지널 Compiz 윈도우 매니저 를 더 선호한다. 특히 노트북처럼 1.4Hz CPU지만 전원절약을 위해 대부분 시간을 600MHz로 동작하고, 비디오카드도 인텔 계열(I810)이라서, 무분별하게(?) 화려한 Beryl 프로젝트보다 Compiz 프로젝트가 더 적합한 것 같다.\n회사에서 작업용으로 사용한 장비의 경우도 NVidia 비디오카드이고 CPU도 넉넉하지만 굳이 Compiz를 사용하는데, Beryl을 이용하면 발생하는 가끔 윈도우가 까맣게 보이는 현상이 Compiz의 경우 발생하지 않기 때문이다.\n우분투의 경우 XGL을 설치하지 않아도 \u0026lsquo; Ubuntu Compiz Repository \u0026rsquo; 페이지의 설명을 따라 몇 개 패키지만 설치하면 자동으로 설치한다. 특히 여기서 개발 버전(development branch)를 설치하면 Beryl 프로젝트에 있는 대부분의 플러그인도 비슷하게 사용할 수 있다.\n","date":1164844800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1164844800,"objectID":"ca19ebc718efb76d57113b37bd8a1455","permalink":"https://lethean.github.io/2006/11/30/i810-compiz-in-ubuntu/","publishdate":"2006-11-30T00:00:00Z","relpermalink":"/2006/11/30/i810-compiz-in-ubuntu/","section":"post","summary":"많은 사람들이 3D 데스크탑 효과를 얻기 위해 Beryl 프로젝트 결과물을 이용하는데, 내 경우 Beryl 보다 심플한 설정 인터페이스를 지닌 오리지널 Compiz 윈도우 매니저 를 더 선호한다.","tags":["Ubuntu","Xorg"],"title":"I810 + Compiz in Ubuntu","type":"post"},{"authors":null,"categories":null,"content":" 리눅스 커널 2.6.19 릴리스 소식 을 접하게 되었다. 역시나 또 많은 새로운 기능이 추가되고, 변경되고 사라졌다. 이 중에서 관심있는 것만 간추려보면 다음과 같다.\nGFS / ECRYPTFS / EXT4 파일 시스템 지원\nGFS 는 레드햇이 주도해서 만드는 클러스터링 파일 시스템, ECRYTPFS는 파일단위별로 암호화가 가능한 파일 시스템이다. EXT4는 EXT3의 다음 버전으로 16테라바이트 이상 크기 지원(64비트), 32000 개 하위디렉토리 제한 없애기, 나노초 단위 파일 시간 정보 저장, mke2fs/e2fsck 속도 향상 등이 주요 이슈이다. 아직 안정화되려면 시간이 더 걸린다고 한다.\nLibata PATA (Parallel ATA) 추가\n병 렬 ATA(Parallel ATA) 장치는 직렬 ATA(Serial ATA) 장치가 이전에 존재하던, 다시 말해 현재 대부분의 데스크탑에서 사용하는 저장 장치 인터페이스이다. 현재 잘 동작하고 있으나 구조적인 문제로 해결이 어려운 몇몇 문제를 안고 있는 드라이버를 SATA 드라이버의 기반이 되는 libata를 기반으로 다시 작성한 PATA 드라이버가 추가되었다. 아직 모든 IDE를 지원하는 것은 아니며 기존 IDE 드라이버와 공존해서 존재한다. 하지만 PATA 드라이버가 안정화되면 점차 기존 IDE 드라이버는 모두 지워질 것이라고 한다. 또한 장치 이름도 더 이상 /dev/hda 식이 아닌 /dev/sda, /dev/sr0 식으로 바뀐다. 즉, 다른 모든 저장장치와 동일한 방식으로 관리된다. 앨런 콕스(Alan Cox)가 주도하는 이 작업은 오랫동안 리눅스 커널에 있던 IDE 드라이버가 이제서야 구조적으로 업그레이드 되는 셈이다. (또 얼마나 많은 리눅스 커널 관련 서적이 Obsolete로 변하게 될지\u0026hellip; 하긴 그래야 새로운 개정판을 구입하겠지만\u0026hellip;)\nALSA가 지원하는 OSS 드라이버 제거\nALSA가 리눅스 커널 2.6의 공식 오디오 드라이버로 지정된 이후로 이제서야 OSS 드라이버가 없어지기 시작했다. 물론 ALSA는 OSS 호환 레이어를 제공하기 때문에 기존 OSS 기반 어플리케이션은 아무 문제가 없다.\nIRQ 핸들러 구조 변경\n모든 인터럽트 핸들러는 CPU 레지스터 상태를 나타내는 \u0026quot;struct pt_regs *\u0026quot;를 인수로 받았는데, CPU별 전역 변수를 두는 대신 인터럽트 핸들러 인수에서 사라졌다. 아키텍쳐에 따라서는 오버헤드 감소로 인한 성능 향상을 기대할 수도 있다. 공식 커널에 포함된 약 1800개의 인터럽트 핸들러가 모두 수정되었다고 한다. (물론 디바이스 드라이버를 별도로 개발하는 사람들에겐 별로 기쁜 소식이 아닐지도\u0026hellip;)\nFAT 파일 시스템에 \u0026lsquo;flush\u0026rsquo; 옵션 추가\nUSB 플래시와 같이 제거 가능한 미디어 장치를 FAT로 마운트할때 \u0026quot;-o flush\u0026quot; 옵션을 주면 가능한 빨리 디스크에 내용을 반영한다. \u0026quot;-o sync\u0026quot;와 비슷하지만 훨씬 더 빠르다고 한다.\n더 자세한 변경사항은 이미 잘 정리된 \u0026lsquo;Kernel Newbies - 리눅스 2.6.19\u0026rsquo; 를 참고하면 된다.\n","date":1164844800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1164844800,"objectID":"6f37d462fe2e828041a2d64e63a975a6","permalink":"https://lethean.github.io/2006/11/30/linux-kernel-2619-release/","publishdate":"2006-11-30T00:00:00Z","relpermalink":"/2006/11/30/linux-kernel-2619-release/","section":"post","summary":"리눅스 커널 2.6.19 릴리스 소식 을 접하게 되었다. 역시나 또 많은 새로운 기능이 추가되고, 변경되고 사라졌다. 이 중에서 관심있는 것만 간추려보면 다음과 같다. GFS / ECRYPTFS /","tags":["Kernel","Linux"],"title":"Linux Kernel 2.6.19 Release","type":"post"},{"authors":null,"categories":null,"content":"업무에 서브버전(Subversion)을 사용한지 오래 되었지만 가끔씩 서버(svnserve)가 늦게 응답을 주는 경우가 종종 있었다. 가끔씩 벌어지는 현상이고, 서버 데몬을 재시작하면 해결되는 문제라 무시하고 있다가 문득 구글링을 해보고 원인을 알았다.\n서브버전은 사용자 인증을 위해 리눅스에서 /dev/random 난수 생성 장치를 이용하는데, 엔트로피가 부족할 경우 채워질때까지 대기하기 때문에 발생하는 현상이다. 서버 장비는 키보드도 거의 사용안하고, IDE 디스크도 없기 때문에 난수 엔트로피를 채워줄 정보가 부족해서 발생하는 경우이다.\n검색을 해보면 설정 옵션을 변경해서 다시 컴파일하라는 둥, 데비안 패키지에 길들여진 내게 무리한 방법만 제시하길래 그냥 다음과 같이 무식하고 단순하며 보안에 위험하다는 방법으로 해결했다.\n# mv /dev/random /dev/random.orig # ln -sf /dev/urandom /dev/random  즉, /dev/random 장치 대신 /dev/urandom 장치를 무조건 사용하게 한뒤, 서브버전 데몬을 재시작하면 된다.\n","date":1161302400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1161302400,"objectID":"4b2d2af1fcec4ac6ee4caab8b9a86967","permalink":"https://lethean.github.io/2006/10/20/slow-subversion-server-response/","publishdate":"2006-10-20T00:00:00Z","relpermalink":"/2006/10/20/slow-subversion-server-response/","section":"post","summary":"업무에 서브버전(Subversion)을 사용한지 오래 되었지만 가끔씩 서버(svnserve)가 늦게 응답을 주는 경우가 종종 있었다. 가끔씩 벌어지는 현","tags":["Linux","Subversion"],"title":"Subversion 서버 응답이 느린 문제","type":"post"},{"authors":null,"categories":null,"content":"외부에서 접속할 수 있는 서버가 master.emstone.com 이고, 접근하려고 하는 내부 네트웍 서버가 svn.emstone.com(192.168.0.143), 서비스가 Subversion 이라고 하면 다음과 같은 작업을 통해 외부에서 직접 접근이 가능하다.\n  우선 master.emstone.com 서버에 SSH 접속이 가능한 계정이 있어야 한다. (여기서는 lethean)\n  현재 컴퓨터의 /etc/hosts 파일을 다음 내용을 추가한다.\n127.0.0.1 svn svn.emstone.com    내부 네트웍 서버 IP가 192.168.0.143 일 경우 다음과 같은 옵션으로 master.emstone.com 서버에 접속한다.\nssh lethean@master.emstone.com -L 3690:192.168.0.143:3690    Subversion 작업을 하면 동작한다.\n  원리는 이렇다. SSH 접속시 \u0026lsquo;-L\u0026rsquo; 옵션은, 로컬 장비(localhost:3690)의 특정 포트에 대한 연결을 접속한 서버(master.emstone.com)에서 접근 가능한 특정 IP 포트(192.168.0.143:3690)로 무조건 송신하고 그 결과를 다시 돌려받는다. 따라서 실제로는 로컬호스트에 대해 작업을 하는 것처럼 보이지만 SSH 연결을 통해 원격으로 동작하는 셈이다.\nSSH 연결을 끊으면 당연히 더이상 동작하지 않게 된다.\n","date":1158192000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1158192000,"objectID":"8ba7268ab7a93e3622b324768b045487","permalink":"https://lethean.github.io/2006/09/14/ssh-port-forwarding-to-access-intranet-servers/","publishdate":"2006-09-14T00:00:00Z","relpermalink":"/2006/09/14/ssh-port-forwarding-to-access-intranet-servers/","section":"post","summary":"외부에서 접속할 수 있는 서버가 master.emstone.com 이고, 접근하려고 하는 내부 네트웍 서버가 svn.emstone.com(192.168.0.143), 서비스가 Subversion 이라고 하면 다음과 같은 작업을 통해 외부에서 직접 접근이 가능하다. 우선 master.emstone.com","tags":["Linux","Network"],"title":"SSH 포트 포워딩(port forwarding) + 내부 네트웍 서버 접근하기","type":"post"},{"authors":null,"categories":null,"content":"(http://www.netsplit.com/blog/work/canonical/upstart.html)\nUNIX System V부터 현재 대부분의 리눅스 배포판에 지금까지 사용하는 sysvinit 시스템이 Ubuntu Edgy 버전에서 upstart라는 이벤트-작업(job) 기반 시스템으로 교체되고 있다. 현존하는 initng, launchd, SMF 등과 같은 sysvinit의 다른 대안을 선택하지 않고 우분투 팀에서 새로 만들어가고 있는 것 같다.\n아마도 가장 큰 변화는 USB 메모리나 USB 네트웍 장치처럼 실행 중에 추가되고 삭제되는 환경을 고려한다는 점이고, 이벤트 기반으로 시스템 초기화 스크립트(/etc/rcS.d)가 재작성되고, 결국에는 모든 패키지의 데몬이 upstart 방식으로 변경될 것 같다.\n과연 upstart 방식이 우분투 리눅스에서만 사용하게 될 것인가, 다른 배포판에도 영향을 끼칠 것인가는 아직 미지수다. 하지만 지금까지 대부분 Unix / Linux 사용자와 관리자에게 너무나 당연하게 여겨졌던 /etc/rc?.d 데몬 방식이 변경되면, 새로 공부할게 한 가지 더 늘어나게 되겠군..\ndbus, udev, hal, \u0026hellip; 리눅스도 이제 충분히 (개발자에게는) 복잡한 시스템이 되어가고 있다.\n","date":1157673600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1157673600,"objectID":"05e46e4aa11f9721a59a96d7011366d6","permalink":"https://lethean.github.io/2006/09/08/upstart-in-universe-of-ubuntu-edgy/","publishdate":"2006-09-08T00:00:00Z","relpermalink":"/2006/09/08/upstart-in-universe-of-ubuntu-edgy/","section":"post","summary":"(http://www.netsplit.com/blog/work/canonical/upstart.html) UNIX System V부터 현재 대부분의 리눅스 배포판에 지금까지 사용하는 sysvinit 시스템이 Ubuntu Edgy 버전에서 upstart라는 이벤트-작업(job) 기반 시스템으로 교체되고 있","tags":["Linux","Ubuntu"],"title":"Upstart in Universe of Ubuntu Edgy","type":"post"},{"authors":null,"categories":null,"content":"프로젝트를 위해 새로운 모니터 2대로 교체하면서 듀얼 모니터를 사용하기 위해 비디오카드도 함께 교체했다. (LG Flatron L2012P x 2 + NVidia Geforce 7300 GT) Ubuntu 6.06 LTS 버전을 사용하고 있는데, 우분투 위키에 있는대로 nvidia-glx 패키지를 설치와 몇몇 설정을 마친 뒤 X 서버 설정까지 튜닝한 이후 다음과 같이 동작하는 환경을 얻게 되었다.\n    원래는 각각 1600x1200 해상도로 셋팅한 것이지만, 이를 세로로 돌려(모니터가 돌아간다!) 길게 옆으로 붙인 것이다.\n이에 대한 X 설정은 아래와 같다.\nSection \u0026quot;Files\u0026quot; FontPath \u0026quot;/home/lethean/.fonts\u0026quot; FontPath \u0026quot;/usr/share/X11/fonts/misc\u0026quot; FontPath \u0026quot;/usr/share/X11/fonts/cyrillic\u0026quot; FontPath \u0026quot;/usr/share/X11/fonts/100dpi/:unscaled\u0026quot; FontPath \u0026quot;/usr/share/X11/fonts/75dpi/:unscaled\u0026quot; FontPath \u0026quot;/usr/share/X11/fonts/Type1\u0026quot; FontPath \u0026quot;/usr/share/X11/fonts/100dpi\u0026quot; FontPath \u0026quot;/usr/share/X11/fonts/75dpi\u0026quot; EndSection Section \u0026quot;Module\u0026quot; Load \u0026quot;bitmap\u0026quot; Load \u0026quot;dbe\u0026quot; Load \u0026quot;ddc\u0026quot; Load \u0026quot;extmod\u0026quot; Load \u0026quot;freetype\u0026quot; Load \u0026quot;glx\u0026quot; Load \u0026quot;int10\u0026quot; Load \u0026quot;type1\u0026quot; Load \u0026quot;vbe\u0026quot; EndSection Section \u0026quot;InputDevice\u0026quot; Identifier \u0026quot;Generic Keyboard\u0026quot; Driver \u0026quot;kbd\u0026quot; Option \u0026quot;CoreKeyboard\u0026quot; Option \u0026quot;XkbRules\u0026quot; \u0026quot;xorg\u0026quot; Option \u0026quot;XkbModel\u0026quot; \u0026quot;pc104\u0026quot; Option \u0026quot;XkbLayout\u0026quot; \u0026quot;us\u0026quot; EndSection Section \u0026quot;InputDevice\u0026quot; Identifier \u0026quot;Configured Mouse\u0026quot; Driver \u0026quot;mouse\u0026quot; Option \u0026quot;CorePointer\u0026quot; Option \u0026quot;Device\u0026quot; \u0026quot;/dev/input/mice\u0026quot; Option \u0026quot;Protocol\u0026quot; \u0026quot;ExplorerPS/2\u0026quot; Option \u0026quot;ZAxisMapping\u0026quot; \u0026quot;4 5\u0026quot; EndSection Section \u0026quot;Device\u0026quot; Identifier \u0026quot;NVIDIA Corporation NVIDIA Default Card\u0026quot; Driver \u0026quot;nvidia\u0026quot; Option \u0026quot;NoLogo\u0026quot; \u0026quot;true\u0026quot; BusID \u0026quot;PCI:1:0:0\u0026quot; Option \u0026quot;RandRRotation\u0026quot; \u0026quot;true\u0026quot; Option \u0026quot;Rotate\u0026quot; \u0026quot;left\u0026quot; Option \u0026quot;UseEdidFreqs\u0026quot; \u0026quot;true\u0026quot; # TwinView Option \u0026quot;TwinView\u0026quot; \u0026quot;true\u0026quot; Option \u0026quot;SecondMonitorHorizSync\u0026quot; \u0026quot;28-83\u0026quot; Option \u0026quot;SecondMointorVertRefresh\u0026quot; \u0026quot;56-85\u0026quot; # Option \u0026quot;TwinViewOrientation\u0026quot; \u0026quot;RightOf\u0026quot; Option \u0026quot;TwinViewOrientation\u0026quot; \u0026quot;Above\u0026quot; Option \u0026quot;MetaModes\u0026quot; \u0026quot;1600x1200,1600x1200\u0026quot; # Option \u0026quot;ConnectedMonitor\u0026quot; \u0026quot;CRT, DFP\u0026quot; EndSection Section \u0026quot;Monitor\u0026quot; Identifier \u0026quot;L2012P\u0026quot; Option \u0026quot;DPMS\u0026quot; HorizSync 28-83 VertRefresh 56-85 EndSection Section \u0026quot;Screen\u0026quot; Identifier \u0026quot;Default Screen\u0026quot; Device \u0026quot;NVIDIA Corporation NVIDIA Default Card\u0026quot; Monitor \u0026quot;L2012P\u0026quot; DefaultDepth 24 SubSection \u0026quot;Display\u0026quot; Depth 16 Modes \u0026quot;1600x1200\u0026quot; EndSubSection SubSection \u0026quot;Display\u0026quot; Depth 24 Modes \u0026quot;1600x1200\u0026quot; EndSubSection EndSection Section \u0026quot;ServerLayout\u0026quot; Identifier \u0026quot;Default Layout\u0026quot; Screen \u0026quot;Default Screen\u0026quot; InputDevice \u0026quot;Generic Keyboard\u0026quot; InputDevice \u0026quot;Configured Mouse\u0026quot; EndSection Section \u0026quot;DRI\u0026quot; Mode 0666 EndSection  ","date":1153353600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1153353600,"objectID":"04eb528eefcd775e5ca75bfdb01d6be9","permalink":"https://lethean.github.io/2006/07/20/dual-monitors-xrandr/","publishdate":"2006-07-20T00:00:00Z","relpermalink":"/2006/07/20/dual-monitors-xrandr/","section":"post","summary":"프로젝트를 위해 새로운 모니터 2대로 교체하면서 듀얼 모니터를 사용하기 위해 비디오카드도 함께 교체했다. (LG Flatron L2012P x 2 + NVidia Geforce 7300 GT) Ubuntu 6.06 LTS 버전을 사용하고 있는데,","tags":["Xorg"],"title":"Dual Monitors +XRandR","type":"post"},{"authors":null,"categories":null,"content":" \u0026lsquo;Manage source code using Git\u0026rsquo; 이 글은 리누스 토발즈가 개발하고 리눅스 커널과 여러 오픈소스 프로젝트 개발에 사용하고 있는 git 소스 코드 관리 시스템에 대한 개략적인 튜토리얼이다. 자세한 기술적인 내용이라기보다 처음 접하는 이들에게 필요한 일종의 소개서 정도 되는 수준이다.\n그런데 이 글을 읽으면서 과연 현재 회사에서 사용하고 있는 서브버전(subversion) 을 git으로 대체가 가능할까 궁금해졌다. 이미 서브버전에 있거나 git가 더 나은 점은 대략 다음과 같이 요약할 수 있다.\n 브랜치 작업이 빠르고 쉽다 (subversion도 역시) 오프라인 작업을 지원해서, 로컬 커밋을 나중에 한꺼번에 할 수 있다. (subversion도 브랜치를 이용하면 가능하지만, 오프라인은 안됨) 커밋이 프로젝트 전체에 걸쳐 원자성을 가진다 (subversion도 역시) 모든 작업트리는 전체 프로젝트 히스토리를 담고 있다.  하지만 subversion에 있지만 git에는 약간 부족한 기능들은 다음과 같다.\n 윈도우즈(windows)와 같은 멀티 플랫폼 지원 : 커맨드라인 툴과 QGit 등을 이용하면 되겠지만, TortoiseSVN, Eclipse 등에 익숙한 사용자에겐 아직 무리 바이너리 \u0026amp; 텍스트 파일 인식 구분 처리 : 라인구분자, 바이너리 diff 처리 등등등 사용자 인증 : git는 훅을 통해 구현하는 것 같은데, 복잡해 보인다  즉, 위의 이유로 인해 아직은 도입이 망설여진다. 하지만, SVN 서버가 회사 내부 네트웍에 있어서 집이나 다른 곳에서 작업할때 커밋하기 불편하거나, 여러 브랜치를 관리하다보면 필요한 독립적인 분산 저장소 등이 필요하다고 느낄때는 아마 다시 git을 검토하고 있을 지도 모른다.\n","date":1151884800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1151884800,"objectID":"9fcf1ec2f02d0d43fb2ad187fcd94cdb","permalink":"https://lethean.github.io/2006/07/03/manage-source-code-using-git/","publishdate":"2006-07-03T00:00:00Z","relpermalink":"/2006/07/03/manage-source-code-using-git/","section":"post","summary":"\u0026lsquo;Manage source code using Git\u0026rsquo; 이 글은 리누스 토발즈가 개발하고 리눅스 커널과 여러 오픈소스 프로젝트 개발에 사용하고 있는 git 소스 코드 관리 시스템에 대한 개략적인 튜토리얼이다. 자세","tags":["Git","Subversion"],"title":"Git을 이용한 소스코드 관리","type":"post"},{"authors":null,"categories":null,"content":" (원문 : Linux on board: This old box: Home automation using X10) 이 글은 전력선(power lines) 위로 데이터를 전송하는데 이용하는 X10 프로토콜을 이용하여 다른 가전 제품을 제어하는 방법을 설명하고 있다. X10 프로토콜은 네트웍으로 사용하기에는 느리지만, 간단하게 원격으로 제품을 제어하는데는 충분하다고 한다. 물론 제어하려는 장치가 X10 프로토콜을 지원해야 하고, X10 프로토콜은 시리얼이나 USB 방식으로 변환되어 들어오기 때문에 별도의 드라이버 없이 프로토콜만 이해하면 프로그래밍이 가능하다.\n이 글에서는 기본적인 작업을 하는 프로그램을 몇가지 셸 코드와 조합하여 cron 등을 이용하여 주기적으로 제어하는 예제를 보여주고 있다. \u0026lsquo;하우스 코드, 유닛 코드, 기능 코드\u0026rsquo; 로 구성된 패킷을 브로드캐스트(broadcast) 방식으로 송신하고, 각 장비들은 자신에게 맞는 코드가 도착했을 경우 이를 받아들여 처리하는 방식이다. 인증이나 다른 복잡한 과정이 필요없기 때문에 프로그래밍도 매우 간단하다.\n","date":1151884800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1151884800,"objectID":"346b4ad8d536fc3bddff8da9a382d489","permalink":"https://lethean.github.io/2006/07/03/home-automation-using-x10/","publishdate":"2006-07-03T00:00:00Z","relpermalink":"/2006/07/03/home-automation-using-x10/","section":"post","summary":"(원문 : Linux on board: This old box: Home automation using X10) 이 글은 전력선(power lines) 위로 데이터를 전송하는데 이용하는 X10 프로토콜을 이용하여 다른 가전 제품을 제어하는 방법을 설명하고","tags":["Embedded"],"title":"X10 프로토콜 이용한 홈 오토메이션","type":"post"},{"authors":null,"categories":null,"content":" Linux: The Case For Removing devfs 그렇게 많은 논란이 있어왔던 devfs 파일시스템이 드디어 공식적으로 리눅스 커널 소스에서 제거되었다. 정확히는 위 기사에 언급된 패치가 리누스 토발즈의 커널 트리에 6월 29일 날짜로 반영 되었다. 따라서 2.6.18 릴리스부터는 공식적으로 적용될 것 같다. 물론 그 전부터 몇몇 드라이버는 이미 devfs 지원을 제거해오기 시작하고, 위 패치가 적용된 이후에도 몇몇 누락된 드라이버들도 계속해서 관련 코드를 제거하는 것 같다.\n우분투를 사용하게 되면서 직접 커널을 컴파일해서 사용하는 경우가 거의 사라진 지금의 내게 있어 사실 devfs 지원이 사라지는 것은 별로 의미가 없다. 왜냐하면 현재 회사 제품에 사용하는 대부분의 임베디드 리눅스 시스템에서는 devfs / udev 모두 사용하지 않고 /dev 디렉토리를 직접 만들어 사용하는 방식을 이용하고 있기 때문이다. 다만 커널 바이너리 크기가 조금 더 작아진다니 그런 혜택이라도 받을 수 있으려나 모르겠다.\n","date":1151884800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1151884800,"objectID":"2f11be794ddd84245473d237fdf7e2e8","permalink":"https://lethean.github.io/2006/07/03/devfs-removed-from-linux-kernel/","publishdate":"2006-07-03T00:00:00Z","relpermalink":"/2006/07/03/devfs-removed-from-linux-kernel/","section":"post","summary":"Linux: The Case For Removing devfs 그렇게 많은 논란이 있어왔던 devfs 파일시스템이 드디어 공식적으로 리눅스 커널 소스에서 제거되었다. 정확히는 위 기사에 언급된 패치가 리누스 토발즈의 커","tags":["Kernel","Linux","Udev"],"title":"리눅스 커널에서 devfs 제거","type":"post"},{"authors":null,"categories":null,"content":" CELF 2006 컨퍼런스에서 공개된 여러 슬라이드 자료 에서 관심있는 몇 가지를 요약해 본다.\nVisualizing Resource Usage During Initialization of Embedded Systems\nBootchart를 임베디드 시스템에 적용하여 임베디드 리눅스 부팅 속도 측정 및 지연 부분을 찾아내는 과정을 보여준다. 더불어 기존 Bootchart의 처리 방식이 저성능 CPU에서는 비효율적이라서 리소스를 적게 차지하도록 새로 개선하는 방법도 소개한다.\nGraphics Subsystem in an Embedded World - Integrating DirectFB into a UHAPI platform\n스트리밍 장비 표준 미들웨어 API인 UHAPI 를 DirectFB 에서 지원하기 위한 기본 지식과 그 과정을 보여준다.\nLow Disturbance Embedded System Tracing with Linux Trace Toolkit Next Generation\n LTTng 를 이용하여 인터럽트 응답시간을 저해하는 요소를 찾아내는 과정을 설명한다\nAnalysis of User Level Device Driver usability in embedded application\n임베디드 시스템은 일반적인 서버나 PC와 달리 항상 새로운 디바이스를 사용하는 경우가 대부분이고 일반적인 용도라기보다 하나의 전용 어플리케이션에 맞추어 동작하는 경우가 대부분이다. 이 글에서는 사용자 레벨 디바이스 드라이버, 즉 일반 어플리케이션 방식으로 드라이버를 제작하는 방식을 제시하고 있다. 새로운 개념이라기보다는 이미 존재하는 mmap(), fasync() 등을 이용하여 DMA, IO 영역, 인터럽트 처리 방법을 보여주고 여러가지 커널 설정에서 성능을 비교해주고 있다.\nEmbedded Linux Optimizations - Size, RAM, speed, power, cost\n Free Electrons 의 강의 시리즈 중에 하나로 보이는 이 자료는, 임베디드 리눅스의 부팅 속도, 메모리 사용크기, 속도, 전원 절약 등 실제 업무에 활용가능한 여러가지 기법을 잘 정리하고 있다. 최신 기술은 물론 고전적인 방식까지 일목요연하게 잘 정리된 것 같다.\n","date":1147132800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1147132800,"objectID":"c890d6fd3bac6cb28a08e0f4d824823f","permalink":"https://lethean.github.io/2006/05/09/celf-2006-conference/","publishdate":"2006-05-09T00:00:00Z","relpermalink":"/2006/05/09/celf-2006-conference/","section":"post","summary":"CELF 2006 컨퍼런스에서 공개된 여러 슬라이드 자료 에서 관심있는 몇 가지를 요약해 본다. Visualizing Resource Usage During Initialization of Embedded Systems Bootchart를 임베디드 시스템에 적용하여 임베디드 리","tags":["Embedded","Linux"],"title":"CELF 2006 컨퍼런스","type":"post"},{"authors":null,"categories":null,"content":" Porting Linux applications to 64-bit systems 를 보면 64비트 환경에서 기존 리눅스 어플리케이션을 동작시키기 위해 C/C++ 프로그래머가 알아야 할 내용을 정리해주고 있다. 다음은 그 중에서 일부분을 정리한 내용이다.\n64비트 표준\n리눅스는 LP64 표준을 따른다. LP64는 long / long long / pointer 형만 64비트이고 나머지는 32비트 환경과 동일한다. 참고로 LLP64는 long long / pointer 형만 64비트, ILP64는 int / long / long long / pointer 가 모두 64비트인 환경을 의미한다. 따라서 기존 32비트 프로그램을 포팅할때 가장 유의할 점은 long 형으로 선언된 자료구조에 대한 처리이다.\n자료구조 정렬(align) 방식\n64비트형(long / double / pointer 등)은 항상 64비트 경계에 정렬된다. 나머지 공간은 모두 패딩된다. 따라서 자료구조 정의시 64비트형일 경우 적절하게 배치하는 것이 좋다.\n변수/상수 정의\n32/64비트 환경에서 32비트 크기를 원하면 int 형을 사용한다. 32비트 환경에서는 32비트, 64비트 환경에서는 64비트로 동작하는 크기를 원하면 long 형을 사용한다. 숫자를 다룰때 바이트를 아끼기 위해 char, short 등을 성능에 그리 좋지 않다.\n32비트 환경에서 모든 비트를 켜기 위해 대개 0xFFFFFFFFL 상수가 사용된다. 하지만 64비트 시스템에서 이 값은 하위 32비트만 켜진 0x00000000FFFFFFFF 값을 의미한다. 따라서 이식성이 좋게 만드려면 다음과 같이 사용하는 것이 좋다.\nlong x = -1L;  또다른 예로 들 수 있는 것은, 최상위 비트를 켤때 많이 사용하는 0x80000000 값이다. 이 값은 다음과 같이 사용하는 것이 좋다.\n1L \u0026lt;\u0026lt; ((sizeof(long) * 8) - 1);  쉬프트(shift) 연산에서 \u0026lsquo;L\u0026rsquo;을 붙여주지 않으면 기본 int(32비트) 형으로 인식하여 원하는 결과를 얻을 수 없음에 주의해야 한다.\n타입 정의\n가능한 표준 C 라이브러리에 정의된 이식성있는 형을 사용하는 경우가 좋다.\n ptrdiff_t : 두 포인터의 차이를 저장할 수 있는 부호있는 정수형이다. size_t : 부호없는 정수형으로 sizeof 연산자의 결과 뿐 아니라 많은 표준 C 라이브러리가 크기를 표현하는데 사용한다. int32_t, uint32_t, \u0026hellip; : 정확한 크기의 정수형을 정의하는데 사용한다. intptr_t, uintptr_t : 정수형으로 변환해도 위험하지 않은 포인터를 담기위한 정수형이다.  포맷팅하기\n32비트 시스템에서 printf() 함수의 \u0026ldquo;%d\u0026quot;는 int / long 형 모두 적절하게 동작하지만, 64비트 시스템에서 long을 인수로 넘기면 하위 32비트만 출력된다. 따라서 long 형을 출력할 경우 정확하게 \u0026ldquo;%ld\u0026rdquo; 라고 적어주는 것이 좋다. 비슷하게 포인터를 출력하기 위해 많이 사용하는 \u0026ldquo;%x\u0026rdquo; 대신 \u0026ldquo;%p\u0026rdquo; 를 사용하면 더 정확한 포인터 값을 출력할 수 있다.\n","date":1147046400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1147046400,"objectID":"b7185f5dad34e2581aea32e985427e2b","permalink":"https://lethean.github.io/2006/05/08/porting-linux-applications-to-64-bit-systems/","publishdate":"2006-05-08T00:00:00Z","relpermalink":"/2006/05/08/porting-linux-applications-to-64-bit-systems/","section":"post","summary":"Porting Linux applications to 64-bit systems 를 보면 64비트 환경에서 기존 리눅스 어플리케이션을 동작시키기 위해 C/C++ 프로그래머가 알아야 할 내용을 정리해주고 있다. 다음은 그 중에서 일부분을 정","tags":["Linux"],"title":"Porting Linux applications to 64-bit systems","type":"post"},{"authors":null,"categories":null,"content":" 프로젝트 관리 10분 가이드 라는 책을 읽고 느낀 점은 대학교때 소프트웨어 공학 개론 수업 내용과 거의 흡사하다는 점 뿐일까. 책에서 말하는 내용 중 몇 가지만 정리해 둔다.\n 프로젝트 계획의 기본은 정확한 목표, 데드라인, 자원 산출이다. 정확한 목표를 설정한다. 세부적인 결과물과 성과를 정의한다. 가능한 자세한 작업 명세 구조를 추출한다. 하지만, 너무 자세하면 안되고, 담당자에게 어느 정도 위임이 가능하면서 관리자가 반드시 확인해야 하는 수준의 작업으로 분류한다. 프로젝트 중간 중간 이정표(milestone)를 두고, 각 단계별 산출 결과물을 명확하게 명시한다. (코드, 문서, 장비 구성 등) 계획 수립 단계에 팀원을 참여시킨다. 프로젝트 스케쥴은 여러가지 변수에 의해 수시로 변동된다. 관리자는 이러한 변화를 항상 감지하고, 대처하고 계획을 수정한다. 프로젝트 회의록 / 일지를 작성하여 유지한다. GANTT 챠트에서는 작업의 계획된 시작/끝 정보와 실제로 실행된 시작/끝 정보가 함께 유지되어야 한다. PERT/CPM 챠트를 이용하여 중대경로(critical path)를 추출하면, 예외처리나 우선순위 변경 작업이 용이해진다.  ","date":1144713600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1144713600,"objectID":"60e370f5cf9a24b7b326306b3f08d20b","permalink":"https://lethean.github.io/2006/04/11/10-minute-guide-to-project-management/","publishdate":"2006-04-11T00:00:00Z","relpermalink":"/2006/04/11/10-minute-guide-to-project-management/","section":"post","summary":"프로젝트 관리 10분 가이드 라는 책을 읽고 느낀 점은 대학교때 소프트웨어 공학 개론 수업 내용과 거의 흡사하다는 점 뿐일까. 책에서 말하는 내용 중 몇 가지만 정리해 둔다","tags":["Agile"],"title":"10 Minute Guide to Project Management","type":"post"},{"authors":null,"categories":null,"content":"\u0026lsquo;Malloc 연구 : 과도한 마이너 폴트 사례 ( A Study in Malloc: A Case of Excessive Minor Faults \u0026lsquo;라는 논문은 개발자가 흔히 부딪힐 수 있는 문제에 대하여 원인 추적 및 해결 과정을 흥미롭게 보여준다. 더불어 리눅스에서 GNU libc의 메모리 관리자를 튜닝하는 방법을 이용해 코드 재작성 없이 어플리케이션 성능을 향상시키는 방법에 대해 논하고 있다.\n컴팩(Compaq)의 CXML이라는 확장 수학 라이브러리를 이용해 어플리케이션을 개발하는 사용자로부터 다음과 같은 문의가 들어왔다. 똑같은 코드와 똑같은 사양의 하드웨어를 기반으로 할때 기존 유닉스(Tru64 UNIX) 환경보다 리눅스(Linux/Alpha)에서 어플리케이션 실행 시간이 너무 많이 차이가 난다는 것이다.\n이 글의 저자는 여러가지 도구를 이용하여 원인이 리눅스 커널의 메모리 관리와 연관이 있다는 것을 밝혀낸다. 그리고, 더 나아가 커널의 메모리 관리가 아닌 GNU libc의 malloc()/free() 구현이 기존 유닉스나 FreeBSD 등과도 다르다는 점을 밝혀낸다.\n일반적으로 brk() 시스템콜을 이용해 힙(heap) 영역을 확장하는 다른 유닉스 시스템과 달리 리눅스가 사용하는 glibc는 일정 크기 이상의 메모리 영역은 mmap()을 이용해 할당한다. 이렇게 할당한 메모리는 사용자가 해제했을때 바로 시스템으로 돌아가고, 전체적으로 시스템은 효율적으로 메모리를 사용할 수 있다는 장점이 있지만, mmap() 시스템콜 자체가 커널 영역 페이지 폴트 메카니즘을 사용하기 때문에 이 부분에서 많은 성능 저하가 발생하게 된다.\n이 논문의 제목인 마이너 폴트(minor faults)란, 아예 할당할 메모리가 없어 스왑(swap)이 필요한 경우가 아닌(major faults), COW(copy-on-write) 기법이나 일반적인 디바이스 메모리 맵핑 등과 같이 물리적인 메모리를 가상 메모리에 맵핑할때 발생하는 페이지 폴트를 의미한다.\n저자는 매우 자세하고 친절하게 몇가지 증상에서 원인을 찾아가는 과정을 설명하고 있다. 여기서 든 예제의 경우 128K 이상의 메모리를 할당하고 해제하는 과정을 반복할 경우 발생하는 이러한 마이너폴트를 줄이기 위해 결론적으로 다음과 같은 방법을 제시하고 있다.\n첫번째 방법은 소스 코드를 수정해 mmap()을 쓰지 않도록 GNU libc의 메모리 관리자에게 알려주는 것이다.\nmallopt (M_MMAP_MAX, 0); mallopt (M_TRIM_THRESHOLD, -1);  두번째 방법은 어플리케이션을 실행하기 전에 환경변수에 이 값을 설정하는 방법이다.\nexport MALLOC_MMAP_MAX_=0 export MALLOC_TRIM_THRESHOLD_=-1  더 자세한 내용은 mallopt() 함수를 참고하면 된다.\n그런데, 요즘 커널과 요즘 glibc에도 그대로 적용이 가능한지는 확인해봐야 할 것 같다.\n","date":1142553600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1142553600,"objectID":"eb3e9ca570c1a40e07187c4d0f153c93","permalink":"https://lethean.github.io/2006/03/17/glibc-memory-allocation-tune/","publishdate":"2006-03-17T00:00:00Z","relpermalink":"/2006/03/17/glibc-memory-allocation-tune/","section":"post","summary":"\u0026lsquo;Malloc 연구 : 과도한 마이너 폴트 사례 ( A Study in Malloc: A Case of Excessive Minor Faults \u0026lsquo;라는 논문은 개발자가 흔히 부딪힐 수 있는 문제에 대하여 원인 추적 및 해결 과정을 흥미롭게 보","tags":["glibc","Linux"],"title":"glibc 메모리 할당 방식 튜닝","type":"post"},{"authors":null,"categories":null,"content":"gcc와 glibc로 어플리케이션 최적화하기 ( Optimizing Applications with gcc \u0026amp; glibc )\nglibc 개발자인 Ulrich Drepper 가 1999년에 작성한 40페이지 분량의 글이다. 대략 관심있는 내용을 정리해본다.\n사용 안되는 코드 컴파일시 제거  다음 코드는 주어진 타입에 따라 다른 작업을 하는데, int형과 long int형이 같은 플랫폼일 경우 좋지 않은 성능을 보인다.\nlong intadd (long int a, void *ptr, int type) { if (type == 0) return a + *(int *)ptr; else return a + *(long int *)ptr; }  위 코드는 다음과 같이 최적화할 수 있다. 이는 컴파일러가 알아서 최적화해준다.\nlong intadd (long int a, void *ptr, int type) { if (sizeof(int) == sizeof(long int) || type == 0) return a + *(int *)ptr; else return a + *(long int *)ptr; }  다음과 같은 방법을 이용하면 전처리기(preprocessor)가 알아서 최적화해준다.\nlong intadd (long int a, void *ptr, int type) { #if LONG_MAX != INT_MAX if (type == 0) return a + *(int *)ptr; else #endif return a + *(long int *)ptr; }  컴파일러 내부 함수(intrinsics) 이용하기 gcc 2.96 이후부터 많은 __builtin_* 함수가 존재한다. 이 함수들은 컴파일시에 컴파일러가 판단하여 인수가 상수이거나 정해진 크기 등일 경우 최적화된 코드를 생성해 준다. 이 함수들은 매크로인 경우도 있고 컴파일시 정적으로 링크되는 라이브러리일 수도 있다. 어떤 함수들은 컴파일러 내부 함수를 이용해 최적화되어 있다. 따라서 가능한 이러한 함수들은 별도 랩핑을 두지 않고 헤더파일을 포함하여 그대로 사용하면 더 좋은 성능의 코드를 얻을 수 있다. 내부 함수를 이용하는 함수 중에 대표적인 것들은 다음과 같은 것들이 있다.\nalloca() memcpy(), memcmp(), memset() strcmp(), strcpy(), strlen()  더 많은 함수는 원문을 참고하면 된다.\nstrcpy()와 memcpy() 문자열의 크기를 이미 알고 있다면 str*() 류의 함수보다 mem*() 류의 함수를 이용하는 것이 좋다. 우선 매 바이트마다 문자열 끝 코드인 0x00을 검사하는 코드가 없어 빠르고, 무엇보다도 memcpy()는 플랫폼 기본 단위(예를 들어 32비트 플랫폼에서는 4바이트) 연산을 하기 때문에, 항상 바이트 단위로 작업하는 strcpy() 또는 strncpy()보다 빠를 수 밖에 없다.\nstrcat(), strncat() 절대로 strcat(), strncat() 함수는 사용하지 말아야 한다. 문자열을 합치는데 이 함수를 이용하는 것은 성능에 치명적이다. 내부적으로 strlen()을 호출하는 것 뿐 아니라 문자열을 처리하기 위한 여러 조건을 검사하기 때문에 매우 느리다. 이보다는 직접 strlen()으로 문자열 길이를 구한 뒤 memcpy()를 이용해 해당 위치에 복사하거나 필요한 작업을 하는 것이 더 현명한 방법이다.\n다음은 이에 대한 샘플 코드이다.\n{ char *buf = ...; size_t bufmax = ...; /* Add 's' to the string in buffer 'buf'. */ if (strlen(buf) + strlen(s) + 1 \u0026gt; bufmax) buf = (char *)realloc(buf, (bufmax *= 2)); strcat(buf, s); }  프로그래머 관점에서 이 코드는 괜찮아 보이지만, 성능은 최악이다. 다음과 같이 고치면 더 좋은 성능을 낼 수 있다.\n{ char *buf = ...; size_t bufmax = ...; size_t slen, buflen; /* Add 's' to the string in buffer 'buf'. */ slen = strlen(s) + 1; buflen = strlen(buf); if (buflen + slen \u0026gt; bufmax) buf = (char *)realloc(buf, (bufmax *= 2)); memcpy(buf + buflen, s, slen); }  메모리 할당 최적화 malloc()과 calloc()의 차이점을 모르는 프로그래머는 없겠지만, 그래서 calloc()보다 직접 malloc() 호출 이후 memset() 등을 이용해 0으로 초기화하는 방법을 많이 이용하기도 한다. 하지만 calloc()은 커널 페이지에서 이미 0으로 초기화되어 있는 영역이 있을 경우 불필요한 초기화 과정을 건너뛰기 때문에 더 좋은 성능을 낼 수 있다.\nalloca() 함수를 모르는 사람도 많은데, 이 함수는 지정한 크기의 영역을 현재 스택 영역에 할당한다. 메모리 관리자를 거치지 않고 단순히 스택 포인터 레지스터 조작만으로 할당 작업이 이루어지기 때문에 매우 성능이 좋을 뿐 아니라, 따로 해제하지 않아도 함수가 끝나는 시점에서 자동으로 해제된다. 따라서 함수 내부에서 임시로 할당하여 사용하는 많은 구현에서 malloc() 보다 alloca() 를 사용한 코드의 성능은 매우 향상된다. glibc에서 확장으로 제공하는 strdupa(), strndupa() 등의 API는 모두 이 방법을 이용한 최적화된 성능을 보장한다.\n그외\u0026hellip;\n기타 이 글에서는 gprof, sprof 등을 이용한 코드 프로파일링 방법과 GCC 컴파일러 확장을 이용한 다양한 최적화 방법을 제시하고 있다. 더불어 저자는 같은 내용에 조금 더 내용이 보강된 Application Optimization on Linux 글에서 프로필과 관련된 더 자세한 정보를 제공하고 있다.\n이 글에서도 언급한 내용이지만, 많은 프로그래머는 자신이 작성한 프로그램이 정말 잘 쓰여지고 성능이 좋다고 생각하지만, 불행하게도 아닌 경우가 대부분이다. 최적화된 프로그램을 작성하는 것은 항상 진행중인 배우는 과정(learning process)이다. 항상 새로운 테크닉을 배우고, 자신의 코드를 검토하고, 상호작용하는 라이브러리와 프로세서에 대해 생각해야 한다.\n","date":1142208000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1142208000,"objectID":"5a14a57c751697a4ba454344ebf1c4b3","permalink":"https://lethean.github.io/2006/03/13/optimizing-applications-with-gcc-and-glibc/","publishdate":"2006-03-13T00:00:00Z","relpermalink":"/2006/03/13/optimizing-applications-with-gcc-and-glibc/","section":"post","summary":"gcc와 glibc로 어플리케이션 최적화하기 ( Optimizing Applications with gcc \u0026amp; glibc ) glibc 개발자인 Ulrich Drepper 가 1999년에 작성한 40페이지 분량의 글이다. 대략 관심있는 내용을 정리해","tags":["GCC","glibc"],"title":"GCC와 GLIBC로 최적화하기","type":"post"},{"authors":null,"categories":null,"content":"우분투 리눅스는 항상 최신 아키텍쳐를 반영하기 때문에 기존 API나 아키텍쳐를 기반으로 동작하는 써드파티 어플리케이션이 동작 안하는 경우가 가끔 있는데, VMWare도 그 중 하나인 것 같다.\n언젠가부터 USB 장치를 VMWare 윈도우즈에서 인식을 못한다고 생각했는데, 오늘 검색해 보니 VMWare가 근거로 하는 /proc/bus/usb 디렉토리 내용이 없어서였다. 다음 줄을 /etc/fstab 파일에 추가해 주고 재부팅하거나, mount -a 명령으로 마운트해준 다음 VMWare를 재시작하면 정상적으로 USB 장치를 인식하게 된다.\nnone /proc/bus/usb usbfs defaults 0 0  ","date":1142035200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1142035200,"objectID":"b2d49c403b2c0892fe71f159c3825ad2","permalink":"https://lethean.github.io/2006/03/11/vmware-usb-in-ubuntu/","publishdate":"2006-03-11T00:00:00Z","relpermalink":"/2006/03/11/vmware-usb-in-ubuntu/","section":"post","summary":"우분투 리눅스는 항상 최신 아키텍쳐를 반영하기 때문에 기존 API나 아키텍쳐를 기반으로 동작하는 써드파티 어플리케이션이 동작 안하는 경우가 가끔 있는데, VMW","tags":["Ubuntu","VMware"],"title":"VMWare USB in Ubuntu","type":"post"},{"authors":null,"categories":null,"content":"Ubuntu 리눅스에서 VMware를 돌리고, 그 안에서 JTAG 케이블을 이용해 부트로더를 올리는 작업을 하기 위해서는 무엇보다 VMware가 /dev/parport0 를 찾을 수 있도록 해주어야 한다. 매번 반복되면서 기록을 남기지 않아 오늘도 다시 고생\u0026hellip; 여기에 그 방법을 남겨 놓는다.\n먼저 ppdev 커널 모듈을 올린다.\nmodprobe ppdev  아예 /etc/modules 에 등록시켜 두는 것이 좋다. 일반 계정으로 접근이 가능하도록 /etc/group 에서 lp 부분을 다음과 같이 수정한다. (여기 lethean이 일반 계정이다)\nlp❌7:cupsys,lethean  이게 전부다.\n","date":1141084800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1141084800,"objectID":"6750d4e9c1207c22756f691553a73e79","permalink":"https://lethean.github.io/2006/02/28/vmware-devparport0-in-ubuntu/","publishdate":"2006-02-28T00:00:00Z","relpermalink":"/2006/02/28/vmware-devparport0-in-ubuntu/","section":"post","summary":"Ubuntu 리눅스에서 VMware를 돌리고, 그 안에서 JTAG 케이블을 이용해 부트로더를 올리는 작업을 하기 위해서는 무엇보다 VMware가 /dev/parport0 를 찾을 수 있도록 해주어야 한","tags":["Ubuntu","VMware"],"title":"VMware /dev/parport0 in Ubuntu","type":"post"},{"authors":null,"categories":null,"content":" glibc(GNU libc) 관리자이며 개발자인 Ulrich Drepper 의 글 중에 \u0026lsquo; Good Practices in Library Design, Implementation, and Maintenance\u0026rsquo; 는 비단 라이브러리 개발 뿐 아니라 일반 프로젝트를 진행할때도 유용한 여러 가이드라인을 제시한다. 간략하게 정리해보면 다음과 같다.\n인터페이스 설계하기\n 가능한 API에 변수를 포함하지 말라. 대신 내부 변수를 처리하는 get-/set-함수를 구현하라. 라이브러리가 제공하는 모든 인터페이스, 변수, 함수, 자료구조에 접두사(prefix)를 붙여라. 모든 객체에 반드시 같은 접두사를 사용할 필요는 없으며, 한 라이브러리가 여러 접두사를 사용해도 된다. C/C++ 라이브러리 설치시 함께 제공하는 헤더파일은 인터페이스를 정의하는데 필요한 정의(definition)와 선언(declaration)만 포함해야 한다. 사용자가 직접 객체를 할당하지 않는 불완전한 형식(incomplete type)을 사용한다면 선정의(forward declaration)를 이용하는 것이 맞다. 컴파일 설정(configuration)이 변경되더라도 라이브러리 헤더 파일은 변하면 안된다. 어쩔 수 없이 불완전하게 정의한 데이터 타입을 제공해야 한다면, 나중에 커질 부분을 고려하여 최소한의 패딩을 만들어야 한다.  라이브러리 구현하기\n 가능한 많은 함수와 변수를 \u0026lsquo;static\u0026rsquo;을 이용하여 오브젝트 파일에 지역적으로(local) 정의하라. 외부로 보여지는(export) 심볼은 최대한 줄여라. 가장 좋은 경우는 문서화된 인터페이스만 보여지는 것이다.  라이브러리 유지하기\n 이전 버전에 없었던 새로운 인터페이스는 따로 표시해야 새로운 인터페이스를 사용하는 어플리케이션이 아예 동작하지 못하도록 할 수 있다. 오류를 수정하는게 아닌 다른 이유로 인터페이스가 변경되더라도 이전 인터페이스는 그대로 존재해야 한다. 문서화된 라이브러리 인터페이스의 모든 면은 문서화해야 한다. 인터페이스가 변경되어야 한다면, 이전 동작이 그대로 유지된다는 것을 보장하기 위해 최소한 새 테스트가 추가되어야 한다.  키워드만 정리한 것이지만, 10쪽 분량밖에 안되는 글이므로 가능한 원본을 읽어보는 것이 좋을 것이다.\n","date":1140739200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1140739200,"objectID":"73ffcb4793106c519e8a9ec2c5bbe840","permalink":"https://lethean.github.io/2006/02/24/good-practices-in-library-design-implementation-and-maintenance/","publishdate":"2006-02-24T00:00:00Z","relpermalink":"/2006/02/24/good-practices-in-library-design-implementation-and-maintenance/","section":"post","summary":"glibc(GNU libc) 관리자이며 개발자인 Ulrich Drepper 의 글 중에 \u0026lsquo; Good Practices in Library Design, Implementation, and Maintenance\u0026rsquo; 는 비단 라이브러리 개발 뿐 아니라 일반 프로젝트를 진행할때도 유용한 여러 가이드라인을 제시한다. 간략","tags":["Coding","glibc"],"title":"라이브러리 설계, 구현, 유지에 좋은 습관","type":"post"},{"authors":null,"categories":null,"content":" YouTube - Crazy Multi-Input Touch Screen 마이너리티 리포트와 같은 인터페이스를 가능케 하는 멀티 입력 터치 스크린 데모 비디오 영상이다. 사실 이 동영상에서 더 궁금한 점은 장치가 아니라 동작하는 소프트웨어 운영체제와 프로그램이 아닐까\u0026hellip;\n","date":1140220800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1140220800,"objectID":"0c3833f5cacf7cd916d960e0d18b94ff","permalink":"https://lethean.github.io/2006/02/18/crazy-multi-input-touch-screen/","publishdate":"2006-02-18T00:00:00Z","relpermalink":"/2006/02/18/crazy-multi-input-touch-screen/","section":"post","summary":"YouTube - Crazy Multi-Input Touch Screen 마이너리티 리포트와 같은 인터페이스를 가능케 하는 멀티 입력 터치 스크린 데모 비디오 영상이다. 사실 이 동영상에서 더 궁금한 점은 장치가 아니라 동작하","tags":["GUI"],"title":"Crazy Multi-Input Touch Screen","type":"post"},{"authors":null,"categories":null,"content":"GCC 4.0부터 포함되어 있는 GCC Symbol Visibility Patch 는 GCC 컴파일러를 조금 더 유용하게 만들어 준다. 홈페이지에서 언급한 이 기능의 장점은 다음과 같다.\n 공유 라이브러리와 같은 DSO(Dynamic Shared Object, 동적 공유 객체)를 로드하는데 걸리는 시간을 획기적으로 향상시켜준다. 컴파일러 최적화기(optimiser)가 더 좋은 코드를 만들수 있다. DSO 크기를 5~20% 정도 줄여준다. 심볼(symbol)이 충돌할 기회를 낮춰준다.  사용법은 다음과 같다. 물론 GCC 4.x 버전이 필요하다.\n모듈에서 제공하는 인터페이스나 API를 정의하는 헤더파일에서 외부로 공개되는 모든 구조체, 클래스, 함수 선언 앞에 __attribute__ ((visibility(\u0026quot;default\u0026quot;))) 키워드를 붙여준다. (매크로를 사용하면 편리하다) 이렇게 한다음 Makefile과 같은 빌드 환경에서 컴파일 옵션에 -fvisibility=hidden 인수를 추가하면 된다. 이렇게 생성된 DSO 파일과 원래 방식으로 생성한 파일을 nm -C -D 명령으로 확인해 보면 차이를 금방 알 수 있다. 다음은 윈도우즈 환경과 호환되는 예제 매크로 파일이다.\n#ifdef _MSC_VER #ifdef BUILDING_DLL #define DLLEXPORT __declspec(dllexport) #else #define DLLEXPORT __declspec(dllimport) #endif #define DLLLOCAL #else #ifdef HAVE_GCCVISIBILITYPATCH #define DLLEXPORT __attribute__ ((visibility(\u0026quot;default\u0026quot;))) #define DLLLOCAL __attribute__ ((visibility(\u0026quot;hidden\u0026quot;))) #else #define DLLEXPORT #define DLLLOCAL #endif #endif extern \u0026quot;C\u0026quot; DLLEXPORT void function(int a); class DLLEXPORT SomeClass{ int c; DLLLOCAL void privateMethod(); // Only for use within this DSOpublic:Person(int _c) : c(_c) { } static void foo(int a); };  실제로 TnFOX 프로젝트에서 사용하는 헤더파일을 참고해도 도움이 될 것이다.\n// Shared library support #ifdef WIN32 #define FXIMPORT __declspec(dllimport) #define FXEXPORT __declspec(dllexport) #define FXDLLLOCAL #define FXDLLPUBLIC #else #define FXIMPORT #ifdef GCC_HASCLASSVISIBILITY #define FXEXPORT __attribute__ ((visibility(\u0026quot;default\u0026quot;))) #define FXDLLLOCAL __attribute__ ((visibility(\u0026quot;hidden\u0026quot;))) #define FXDLLPUBLIC __attribute__ ((visibility(\u0026quot;default\u0026quot;))) #else #define FXEXPORT #define FXDLLLOCAL #define FXDLLPUBLIC #endif #endif // Define FXAPI for DLL builds #ifdef FOXDLL #ifdef FOXDLL_EXPORTS #define FXAPI FXEXPORT #else #define FXAPI FXIMPORT #endif // FOXDLL_EXPORTS #else #define FXAPI #endif // FOXDLL // Throwable classes must always be visible on GCC in all binaries #ifdef WIN32 #define FXEXCEPTIONAPI(api) api #elif defined(GCC_HASCLASSVISIBILITY) #define FXEXCEPTIONAPI(api) FXEXPORT #else #define FXEXCEPTIONAPI(api) #endif  ","date":1138665600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1138665600,"objectID":"bc2f4ee7b51060d99e98b0cf06424e53","permalink":"https://lethean.github.io/2006/01/31/gcc-symbol-visibility-patch/","publishdate":"2006-01-31T00:00:00Z","relpermalink":"/2006/01/31/gcc-symbol-visibility-patch/","section":"post","summary":"GCC 4.0부터 포함되어 있는 GCC Symbol Visibility Patch 는 GCC 컴파일러를 조금 더 유용하게 만들어 준다. 홈페이지에서 언급한 이 기능의 장점은 다음과 같다. 공유 라이브러리와 같은 DSO(Dynamic Shared","tags":["GCC"],"title":"GCC Symbol Visibility Patch","type":"post"},{"authors":null,"categories":null,"content":"크로스 플랫폼 어플리케이션 개발을 위해 지금까지 많은 라이브러리를 검토했지만 대부분 아쉬운 점이 많았다. 덩치가 너무 크거나, 의존하는 라이브러리가 너무 많거나, 반대로 너무 기능이 제한적이고 부족하거나 하는 이유로 진행하는 프로젝트에서는 직접 만들어 사용하고 있는 실정이다.\n오늘 문득 Apache2 웹서버와 Subversion 버전 관리 소프트웨어가 사용하는 APR (Apache Portable Runtime) 라이브러리를 살펴보게 되었다. 그 존재는 Subversion을 사용하기 시작하면서부터 알고 있었으나 사이트를 들어가서 검토까지 해본 건 이번이 처음이다. 튼튼한 네트워크 서버를 만들면서 구축한 라이브러리의 특성을 한눈에 확인할 수 있다. 프로세스, 쓰레드, 시그널, MMAP, 메모리 관리, 공유 메모리 등과 같은 부분의 API가 정교하게 다듬어져 있다.\n하지만 아직까지는 GLib 에게 더 높은 점수를 주고 싶다. GObject까지는 필요 없더라도 GLib 자체는 충분히 안정화되어 가고 있다. 초기 버전에 비해 Win32 지원이 날이 갈수록 좋아지는 걸 확인하고 있다. GLib에서 가장 좋아하는 부분은 메인 이벤트 루프를 지원한다는 점이다.(물론 가장 까다로운 부분이라 고생하는 부분이기도 하다)\nGLib과 APR을 대충 비교하면, GLib과 겹치는 부분도 있지만 없는 부분도 많다. 물론 GLib에만 있는 부분이 더 많다. 그리고 APR은 아직도 너무 치열하게 개발중이다. 즉, GLib은 이미 API가 안정화 단계에 있는데 APR은 아직도 활발하게 API가 변경되고 있다.\n지금 당장 프로젝트에 도입할 수는 없지만, 몇 개월 뒤에는 또 어떻게 발전해 있을까 궁금해진다.\n","date":1137715200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1137715200,"objectID":"06ecbaf267274936c7eec20afd9caf45","permalink":"https://lethean.github.io/2006/01/20/aprapache-portable-runtime/","publishdate":"2006-01-20T00:00:00Z","relpermalink":"/2006/01/20/aprapache-portable-runtime/","section":"post","summary":"크로스 플랫폼 어플리케이션 개발을 위해 지금까지 많은 라이브러리를 검토했지만 대부분 아쉬운 점이 많았다. 덩치가 너무 크거나, 의존하는 라이브러리가 너무 많거나","tags":["Apache","GLib"],"title":"APR(Apache Portable Runtime)","type":"post"},{"authors":null,"categories":null,"content":"Robert Love의 블로그에 올라온 \u0026lsquo; With a little help from your compiler \u0026rsquo; 라는 글을 보면 GCC 3 이후에 추가된 여러가지 확장 기능에 대해 설명하고 있다. 이 기능들을 이용하면 GCC 컴파일러가 코드를 최적화하는데 더 많은 정보를 줄 수 있고, 프로그래머의 작은 실수를 컴파일 과정에서 미리 잡아낼 수도 있다. 이 중에서 관심이 가는 몇가지만 간추려보자.\n우선 GCC가 아닌 컴파일러와의 호환을 위해 다음과 같은 헤더 파일을 하나 만들어 사용한다.\n#if __GNUC__ \u0026gt;= 3 # define inline inline __attribute__ ((always_inline)) # define __pure __attribute__ ((pure)) # define __const __attribute__ ((const)) # define __noreturn __attribute__ ((noreturn)) # define __malloc __attribute__ ((malloc)) # define __must_check __attribute__ ((warn_unused_result)) # define __deprecated __attribute__ ((deprecated)) # define __used __attribute__ ((used)) # define __unused __attribute__ ((unused)) # define __packed __attribute__ ((packed)) # define likely(x) __builtin_expect (!!(x), 1) # define unlikely(x) __builtin_expect (!!(x), 0) #else # define inline /* no inline */ # define __pure /* no pure */ # define __const /* no const */ # define __noreturn /* no noreturn */ # define __malloc /* no malloc */ # define __must_check /* no warn_unused_result */ # define __deprecated /* no deprecated */ # define __used /* no used */ # define __unused /* no unused */ # define __packed /* no packed */ # define likely(x) (x) # define unlikely(x) (x) #endif  참고로 VisualC++은 inline 키워드를 C++ 컴파일러는 정상적으로 인식하나 C 컴파일러는 인식하지 못한다. 따라서 __inline 로 해주면 문제없이 컴파일할 수 있다.\n__const int f (int x) { ... }  __const 같은 경우 함수 내부에서 절대로 전역 변수에 접근할 수 없고, 포인터 인수를 받을 수도 없도록 한다. abs() 같은 수학 함수에 적합하다.\n__must_check int f (void) { ... }  리눅스 커널 API 중에서 copy_{tofrom}_user() 에서 사용되어 친숙한 기능으로, 호출하는 코드에서 이 함수의 리턴값을 반드시 검사하도록 컴파일 과정에서 알려준다.\n__deprecated void f (void) { ... }  함수를 호출하게 되면 컴파일 과정에서 경고를 준다. 새로운 API로 대체되었거나, 앞으로 없어질 API를 명시하는데 유용하다.\nstatic __used void f (void) { ... }  어셈블리 코드에서만 호출하거나 다른 이유로 최적화 과정에서 없어지면 안되는 경우를 명시한다. 사용하지 않은 변수나 함수라는 컴파일러 경고도 없애준다.\nvoid f (int x __unused) { ... }  지정한 인수를 사용하지 않는 경우를 이미 프로그래머가 알고 있음을 컴파일러에게 알려주어 경고 메시지를 뿌리지 말도록 한다. 권하는 경우는 아니지만, 이벤트 방식 GUI 프로그래밍에서 많이 발견할 수 있는 패턴이다.\nstruct __packed s { ... }  구조체 필드를 정렬(align)에 상관없이 압축한다. 구조체 크기는 줄어들 수 있지만, 지금까지 경험으로 볼때 별로 권장하고 싶지 않은 기능이다. ARM과 같은 아키텍쳐에서는 정렬되어 있지 않을 경우 바로 오동작을 일으킨다. 가장 좋은 방법은 구조체의 필드 순서 및 크기를 프로그래머가 정확하게 배치하는 것이다.\nif (unlikely (foo) \u0026amp;\u0026amp; likely (bar)) { ... }  리눅스 커널 소스에서 많이 볼 수 있는 문법이다. 특정 조건이 일어날 확률이 훨씬 많을 경우 GCC에게 이를 알려주어 블럭 재배치 최적화에 이용하도록 할 수 있다.\n","date":1137715200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1137715200,"objectID":"5601dcb90bd851d438d574fb71adb956","permalink":"https://lethean.github.io/2006/01/20/using-gcc-extensions/","publishdate":"2006-01-20T00:00:00Z","relpermalink":"/2006/01/20/using-gcc-extensions/","section":"post","summary":"Robert Love의 블로그에 올라온 \u0026lsquo; With a little help from your compiler \u0026rsquo; 라는 글을 보면 GCC 3 이후에 추가된 여러가지 확장 기능에 대해 설명하고 있다. 이 기능들을 이용하면 GCC 컴파일러가 코","tags":["GCC"],"title":"GCC 확장 기능 이용하기","type":"post"},{"authors":null,"categories":null,"content":"C/C++ 프로그래밍을 10년 넘게 해오면서 아마도 언젠가는 이런 문제를 부딪힌 적이 있었을 지도 모른다. 다만 잊어버리고, 다음에 또 반복하고\u0026hellip;\n몇 주에 걸쳐 원인을 알 수 없는 세그멘테이션 폴트를 발생하는 문제를 디버깅했다. 프로그램은 e2fsck 명령 실행 결과를 popen()을 이용하여 얻어온뒤 syslog()를 통해 출력한다. gdb 백트레이스는 syslog() 함수 내부에서 호출하는 printf() 종류의 함수에서 멈추고 있었다. 지금까지 그랬던 것처럼 그 시점 이전 어디선가 메모리 침범이 발생한 것이라 판단하고 모든 관련 코드를 재검토하고 의심이 가는 부분을 재작성하기를 반복했으나 해결할 수 없었다. 그러다가 항상 같은 문자열에서 오류를 낸다는 패턴을 다시 검토하게 되었는데, 문제의 문자열은 \u0026lsquo;%\u0026rsquo; 기호를 포함하고 있었다. 순간 머리를 스치는 생각\u0026hellip; 역시 syslog()의 매뉴얼 페이지를 확인해 보니 syslog()는 printf() 스타일의 가변 인수를 지원하는 함수였던 것이다. 즉, 문자열의 \u0026lsquo;%\u0026rsquo; 기호를 보고 뒤에 오는 \u0026rsquo;s', \u0026rsquo;d' 등의 문자와 연동하여 있지도 않은 인수를 접근하면서 발생하는 문제였다. 즉, 다음 코드는\nsyslog(LOG_INFO, msg);  다음과 같이 작성해야 하는 것이다.\nsyslog(LOG_INFO, \u0026quot;%s\u0026quot;, msg);  printf() 방식의 함수는 의외로 많다. sprintf(), scanf(), syslog(), 심지어 자체적으로 만들어 사용하는 디버그 매크로까지\u0026hellip; 하지만, 위와 같이 첫번째 인수인 포맷을 지정하고 않고 출력할 문자열을 그대로 전달하면 일단 컴파일과 실행에는 문제가 없지만, \u0026lsquo;%\u0026rsquo;, '' 등의 기호가 포함되어 있다면 개발자의 삶은 고달퍼지기 시작하는 것이다.\n","date":1137715200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1137715200,"objectID":"9757d356692cccd3a97957b374f02e49","permalink":"https://lethean.github.io/2006/01/20/printf-pitfall/","publishdate":"2006-01-20T00:00:00Z","relpermalink":"/2006/01/20/printf-pitfall/","section":"post","summary":"C/C++ 프로그래밍을 10년 넘게 해오면서 아마도 언젠가는 이런 문제를 부딪힌 적이 있었을 지도 모른다. 다만 잊어버리고, 다음에 또 반복하고\u0026hellip; 몇 주에 걸","tags":["Coding"],"title":"printf() 함정에 빠지다","type":"post"},{"authors":null,"categories":null,"content":"대부분의 프로젝트를 GTK+를 이용하지만, 잊어버릴만 하면 부딪히는 문제 중 하나가 바로 멀티쓰레드 프로그램에서 GTK+ 위젯을 다룰때 발생하는 여러가지 현상들이다.\n우선 가장 쉽게 만나는 패턴은 XLib에서 Sync 에러를 내면서 프로그램 종료, 아니면 반대로 GUI가 블럭킹되어 아무 것도 동작안하는 현상이다. 그 다음으로는 해제된 위젯에 접근하거나, 아직 초기화가 덜된 위젯에 접근할 경우 발생하는 무수한 오동작 현상이 있지만, 이는 어플리케이션 설계의 문제이기도 하다.\n첫번째 패턴은 GTK+를 멀티쓰레드에서 이용할 경우 처음 사용하는 사람은 누구나 만나게 된다. X 윈도우는 프로세스별로 접근은 제어해주지만, 쓰레드별 접근은 제어를 해주지 않기 때문에 이는 상위 라이브러리나 프로그래머가 처리해야 한다는 점을 모를 경우 말이다.\n물론 GTK+ 매뉴얼에는 친절하게 설명 이 되어 있다. 시그널 핸들러를 통해 호출되는 콜백 함수는 항상 GDK 쓰레드가 잠겨서 호출되지만, g_idle_add(), g_timeout_add() 등을 통해 호출되는 콜백 함수는 프로그래머가 해주어야 한다. 또한 메인 GTK+ 쓰레드가 아닌 쓰레드에서 GTK+ 위젯을 접근하려면 g_idle_add() 또는 다른 메시징 방식을 이용해 메인 쓰레드에서 처리하도록 하거나, 매번 GDK 쓰레드 잠금/해제를 프로그래머가 해주어야 한다. gtk_main_iteration() 등의 도움을 받기도 한다.\n하지만, 내가 말하고 싶은 건, 그럼에도 불구하고 너무 복잡하다. GTK+의 많은 부분을 좋아하지만 이 부분만큼은 정말 GTK+가 알아서 해주면 얼마나 좋을까라는 생각을 몇 년째 하고 있다. 수십 개의 쓰레드가 존재하고, 외부 명령을 호출하여 그 결과를 GUI에 반영하면서 다른 GUI 부분들도 정상적으로 동작해야 하는데, 기능 외적인 부분에 항상 너무 많은 시간이 소모된다. 모든 경우를 위와 같은 방식으로 해결할 수도 없다. 4년 넘게 GTK+ 어플리케이션을 만들어 프로젝트를 진행하고 있지만, 기능이 추가될때마다 똑같은 홍역을 겪고 있다.\n이제, 다른 대안을 찾아야 할 시기일까\u0026hellip;\n","date":1137715200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1137715200,"objectID":"cd20d0e53ebd3a375451fa5d366eff8f","permalink":"https://lethean.github.io/2006/01/20/multi-thread-gtk-programming/","publishdate":"2006-01-20T00:00:00Z","relpermalink":"/2006/01/20/multi-thread-gtk-programming/","section":"post","summary":"대부분의 프로젝트를 GTK+를 이용하지만, 잊어버릴만 하면 부딪히는 문제 중 하나가 바로 멀티쓰레드 프로그램에서 GTK+ 위젯을 다룰때 발생하는 여러가지 현상들이다","tags":["GLib","GTK+"],"title":"멀티쓰레드 GTK+ 프로그래밍","type":"post"},{"authors":null,"categories":null,"content":"언젠가 \u0026lsquo;유림\u0026rsquo;이라는 책을 소개하는 TV 프로그램에 나온 작가 최인호 왈:\n 우리 나라 교육은 나은 사람 하나를 만들기 위해 아흔 아홉을 희생한다. 백 명 모두를 나은 사람으로 만드는 것은 불가능하다. 하지만 모두를 된 사람을 만드는 교육은 가능하다. \u0026lsquo;나은 사람\u0026rsquo;보다 \u0026lsquo;된 사람\u0026rsquo;이 더 행복하다는 사실은 진실이다. 원래 중국집 주방장과 소설가는 이런 자리에 나오면 안된다. 짜장면을 맛있게 먹었으면 그만이지 주방장을 불러 이러쿵 저러쿵 설명하게 하는 것은 별로 좋은 일이 아니다.  프로그래머도 마찬가지가 아닐까? 프로그래머는 자신이 설계하고 구현한 프로그램을 사용자가 편하고 유용하게 사용하면 그만이다. 원칙적으로 프로그래머가 다른 프로그래머와 프로그램에 대해 얘기해야 하는 방법은 자신의 코드를 통해서다.\n하지만 우리는 이미 프로그래머가 아티스트보다는 엔지니어로서, 때로는 웅변가나 저술가로서 역할을 더 많이 해야 인정을 받는 세상에 살고 있다. 프로그램도 잘 짜야 하고, 말도 잘해야 되고, 글도 잘 써야 되고, 영어도 잘 해야 되고, 사람들도 잘 이끌어야 하고\u0026hellip;\n카스탈리엔은 점점 멀어져가고 있다.\n","date":1137715200,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1137715200,"objectID":"4664564e283009ae2f63bebaba8d5c25","permalink":"https://lethean.github.io/2006/01/20/cookers-writers-and-programmers/","publishdate":"2006-01-20T00:00:00Z","relpermalink":"/2006/01/20/cookers-writers-and-programmers/","section":"post","summary":"언젠가 \u0026lsquo;유림\u0026rsquo;이라는 책을 소개하는 TV 프로그램에 나온 작가 최인호 왈: 우리 나라 교육은 나은 사람 하나를 만들기 위해 아흔 아홉을 희생한","tags":["Agile"],"title":"중국집 주방장과 소설가, 프로그래머","type":"post"},{"authors":null,"categories":null,"content":"데비안 패키지 glibc-2.3.5 이후부터 ldd 명령의 결과에 예전에 없던 \u0026lsquo;linux-gate.so.1\u0026rsquo; 공유 라이브러리가 포함되어 있어 궁금했다. 다음 예에서 첫번째 줄이다.\n# ldd /bin/sh linux-gate.so.1 =\u0026gt; (0xffffe000) libdl.so.2 =\u0026gt; /lib/libdl.so.2 (0xb7fb2000) libc.so.6 =\u0026gt; /lib/libc.so.6 (0xb7e7c000) /lib/ld-linux.so.2 (0xb7fba000)  Google에서 찾아본 결과 \u0026ldquo; What is linux-gate.so.1? \u0026rdquo; 문서가 가장 잘 설명해주고 있었다. 2.5 커널부터 시스템콜 호출을 전통적인 'int 0x80'이 아닌 인텔 펜티엄 II 이후에 추가된 sysenter 인스트럭션을 이용하여 오버헤드를 줄이고, 64비트 머신과의 일관성을 유지하기 위해 고안된 방법이었다. 이 공유라이브러리는 커널이 마치 DSO처럼 제공하는 시스템콜 라이브러리인 셈이다. 그래서 파일시스템에는 실제 이 파일이 없다. \u0026lsquo;linux-gate\u0026rsquo; 라는 이름은 커널과 사용자 프로세스간의 통로라는 뜻에서 그렇게 붙인 것 같다.\n몇년 동안 2.6 커널을 사용해왔는데 왜 모르고 있었을까. 이유를 조금 더 조사해 보니, 다음에 보는 것처럼 glibc 버전과 상관없이 커널은 이미 지원하고 있었다. 다음은 glibc-2.3.5가 아니고 커널만 2.6인 시스템에서 출력한 결과다. 여기서 가장 마지막의 \u0026lsquo;[vdso]\u0026rsquo; 부분이 바로 그것이다.\n[lethean@lethean ~]$ cat /proc/self/maps 08048000-0804c000 r-xp 00000000 03:01 758909 /bin/cat 0804c000-0804d000 rw-p 00003000 03:01 758909 /bin/cat 0804d000-0806e000 rw-p 0804d000 00:00 0 [heap] ... b7f23000-b7f38000 r-xp 00000000 03:01 734436 /lib/ld-2.3.6.so b7f38000-b7f39000 rw-p 00014000 03:01 734436 /lib/ld-2.3.6.so bf923000-bf938000 rw-p bf923000 00:00 0 [stack] ffffe000-fffff000 ---p 00000000 00:00 0 [vdso]  단지 glibc-2.3.5 버전에 포함된 ldd가 이를 \u0026lsquo;linux-gate.so.1\u0026rsquo; 이라는 표시하기 시작한 것이다.\n","date":1137456000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1137456000,"objectID":"df7059f10fb21ce116bbb890462238c0","permalink":"https://lethean.github.io/2006/01/17/linux-gateso1/","publishdate":"2006-01-17T00:00:00Z","relpermalink":"/2006/01/17/linux-gateso1/","section":"post","summary":"데비안 패키지 glibc-2.3.5 이후부터 ldd 명령의 결과에 예전에 없던 \u0026lsquo;linux-gate.so.1\u0026rsquo; 공유 라이브러리가 포함되어 있어 궁금했다. 다음 예에서 첫번째 줄이다. # ldd /bin/sh linux-gate.so.1 =\u0026gt; (0xffffe000) libdl.so.2 =\u0026gt; /lib/libdl.so.2 (0xb7fb2000) libc.so.6 =\u0026gt; /lib/libc.so.6 (0xb7e7c000) /lib/ld-linux.so.2","tags":["glibc","Linux"],"title":"linux-gate.so.1","type":"post"},{"authors":null,"categories":null,"content":"Ubuntu(dapper) 리눅스에서 지금까지 사용하던 나비(nabi) 입력기를 SCIM 으로 대체하기로 했다. 한국어 뿐 아니라 일본어, 중국어 입력이 필요해지기 시작했고, 현재 개발중인 제품의 기본 입력기로 장착하기 위해 미리 사용해 보기 위해서이기도 하다.\n설치하는 순서하는 다음과 같다.\n우선 먼저 SCIM 관련 패키지와 일본어 한자 입력을 위한 Canna 한자 서버 패키지를 설치한다.\n# sudo apt-get remove nabi # sudo apt-get install scim scim-gtk-immodule # sudo apt-get install scim-hangul scim-canna scim-pinyin # sudo apt-get install canna # for japanese dict server  X가 기동될때 자동으로 시작할 수 있도록 다음과 같은 작업을 해준다. (im-switch, update-alternatives 등의 데비안 도구를 사용할 수도 있지만 이 방법이 내겐 더 명확하다)\n# cd /etc/X11/xinit/xinput.d # sudo cat \u0026gt; scim XIM=SCIM XIM_PROGRAM=/usr/bin/scim XIM_ARGS=\u0026quot;-d\u0026quot; GTK_IM_MODULE=scim DEPENDS=\u0026quot;scim,scim-gtk2-immodule\u0026quot; [CTRL-D] # ln -sf scim ko_KR  이제 X를 재시작하거나, 시스템을 재시작하면 특별한 설정없이 자동으로 SCIM 입력기가 실행된다.\n여기까지만 해도 문제는 없지만, 입력 전환 키가 [CTRL-SPACE]라서, 익숙한 [SHIFT-SPACE]를 사용하기 위해 SCIM 설정에서 키를 추가해주기만 하면 된다.\n","date":1137024000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1137024000,"objectID":"efc3a064b8aaf87a072b82511a17889a","permalink":"https://lethean.github.io/2006/01/12/scim-in-ubuntu/","publishdate":"2006-01-12T00:00:00Z","relpermalink":"/2006/01/12/scim-in-ubuntu/","section":"post","summary":"Ubuntu(dapper) 리눅스에서 지금까지 사용하던 나비(nabi) 입력기를 SCIM 으로 대체하기로 했다. 한국어 뿐 아니라 일본어, 중국어 입력이 필요해지기 시작했고, 현재 개발중인","tags":["Ubuntu"],"title":"SCIM in Ubuntu","type":"post"},{"authors":null,"categories":null,"content":" 임베디드 시스템에 오픈 소스를 사용하면 좋은 이유(Advantages of Free Software and Open Source in embedded systems) 이 자료는 임베디드 시스템 개발에 오픈 소스를 이용해야 하는 이유를 조목 조목 나열하며 설명하고 있다. 총 49페이지 분량으로 되어 있으며, 임베디드 시스템 개발자 / 관리자 / 회사 / 컨텐트 공급자 / 고객과 최종 사용자별로 나누어 장점을 설명하고 있다. 그와 더불어 오픈 소스에 대한 오해와 어려움, 단점 등도 요약하고 있다. 이 중에서 장점 부분은 분량도 많고 누구나 예상할 수 있는 내용이라 생략하고, 그 외적인 부분만 따로 정리해 본다.\n이 자료에서 밝히는 오픈 소스에 대한 첫번째 오해는, \u0026ldquo;내 코드를 세상에 무조건 공개해야 한다\u0026rdquo;는 생각이다. 이는 GPL(LGPL이 아닌) 등과 같은 카피레프트(Copyleft) 라이브러리를 사용하거나, 이러한 프로그램을 수정하여 확장할 경우에만 그렇다. 두번째 오해는 \u0026ldquo;지원이나 교육을 받을 수 없다\u0026rdquo;인데, 수많은 교육기관에서 강의를 받는 것은 물론 많은 회사로부터 기술지원을 받는 것이 가능하다.\n기술적인 어려움은 다음과 같은 항목을 나열하고 있다.\n 오픈 소스는 자주 업그레이드되고 갱신되므로 변경사항을 관리해야 한다. 따라서 가능한 초기에 컴포넌트를 고정(freeze)해야 한다. 솔루션이 너무 많아 선택하기 힘들다. 마치 모래에서 사금을 채취하는 것과도 비슷하기에, 모든 솔루션을 검토하고 오픈 소스 소식을 따라가기에 시간이 부족하다. 이 경우 전문가의 조언을 구하는 것이 필요하다. 길게 지속되는 솔루션이 필요하다. 많은 사용자와 개발자가 있고 커뮤니티가 형성되어 활발하게 개발되고 있는지도 중요하다. 개발에 필요한 문서, 소스 등이 산재해 있어 웹 검색에 경험이 필요하다.  이 외에도 몇 가지 내용이 더 있지만, 여기까지만 정리한다.\n","date":1137024000,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1137024000,"objectID":"e75e4e5a1f4602a3db0d784e362e1c7a","permalink":"https://lethean.github.io/2006/01/12/advantages-of-free-software-and-open-source-in-embedded-systems/","publishdate":"2006-01-12T00:00:00Z","relpermalink":"/2006/01/12/advantages-of-free-software-and-open-source-in-embedded-systems/","section":"post","summary":"임베디드 시스템에 오픈 소스를 사용하면 좋은 이유(Advantages of Free Software and Open Source in embedded systems) 이 자료는 임베디드 시스템 개발에 오픈 소스를 이용해야 하는 이유를 조","tags":["Embedded","OpenSource"],"title":"임베디드 시스템에 오픈 소스를 사용하면 좋은 이유","type":"post"},{"authors":null,"categories":null,"content":" Duff\u0026rsquo;s Device 는 연속적인 복사 작업을 수행하는 알고리즘에 있어 C 언어로 구현된 가장 최적화된 기법이다. 일반적으로 어셈블리에서 사용되는 기술을 switch 문과 루프 풀기(Loop Unrolling) 기법을 이용하여 구현하는데, 이 기법이 발표된 1983년 이후 아직까지 이보다 더 최적화된 구현은 없다고 한다. 코드를 보면 다음과 같다.\nint n = (count + 7) / 8; /* count \u0026gt; 0 assumed */ switch (count % 8) { case 0: do { *to = *from++; case 7: *to = *from++; case 6: *to = *from++; case 5: *to = *from++; case 4: *to = *from++; case 3: *to = *from++; case 2: *to = *from++; case 1: *to = *from++; } while (--n \u0026gt; 0); }  얼핏보면 컴파일도 안될 것 같지만 깔끔하게 컴파일되고 제대로 동작하는 ANSI C 코드이다. 이 코드는 switch 문의 case 문이 goto 문에서도 사용하는 레이블(label)로 처리된다는 점을 이용한다. 8의 배수 크기만큼은 do { } while () 문의 최적화된 루프 풀기(loop unroll) 코드로 동작하고, 8로 나누어지지 않는 나머지 부분은 switch() 문에 의해 직접 해당 위치로 점프하여 그만큼을 미리 수행하는 방식이다. \u0026lsquo; Loop Unrolling with Duff\u0026rsquo;s Device \u0026rsquo; 리뷰 문서는 이 알고리즘을 더 자세히 설명하고 있다.\n \u0026lsquo;Coroutines in C\u0026rsquo; 는 Duff\u0026rsquo;s Device에서 사용한 switch 기법을 이용하여 상태가 유지되는 함수를 만들 수 있는 방법을 알려주고 있다. 또한 스테이트 머신(state machine)과 같이 상태에 따라 다른 동작을 해야하는 루틴을 만들 경우 상태 변수에 따라 일일히 분기하는 알고리즘이 아니라, 하나의 작업 흐름대로 코드를 만들고, 다음에 루틴에 진입할 경우 바로 마지막 작업 시점에서 계속 수행되도록 할 수 있다. Duff\u0026rsquo;s Device 기법을 고안한 사람도 처음에는 인터럽트 핸들러를 작성할때 이 방법을 이용하여 만들었다고 한다.\n Protothreads 라이브러리는 Duff\u0026rsquo;s Device 기법을 이용하여 ANSI C 에서 멀티쓰레드를 프로그래밍을 할 수 있도록 도와준다. 쓰레드별 스택(stack)을 지원하지 않고 이벤트 기반으로 동작할 경우에만 유용하다. 하지만, 메모리가 적은 임베디드 시스템이나 마이크로 컨트롤러 시스템에서 멀티쓰레드를 지원하는 운영체제를 이용하기 힘든 경우가 많은데, 이런 경우에 적합하다고 하며, 실제로 이 라이브러리를 이용해 구현한 초경량 커널에 대한 정보도 얻을 수 있다.\n","date":1136937600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1136937600,"objectID":"2531291029f2e4f0d4a9ce84aec167dd","permalink":"https://lethean.github.io/2006/01/11/duffs-device/","publishdate":"2006-01-11T00:00:00Z","relpermalink":"/2006/01/11/duffs-device/","section":"post","summary":"Duff\u0026rsquo;s Device 는 연속적인 복사 작업을 수행하는 알고리즘에 있어 C 언어로 구현된 가장 최적화된 기법이다. 일반적으로 어셈블리에서 사용되는 기술을 switch 문과 루프 풀기(Loo","tags":["Coding"],"title":"Duff's Device","type":"post"},{"authors":null,"categories":null,"content":"Edgewall Software의 Trac 시스템에 대해 KLDP 포럼 에서 많은 사람이 호평을 하길래 한번 살펴보았다. 하지만 5년째 사용하고 있는 Bugzilla 에서 유용하다고 생각하는 몇몇 기능이 없어 조금 나중에 다시 검토하기로 했다. 다음은 당장 눈에 띄는 아쉬운 점이다.\n 모든 작업에 대한 이메일 전송 기능이 없다.(가장 중요) 이메일 기능이 지원되도 버그질라만큼 풍부한 조절이 가능할지 의문이다. 분류 / 프로젝트 / 컴포넌트 등과 같은 복수 프로젝트 지원이 미비하다. 키워드 / QA 관리자 등의 기능이 없다.  물론 버그질라에 없는 기능도 많지만, 언제나 그렇듯이 새로운 시스템을 도입하려면 기존 시스템에서 유용한 부분은 당연히 제공하고 부가적이고 아쉬운 기능가지 제공해야 설득력이 있는 것 같다.\n","date":1136937600,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1136937600,"objectID":"622091712eb03153a25697a400dc32da","permalink":"https://lethean.github.io/2006/01/11/trac-and-bugzilla/","publishdate":"2006-01-11T00:00:00Z","relpermalink":"/2006/01/11/trac-and-bugzilla/","section":"post","summary":"Edgewall Software의 Trac 시스템에 대해 KLDP 포럼 에서 많은 사람이 호평을 하길래 한번 살펴보았다. 하지만 5년째 사용하고 있는 Bugzilla 에서 유용하다고 생각하는 몇몇 기능이","tags":["Bugzilla"],"title":"Trac and Bugzilla","type":"post"},{"authors":null,"categories":null,"content":"리누스 토발즈가 비공식적인 메일링 리스트에서 GNOME을 쓰지 말고 KDE를 쓰라고 했다는 발언과 기사 를 보면서, 오래전(5~6년?) KDE를 한 번 써보고 그 조잡함에 질려 GNOME 2.x 대 이후 완전한 GNOME 사용자로 살아온 나는 뭔가 그럴듯한 반박거리를 생각하고 있었다. 그러다가 문득 그놈플래닛 에 올라온 Luis Villa의 블로그 에서 언급한 Jakub \u0026lsquo;jimmac\u0026rsquo; Steiner의 웹로그 에서 GNOME과 KDE를 리모콘에 비유한 그림을 보고 더 이상 내가 고민할 필요가 없다고 생각했다.\n전혀 허락없이 링크하는 그림은 다음과 같다.\nGNOME을 선호하는 이유는, 나 역시, 중요하고 자주 사용하는 인터페이스만 갖춤으로써, 사용자가 핵심 작업에 집중할 수 있도록 도와준다는 점이다. 그리고, 개인적으로 난 심플의 아름다움을 좋아한다.\n","date":1134604800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1134604800,"objectID":"5d1fd6dcd89b3135def473df8233fc0e","permalink":"https://lethean.github.io/2005/12/15/gnome-or-kde/","publishdate":"2005-12-15T00:00:00Z","relpermalink":"/2005/12/15/gnome-or-kde/","section":"post","summary":"리누스 토발즈가 비공식적인 메일링 리스트에서 GNOME을 쓰지 말고 KDE를 쓰라고 했다는 발언과 기사 를 보면서, 오래전(5~6년?) KDE를 한 번 써보고 그","tags":["GNOME"],"title":"GNOME or KDE ?","type":"post"},{"authors":null,"categories":null,"content":"멀티 쓰레드 방식 프로그래밍은 강력한 효율을 제공하지만 그만큼 프로그래머를 힘들게 하기도 한다. 그렇다면, 멀티 쓰레드 방식을 대체할 수 있는 방법은 무엇이 있을까? 물론 많은 사람들이 이 주제에 대하여 책도 쓰고 글도 남겼지만 여기는 내 블로그니까, 가능한 내 경험에 비추어 생각해본다.\n뮤텍스(mutex)를 사용해야 하는 구조로 설계하지 말기 뮤텍스를 이용하는 근본적인 이유는 하나의 리소스에 대해 동시에 접근할 경우 문제가 발생할 수 있을 경우 이에 대한 상호 배제(Mutual Exclusion)를 하기 위함이다. 하지만 하나의 리소스 또는 기능에 대한 처리를 전담하는 쓰레드를 만들고, 원하는 작업을 이 쓰레드(또는 프로세스)에게 메시지로 전달하여 처리하는 방식을 이용하면 뮤텍스를 사용해야 하는 경우는 사라지게 된다. 즉, 메시지 처리 방식(message-driven)을 이용하는 것이다. 물론 이 방식은 비동기적인 메시지일 경우 별로 문제가 없지만, 동기화가 필요한 경우 복잡해진다는 단점이 있다. 또한 성능 문제도 무시할 수 없다.\n폴링(polling) 방식을 적극적으로 이용하고 쓰레드로 분리하지 않기 멀 티쓰레드 프로그래밍시 발생하는 대부분의 문제는 한번 쓰레드 방식을 이용하게 되면 이후 추가되는 모든 구현에 적극적으로 쓰레드를 도입하게 되는 습관에서 시작한다. 특히 IO(비디오,디스크,네트워크) 관련 처리에 대한 비동기 처리를 폴링 방식으로 프로그래밍하면 느려지고 복잡하기 때문에 쓰레드로 분리해서 쉽게 해결하지만, 바로 이때부터가 재앙의 시작이다. 경험상으로 보면 가장 큰 기능별로 쓰레드를 분리하는 것이 가장 바람직하며, 정말로 성능에 별로 지장을 주지 않는다면 조금 수고가 들더라도 비동기 방식으로 제작하여 한 쓰레드에서 수행되도록 하는 것이 데드락(deadlock)과 같은 저주를 피하면서 뇌세포에게 더 많은 휴식을 줄 수 있는 방법일 것이다.\n이미 잘설계된 라이브러리를 이용하기  GLib 같은 라이브러리를 살펴보면 위의 원칙대로 프로그래밍하기 위한 API가 너무나 잘 지원되고 있다. 욕심이 나지 않을 수가 없다. 다만, 임베디드 시스템에도 이용할 수 있도록 다른 라이브러리에 대한 의존성이 적고, WinCE 등과 같은 플랫폼도 문제없이 지원한다면 현재 진행중인 모든 프로젝트의 기본 라이브러리로 채택하지 않을 이유가 없을텐데 말이다.\n물론 다른 규칙도 많겠지만, 오늘은 일단 여기까지만\u0026hellip; :)\n","date":1132444800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1132444800,"objectID":"4025312aef0fadaef7a373b43777a0d0","permalink":"https://lethean.github.io/2005/11/20/multi-thread-programming-rules/","publishdate":"2005-11-20T00:00:00Z","relpermalink":"/2005/11/20/multi-thread-programming-rules/","section":"post","summary":"멀티 쓰레드 방식 프로그래밍은 강력한 효율을 제공하지만 그만큼 프로그래머를 힘들게 하기도 한다. 그렇다면, 멀티 쓰레드 방식을 대체할 수 있는 방법은 무엇이 있을까","tags":["Coding","GLib"],"title":"멀티쓰레드 프로그래밍 규칙","type":"post"},{"authors":null,"categories":null,"content":"데스크탑 개발 환경으로 사용하던 장비를 915 보드로 변경하면서 기존에 사용하던 하드디스크를 그대로 장착해서 환경을 꾸몄다. 사용하던 NVidia 비디오 카드는 AGP 방식인데 새로운 보드는 PCI Express 방식이라 어쩔 수 없이 내장 그래픽 보드인 915G를 이용하게 되었는데, 문제는 모니터로 사용하던 LG FLATRON L2010P 모델 (20인치)에서 주파수 범위 에러가 나면서 모니터를 인식하지 못하는 것이었다. CRT 모니터에 연결하니 정상적으로 나오고, 다른 머신에서 네트웍으로 접속해 확인하면 모든 프로그램은 정상적으로 구동된 것을 확인할 수 있었다. 모니터 주파수 문제임을 확인하고, 구글링을 통해 이것 저것 정보를 찾아보았으나 결국 실패, 혹시나 하고 X.Org의 버그질라에서 비슷한 현상을 발견하고 여러가지 옵션을 조합해서 해결할 수 있었다.\n문제의 원인은 X 서버의 DDC 모듈이 모니터의 수평/수직 주파수를 자동으로 알아오는데 이 값이 잘못된 것이었다. 해결책은 수동으로 주파수를 입력하고 DDC 모듈을 사용하지 못하게 하는 것인데, 수직 주파수의 경우 일반적으로 사용하는 주파수 범위가 아닌 TFT LCD 모니터 특성에 맞게 60.0 을 고정으로 설정해야 한다는 점이 특이하다. 다음은 xorg.conf 중 이 부분에 해당하는 설정이다.\nSection \u0026quot;Device\u0026quot; Identifier \u0026quot;Intel Corporation i915\u0026quot; Driver \u0026quot;i810\u0026quot; BusID \u0026quot;PCI:0:2:0\u0026quot; Option \u0026quot;NoDDC\u0026quot; \u0026quot;true\u0026quot; # Option \u0026quot;VBERestore\u0026quot; \u0026quot;true\u0026quot; # Option \u0026quot;DisplayInfo\u0026quot; \u0026quot;false\u0026quot; EndSection Section \u0026quot;Monitor\u0026quot; Identifier \u0026quot;L2010P\u0026quot; HorizSync 28-92 VertRefresh 60.0 Option \u0026quot;DPMS\u0026quot; EndSection  여기서 수평주파수 값은 sudo ddcprobe 결과값을 그대로 적어준 것이다.\n한가지 놀란 점은 혹시나 하고 glxgears 프로그램을 실행했더니, 느낌인지는 몰라도 NVidia보다 CPU 점유율도 낮고 성능이 더 좋은 것 같다는 점이다.\n","date":1132358400,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1132358400,"objectID":"7ccea94f9c6d29e65634cf851150ddad","permalink":"https://lethean.github.io/2005/11/19/xorg-i810915g-lg-flatron-l2010p/","publishdate":"2005-11-19T00:00:00Z","relpermalink":"/2005/11/19/xorg-i810915g-lg-flatron-l2010p/","section":"post","summary":"데스크탑 개발 환경으로 사용하던 장비를 915 보드로 변경하면서 기존에 사용하던 하드디스크를 그대로 장착해서 환경을 꾸몄다. 사용하던 NVidia 비디오 카드는 AGP 방식인데 새","tags":["Xorg"],"title":"X.ORG + I810(915G) + LG FLATRON L2010P","type":"post"},{"authors":null,"categories":null,"content":"퀘이크3(Quake3) 소스가 GPL 라이센스로 풀리면서 나같은 사람도 한번 얼핏 훑어볼 기회가 생겼다. 얼핏 훑어본 퀘이크3 소스 코드의 특징은 다음과 같다.\n 메모리 할당은 대부분 필요한 크기를 정해서 초기에 한꺼번에 할당한다. 즉, 프로그램 실행 도중에 메모리를 할당하고 해제하는 일이 거의 없다. 링크드 리스트 대신 배열을 많이 쓴다. 내부적으로 가상 머신을 따로 만들어 사용한다. 또한 멀티쓰레드 방식이 아닌 가능한 하나의 이벤트 루프 안에서 모든 것을 처리하는 것 같다. (전통적인 게임 프로그래밍 방식?) 이름 충돌을 위해 전역 변수에 static 키워드를 철저하게 지킨다. 대신 네이밍룰은 조금 자유로운 것 같다. 역시 메뉴와 같은 UI 엔진은 따로 구현하고 있다.  역시 게임 소프트웨어는 소프트웨어의 모든 기술을 망라하여 이용하고 있다는 느낌도 새삼 든다. 우리는 책임도 지지 못하는 메모리 할당 방식 API를 너무 남용하고 있는 것은 아닐까.\n","date":1132012800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1132012800,"objectID":"d55aab3cd6a4576723d7f9e9d35451db","permalink":"https://lethean.github.io/2005/11/15/quake3-source-skimming/","publishdate":"2005-11-15T00:00:00Z","relpermalink":"/2005/11/15/quake3-source-skimming/","section":"post","summary":"퀘이크3(Quake3) 소스가 GPL 라이센스로 풀리면서 나같은 사람도 한번 얼핏 훑어볼 기회가 생겼다. 얼핏 훑어본 퀘이크3 소스 코드의 특징은 다음과 같다. 메모","tags":["Coding"],"title":"Quake3 Source Skimming","type":"post"},{"authors":null,"categories":null,"content":"대체로 무해함 \u0026ldquo;은하수를 여행하는 히치하이커를 위한 안내서\u0026quot;의 한 구절 lethean a. Of or pertaining to Lethe; resembling in effect the water of Lethe. \u0026ndash;Milton. Barrow. [1913 Webster]\na. 망각의 강의;과거를 잊게 하는\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"ko","lastmod":1580727393,"objectID":"ccd6b56826a656fd1c9d2a5ac9e59037","permalink":"https://lethean.github.io/lethean/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/lethean/","section":"","summary":"대체로 무해함 \u0026ldquo;은하수를 여행하는 히치하이커를 위한 안내서\u0026quot;의 한 구절 lethean a. Of or pertaining to Lethe; resembling in effect the water of Lethe. \u0026ndash;Milton. Barrow. [1913 Webster] a. 망각의 강의;과거를","tags":null,"title":"소개","type":"page"}]